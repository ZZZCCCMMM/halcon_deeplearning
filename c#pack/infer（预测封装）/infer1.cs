//
// File generated by HDevelop for HALCON/.NET (C#) Version 23.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  // Procedures 
  // External procedures 
  // Chapter: Image / Channel
  private void add_colormap_to_image (HObject ho_GrayValueImage, HObject ho_Image, 
      out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
    HObject ho_Channel=null, ho_ChannelScaled=null, ho_ChannelScaledByte=null;
    HObject ho_ImageByte, ho_ImageByteR=null, ho_ImageByteG=null;
    HObject ho_ImageByteB=null;

    // Local copy input parameter variables 
    HObject ho_GrayValueImage_COPY_INP_TMP;
    ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



    // Local control variables 

    HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
    HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ColoredImage);
    HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
    HOperatorSet.GenEmptyObj(out ho_Channels);
    HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
    HOperatorSet.GenEmptyObj(out ho_ImageByte);
    HOperatorSet.GenEmptyObj(out ho_ImageByteR);
    HOperatorSet.GenEmptyObj(out ho_ImageByteG);
    HOperatorSet.GenEmptyObj(out ho_ImageByteB);
    try
    {
      //
      //This procedure adds a gray-value image to a RGB image with a chosen color map.
      //
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
      //The image LUT needs a byte image. Rescale real images.
      if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0, 
            1);
        ho_GrayValueImage_COPY_INP_TMP.Dispose();
        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "byte");
        ho_GrayValueImage_COPY_INP_TMP.Dispose();
        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
      {
        throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
      }
      //
      //Apply the chosen color scheme on the gray value.
      ho_RGBValueImage.Dispose();
      apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage, 
          hv_HeatmapColorScheme);
      //
      //Convert input image to byte image for visualization.
      ho_Channels.Dispose();
      HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
      ho_ChannelsScaled.Dispose();
      HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
      HTuple end_val19 = hv_NumChannels;
      HTuple step_val19 = 1;
      for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
      {
        ho_Channel.Dispose();
        HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
        hv_ChannelMin.Dispose();hv_ChannelMax.Dispose();hv__.Dispose();
        HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax, 
            out hv__);
        ho_ChannelScaled.Dispose();
        scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
        ho_ChannelScaledByte.Dispose();
        HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte, 
            "byte");
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
            );
        ho_ChannelsScaled.Dispose();
        ho_ChannelsScaled = ExpTmpOutVar_0;
        }
      }
      ho_ImageByte.Dispose();
      HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
      //
      //Note that ImageByte needs to have the same number of channels as
      //RGBValueImage to display color map image correctly.
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
      if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
      {
        //Just take the first channel and use this to generate
        //an image with 3 channels for visualization.
        ho_ImageByteR.Dispose();
        HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
        ho_ImageByteG.Dispose();
        HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
        ho_ImageByteB.Dispose();
        HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
        ho_ImageByte.Dispose();
        HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
            );
      }
      //
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5, 
          0);
      ho_RGBValueImage.Dispose();
      ho_RGBValueImage = ExpTmpOutVar_0;
      }
      ho_ColoredImage.Dispose();
      ho_ColoredImage = new HObject(ho_RGBValueImage);
      //
      ho_GrayValueImage_COPY_INP_TMP.Dispose();
      ho_RGBValueImage.Dispose();
      ho_Channels.Dispose();
      ho_ChannelsScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ChannelScaledByte.Dispose();
      ho_ImageByte.Dispose();
      ho_ImageByteR.Dispose();
      ho_ImageByteG.Dispose();
      ho_ImageByteB.Dispose();

      hv_Type.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_ChannelMin.Dispose();
      hv_ChannelMax.Dispose();
      hv__.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_GrayValueImage_COPY_INP_TMP.Dispose();
      ho_RGBValueImage.Dispose();
      ho_Channels.Dispose();
      ho_ChannelsScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ChannelScaledByte.Dispose();
      ho_ImageByte.Dispose();
      ho_ImageByteR.Dispose();
      ho_ImageByteG.Dispose();
      ho_ImageByteB.Dispose();

      hv_Type.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_ChannelMin.Dispose();
      hv_ChannelMax.Dispose();
      hv__.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Image / Channel
  // Short Description: Create a lookup table and convert a gray scale image. 
  public void apply_colorscheme_on_gray_value_image (HObject ho_InputImage, out HObject ho_ResultImage, 
      HTuple hv_Schema)
  {




    // Local iconic variables 

    HObject ho_ImageR, ho_ImageG, ho_ImageB;

    // Local control variables 

    HTuple hv_X = new HTuple(), hv_Low = new HTuple();
    HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
    HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
    HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
    HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
    HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ResultImage);
    HOperatorSet.GenEmptyObj(out ho_ImageR);
    HOperatorSet.GenEmptyObj(out ho_ImageG);
    HOperatorSet.GenEmptyObj(out ho_ImageB);
    try
    {
      //
      //This procedure generates an RGB ResultImage for a gray-value InputImage.
      //In order to do so, create a color distribution as look up table
      //according to the Schema.
      //
      hv_X.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_X = HTuple.TupleGenSequence(
          0,255,1);
      }
      hv_Low.Dispose();
      HOperatorSet.TupleGenConst(256, 0, out hv_Low);
      hv_High.Dispose();
      HOperatorSet.TupleGenConst(256, 255, out hv_High);
      //
      if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
      {
        //Scheme Jet: from blue to red
        hv_OffR.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffR = 3.0*64.0;
        }
        hv_OffG.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffG = 2.0*64.0;
        }
        hv_OffB.Dispose();
        hv_OffB = 64.0;
        hv_A1.Dispose();
        hv_A1 = -4.0;
        hv_A0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0 = 255.0+128.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = ((((((((hv_X-hv_OffR)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = ((((((((hv_X-hv_OffG)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = ((((((((hv_X-hv_OffB)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
      {
        //Scheme InvJet: from red to blue.
        hv_OffR.Dispose();
        hv_OffR = 64;
        hv_OffG.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffG = 2*64;
        }
        hv_OffB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffB = 3*64;
        }
        hv_A1.Dispose();
        hv_A1 = -4.0;
        hv_A0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0 = 255.0+128.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = ((((((((hv_X-hv_OffR)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = ((((((((hv_X-hv_OffG)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = ((((((((hv_X-hv_OffB)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
      {
        //Scheme Hot.
        hv_A1.Dispose();
        hv_A1 = 3.0;
        hv_A0R.Dispose();
        hv_A0R = 0.0;
        hv_A0G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0G = ((1.0/3.0)*hv_A1)*255.0;
        }
        hv_A0B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0B = ((2.0/3.0)*hv_A1)*255.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = (((((hv_X*hv_A1)-hv_A0R)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = (((((hv_X*hv_A1)-hv_A0G)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = (((((hv_X*hv_A1)-hv_A0B)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
      {
        //Scheme Inverse Hot.
        hv_A1.Dispose();
        hv_A1 = -3.0;
        hv_A0R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0R = hv_A1*255.0;
        }
        hv_A0G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0G = ((2.0/3.0)*hv_A1)*255.0;
        }
        hv_A0B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0B = ((1.0/3.0)*hv_A1)*255.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = (((((hv_X*hv_A1)-hv_A0R)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = (((((hv_X*hv_A1)-hv_A0G)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = (((((hv_X*hv_A1)-hv_A0B)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else
      {
        //
        throw new HalconException(("Unknown color schema: "+hv_Schema)+".");
        //
      }
      //
      ho_ImageR.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
      ho_ImageG.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
      ho_ImageB.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
      ho_ResultImage.Dispose();
      HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
      //
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_X.Dispose();
      hv_Low.Dispose();
      hv_High.Dispose();
      hv_OffR.Dispose();
      hv_OffG.Dispose();
      hv_OffB.Dispose();
      hv_A1.Dispose();
      hv_A0.Dispose();
      hv_R.Dispose();
      hv_G.Dispose();
      hv_B.Dispose();
      hv_A0R.Dispose();
      hv_A0G.Dispose();
      hv_A0B.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_X.Dispose();
      hv_Low.Dispose();
      hv_High.Dispose();
      hv_OffR.Dispose();
      hv_OffG.Dispose();
      hv_OffB.Dispose();
      hv_A1.Dispose();
      hv_A0.Dispose();
      hv_R.Dispose();
      hv_G.Dispose();
      hv_B.Dispose();
      hv_A0R.Dispose();
      hv_A0G.Dispose();
      hv_A0B.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / OCR
  // Short Description: Compute zoom factors to fit an image to a target size. 
  private void calculate_dl_image_zoom_factors (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      HTuple hv_TargetWidth, HTuple hv_TargetHeight, HTuple hv_DLPreprocessParam, 
      out HTuple hv_ZoomFactorWidth, out HTuple hv_ZoomFactorHeight)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ScaleWidthUnit = new HTuple(), hv_ScaleHeightUnit = new HTuple();
    HTuple hv_PreserveAspectRatio = new HTuple(), hv_Scale = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
    // Initialize local and output iconic variables 
    hv_ZoomFactorWidth = new HTuple();
    hv_ZoomFactorHeight = new HTuple();
    try
    {
      //Calculate the unit zoom factors, which zoom the input image to 1px.
      hv_ScaleWidthUnit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleWidthUnit = 1.0/(hv_ImageWidth.TupleReal()
          );
      }
      hv_ScaleHeightUnit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleHeightUnit = 1.0/(hv_ImageHeight.TupleReal()
          );
      }
      //
      //Calculate the required zoom factors for the available target size.
      hv_ZoomFactorWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZoomFactorWidth = hv_TargetWidth*hv_ScaleWidthUnit;
      }
      hv_ZoomFactorHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZoomFactorHeight = hv_TargetHeight*hv_ScaleHeightUnit;
      }
      //
      //Aspect-ratio preserving zoom is supported for model type 'ocr_detection' only.
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
      HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "ocr_detection");
      hv_PreserveAspectRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PreserveAspectRatio = ((hv_DLPreprocessParam.TupleConcat(
          hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem("model_type","comp");
      }
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
          "HNULL");
      }
      //
      if ((int)(hv_PreserveAspectRatio) != 0)
      {
        //
        //Use smaller scaling factor, which results in unfilled domain
        //on the respective other axis.
        hv_Scale.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Scale = hv_ZoomFactorWidth.TupleMin2(
            hv_ZoomFactorHeight);
        }
        //Ensure that the zoom factors result in lengths of at least 1px.
        hv_ZoomFactorWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomFactorWidth = hv_Scale.TupleMax2(
            hv_ScaleWidthUnit);
        }
        hv_ZoomFactorHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomFactorHeight = hv_Scale.TupleMax2(
            hv_ScaleHeightUnit);
        }
      }

      hv_ScaleWidthUnit.Dispose();
      hv_ScaleHeightUnit.Dispose();
      hv_PreserveAspectRatio.Dispose();
      hv_Scale.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ScaleWidthUnit.Dispose();
      hv_ScaleHeightUnit.Dispose();
      hv_PreserveAspectRatio.Dispose();
      hv_Scale.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Check the content of the parameter dictionary DLPreprocessParam. 
  private void check_dl_preprocess_param (HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CheckParams = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_SupportedModelTypes = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ParamNamesGeneral = new HTuple(), hv_ParamNamesSegmentation = new HTuple();
    HTuple hv_ParamNamesDetectionOptional = new HTuple(), hv_ParamNamesPreprocessingOptional = new HTuple();
    HTuple hv_ParamNames3DGrippingPointsOptional = new HTuple();
    HTuple hv_ParamNamesAll = new HTuple(), hv_ParamNames = new HTuple();
    HTuple hv_KeysExists = new HTuple(), hv_I = new HTuple();
    HTuple hv_Exists = new HTuple(), hv_InputKeys = new HTuple();
    HTuple hv_Key = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_ValidValues = new HTuple();
    HTuple hv_ValidTypes = new HTuple(), hv_V = new HTuple();
    HTuple hv_T = new HTuple(), hv_IsInt = new HTuple(), hv_ValidTypesListing = new HTuple();
    HTuple hv_ValidValueListing = new HTuple(), hv_EmptyStrings = new HTuple();
    HTuple hv_ImageRangeMinExists = new HTuple(), hv_ImageRangeMaxExists = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_IndexParam = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_ClassIDsBackground = new HTuple(), hv_Intersection = new HTuple();
    HTuple hv_IgnoreClassIDs = new HTuple(), hv_KnownClasses = new HTuple();
    HTuple hv_IgnoreClassID = new HTuple(), hv_OptionalKeysExist = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_IsInstanceSegmentation = new HTuple();
    HTuple hv_IgnoreDirection = new HTuple(), hv_ClassIDsNoOrientation = new HTuple();
    HTuple hv_SemTypes = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure checks a dictionary with parameters for DL preprocessing.
      //
      hv_CheckParams.Dispose();
      hv_CheckParams = 1;
      //If check_params is set to false, do not check anything.
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "check_params", 
          out hv_KeyExists);
      if ((int)(hv_KeyExists) != 0)
      {
        hv_CheckParams.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "check_params", out hv_CheckParams);
        if ((int)(hv_CheckParams.TupleNot()) != 0)
        {

          hv_CheckParams.Dispose();
          hv_KeyExists.Dispose();
          hv_DLModelType.Dispose();
          hv_Exception.Dispose();
          hv_SupportedModelTypes.Dispose();
          hv_Index.Dispose();
          hv_ParamNamesGeneral.Dispose();
          hv_ParamNamesSegmentation.Dispose();
          hv_ParamNamesDetectionOptional.Dispose();
          hv_ParamNamesPreprocessingOptional.Dispose();
          hv_ParamNames3DGrippingPointsOptional.Dispose();
          hv_ParamNamesAll.Dispose();
          hv_ParamNames.Dispose();
          hv_KeysExists.Dispose();
          hv_I.Dispose();
          hv_Exists.Dispose();
          hv_InputKeys.Dispose();
          hv_Key.Dispose();
          hv_Value.Dispose();
          hv_Indices.Dispose();
          hv_ValidValues.Dispose();
          hv_ValidTypes.Dispose();
          hv_V.Dispose();
          hv_T.Dispose();
          hv_IsInt.Dispose();
          hv_ValidTypesListing.Dispose();
          hv_ValidValueListing.Dispose();
          hv_EmptyStrings.Dispose();
          hv_ImageRangeMinExists.Dispose();
          hv_ImageRangeMaxExists.Dispose();
          hv_ImageRangeMin.Dispose();
          hv_ImageRangeMax.Dispose();
          hv_IndexParam.Dispose();
          hv_SetBackgroundID.Dispose();
          hv_ClassIDsBackground.Dispose();
          hv_Intersection.Dispose();
          hv_IgnoreClassIDs.Dispose();
          hv_KnownClasses.Dispose();
          hv_IgnoreClassID.Dispose();
          hv_OptionalKeysExist.Dispose();
          hv_InstanceType.Dispose();
          hv_IsInstanceSegmentation.Dispose();
          hv_IgnoreDirection.Dispose();
          hv_ClassIDsNoOrientation.Dispose();
          hv_SemTypes.Dispose();

          return;
        }
      }
      //
      try
      {
        hv_DLModelType.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        throw new HalconException(new HTuple(new HTuple("DLPreprocessParam needs the parameter: '")+"model_type")+"'");
      }
      //
      //Check for correct model type.
      hv_SupportedModelTypes.Dispose();
      hv_SupportedModelTypes = new HTuple();
      hv_SupportedModelTypes[0] = "3d_gripping_point_detection";
      hv_SupportedModelTypes[1] = "anomaly_detection";
      hv_SupportedModelTypes[2] = "classification";
      hv_SupportedModelTypes[3] = "detection";
      hv_SupportedModelTypes[4] = "gc_anomaly_detection";
      hv_SupportedModelTypes[5] = "ocr_recognition";
      hv_SupportedModelTypes[6] = "ocr_detection";
      hv_SupportedModelTypes[7] = "segmentation";
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_SupportedModelTypes, hv_DLModelType, out hv_Index);
      if ((int)((new HTuple(hv_Index.TupleEqual(-1))).TupleOr(new HTuple(hv_Index.TupleEqual(
          new HTuple())))) != 0)
      {
        throw new HalconException(new HTuple("Only models of type '3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'ocr_detection' or 'segmentation' are supported"));

        hv_CheckParams.Dispose();
        hv_KeyExists.Dispose();
        hv_DLModelType.Dispose();
        hv_Exception.Dispose();
        hv_SupportedModelTypes.Dispose();
        hv_Index.Dispose();
        hv_ParamNamesGeneral.Dispose();
        hv_ParamNamesSegmentation.Dispose();
        hv_ParamNamesDetectionOptional.Dispose();
        hv_ParamNamesPreprocessingOptional.Dispose();
        hv_ParamNames3DGrippingPointsOptional.Dispose();
        hv_ParamNamesAll.Dispose();
        hv_ParamNames.Dispose();
        hv_KeysExists.Dispose();
        hv_I.Dispose();
        hv_Exists.Dispose();
        hv_InputKeys.Dispose();
        hv_Key.Dispose();
        hv_Value.Dispose();
        hv_Indices.Dispose();
        hv_ValidValues.Dispose();
        hv_ValidTypes.Dispose();
        hv_V.Dispose();
        hv_T.Dispose();
        hv_IsInt.Dispose();
        hv_ValidTypesListing.Dispose();
        hv_ValidValueListing.Dispose();
        hv_EmptyStrings.Dispose();
        hv_ImageRangeMinExists.Dispose();
        hv_ImageRangeMaxExists.Dispose();
        hv_ImageRangeMin.Dispose();
        hv_ImageRangeMax.Dispose();
        hv_IndexParam.Dispose();
        hv_SetBackgroundID.Dispose();
        hv_ClassIDsBackground.Dispose();
        hv_Intersection.Dispose();
        hv_IgnoreClassIDs.Dispose();
        hv_KnownClasses.Dispose();
        hv_IgnoreClassID.Dispose();
        hv_OptionalKeysExist.Dispose();
        hv_InstanceType.Dispose();
        hv_IsInstanceSegmentation.Dispose();
        hv_IgnoreDirection.Dispose();
        hv_ClassIDsNoOrientation.Dispose();
        hv_SemTypes.Dispose();

        return;
      }
      //
      //Parameter names that are required.
      //General parameters.
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesGeneral = new HTuple();
      hv_ParamNamesGeneral[0] = "model_type";
      hv_ParamNamesGeneral[1] = "image_width";
      hv_ParamNamesGeneral[2] = "image_height";
      hv_ParamNamesGeneral[3] = "image_num_channels";
      hv_ParamNamesGeneral[4] = "image_range_min";
      hv_ParamNamesGeneral[5] = "image_range_max";
      hv_ParamNamesGeneral[6] = "normalization_type";
      hv_ParamNamesGeneral[7] = "domain_handling";
      //Segmentation specific parameters.
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesSegmentation = new HTuple();
      hv_ParamNamesSegmentation[0] = "ignore_class_ids";
      hv_ParamNamesSegmentation[1] = "set_background_id";
      hv_ParamNamesSegmentation[2] = "class_ids_background";
      //Detection specific parameters.
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesDetectionOptional = new HTuple();
      hv_ParamNamesDetectionOptional[0] = "instance_type";
      hv_ParamNamesDetectionOptional[1] = "ignore_direction";
      hv_ParamNamesDetectionOptional[2] = "class_ids_no_orientation";
      hv_ParamNamesDetectionOptional[3] = "instance_segmentation";
      //Optional preprocessing parameters.
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNamesPreprocessingOptional = new HTuple();
      hv_ParamNamesPreprocessingOptional[0] = "mean_values_normalization";
      hv_ParamNamesPreprocessingOptional[1] = "deviation_values_normalization";
      hv_ParamNamesPreprocessingOptional[2] = "check_params";
      hv_ParamNamesPreprocessingOptional[3] = "augmentation";
      //3D Gripping Point Detection specific parameters.
      hv_ParamNames3DGrippingPointsOptional.Dispose();
      hv_ParamNames3DGrippingPointsOptional = new HTuple();
      hv_ParamNames3DGrippingPointsOptional[0] = "min_z";
      hv_ParamNames3DGrippingPointsOptional[1] = "max_z";
      hv_ParamNames3DGrippingPointsOptional[2] = "normal_image_width";
      hv_ParamNames3DGrippingPointsOptional[3] = "normal_image_height";
      //All parameters
      hv_ParamNamesAll.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamNamesAll = new HTuple();
      hv_ParamNamesAll = hv_ParamNamesAll.TupleConcat(hv_ParamNamesGeneral, hv_ParamNamesSegmentation, hv_ParamNamesDetectionOptional, hv_ParamNames3DGrippingPointsOptional, hv_ParamNamesPreprocessingOptional);
      }
      hv_ParamNames.Dispose();
      hv_ParamNames = new HTuple(hv_ParamNamesGeneral);
      if ((int)((new HTuple(hv_DLModelType.TupleEqual("segmentation"))).TupleOr(new HTuple(hv_DLModelType.TupleEqual(
          "3d_gripping_point_detection")))) != 0)
      {
        //Extend ParamNames for models of type segmentation.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ParamNames = hv_ParamNames.TupleConcat(
            hv_ParamNamesSegmentation);
        hv_ParamNames.Dispose();
        hv_ParamNames = ExpTmpLocalVar_ParamNames;
        }
        }
      }
      //
      //Check if legacy parameter exist.
      //Otherwise map it to the legal parameter.
      replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);
      //
      //Check that all necessary parameters are included.
      //
      hv_KeysExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNames, 
          out hv_KeysExists);
      if ((int)(new HTuple(((((hv_KeysExists.TupleEqualElem(0))).TupleSum())).TupleGreater(
          0))) != 0)
      {
        for (hv_I=0; (int)hv_I<=(int)(new HTuple(hv_KeysExists.TupleLength())); hv_I = (int)hv_I + 1)
        {
          hv_Exists.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Exists = hv_KeysExists.TupleSelect(
              hv_I);
          }
          if ((int)(hv_Exists.TupleNot()) != 0)
          {
            throw new HalconException(("DLPreprocessParam needs the parameter: '"+(hv_ParamNames.TupleSelect(
                hv_I)))+"'");
          }
        }
      }
      //
      //Check the keys provided.
      hv_InputKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "keys", new HTuple(), out hv_InputKeys);
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_InputKeys.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        hv_Key.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Key = hv_InputKeys.TupleSelect(
            hv_I);
        }
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_Key, out hv_Value);
        //Check that the key is known.
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_ParamNamesAll, hv_Key, out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
        {
          throw new HalconException(("Unknown key for DLPreprocessParam: '"+(hv_InputKeys.TupleSelect(
              hv_I)))+"'");

          hv_CheckParams.Dispose();
          hv_KeyExists.Dispose();
          hv_DLModelType.Dispose();
          hv_Exception.Dispose();
          hv_SupportedModelTypes.Dispose();
          hv_Index.Dispose();
          hv_ParamNamesGeneral.Dispose();
          hv_ParamNamesSegmentation.Dispose();
          hv_ParamNamesDetectionOptional.Dispose();
          hv_ParamNamesPreprocessingOptional.Dispose();
          hv_ParamNames3DGrippingPointsOptional.Dispose();
          hv_ParamNamesAll.Dispose();
          hv_ParamNames.Dispose();
          hv_KeysExists.Dispose();
          hv_I.Dispose();
          hv_Exists.Dispose();
          hv_InputKeys.Dispose();
          hv_Key.Dispose();
          hv_Value.Dispose();
          hv_Indices.Dispose();
          hv_ValidValues.Dispose();
          hv_ValidTypes.Dispose();
          hv_V.Dispose();
          hv_T.Dispose();
          hv_IsInt.Dispose();
          hv_ValidTypesListing.Dispose();
          hv_ValidValueListing.Dispose();
          hv_EmptyStrings.Dispose();
          hv_ImageRangeMinExists.Dispose();
          hv_ImageRangeMaxExists.Dispose();
          hv_ImageRangeMin.Dispose();
          hv_ImageRangeMax.Dispose();
          hv_IndexParam.Dispose();
          hv_SetBackgroundID.Dispose();
          hv_ClassIDsBackground.Dispose();
          hv_Intersection.Dispose();
          hv_IgnoreClassIDs.Dispose();
          hv_KnownClasses.Dispose();
          hv_IgnoreClassID.Dispose();
          hv_OptionalKeysExist.Dispose();
          hv_InstanceType.Dispose();
          hv_IsInstanceSegmentation.Dispose();
          hv_IgnoreDirection.Dispose();
          hv_ClassIDsNoOrientation.Dispose();
          hv_SemTypes.Dispose();

          return;
        }
        //Set expected values and types.
        hv_ValidValues.Dispose();
        hv_ValidValues = new HTuple();
        hv_ValidTypes.Dispose();
        hv_ValidTypes = new HTuple();
        if ((int)(new HTuple(hv_Key.TupleEqual("normalization_type"))) != 0)
        {
          hv_ValidValues.Dispose();
          hv_ValidValues = new HTuple();
          hv_ValidValues[0] = "all_channels";
          hv_ValidValues[1] = "first_channel";
          hv_ValidValues[2] = "constant_values";
          hv_ValidValues[3] = "none";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("domain_handling"))) != 0)
        {
          if ((int)(new HTuple(hv_DLModelType.TupleEqual("anomaly_detection"))) != 0)
          {
            hv_ValidValues.Dispose();
            hv_ValidValues = new HTuple();
            hv_ValidValues[0] = "full_domain";
            hv_ValidValues[1] = "crop_domain";
            hv_ValidValues[2] = "keep_domain";
          }
          else if ((int)(new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
          {
            hv_ValidValues.Dispose();
            hv_ValidValues = new HTuple();
            hv_ValidValues[0] = "full_domain";
            hv_ValidValues[1] = "crop_domain";
            hv_ValidValues[2] = "keep_domain";
          }
          else
          {
            hv_ValidValues.Dispose();
            hv_ValidValues = new HTuple();
            hv_ValidValues[0] = "full_domain";
            hv_ValidValues[1] = "crop_domain";
          }
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("model_type"))) != 0)
        {
          hv_ValidValues.Dispose();
          hv_ValidValues = new HTuple();
          hv_ValidValues[0] = "3d_gripping_point_detection";
          hv_ValidValues[1] = "anomaly_detection";
          hv_ValidValues[2] = "classification";
          hv_ValidValues[3] = "detection";
          hv_ValidValues[4] = "gc_anomaly_detection";
          hv_ValidValues[5] = "ocr_recognition";
          hv_ValidValues[6] = "ocr_detection";
          hv_ValidValues[7] = "segmentation";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("augmentation"))) != 0)
        {
          hv_ValidValues.Dispose();
          hv_ValidValues = new HTuple();
          hv_ValidValues[0] = "true";
          hv_ValidValues[1] = "false";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("set_background_id"))) != 0)
        {
          hv_ValidTypes.Dispose();
          hv_ValidTypes = "int";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("class_ids_background"))) != 0)
        {
          hv_ValidTypes.Dispose();
          hv_ValidTypes = "int";
        }
        //Check that type is valid.
        if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleGreater(
            0))) != 0)
        {
          for (hv_V=0; (int)hv_V<=(int)((new HTuple(hv_ValidTypes.TupleLength()))-1); hv_V = (int)hv_V + 1)
          {
            hv_T.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_T = hv_ValidTypes.TupleSelect(
                hv_V);
            }
            if ((int)(new HTuple(hv_T.TupleEqual("int"))) != 0)
            {
              hv_IsInt.Dispose();
              HOperatorSet.TupleIsInt(hv_Value, out hv_IsInt);
              if ((int)(hv_IsInt.TupleNot()) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_ValidTypes = ("'"+hv_ValidTypes)+"'";
                hv_ValidTypes.Dispose();
                hv_ValidTypes = ExpTmpLocalVar_ValidTypes;
                }
                }
                if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleLess(
                    2))) != 0)
                {
                  hv_ValidTypesListing.Dispose();
                  hv_ValidTypesListing = new HTuple(hv_ValidTypes);
                }
                else
                {
                  hv_ValidTypesListing.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ValidTypesListing = ((((hv_ValidTypes.TupleSelectRange(
                      0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidTypes.TupleLength()
                      ))-2)))+new HTuple(", "))+(hv_ValidTypes.TupleSelect((new HTuple(hv_ValidTypes.TupleLength()
                      ))-1)))).TupleSum();
                  }
                }
                throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid types are: ")+hv_ValidTypesListing)+". The given value was '")+hv_Value)+"'.");

                hv_CheckParams.Dispose();
                hv_KeyExists.Dispose();
                hv_DLModelType.Dispose();
                hv_Exception.Dispose();
                hv_SupportedModelTypes.Dispose();
                hv_Index.Dispose();
                hv_ParamNamesGeneral.Dispose();
                hv_ParamNamesSegmentation.Dispose();
                hv_ParamNamesDetectionOptional.Dispose();
                hv_ParamNamesPreprocessingOptional.Dispose();
                hv_ParamNames3DGrippingPointsOptional.Dispose();
                hv_ParamNamesAll.Dispose();
                hv_ParamNames.Dispose();
                hv_KeysExists.Dispose();
                hv_I.Dispose();
                hv_Exists.Dispose();
                hv_InputKeys.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_Indices.Dispose();
                hv_ValidValues.Dispose();
                hv_ValidTypes.Dispose();
                hv_V.Dispose();
                hv_T.Dispose();
                hv_IsInt.Dispose();
                hv_ValidTypesListing.Dispose();
                hv_ValidValueListing.Dispose();
                hv_EmptyStrings.Dispose();
                hv_ImageRangeMinExists.Dispose();
                hv_ImageRangeMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IndexParam.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassIDsBackground.Dispose();
                hv_Intersection.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_KnownClasses.Dispose();
                hv_IgnoreClassID.Dispose();
                hv_OptionalKeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_SemTypes.Dispose();

                return;
              }
            }
            else
            {
              throw new HalconException("Internal error. Unknown valid type.");
            }
          }
        }
        //Check that value is valid.
        if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleGreater(
            0))) != 0)
        {
          hv_Index.Dispose();
          HOperatorSet.TupleFindFirst(hv_ValidValues, hv_Value, out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ValidValues = ("'"+hv_ValidValues)+"'";
            hv_ValidValues.Dispose();
            hv_ValidValues = ExpTmpLocalVar_ValidValues;
            }
            }
            if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleLess(
                2))) != 0)
            {
              hv_ValidValueListing.Dispose();
              hv_ValidValueListing = new HTuple(hv_ValidValues);
            }
            else
            {
              hv_EmptyStrings.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_EmptyStrings = HTuple.TupleGenConst(
                  (new HTuple(hv_ValidValues.TupleLength()))-2,"");
              }
              hv_ValidValueListing.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ValidValueListing = ((((hv_ValidValues.TupleSelectRange(
                  0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidValues.TupleLength()
                  ))-2)))+new HTuple(", "))+(hv_EmptyStrings.TupleConcat(hv_ValidValues.TupleSelect(
                  (new HTuple(hv_ValidValues.TupleLength()))-1))))).TupleSum();
              }
            }
            throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid values are: ")+hv_ValidValueListing)+". The given value was '")+hv_Value)+"'.");
          }
        }
      }
      //
      //Check the correct setting of ImageRangeMin and ImageRangeMax.
      if ((int)((new HTuple(hv_DLModelType.TupleEqual("classification"))).TupleOr(
          new HTuple(hv_DLModelType.TupleEqual("detection")))) != 0)
      {
        //Check ImageRangeMin and ImageRangeMax.
        hv_ImageRangeMinExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_min", 
            out hv_ImageRangeMinExists);
        hv_ImageRangeMaxExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_max", 
            out hv_ImageRangeMaxExists);
        //If they are present, check that they are set correctly.
        if ((int)(hv_ImageRangeMinExists) != 0)
        {
          hv_ImageRangeMin.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
          if ((int)(new HTuple(hv_ImageRangeMin.TupleNotEqual(-127))) != 0)
          {
            throw new HalconException(("For model type "+hv_DLModelType)+" ImageRangeMin has to be -127.");
          }
        }
        if ((int)(hv_ImageRangeMaxExists) != 0)
        {
          hv_ImageRangeMax.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
          if ((int)(new HTuple(hv_ImageRangeMax.TupleNotEqual(128))) != 0)
          {
            throw new HalconException(("For model type "+hv_DLModelType)+" ImageRangeMax has to be 128.");
          }
        }
      }
      //
      //Check segmentation specific parameters.
      if ((int)((new HTuple(hv_DLModelType.TupleEqual("segmentation"))).TupleOr(new HTuple(hv_DLModelType.TupleEqual(
          "3d_gripping_point_detection")))) != 0)
      {
        //Check if detection specific parameters are set.
        hv_KeysExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional, 
            out hv_KeysExists);
        //If they are present, check that they are [].
        for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_ParamNamesDetectionOptional.TupleLength()
            ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
        {
          if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Value.Dispose();
            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                hv_IndexParam), out hv_Value);
            }
            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
            {
              throw new HalconException(((("The preprocessing parameter '"+(hv_ParamNamesDetectionOptional.TupleSelect(
                  hv_IndexParam)))+"' was set to ")+hv_Value)+new HTuple(" but for segmentation it should be set to [], as it is not used for this method."));
            }
          }
        }
        //Check 'set_background_id'.
        hv_SetBackgroundID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
        if ((int)((new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))).TupleAnd(
            new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
        {
          throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '")+"set_background_id")+new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
        }
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
            1))) != 0)
        {
          throw new HalconException("Only one class_id as 'set_background_id' allowed.");
        }
        //Check 'class_ids_background'.
        hv_ClassIDsBackground.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassIDsBackground);
        if ((int)((new HTuple(hv_ClassIDsBackground.TupleNotEqual(new HTuple()))).TupleAnd(
            new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
        {
          throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '")+"class_ids_background")+new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
        }
        if ((int)((new HTuple((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
            )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
            )).TupleGreater(0))).TupleNot()))).TupleOr((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
            )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
            )).TupleGreater(0))).TupleNot()))) != 0)
        {
          throw new HalconException("Both keys 'set_background_id' and 'class_ids_background' are required.");
        }
        //Check that 'class_ids_background' and 'set_background_id' are disjoint.
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
            0))) != 0)
        {
          hv_Intersection.Dispose();
          HOperatorSet.TupleIntersection(hv_SetBackgroundID, hv_ClassIDsBackground, 
              out hv_Intersection);
          if ((int)(new HTuple(hv_Intersection.TupleLength())) != 0)
          {
            throw new HalconException("Class IDs in 'set_background_id' and 'class_ids_background' need to be disjoint.");
          }
        }
        //Check 'ignore_class_ids'.
        hv_IgnoreClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
        if ((int)((new HTuple(hv_IgnoreClassIDs.TupleNotEqual(new HTuple()))).TupleAnd(
            new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
        {
          throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '")+"ignore_class_ids")+new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
        }
        hv_KnownClasses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KnownClasses = new HTuple();
        hv_KnownClasses = hv_KnownClasses.TupleConcat(hv_SetBackgroundID, hv_ClassIDsBackground);
        }
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
            ))-1); hv_I = (int)hv_I + 1)
        {
          hv_IgnoreClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
              hv_I);
          }
          hv_Index.Dispose();
          HOperatorSet.TupleFindFirst(hv_KnownClasses, hv_IgnoreClassID, out hv_Index);
          if ((int)((new HTuple((new HTuple(hv_Index.TupleLength())).TupleGreater(
              0))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
          {
            throw new HalconException("The given 'ignore_class_ids' must not be included in the 'class_ids_background' or 'set_background_id'.");
          }
        }
      }
      else if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
      {
        //Check if segmentation specific parameters are set.
        hv_KeysExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesSegmentation, 
            out hv_KeysExists);
        //If they are present, check that they are [].
        for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_ParamNamesSegmentation.TupleLength()
            ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
        {
          if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Value.Dispose();
            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesSegmentation.TupleSelect(
                hv_IndexParam), out hv_Value);
            }
            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
            {
              throw new HalconException(((("The preprocessing parameter '"+(hv_ParamNamesSegmentation.TupleSelect(
                  hv_IndexParam)))+"' was set to ")+hv_Value)+new HTuple(" but for detection it should be set to [], as it is not used for this method."));
            }
          }
        }
        //Check optional parameters.
        hv_OptionalKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional, 
            out hv_OptionalKeysExist);
        if ((int)(hv_OptionalKeysExist.TupleSelect(0)) != 0)
        {
          //Check 'instance_type'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_InstanceType.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              0), out hv_InstanceType);
          }
          if ((int)(new HTuple((new HTuple((((new HTuple("rectangle1")).TupleConcat(
              "rectangle2")).TupleConcat("mask")).TupleFind(hv_InstanceType))).TupleEqual(
              -1))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'instance_type': "+hv_InstanceType)+new HTuple(", only 'rectangle1' and 'rectangle2' are allowed"));
          }
        }
        //If instance_segmentation is set we might overwrite the instance_type for the preprocessing.
        if ((int)(hv_OptionalKeysExist.TupleSelect(3)) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IsInstanceSegmentation.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              3), out hv_IsInstanceSegmentation);
          }
          if ((int)(new HTuple((new HTuple(((((new HTuple(1)).TupleConcat(0)).TupleConcat(
              "true")).TupleConcat("false")).TupleFind(hv_IsInstanceSegmentation))).TupleEqual(
              -1))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'instance_segmentation': "+hv_IsInstanceSegmentation)+new HTuple(", only true, false, 'true' and 'false' are allowed"));
          }
        }
        if ((int)(hv_OptionalKeysExist.TupleSelect(1)) != 0)
        {
          //Check 'ignore_direction'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IgnoreDirection.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              1), out hv_IgnoreDirection);
          }
          if ((int)(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
              hv_IgnoreDirection))).TupleEqual(-1))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'ignore_direction': "+hv_IgnoreDirection)+new HTuple(", only true and false are allowed"));
          }
        }
        if ((int)(hv_OptionalKeysExist.TupleSelect(2)) != 0)
        {
          //Check 'class_ids_no_orientation'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassIDsNoOrientation.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              2), out hv_ClassIDsNoOrientation);
          }
          hv_SemTypes.Dispose();
          HOperatorSet.TupleSemTypeElem(hv_ClassIDsNoOrientation, out hv_SemTypes);
          if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
              new HTuple(((((hv_SemTypes.TupleEqualElem("integer"))).TupleSum())).TupleNotEqual(
              new HTuple(hv_ClassIDsNoOrientation.TupleLength()))))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': "+hv_ClassIDsNoOrientation)+new HTuple(", only integers are allowed"));
          }
          else
          {
            if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
                new HTuple(((((hv_ClassIDsNoOrientation.TupleGreaterEqualElem(0))).TupleSum()
                )).TupleNotEqual(new HTuple(hv_ClassIDsNoOrientation.TupleLength()
                ))))) != 0)
            {
              throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': "+hv_ClassIDsNoOrientation)+new HTuple(", only non-negative integers are allowed"));
            }
          }
        }
      }
      //

      hv_CheckParams.Dispose();
      hv_KeyExists.Dispose();
      hv_DLModelType.Dispose();
      hv_Exception.Dispose();
      hv_SupportedModelTypes.Dispose();
      hv_Index.Dispose();
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNames3DGrippingPointsOptional.Dispose();
      hv_ParamNamesAll.Dispose();
      hv_ParamNames.Dispose();
      hv_KeysExists.Dispose();
      hv_I.Dispose();
      hv_Exists.Dispose();
      hv_InputKeys.Dispose();
      hv_Key.Dispose();
      hv_Value.Dispose();
      hv_Indices.Dispose();
      hv_ValidValues.Dispose();
      hv_ValidTypes.Dispose();
      hv_V.Dispose();
      hv_T.Dispose();
      hv_IsInt.Dispose();
      hv_ValidTypesListing.Dispose();
      hv_ValidValueListing.Dispose();
      hv_EmptyStrings.Dispose();
      hv_ImageRangeMinExists.Dispose();
      hv_ImageRangeMaxExists.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IndexParam.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassIDsBackground.Dispose();
      hv_Intersection.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_KnownClasses.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_OptionalKeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_IsInstanceSegmentation.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_SemTypes.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_CheckParams.Dispose();
      hv_KeyExists.Dispose();
      hv_DLModelType.Dispose();
      hv_Exception.Dispose();
      hv_SupportedModelTypes.Dispose();
      hv_Index.Dispose();
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNames3DGrippingPointsOptional.Dispose();
      hv_ParamNamesAll.Dispose();
      hv_ParamNames.Dispose();
      hv_KeysExists.Dispose();
      hv_I.Dispose();
      hv_Exists.Dispose();
      hv_InputKeys.Dispose();
      hv_Key.Dispose();
      hv_Value.Dispose();
      hv_Indices.Dispose();
      hv_ValidValues.Dispose();
      hv_ValidTypes.Dispose();
      hv_V.Dispose();
      hv_T.Dispose();
      hv_IsInt.Dispose();
      hv_ValidTypesListing.Dispose();
      hv_ValidValueListing.Dispose();
      hv_EmptyStrings.Dispose();
      hv_ImageRangeMinExists.Dispose();
      hv_ImageRangeMaxExists.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IndexParam.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassIDsBackground.Dispose();
      hv_Intersection.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_KnownClasses.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_OptionalKeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_IsInstanceSegmentation.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_SemTypes.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Compute 3D normals. 
  private void compute_normals_xyz (HObject ho_x, HObject ho_y, HObject ho_z, out HObject ho_NXImage, 
      out HObject ho_NYImage, out HObject ho_NZImage, HTuple hv_Smoothing)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_xScaled, ho_yScaled, ho_zScaled;
    HObject ho_xDiffRow, ho_xDiffCol, ho_yDiffRow, ho_yDiffCol;
    HObject ho_zDiffRow, ho_zDiffCol, ho_ImageResult, ho_ImageResult2;
    HObject ho_NXRaw, ho_NYRaw, ho_NZRaw, ho_NXSquare, ho_NYSquare;
    HObject ho_NZSquare, ho_ImageResult1, ho_SqrtImage;

    // Local control variables 

    HTuple hv_Factor = new HTuple(), hv_MaskRow = new HTuple();
    HTuple hv_MaskCol = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_NXImage);
    HOperatorSet.GenEmptyObj(out ho_NYImage);
    HOperatorSet.GenEmptyObj(out ho_NZImage);
    HOperatorSet.GenEmptyObj(out ho_xScaled);
    HOperatorSet.GenEmptyObj(out ho_yScaled);
    HOperatorSet.GenEmptyObj(out ho_zScaled);
    HOperatorSet.GenEmptyObj(out ho_xDiffRow);
    HOperatorSet.GenEmptyObj(out ho_xDiffCol);
    HOperatorSet.GenEmptyObj(out ho_yDiffRow);
    HOperatorSet.GenEmptyObj(out ho_yDiffCol);
    HOperatorSet.GenEmptyObj(out ho_zDiffRow);
    HOperatorSet.GenEmptyObj(out ho_zDiffCol);
    HOperatorSet.GenEmptyObj(out ho_ImageResult);
    HOperatorSet.GenEmptyObj(out ho_ImageResult2);
    HOperatorSet.GenEmptyObj(out ho_NXRaw);
    HOperatorSet.GenEmptyObj(out ho_NYRaw);
    HOperatorSet.GenEmptyObj(out ho_NZRaw);
    HOperatorSet.GenEmptyObj(out ho_NXSquare);
    HOperatorSet.GenEmptyObj(out ho_NYSquare);
    HOperatorSet.GenEmptyObj(out ho_NZSquare);
    HOperatorSet.GenEmptyObj(out ho_ImageResult1);
    HOperatorSet.GenEmptyObj(out ho_SqrtImage);
    try
    {
      //For numerical reasons we scale the input data
      hv_Factor.Dispose();
      hv_Factor = 1e6;
      ho_xScaled.Dispose();
      HOperatorSet.ScaleImage(ho_x, out ho_xScaled, hv_Factor, 0);
      ho_yScaled.Dispose();
      HOperatorSet.ScaleImage(ho_y, out ho_yScaled, hv_Factor, 0);
      ho_zScaled.Dispose();
      HOperatorSet.ScaleImage(ho_z, out ho_zScaled, hv_Factor, 0);

      //Filter for diffs in row/col direction
      hv_MaskRow.Dispose();
      hv_MaskRow = new HTuple();
      hv_MaskRow[0] = 2;
      hv_MaskRow[1] = 1;
      hv_MaskRow[2] = 1.0;
      hv_MaskRow[3] = 1;
      hv_MaskRow[4] = -1;
      hv_MaskCol.Dispose();
      hv_MaskCol = new HTuple();
      hv_MaskCol[0] = 1;
      hv_MaskCol[1] = 2;
      hv_MaskCol[2] = 1.0;
      hv_MaskCol[3] = -1;
      hv_MaskCol[4] = 1;
      ho_xDiffRow.Dispose();
      HOperatorSet.ConvolImage(ho_xScaled, out ho_xDiffRow, hv_MaskRow, "continued");
      ho_xDiffCol.Dispose();
      HOperatorSet.ConvolImage(ho_xScaled, out ho_xDiffCol, hv_MaskCol, "continued");
      ho_yDiffRow.Dispose();
      HOperatorSet.ConvolImage(ho_yScaled, out ho_yDiffRow, hv_MaskRow, "continued");
      ho_yDiffCol.Dispose();
      HOperatorSet.ConvolImage(ho_yScaled, out ho_yDiffCol, hv_MaskCol, "continued");
      ho_zDiffRow.Dispose();
      HOperatorSet.ConvolImage(ho_zScaled, out ho_zDiffRow, hv_MaskRow, "continued");
      ho_zDiffCol.Dispose();
      HOperatorSet.ConvolImage(ho_zScaled, out ho_zDiffCol, hv_MaskCol, "continued");
      //
      //Calculate normal as cross product
      ho_ImageResult.Dispose();
      HOperatorSet.MultImage(ho_yDiffRow, ho_zDiffCol, out ho_ImageResult, 1.0, 0);
      ho_ImageResult2.Dispose();
      HOperatorSet.MultImage(ho_zDiffRow, ho_yDiffCol, out ho_ImageResult2, -1.0, 
          0);
      ho_NXRaw.Dispose();
      HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NXRaw, 1.0, 0);
      //
      ho_ImageResult.Dispose();
      HOperatorSet.MultImage(ho_xDiffRow, ho_zDiffCol, out ho_ImageResult, -1.0, 
          0);
      ho_ImageResult2.Dispose();
      HOperatorSet.MultImage(ho_zDiffRow, ho_xDiffCol, out ho_ImageResult2, 1.0, 
          0);
      ho_NYRaw.Dispose();
      HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NYRaw, 1.0, 0);
      //
      ho_ImageResult.Dispose();
      HOperatorSet.MultImage(ho_xDiffRow, ho_yDiffCol, out ho_ImageResult, 1.0, 0);
      ho_ImageResult2.Dispose();
      HOperatorSet.MultImage(ho_yDiffRow, ho_xDiffCol, out ho_ImageResult2, -1.0, 
          0);
      ho_NZRaw.Dispose();
      HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NZRaw, 1.0, 0);

      //Smooth
      //-> 5 is used as it is used in surface_normals_object_model_3d - 'xyz_mapping'
      if ((int)(hv_Smoothing) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MeanImage(ho_NXRaw, out ExpTmpOutVar_0, 5, 5);
        ho_NXRaw.Dispose();
        ho_NXRaw = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MeanImage(ho_NYRaw, out ExpTmpOutVar_0, 5, 5);
        ho_NYRaw.Dispose();
        ho_NYRaw = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MeanImage(ho_NZRaw, out ExpTmpOutVar_0, 5, 5);
        ho_NZRaw.Dispose();
        ho_NZRaw = ExpTmpOutVar_0;
        }
      }

      //Normalize
      ho_NXSquare.Dispose();
      HOperatorSet.MultImage(ho_NXRaw, ho_NXRaw, out ho_NXSquare, 1.0, 0);
      ho_NYSquare.Dispose();
      HOperatorSet.MultImage(ho_NYRaw, ho_NYRaw, out ho_NYSquare, 1.0, 0);
      ho_NZSquare.Dispose();
      HOperatorSet.MultImage(ho_NZRaw, ho_NZRaw, out ho_NZSquare, 1.0, 0);
      ho_ImageResult1.Dispose();
      HOperatorSet.AddImage(ho_NXSquare, ho_NYSquare, out ho_ImageResult1, 1.0, 0);
      ho_ImageResult2.Dispose();
      HOperatorSet.AddImage(ho_ImageResult1, ho_NZSquare, out ho_ImageResult2, 1.0, 
          0);
      ho_SqrtImage.Dispose();
      HOperatorSet.SqrtImage(ho_ImageResult2, out ho_SqrtImage);
      //
      ho_NXImage.Dispose();
      HOperatorSet.DivImage(ho_NXRaw, ho_SqrtImage, out ho_NXImage, 1.0, 0);
      ho_NYImage.Dispose();
      HOperatorSet.DivImage(ho_NYRaw, ho_SqrtImage, out ho_NYImage, 1.0, 0);
      ho_NZImage.Dispose();
      HOperatorSet.DivImage(ho_NZRaw, ho_SqrtImage, out ho_NZImage, 1.0, 0);
      ho_xScaled.Dispose();
      ho_yScaled.Dispose();
      ho_zScaled.Dispose();
      ho_xDiffRow.Dispose();
      ho_xDiffCol.Dispose();
      ho_yDiffRow.Dispose();
      ho_yDiffCol.Dispose();
      ho_zDiffRow.Dispose();
      ho_zDiffCol.Dispose();
      ho_ImageResult.Dispose();
      ho_ImageResult2.Dispose();
      ho_NXRaw.Dispose();
      ho_NYRaw.Dispose();
      ho_NZRaw.Dispose();
      ho_NXSquare.Dispose();
      ho_NYSquare.Dispose();
      ho_NZSquare.Dispose();
      ho_ImageResult1.Dispose();
      ho_SqrtImage.Dispose();

      hv_Factor.Dispose();
      hv_MaskRow.Dispose();
      hv_MaskCol.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_xScaled.Dispose();
      ho_yScaled.Dispose();
      ho_zScaled.Dispose();
      ho_xDiffRow.Dispose();
      ho_xDiffCol.Dispose();
      ho_yDiffRow.Dispose();
      ho_yDiffCol.Dispose();
      ho_zDiffRow.Dispose();
      ho_zDiffCol.Dispose();
      ho_ImageResult.Dispose();
      ho_ImageResult2.Dispose();
      ho_NXRaw.Dispose();
      ho_NYRaw.Dispose();
      ho_NZRaw.Dispose();
      ho_NXSquare.Dispose();
      ho_NYSquare.Dispose();
      ho_NZSquare.Dispose();
      ho_ImageResult1.Dispose();
      ho_SqrtImage.Dispose();

      hv_Factor.Dispose();
      hv_MaskRow.Dispose();
      hv_MaskCol.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
  public void convert_ocr_detection_result_to_object_detection (HTuple hv_OcrResults, 
      out HTuple hv_DetectionResults)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Index = new HTuple(), hv_OcrResult = new HTuple();
    HTuple hv_RequiredKeysExist = new HTuple(), hv_DetectionResult = new HTuple();
    HTuple hv___Tmp_Ctrl_Type = new HTuple();
    // Initialize local and output iconic variables 
    hv_DetectionResults = new HTuple();
    try
    {
      //
      //Convert Deep OCR Detection results
      //to Object Detection results.
      //
      //Create DetectionResults Dict
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DetectionResults.Dispose();
      HOperatorSet.TupleGenConst(new HTuple(hv_OcrResults.TupleLength()), HTuple.TupleConstant(
          "HNULL"), out hv_DetectionResults);
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_OcrResults.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_OcrResult.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OcrResult = hv_OcrResults.TupleSelect(
            hv_Index);
        }
        //Check if input is valid
        hv_RequiredKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult, "key_exists", "words", out hv_RequiredKeysExist);
        if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
            )))) != 0)
        {
          throw new HalconException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RequiredKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_exists", 
            ((((new HTuple("row")).TupleConcat("col")).TupleConcat("phi")).TupleConcat(
            "length1")).TupleConcat("length2"), out hv_RequiredKeysExist);
        }
        if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
            )))) != 0)
        {
          throw new HalconException(("The item at Index "+hv_Index)+" is not a valid Deep OCR Detection Result");
        }
        //Convert ocr detection result to object detection
        hv_DetectionResult.Dispose();
        HOperatorSet.CreateDict(out hv_DetectionResult);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Type.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", 
            "row", out hv___Tmp_Ctrl_Type);
        }
        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
              "row"), hv_DetectionResult, "bbox_row");
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_row", ((hv_OcrResult.TupleGetDictTuple(
              "words"))).TupleGetDictTuple("row"));
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Type.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", 
            "col", out hv___Tmp_Ctrl_Type);
        }
        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
              "col"), hv_DetectionResult, "bbox_col");
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_col", ((hv_OcrResult.TupleGetDictTuple(
              "words"))).TupleGetDictTuple("col"));
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Type.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", 
            "phi", out hv___Tmp_Ctrl_Type);
        }
        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
              "phi"), hv_DetectionResult, "bbox_phi");
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_phi", ((hv_OcrResult.TupleGetDictTuple(
              "words"))).TupleGetDictTuple("phi"));
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Type.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", 
            "length1", out hv___Tmp_Ctrl_Type);
        }
        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
              "length1"), hv_DetectionResult, "bbox_length1");
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length1", ((hv_OcrResult.TupleGetDictTuple(
              "words"))).TupleGetDictTuple("length1"));
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Type.Dispose();
        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type", 
            "length2", out hv___Tmp_Ctrl_Type);
        }
        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
              "length2"), hv_DetectionResult, "bbox_length2");
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length2", ((hv_OcrResult.TupleGetDictTuple(
              "words"))).TupleGetDictTuple("length2"));
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_confidence", HTuple.TupleGenConst(
            new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
            ),1.0));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_class_id", HTuple.TupleGenConst(
            new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
            ),0));
        }
        if (hv_DetectionResults == null)
          hv_DetectionResults = new HTuple();
        hv_DetectionResults[hv_Index] = hv_DetectionResult;
      }



      hv_Index.Dispose();
      hv_OcrResult.Dispose();
      hv_RequiredKeysExist.Dispose();
      hv_DetectionResult.Dispose();
      hv___Tmp_Ctrl_Type.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Index.Dispose();
      hv_OcrResult.Dispose();
      hv_RequiredKeysExist.Dispose();
      hv_DetectionResult.Dispose();
      hv___Tmp_Ctrl_Type.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Tools / Geometry
  // Short Description: Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points. 
  private void convert_rect2_5to8param (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, 
      HTuple hv_Length2, HTuple hv_Phi, out HTuple hv_Row1, out HTuple hv_Col1, out HTuple hv_Row2, 
      out HTuple hv_Col2, out HTuple hv_Row3, out HTuple hv_Col3, out HTuple hv_Row4, 
      out HTuple hv_Col4)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Co1 = new HTuple(), hv_Co2 = new HTuple();
    HTuple hv_Si1 = new HTuple(), hv_Si2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_Row1 = new HTuple();
    hv_Col1 = new HTuple();
    hv_Row2 = new HTuple();
    hv_Col2 = new HTuple();
    hv_Row3 = new HTuple();
    hv_Col3 = new HTuple();
    hv_Row4 = new HTuple();
    hv_Col4 = new HTuple();
    try
    {
      //This procedure takes the parameters for a rectangle of type 'rectangle2'
      //and returns the coordinates of the four corners.
      //
      hv_Co1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Co1 = (hv_Phi.TupleCos()
          )*hv_Length1;
      }
      hv_Co2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Co2 = (hv_Phi.TupleCos()
          )*hv_Length2;
      }
      hv_Si1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Si1 = (hv_Phi.TupleSin()
          )*hv_Length1;
      }
      hv_Si2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Si2 = (hv_Phi.TupleSin()
          )*hv_Length2;
      }

      hv_Col1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col1 = (hv_Co1-hv_Si2)+hv_Col;
      }
      hv_Row1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row1 = ((-hv_Si1)-hv_Co2)+hv_Row;
      }
      hv_Col2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col2 = ((-hv_Co1)-hv_Si2)+hv_Col;
      }
      hv_Row2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row2 = (hv_Si1-hv_Co2)+hv_Row;
      }
      hv_Col3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col3 = ((-hv_Co1)+hv_Si2)+hv_Col;
      }
      hv_Row3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row3 = (hv_Si1+hv_Co2)+hv_Row;
      }
      hv_Col4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col4 = (hv_Co1+hv_Si2)+hv_Col;
      }
      hv_Row4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row4 = ((-hv_Si1)+hv_Co2)+hv_Row;
      }


      hv_Co1.Dispose();
      hv_Co2.Dispose();
      hv_Si1.Dispose();
      hv_Si2.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Co1.Dispose();
      hv_Co2.Dispose();
      hv_Si1.Dispose();
      hv_Si2.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Tools / Geometry
  // Short Description: Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2. 
  private void convert_rect2_8to5param (HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, 
      HTuple hv_Col2, HTuple hv_Row3, HTuple hv_Col3, HTuple hv_Row4, HTuple hv_Col4, 
      HTuple hv_ForceL1LargerL2, out HTuple hv_Row, out HTuple hv_Col, out HTuple hv_Length1, 
      out HTuple hv_Length2, out HTuple hv_Phi)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Hor = new HTuple(), hv_Vert = new HTuple();
    HTuple hv_IdxSwap = new HTuple(), hv_Tmp = new HTuple();
    // Initialize local and output iconic variables 
    hv_Row = new HTuple();
    hv_Col = new HTuple();
    hv_Length1 = new HTuple();
    hv_Length2 = new HTuple();
    hv_Phi = new HTuple();
    try
    {
      //This procedure takes the corners of four-sided figures
      //and returns the parameters of type 'rectangle2'.
      //
      //Calculate center row and column.
      hv_Row.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row = (((hv_Row1+hv_Row2)+hv_Row3)+hv_Row4)/4.0;
      }
      hv_Col.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col = (((hv_Col1+hv_Col2)+hv_Col3)+hv_Col4)/4.0;
      }
      //Length1 and Length2.
      hv_Length1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length1 = (((((hv_Row1-hv_Row2)*(hv_Row1-hv_Row2))+((hv_Col1-hv_Col2)*(hv_Col1-hv_Col2)))).TupleSqrt()
          )/2.0;
      }
      hv_Length2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length2 = (((((hv_Row2-hv_Row3)*(hv_Row2-hv_Row3))+((hv_Col2-hv_Col3)*(hv_Col2-hv_Col3)))).TupleSqrt()
          )/2.0;
      }
      //Calculate the angle phi.
      hv_Hor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Hor = hv_Col1-hv_Col2;
      }
      hv_Vert.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Vert = hv_Row2-hv_Row1;
      }
      if ((int)(hv_ForceL1LargerL2) != 0)
      {
        //Swap length1 and length2 if necessary.
        hv_IdxSwap.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IdxSwap = ((((hv_Length2-hv_Length1)).TupleGreaterElem(
            1e-9))).TupleFind(1);
        }
        if ((int)(new HTuple(hv_IdxSwap.TupleNotEqual(-1))) != 0)
        {
          hv_Tmp.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Tmp = hv_Length1.TupleSelect(
              hv_IdxSwap);
          }
          if (hv_Length1 == null)
            hv_Length1 = new HTuple();
          hv_Length1[hv_IdxSwap] = hv_Length2.TupleSelect(hv_IdxSwap);
          if (hv_Length2 == null)
            hv_Length2 = new HTuple();
          hv_Length2[hv_IdxSwap] = hv_Tmp;
          if (hv_Hor == null)
            hv_Hor = new HTuple();
          hv_Hor[hv_IdxSwap] = (hv_Col2.TupleSelect(hv_IdxSwap))-(hv_Col3.TupleSelect(
              hv_IdxSwap));
          if (hv_Vert == null)
            hv_Vert = new HTuple();
          hv_Vert[hv_IdxSwap] = (hv_Row3.TupleSelect(hv_IdxSwap))-(hv_Row2.TupleSelect(
              hv_IdxSwap));
        }
      }
      hv_Phi.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Phi = hv_Vert.TupleAtan2(
          hv_Hor);
      }
      //

      hv_Hor.Dispose();
      hv_Vert.Dispose();
      hv_IdxSwap.Dispose();
      hv_Tmp.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Hor.Dispose();
      hv_Vert.Dispose();
      hv_IdxSwap.Dispose();
      hv_Tmp.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Crops a given image object based on the given domain handling. 
  private void crop_dl_sample_image (HObject ho_Domain, HTuple hv_DLSample, HTuple hv_Key, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho___Tmp_Obj_0=null;

    // Local control variables 

    HTuple hv_KeyExists = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Column2 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
    try
    {
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", hv_Key, out hv_KeyExists);
      if ((int)(hv_KeyExists) != 0)
      {
        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "crop_domain");
        if ((int)(((hv_DLPreprocessParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
            "domain_handling","comp")) != 0)
        {
          hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
          HOperatorSet.SmallestRectangle1(ho_Domain, out hv_Row1, out hv_Column1, 
              out hv_Row2, out hv_Column2);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho___Tmp_Obj_0.Dispose();
          HOperatorSet.CropPart(hv_DLSample.TupleGetDictObject(hv_Key), out ho___Tmp_Obj_0, 
              hv_Row1, hv_Column1, (hv_Column2-hv_Column1)+1, (hv_Row2-hv_Row1)+1);
          }
          HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, hv_Key);
        }
        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
            "HNULL");
        }
      }
      ho___Tmp_Obj_0.Dispose();

      hv_KeyExists.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho___Tmp_Obj_0.Dispose();

      hv_KeyExists.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Close all window handles contained in a dictionary. 
  public void dev_close_window_dict (HTuple hv_WindowHandleDict)
  {



      // Local iconic variables 

      // Local control variables 

      HTuple hv_WindowHandleDicts = new HTuple();
      HTuple hv_WindowDictIdx = new HTuple(), hv_WindowHandleKeys = new HTuple();
      HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
      HTuple hv_Exception = new HTuple(), hv_RemovedWindowIndices = new HTuple();
      HTuple hv_WindowHandleIndex = new HTuple();
      HTuple   hv_WindowHandleDict_COPY_INP_TMP = new HTuple(hv_WindowHandleDict);

      // Initialize local and output iconic variables 
      try
      {
      //
      //This procedure closes all window handles
      //that are contained in the dictionary WindowHandleDict.
      //
      hv_WindowHandleDicts.Dispose();
      hv_WindowHandleDicts = new HTuple(hv_WindowHandleDict_COPY_INP_TMP);
      for (hv_WindowDictIdx=0; (int)hv_WindowDictIdx<=(int)((new HTuple(hv_WindowHandleDicts.TupleLength()
          ))-1); hv_WindowDictIdx = (int)hv_WindowDictIdx + 1)
      {
        hv_WindowHandleDict_COPY_INP_TMP.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowHandleDict_COPY_INP_TMP = hv_WindowHandleDicts.TupleSelect(
            hv_WindowDictIdx);
        }
        hv_WindowHandleKeys.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "keys", new HTuple(), 
            out hv_WindowHandleKeys);
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          try
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowHandles.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                hv_Index), out hv_WindowHandles);
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            continue;
          }
          hv_RemovedWindowIndices.Dispose();
          hv_RemovedWindowIndices = new HTuple();
          for (hv_WindowHandleIndex=0; (int)hv_WindowHandleIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
              ))-1); hv_WindowHandleIndex = (int)hv_WindowHandleIndex + 1)
          {
            //Not every entry has to be a window handle, therefore use try-catch.
            try
            {
              //Call set_window_param to check if the handle is a window handle.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowHandleIndex), 
                  "flush", "true");
              }
              HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                  hv_WindowHandleIndex));
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_RemovedWindowIndices = hv_RemovedWindowIndices.TupleConcat(
                  hv_WindowHandleIndex);
              hv_RemovedWindowIndices.Dispose();
              hv_RemovedWindowIndices = ExpTmpLocalVar_RemovedWindowIndices;
              }
              }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
              HDevExpDefaultException1.ToHTuple(out hv_Exception);
            }
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRemove(hv_WindowHandles, hv_RemovedWindowIndices, out ExpTmpOutVar_0);
          hv_WindowHandles.Dispose();
          hv_WindowHandles = ExpTmpOutVar_0;
          }
          //If some entries remained, set reduced tuple. Otherwise, remove whole key entry.
          if ((int)(new HTuple((new HTuple(hv_WindowHandles.TupleLength())).TupleGreater(
              0))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                hv_Index), hv_WindowHandles);
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.RemoveDictKey(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                hv_Index));
            }
          }
        }
      }
      //

      hv_WindowHandleDict_COPY_INP_TMP.Dispose();
      hv_WindowHandleDicts.Dispose();
      hv_WindowDictIdx.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandles.Dispose();
      hv_Exception.Dispose();
      hv_RemovedWindowIndices.Dispose();
      hv_WindowHandleIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleDict_COPY_INP_TMP.Dispose();
      hv_WindowHandleDicts.Dispose();
      hv_WindowDictIdx.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandles.Dispose();
      hv_Exception.Dispose();
      hv_RemovedWindowIndices.Dispose();
      hv_WindowHandleIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of the confidences. 
  private void dev_display_confidence_regions (HObject ho_ImageConfidence, HTuple hv_DrawTransparency, 
      out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Region=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
    HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure displays a map of the confidences
      //given in ImageConfidence as regions.
      //DrawTransparency determines the alpha value of the colors.
      //The used colors are returned.
      //
      //Define colors.
      hv_NumColors.Dispose();
      hv_NumColors = 20;
      hv_Colors.Dispose();
      get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
      hv_WeightsColorsAlpha.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
      }
      hv_ColorIndex.Dispose();
      hv_ColorIndex = 0;
      //
      //Threshold the image according to
      //the number of colors and
      //display resulting regions.
      HTuple end_val15 = hv_NumColors-1;
      HTuple step_val15 = 1;
      for (hv_ColorIndex=0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
      {
        hv_Threshold.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Threshold = hv_ColorIndex*(1.0/hv_NumColors);
        }
        hv_MinGray.Dispose();
        hv_MinGray = new HTuple(hv_Threshold);
        hv_MaxGray.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxGray = hv_Threshold+(1/hv_NumColors);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Region.Dispose();
        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold+(1.0/hv_NumColors));
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
              hv_ColorIndex));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
        }
      }
      ho_Region.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_ColorIndex.Dispose();
      hv_Threshold.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Region.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_ColorIndex.Dispose();
      hv_Threshold.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Visualize different images, annotations and inference results for a sample. 
  public void dev_display_dl_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
      HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image=null, ho_Domain=null, ho_GrippingMapImageResult=null;
    HObject ho_Cross=null, ho_GrippingMapGroundTruth=null, ho_X=null;
    HObject ho_Y=null, ho_Z=null, ho_AnomalyImage=null, ho_AnomalyRegion=null;
    HObject ho_ConfidenceImage=null, ho_HeatmapScene=null, ho_ScoreMaps=null;
    HObject ho_CharacterScoreMap=null, ho_LinkScoreMap=null;
    HObject ho_OrientationSinScoreMap=null, ho_OrientationCosScoreMap=null;
    HObject ho_ScoreMap=null, ho_OrientationScoreMap=null, ho_PredictionColorFrame=null;
    HObject ho_ImageHeatmap=null, ho_PredictionSymbol=null;
    HObject ho_CrossLineH=null, ho_CrossLineV=null, ho_ImageConfidence=null;
    HObject ho_SegmentationImagGroundTruth=null, ho_SegmentationImageResult=null;
    HObject ho_ImageAbsDiff=null, ho_DiffRegion=null, ho_ImageWeight=null;

    // Local control variables 

    HTuple hv_Params = new HTuple(), hv_GenParamNames = new HTuple();
    HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_KeyExists = new HTuple(), hv_SampleKeys = new HTuple();
    HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
    HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
    HTuple hv_IsOCRDetection = new HTuple(), hv_AdditionalGreenClassNames = new HTuple();
    HTuple hv_KeyIndex = new HTuple(), hv_OcrResult = new HTuple();
    HTuple hv_MaxClassIdSample = new HTuple(), hv_EmptySample = new HTuple();
    HTuple hv_MaxClassIdResult = new HTuple(), hv_EmptyResult = new HTuple();
    HTuple hv_MaxClassId = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_ClassNameKey = new HTuple();
    HTuple hv_ClassIdKey = new HTuple(), hv_ResultClassNames = new HTuple();
    HTuple hv_ResultClassIds = new HTuple(), hv_SortIndices = new HTuple();
    HTuple hv_UniqueClassIds = new HTuple(), hv_UniqueClassNames = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_ClassesLegend = new HTuple();
    HTuple hv_InvalidInput = new HTuple(), hv_ClassKeys = new HTuple();
    HTuple hv_ClassKeysExist = new HTuple(), hv_DLDatasetInfoKeys = new HTuple();
    HTuple hv_Index = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
    HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MetaInfoExists = new HTuple(), hv_FlushValues = new HTuple();
    HTuple hv_WindowHandleKeys = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
    HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
    HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
    HTuple hv_ColorsGrippingGroundTruth = new HTuple(), hv_ImageClassIDs = new HTuple();
    HTuple hv_GrippingPointsExists = new HTuple(), hv_Rows = new HTuple();
    HTuple hv_Columns = new HTuple(), hv_AnomalyImages = new HTuple();
    HTuple hv_PossibleKeysForDisplay = new HTuple(), hv_AddDisplayKey = new HTuple();
    HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
    HTuple hv_AnomalyResultPostfix = new HTuple(), hv_AnomalyScore = new HTuple();
    HTuple hv_AnomalyClassID = new HTuple(), hv_AnomalyClassThresholdDisplay = new HTuple();
    HTuple hv_AnomalyRegionThresholdDisplay = new HTuple();
    HTuple hv_WindowHandleName = new HTuple(), hv_AnomalyRegionGroundTruthExists = new HTuple();
    HTuple hv_Text = new HTuple(), hv_PredictionColor = new HTuple();
    HTuple hv_LineColors = new HTuple(), hv_ResultColorOffset = new HTuple();
    HTuple hv_AnomalyRegionExists = new HTuple(), hv_AnomalyImageKey = new HTuple();
    HTuple hv_AnomalyScoreKey = new HTuple(), hv_AnomalyResultKey = new HTuple();
    HTuple hv_AnomalyRegionKey = new HTuple(), hv_DisplayDirectionTemp = new HTuple();
    HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxConfidences = new HTuple();
    HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
    HTuple hv_BboxColorsBoth = new HTuple(), hv_BboxClassLabelIndexUniq = new HTuple();
    HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
    HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxColorsResults = new HTuple();
    HTuple hv_BboxClassIndexUniq = new HTuple(), hv_ClassificationLabelIDGroundTruth = new HTuple();
    HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_PredictionText = new HTuple();
    HTuple hv_BoarderOffset = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
    HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
    HTuple hv_MarginBottom = new HTuple(), hv_WindowCoordinates = new HTuple();
    HTuple hv_CurrentWindowHeight = new HTuple(), hv__ = new HTuple();
    HTuple hv_MaxHeight = new HTuple(), hv_SelectedHeatmapMethod = new HTuple();
    HTuple hv_DictHeatmap = new HTuple(), hv_MethodName = new HTuple();
    HTuple hv_HeatmapKeys = new HTuple(), hv_HeatmapImageName = new HTuple();
    HTuple hv_TargetClassID = new HTuple(), hv_Confidences = new HTuple();
    HTuple hv_MaxDeviation = new HTuple(), hv_ClassificationLabelNameResult = new HTuple();
    HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
    HTuple hv_ShowGT = new HTuple(), hv_ShowResult = new HTuple();
    HTuple hv_NumLines = new HTuple(), hv_Type = new HTuple();
    HTuple hv_GTWordKeyExists = new HTuple(), hv_HeightWindow = new HTuple();
    HTuple hv_HeightMarginBottom = new HTuple(), hv_Size = new HTuple();
    HTuple hv_Length = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_HomMat2DIdentity = new HTuple();
    HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DCompose = new HTuple();
    HTuple hv_PredictionForegroundColor = new HTuple(), hv_PredictionBackgroundColor = new HTuple();
    HTuple hv_Spaces = new HTuple(), hv_ConfidenceColors = new HTuple();
    HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
    HTuple hv_ResultIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
    HTuple hv_ImageClassIDsIndices = new HTuple(), hv_ImageClassIDsIndex = new HTuple();
    HTuple hv_StringSegExcludeClassIDs = new HTuple(), hv_StringIndex = new HTuple();
    HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_ColorsSegmentation = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Width = new HTuple(), hv_MinWeight = new HTuple();
    HTuple hv_WeightsColors = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_WindowHandleKeysNew = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_2 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_3 = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_4 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_5 = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_6 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_7 = new HTuple();
    HTuple hv___Tmp_Ctrl_1 = new HTuple(), hv___Tmp_Ctrl_Type = new HTuple();
    HTuple   hv_DLResult_COPY_INP_TMP = new HTuple(hv_DLResult);
    HTuple   hv_KeysForDisplay_COPY_INP_TMP = new HTuple(hv_KeysForDisplay);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_GrippingMapImageResult);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    HOperatorSet.GenEmptyObj(out ho_GrippingMapGroundTruth);
    HOperatorSet.GenEmptyObj(out ho_X);
    HOperatorSet.GenEmptyObj(out ho_Y);
    HOperatorSet.GenEmptyObj(out ho_Z);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    HOperatorSet.GenEmptyObj(out ho_ConfidenceImage);
    HOperatorSet.GenEmptyObj(out ho_HeatmapScene);
    HOperatorSet.GenEmptyObj(out ho_ScoreMaps);
    HOperatorSet.GenEmptyObj(out ho_CharacterScoreMap);
    HOperatorSet.GenEmptyObj(out ho_LinkScoreMap);
    HOperatorSet.GenEmptyObj(out ho_OrientationSinScoreMap);
    HOperatorSet.GenEmptyObj(out ho_OrientationCosScoreMap);
    HOperatorSet.GenEmptyObj(out ho_ScoreMap);
    HOperatorSet.GenEmptyObj(out ho_OrientationScoreMap);
    HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
    HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
    HOperatorSet.GenEmptyObj(out ho_PredictionSymbol);
    HOperatorSet.GenEmptyObj(out ho_CrossLineH);
    HOperatorSet.GenEmptyObj(out ho_CrossLineV);
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
    HOperatorSet.GenEmptyObj(out ho_DiffRegion);
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    try
    {
      //
      //This procedure displays the content of the provided DLSample and/or DLResult
      //depending on the input string KeysForDisplay.
      //DLDatasetInfo is a dictionary containing the information about the dataset.
      //The visualization can be adapted with GenParam.
      //
      //** Set the default values: ***
      hv_Params.Dispose();
      HOperatorSet.CreateDict(out hv_Params);
      //
      //Define the screen width when a new window row is started.
      HOperatorSet.SetDictTuple(hv_Params, "threshold_width", 1024);
      //Since potentially a lot of windows are opened,
      //scale the windows consistently.
      HOperatorSet.SetDictTuple(hv_Params, "scale_windows", 0.8);
      //Set a font and a font size.
      HOperatorSet.SetDictTuple(hv_Params, "font", "mono");
      HOperatorSet.SetDictTuple(hv_Params, "font_size", 14);
      //
      HOperatorSet.SetDictTuple(hv_Params, "line_width", 2);
      HOperatorSet.SetDictTuple(hv_Params, "map_transparency", "cc");
      HOperatorSet.SetDictTuple(hv_Params, "map_color_bar_width", 140);
      //
      //Define parameter values specifically for 3d_gripping_point_detection
      HOperatorSet.SetDictTuple(hv_Params, "gripping_point_color", "#00FF0099");
      HOperatorSet.SetDictTuple(hv_Params, "gripping_point_size", 6);
      HOperatorSet.SetDictTuple(hv_Params, "region_color", "#FF000040");
      HOperatorSet.SetDictTuple(hv_Params, "gripping_point_map_color", "#83000080");
      HOperatorSet.SetDictTuple(hv_Params, "gripping_point_background_color", "#00007F80");
      //
      //Define parameter values specifically for anomaly detection
      //and Global Context Anomaly Detection.
      HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_threshold", -1);
      HOperatorSet.SetDictTuple(hv_Params, "anomaly_classification_threshold", -1);
      HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_label_color", "#40e0d0");
      HOperatorSet.SetDictTuple(hv_Params, "anomaly_color_transparency", "40");
      HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_result_color", "#ff0000c0");
      //
      //Define segmentation-specific parameter values.
      HOperatorSet.SetDictTuple(hv_Params, "segmentation_max_weight", 0);
      HOperatorSet.SetDictTuple(hv_Params, "segmentation_draw", "fill");
      HOperatorSet.SetDictTuple(hv_Params, "segmentation_transparency", "aa");
      HOperatorSet.SetDictTuple(hv_Params, "segmentation_exclude_class_ids", new HTuple());
      //
      //Define bounding box-specific parameter values.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_Params, "bbox_label_color", new HTuple("#000000")+"99");
      }
      HOperatorSet.SetDictTuple(hv_Params, "bbox_display_confidence", 1);
      HOperatorSet.SetDictTuple(hv_Params, "bbox_text_color", "#eeeeee");
      //
      //By default, display a description on the bottom.
      HOperatorSet.SetDictTuple(hv_Params, "display_bottom_desc", 1);
      //
      //By default, show a legend with class IDs.
      HOperatorSet.SetDictTuple(hv_Params, "display_legend", 1);
      //
      //By default, show the anomaly ground truth regions.
      HOperatorSet.SetDictTuple(hv_Params, "display_ground_truth_anomaly_regions", 
          1);
      //
      //By default, show class IDs and color frames for classification ground truth/results.
      HOperatorSet.SetDictTuple(hv_Params, "display_classification_ids", 1);
      HOperatorSet.SetDictTuple(hv_Params, "display_classification_color_frame", 
          1);
      //
      //By default, show class labels for detection ground truth/results.
      HOperatorSet.SetDictTuple(hv_Params, "display_labels", 1);
      //
      //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
      HOperatorSet.SetDictTuple(hv_Params, "display_direction", 1);
      //
      //By default, use color scheme 'Jet' for the heatmap display.
      HOperatorSet.SetDictTuple(hv_Params, "heatmap_color_scheme", "jet");
      //** Set user-defined values: ***
      //
      //Overwrite default values by given generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamNames.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
        for (hv_ParamIndex=0; (int)hv_ParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
            ))-1); hv_ParamIndex = (int)hv_ParamIndex + 1)
        {
          hv_GenParamName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GenParamName = hv_GenParamNames.TupleSelect(
              hv_ParamIndex);
          }
          hv_KeyExists.Dispose();
          HOperatorSet.GetDictParam(hv_Params, "key_exists", hv_GenParamName, out hv_KeyExists);
          if ((int)(hv_KeyExists.TupleNot()) != 0)
          {
            throw new HalconException(("Unknown generic parameter: "+hv_GenParamName)+".");
          }
          hv___Tmp_Ctrl_Type.Dispose();
          HOperatorSet.GetDictParam(hv_GenParam, "key_data_type", hv_GenParamName, 
              out hv___Tmp_Ctrl_Type);
          if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictObject(hv_GenParam.TupleGetDictObject(hv_GenParamName), 
                hv_Params, hv_GenParamName);
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_Params, hv_GenParamName, hv_GenParam.TupleGetDictTuple(
                hv_GenParamName));
            }
          }
        }
      }
      //
      if ((int)((new HTuple((new HTuple(hv_DLSample.TupleLength())).TupleGreater(
          1))).TupleOr(new HTuple((new HTuple(hv_DLResult_COPY_INP_TMP.TupleLength()
          )).TupleGreater(1)))) != 0)
      {
        throw new HalconException("Only a single dictionary for DLSample and DLResult is allowed");
      }
      //
      //Get the dictionary keys.
      hv_SampleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
      if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_ResultKeys.Dispose();
        HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "keys", new HTuple(), 
            out hv_ResultKeys);
      }
      //
      //Get image ID if it is available.
      hv_ImageIDExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
      if ((int)(hv_ImageIDExists) != 0)
      {
        hv_ImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
        hv_ImageIDString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDString = "image ID "+hv_ImageID;
        }
        hv_ImageIDStringBraces.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDStringBraces = ("(image ID "+hv_ImageID)+")";
        }
        hv_ImageIDStringCapital.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDStringCapital = "Image ID "+hv_ImageID;
        }
      }
      else
      {
        hv_ImageIDString.Dispose();
        hv_ImageIDString = "";
        hv_ImageIDStringBraces.Dispose();
        hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
        hv_ImageIDStringCapital.Dispose();
        hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
      }
      //
      //** Convert a Deep OCR Detection result to an Object Detection result if necessary ***
      //
      hv_IsOCRDetection.Dispose();
      hv_IsOCRDetection = 0;
      hv_AdditionalGreenClassNames.Dispose();
      hv_AdditionalGreenClassNames = new HTuple();
      hv_KeyIndex.Dispose();
      hv_KeyIndex = 0;
      for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_KeysForDisplay_COPY_INP_TMP.TupleLength()
          ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
      {
        //Check if Deep OCR Detection case
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IsOCRDetection.Dispose();
        HOperatorSet.TupleStrstr(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
            "ocr_detection", out hv_IsOCRDetection);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_IsOCRDetection = new HTuple(hv_IsOCRDetection.TupleEqual(
            0));
        hv_IsOCRDetection.Dispose();
        hv_IsOCRDetection = ExpTmpLocalVar_IsOCRDetection;
        }
        }
        if ((int)(hv_IsOCRDetection) != 0)
        {
          //Turn off labels
          HOperatorSet.SetDictTuple(hv_Params, "bbox_display_confidence", 0);
          HOperatorSet.SetDictTuple(hv_Params, "display_labels", 0);
          //Mark the class 'word' as green
          hv_AdditionalGreenClassNames.Dispose();
          hv_AdditionalGreenClassNames = "word";
          if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
          {
            hv_OcrResult.Dispose();
            hv_OcrResult = new HTuple(hv_DLResult_COPY_INP_TMP);
            hv_DLResult_COPY_INP_TMP.Dispose();
            convert_ocr_detection_result_to_object_detection(hv_OcrResult, out hv_DLResult_COPY_INP_TMP);
            hv_ResultKeys.Dispose();
            HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "keys", new HTuple(), 
                out hv_ResultKeys);
            break;
          }
        }
      }
      //
      //Check if DLDatasetInfo is valid.
      //
      if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
      {
        hv_MaxClassIdSample.Dispose();hv_EmptySample.Dispose();
        dev_display_dl_data_get_max_class_id(hv_DLSample, out hv_MaxClassIdSample, 
            out hv_EmptySample);
        hv_MaxClassIdResult.Dispose();hv_EmptyResult.Dispose();
        dev_display_dl_data_get_max_class_id(hv_DLResult_COPY_INP_TMP, out hv_MaxClassIdResult, 
            out hv_EmptyResult);
        hv_MaxClassId.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxClassId = hv_MaxClassIdSample.TupleMax2(
            hv_MaxClassIdResult);
        }
        if ((int)(hv_EmptySample.TupleAnd(hv_EmptyResult)) != 0)
        {
          hv_MaxClassId.Dispose();
          hv_MaxClassId = 1;
        }
        if ((int)(new HTuple(hv_MaxClassId.TupleEqual(-1))) != 0)
        {
          hv_MaxClassId.Dispose();
          hv_MaxClassId = 1000;
        }
        if ((int)(hv_IsOCRDetection) != 0)
        {
          hv_ClassNames.Dispose();
          hv_ClassNames = new HTuple();
          hv_ClassNames[0] = "word";
          hv_ClassNames[1] = "char";
          hv_ClassNames[2] = "ignore";
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassIDs.Dispose();
          HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassNames.TupleLength()
              ))-1, 1, out hv_ClassIDs);
          }
        }
        else
        {
          hv_ClassIDs.Dispose();
          HOperatorSet.TupleGenSequence(0, hv_MaxClassId, 1, out hv_ClassIDs);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassNames.Dispose();
          HOperatorSet.TupleGenConst(hv_MaxClassId+1, "unknown", out hv_ClassNames);
          }
        }
        //Try to get the class names from the result dictionary.
        //This works only for detection and classification results.
        if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
        {
          hv_ClassNameKey.Dispose();
          HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*class_name.*", out hv_ClassNameKey);
          hv_ClassIdKey.Dispose();
          HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*class_id.*", out hv_ClassIdKey);
          if ((int)((new HTuple((new HTuple(hv_ClassNameKey.TupleLength())).TupleEqual(
              1))).TupleAnd(new HTuple((new HTuple(hv_ClassIdKey.TupleLength())).TupleEqual(
              1)))) != 0)
          {
            hv_ResultClassNames.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, hv_ClassNameKey, 
                out hv_ResultClassNames);
            hv_ResultClassIds.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, hv_ClassIdKey, out hv_ResultClassIds);
            hv_SortIndices.Dispose();
            HOperatorSet.TupleSortIndex(hv_ResultClassIds, out hv_SortIndices);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_UniqueClassIds.Dispose();
            HOperatorSet.TupleUniq(hv_ResultClassIds.TupleSelect(hv_SortIndices), 
                out hv_UniqueClassIds);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_UniqueClassNames.Dispose();
            HOperatorSet.TupleUniq(hv_ResultClassNames.TupleSelect(hv_SortIndices), 
                out hv_UniqueClassNames);
            }
            if (hv_ClassNames == null)
              hv_ClassNames = new HTuple();
            hv_ClassNames[hv_UniqueClassIds] = hv_UniqueClassNames;
          }
        }
        hv_Colors.Dispose();
        get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, out hv_Colors);
        hv_ClassesLegend.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
        }
        hv_InvalidInput.Dispose();
        hv_InvalidInput = 0;
      }
      else
      {
        //Check if DLDatasetInfo contains necessary keys.
        hv_ClassKeys.Dispose();
        hv_ClassKeys = new HTuple();
        hv_ClassKeys[0] = "class_names";
        hv_ClassKeys[1] = "class_ids";
        hv_ClassKeysExist.Dispose();
        HOperatorSet.GetHandleParam(hv_DLDatasetInfo, "key_exists", hv_ClassKeys, 
            out hv_ClassKeysExist);
        if ((int)(new HTuple(((hv_ClassKeysExist.TupleMin())).TupleEqual(0))) != 0)
        {
          //In that case we expect that the class names and ids are never used.
        }
        else
        {
          hv_DLDatasetInfoKeys.Dispose();
          HOperatorSet.GetHandleParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ClassKeys.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_ClassKeys.TupleSelect(
                hv_Index)))).TupleEqual(-1))) != 0)
            {
              throw new HalconException(("Key "+(hv_ClassKeys.TupleSelect(
                  hv_Index)))+" is missing in DLDatasetInfo.");
            }
          }
          //
          //Get the general dataset information, if available.
          hv_ClassNames.Dispose();
          HOperatorSet.GetHandleTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
          hv_ClassIDs.Dispose();
          HOperatorSet.GetHandleTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
          //
          //Define distinct colors for the classes.
          hv_Colors.Dispose();
          get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, out hv_Colors);
          //
          hv_ClassesLegend.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
          }
        }
      }
      //
      //** Set window parameters: ***
      //
      //Set previous window coordinates.
      hv_PrevWindowCoordinates.Dispose();
      hv_PrevWindowCoordinates = new HTuple();
      hv_PrevWindowCoordinates[0] = 0;
      hv_PrevWindowCoordinates[1] = 0;
      hv_PrevWindowCoordinates[2] = 0;
      hv_PrevWindowCoordinates[3] = 0;
      //
      //Check that the WindowHandleDict is of type dictionary.
      try
      {
        hv_Keys.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
        {
          throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
        }
        else
        {
          throw new HalconException(hv_Exception);
        }
      }
      //For better usage, add meta information about the window handles in WindowHandleDict.
      hv_MetaInfoExists.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "meta_information", 
          out hv_MetaInfoExists);
      if ((int)(hv_MetaInfoExists.TupleNot()) != 0)
      {
        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv___Tmp_Ctrl_Dict_Init_1);
        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
            "HNULL");
        }
      }
      //
      //For each window, set 'flush' to 'false' to avoid flickering.
      hv_FlushValues.Dispose();
      hv_FlushValues = new HTuple();
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Only consider the WindowHandleKeys that are needed for the current visualization.
        hv_KeyIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KeyIndex = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
            hv_WindowHandleKeys.TupleSelect(hv_Index));
        }
        if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
            new HTuple())))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandles.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
              hv_Index), out hv_WindowHandles);
          }
          for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
              ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FlushValue.Dispose();
            HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", out hv_FlushValue);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                hv_FlushValue);
            hv_FlushValues.Dispose();
            hv_FlushValues = ExpTmpLocalVar_FlushValues;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", "false");
            }
          }
        }
      }
      //
      //** Display the data: ***
      //
      //Display data dictionaries.
      hv_KeyIndex.Dispose();
      hv_KeyIndex = 0;
      while ((int)(new HTuple(hv_KeyIndex.TupleLess(new HTuple(hv_KeysForDisplay_COPY_INP_TMP.TupleLength()
          )))) != 0)
      {
        //
        //Is it an Deep OCR detection case?
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IsOCRDetection.Dispose();
        HOperatorSet.TupleStrstr(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
            "ocr_detection", out hv_IsOCRDetection);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_IsOCRDetection = new HTuple(hv_IsOCRDetection.TupleEqual(
            0));
        hv_IsOCRDetection.Dispose();
        hv_IsOCRDetection = ExpTmpLocalVar_IsOCRDetection;
        }
        }
        //
        if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
            "image"))) != 0)
        {
          //
          //Image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("image_with_domain"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_Domain.Dispose();
          HOperatorSet.GetDomain(ho_Image, out ho_Domain);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "region_color"));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Domain, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("normals"))) != 0)
        {
          //
          //Normal image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_confidence"))) != 0)
        {
          //
          //Confidence image.
          if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
          {
            throw new HalconException("DLResult dict is empty.");
          }
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex)))).TupleNotEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Image.Dispose();
            HOperatorSet.GetDictObject(out ho_Image, hv_DLResult_COPY_INP_TMP, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                hv_KeyIndex));
            }
          }
          else
          {
            throw new HalconException(("Image with key '"+(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                hv_KeyIndex)))+"' could not be found in DLResult.");
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping confidence", 
                "window", "top", "left", "black", "box", "true");
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_map"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Gripping map image result.
          if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
          {
            throw new HalconException("DLResult dict is empty.");
          }
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("gripping_map"))).TupleNotEqual(
              -1))) != 0)
          {
            ho_GrippingMapImageResult.Dispose();
            HOperatorSet.GetDictObject(out ho_GrippingMapImageResult, hv_DLResult_COPY_INP_TMP, 
                "gripping_map");
          }
          else
          {
            throw new HalconException(new HTuple(new HTuple("Image with key '")+"gripping_map")+"' could not be found in DLResult.");
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "background_color", 
              "#000000");
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
          }
          ho_Domain.Dispose();
          HOperatorSet.GetDomain(ho_GrippingMapImageResult, out ho_Domain);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReduceDomain(ho_Image, ho_Domain, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //Display gripping regions.
          hv_ColorsGrippingGroundTruth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsGrippingGroundTruth = new HTuple();
          hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
              "gripping_point_map_color"));
          hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
              "gripping_point_background_color"));
          }
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_GrippingMapImageResult, (new HTuple(1)).TupleConcat(
              0), hv_ColorsGrippingGroundTruth, new HTuple(), out hv_ImageClassIDs);
          //Display gripping points.
          hv_GrippingPointsExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "key_exists", "gripping_points", 
              out hv_GrippingPointsExists);
          if ((int)(hv_GrippingPointsExists) != 0)
          {
            hv_Rows.Dispose();hv_Columns.Dispose();
            get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows, 
                out hv_Columns);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
                "gripping_point_size"), 0.785398);
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                  "line_width"));
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                  "gripping_point_color"));
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
            }
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_map_ground_truth"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Gripping map ground truth.
          if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
              -1))) != 0)
          {
            ho_GrippingMapGroundTruth.Dispose();
            HOperatorSet.GetDictObject(out ho_GrippingMapGroundTruth, hv_DLSample, 
                "segmentation_image");
          }
          else
          {
            throw new HalconException(new HTuple(new HTuple("Image with key '")+"segmentation_image")+"' could not be found in DLSample.");
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display gripping regions.
          hv_ColorsGrippingGroundTruth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsGrippingGroundTruth = new HTuple();
          hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
              "gripping_point_map_color"));
          hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
              "gripping_point_background_color"));
          }
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_GrippingMapGroundTruth, hv_ClassIDs, 
              hv_ColorsGrippingGroundTruth, new HTuple(), out hv_ImageClassIDs);
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping map ground truth", 
                "window", "top", "left", "black", "box", "true");
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("x"))) != 0)
        {
          //
          //X.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("xyz"))) != 0)
        {
          //
          //XYZ.
          ho_X.Dispose();
          get_dl_sample_image(out ho_X, hv_SampleKeys, hv_DLSample, "x");
          ho_Y.Dispose();
          get_dl_sample_image(out ho_Y, hv_SampleKeys, hv_DLSample, "y");
          ho_Z.Dispose();
          get_dl_sample_image(out ho_Z, hv_SampleKeys, hv_DLSample, "z");
          ho_Image.Dispose();
          HOperatorSet.Compose3(ho_X, ho_Y, ho_Z, out ho_Image);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("y"))) != 0)
        {
          //
          //Y.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("z"))) != 0)
        {
          //
          //Z.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_point_cloud"))) != 0)
        {
          //
          //In case of 'gripping_point_cloud' provide a window that can be used by the procedure
          //dev_display_dl_3d_data. No actual drawing happens  in this procedure to keep it
          //free from operators not belonging either to the Foundation or Deep Learning
          //license modules.
          hv_SampleKeys.Dispose();
          HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Do nothing here and draw later
          //
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_both_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_both_global")))) != 0)
        {
          //
          //In case of 'anomaly_both', also plot 'anomaly_both_local'
          //and 'anomaly_both_global', if available.
          hv_AnomalyImages.Dispose();
          HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*anomaly_image.*", out hv_AnomalyImages);
          if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
              "anomaly_both"))) != 0)
          {
            hv_PossibleKeysForDisplay.Dispose();
            HOperatorSet.TupleRegexpReplace(hv_AnomalyImages, "image", "both", out hv_PossibleKeysForDisplay);
            hv_AddDisplayKey.Dispose();
            hv_AddDisplayKey = 0;
            for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_PossibleKeysForDisplay.TupleLength()
                ))-1); hv_Index = (int)hv_Index + 1)
            {
              if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleFindFirst(
                  hv_PossibleKeysForDisplay.TupleSelect(hv_Index)))).TupleEqual(-1))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_KeysForDisplay = hv_KeysForDisplay_COPY_INP_TMP.TupleConcat(
                    hv_PossibleKeysForDisplay.TupleSelect(hv_Index));
                hv_KeysForDisplay_COPY_INP_TMP.Dispose();
                hv_KeysForDisplay_COPY_INP_TMP = ExpTmpLocalVar_KeysForDisplay;
                }
                }
                hv_AddDisplayKey.Dispose();
                hv_AddDisplayKey = 1;
              }
            }
            //
            //Display not possible for 'anomaly_both' if key 'anomaly_image' is missing.
            if ((int)((new HTuple(((hv_PossibleKeysForDisplay.TupleFindFirst(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                hv_KeyIndex)))).TupleEqual(-1))).TupleAnd(hv_AddDisplayKey)) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_KeyIndex = hv_KeyIndex+1;
              hv_KeyIndex.Dispose();
              hv_KeyIndex = ExpTmpLocalVar_KeyIndex;
              }
              }
              continue;
            }
          }
          //
          //Get image and ground truth.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          hv_AnomalyLabelGroundTruth.Dispose();hv_AnomalyLabelIDGroundTruth.Dispose();
          get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth, 
              out hv_AnomalyLabelIDGroundTruth);
          //
          //Get the anomaly results either by applying the specified thresholds or out of DLResult.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnomalyResultPostfix.Dispose();
          HOperatorSet.TupleRegexpMatch(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex), "anomaly_both(.*)", out hv_AnomalyResultPostfix);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_AnomalyImage.Dispose();ho_AnomalyRegion.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();hv_AnomalyClassThresholdDisplay.Dispose();hv_AnomalyRegionThresholdDisplay.Dispose();
          get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
              hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
              "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore, 
              out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
          }
          //
          //Get open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          hv_WindowHandleName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandleName = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_WindowHandleName, out hv_CurrentWindowHandle, out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualize image, ground truth (if available), and result regions.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          hv_AnomalyRegionGroundTruthExists.Dispose();
          hv_AnomalyRegionGroundTruthExists = "false";
          if ((int)(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AnomalyRegionGroundTruthExists.Dispose();
            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
                hv_CurrentWindowHandle, hv_Params.TupleGetDictTuple("line_width"), 
                hv_Params.TupleGetDictTuple("anomaly_region_label_color"), hv_Params.TupleGetDictTuple(
                "anomaly_color_transparency"), out hv_AnomalyRegionGroundTruthExists);
            }
          }
          //
          //Display anomaly regions defined by the specified threshold or out of DLResult.
          hv___Tmp_Ctrl_Dict_Init_2.Dispose();
          HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_2);
          HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", -1);
          if ((int)((new HTuple(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2))).TupleTestEqualDictItem(
              "anomaly_region_threshold","comp"))).TupleNot())).TupleOr(new HTuple(((hv_ResultKeys.TupleFind(
              "anomaly_region"+hv_AnomalyResultPostfix))).TupleNotEqual(-1)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
                hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple(
                "anomaly_region_result_color"));
            }
          }
          hv___Tmp_Ctrl_Dict_Init_2.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv___Tmp_Ctrl_Dict_Init_2 = HTuple.TupleConstant(
              "HNULL");
          }
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "GT and detected anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Get prediction color.
          hv_PredictionColor.Dispose();
          hv_PredictionColor = "white";
          if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
          {
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "green";
          }
          else if ((int)(new HTuple(hv_AnomalyClassID.TupleNotEqual(-1))) != 0)
          {
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "red";
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                1))))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation ground truth found";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                0))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
            }
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_3);
            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", -1);
            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3))).TupleTestEqualDictItem(
                "anomaly_region_threshold","comp"))).TupleAnd(new HTuple(((hv_ResultKeys.TupleFind(
                "anomaly_region"+hv_AnomalyResultPostfix))).TupleEqual(-1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
            }
            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv___Tmp_Ctrl_Dict_Init_3 = HTuple.TupleConstant(
                "HNULL");
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = (("anomaly_score"+hv_AnomalyResultPostfix)+": ")+(hv_AnomalyScore.TupleString(
                ".3f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            }
            //
            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: "+(hv_AnomalyClassThresholdDisplay.TupleString(
                  ".3f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: "+(hv_AnomalyRegionThresholdDisplay.TupleString(
                  ".3f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_WindowHandleName, out hv_WindowImageRatio, 
                out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            hv_ResultColorOffset.Dispose();
            hv_ResultColorOffset = 10;
            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                1))))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_ResultColorOffset = hv_ResultColorOffset+2;
              hv_ResultColorOffset.Dispose();
              hv_ResultColorOffset = ExpTmpLocalVar_ResultColorOffset;
              }
              }
            }
            if (hv_LineColors == null)
              hv_LineColors = new HTuple();
            hv_LineColors[hv_ResultColorOffset] = hv_PredictionColor;
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_ground_truth"))) != 0)
        {
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          hv_AnomalyLabelGroundTruth.Dispose();hv_AnomalyLabelIDGroundTruth.Dispose();
          get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth, 
              out hv_AnomalyLabelIDGroundTruth);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          hv_AnomalyRegionExists.Dispose();
          hv_AnomalyRegionExists = "false";
          if ((int)(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")) != 0)
          {
            //Show the ground truth region.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AnomalyRegionExists.Dispose();
            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
                hv_CurrentWindowHandle, hv_Params.TupleGetDictTuple("line_width"), 
                hv_Params.TupleGetDictTuple("anomaly_region_label_color"), hv_Params.TupleGetDictTuple(
                "anomaly_color_transparency"), out hv_AnomalyRegionExists);
            }
          }
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_image"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_image_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_image_global")))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get the anomaly results either by applying the specified thresholds or out of DLResult.
          hv_AnomalyImageKey.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnomalyImageKey = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex);
          }
          hv_AnomalyResultPostfix.Dispose();
          HOperatorSet.TupleRegexpMatch(hv_AnomalyImageKey, "anomaly_image(.*)", 
              out hv_AnomalyResultPostfix);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_AnomalyImage.Dispose();ho_AnomalyRegion.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();hv_AnomalyClassThresholdDisplay.Dispose();hv_AnomalyRegionThresholdDisplay.Dispose();
          get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
              hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
              "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore, 
              out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
          }
          //
          //Read in input image.
          ho_Image.Dispose();
          HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
          //Add the anomaly image to the input image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HObject ExpTmpOutVar_0;
          add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_Params.TupleGetDictTuple(
              "heatmap_color_scheme"));
          ho_AnomalyImage.Dispose();
          ho_AnomalyImage = ExpTmpOutVar_0;
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
          }
          hv_Text.Dispose();
          hv_Text = new HTuple(hv_AnomalyImageKey);
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          hv_AnomalyScoreKey.Dispose();
          HOperatorSet.TupleRegexpReplace(hv_AnomalyImageKey, "image", "score", out hv_AnomalyScoreKey);
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                0))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = (hv_AnomalyScoreKey+": ")+(hv_AnomalyScore.TupleString(
                ".3f"));
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_result"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_result_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("anomaly_result_global")))) != 0)
        {
          //
          //Get image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get the anomaly results either by applying the specified thresholds or out of DLResult.
          hv_AnomalyResultKey.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnomalyResultKey = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex);
          }
          hv_AnomalyResultPostfix.Dispose();
          HOperatorSet.TupleRegexpMatch(hv_AnomalyResultKey, "anomaly_result(.*)", 
              out hv_AnomalyResultPostfix);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_AnomalyImage.Dispose();ho_AnomalyRegion.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();hv_AnomalyClassThresholdDisplay.Dispose();hv_AnomalyRegionThresholdDisplay.Dispose();
          get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP, 
              hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
              "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore, 
              out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display anomaly regions defined by the specified threshold or out of DLResult.
          hv_AnomalyRegionKey.Dispose();
          HOperatorSet.TupleRegexpReplace(hv_AnomalyResultKey, "result", "region", 
              out hv_AnomalyRegionKey);
          hv___Tmp_Ctrl_Dict_Init_4.Dispose();
          HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_4);
          HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_4, "comp", -1);
          if ((int)((new HTuple(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_4))).TupleTestEqualDictItem(
              "anomaly_region_threshold","comp"))).TupleNot())).TupleOr(new HTuple(((hv_ResultKeys.TupleFind(
              hv_AnomalyRegionKey))).TupleNotEqual(-1)))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle, 
                hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple(
                "anomaly_region_result_color"));
            }
          }
          hv___Tmp_Ctrl_Dict_Init_4.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv___Tmp_Ctrl_Dict_Init_4 = HTuple.TupleConstant(
              "HNULL");
          }
          //
          hv_AnomalyScoreKey.Dispose();
          HOperatorSet.TupleRegexpReplace(hv_AnomalyResultKey, "result", "score", 
              out hv_AnomalyScoreKey);
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Detected anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                0))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
            }
            hv___Tmp_Ctrl_Dict_Init_5.Dispose();
            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_5);
            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_5, "comp", -1);
            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_5))).TupleTestEqualDictItem(
                "anomaly_region_threshold","comp"))).TupleAnd(new HTuple(((hv_ResultKeys.TupleFind(
                hv_AnomalyRegionKey))).TupleEqual(-1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
            }
            hv___Tmp_Ctrl_Dict_Init_5.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv___Tmp_Ctrl_Dict_Init_5 = HTuple.TupleConstant(
                "HNULL");
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = (hv_AnomalyScoreKey+": ")+(hv_AnomalyScore.TupleString(
                ".3f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            }
            //
            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: "+(hv_AnomalyClassThresholdDisplay.TupleString(
                  ".3f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: "+(hv_AnomalyRegionThresholdDisplay.TupleString(
                  ".3f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_heatmap"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get gripping points
          hv_Rows.Dispose();hv_Columns.Dispose();
          get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows, out hv_Columns);
          //
          //Confidence image.
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("gripping_confidence"))).TupleNotEqual(
              -1))) != 0)
          {
            ho_ConfidenceImage.Dispose();
            HOperatorSet.GetDictObject(out ho_ConfidenceImage, hv_DLResult_COPY_INP_TMP, 
                "gripping_confidence");
          }
          else
          {
            throw new HalconException("Image with key 'gripping_confidence' could not be found in DLResult.");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_HeatmapScene.Dispose();
          add_colormap_to_image(ho_ConfidenceImage, ho_Image, out ho_HeatmapScene, 
              hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_HeatmapScene, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping heatmap", 
                "window", "top", "left", "black", "box", "true");
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Cross.Dispose();
          HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
              "gripping_point_size"), 0.785398);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "line_width"));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "gripping_point_color"));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("gripping_points"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get gripping points
          hv_Rows.Dispose();hv_Columns.Dispose();
          get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows, out hv_Columns);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping points", 
                "window", "top", "left", "black", "box", "true");
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Cross.Dispose();
          HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
              "gripping_point_size"), 0.785398);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "line_width"));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "gripping_point_color"));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
          }
          //
        }
        else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("bbox_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_detection_both")))) != 0)
        {
          //
          //Ground truth and result bounding boxes on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if ((int)(hv_IsOCRDetection) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Visualization.
          //
          hv_DisplayDirectionTemp.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
              "display_direction");
          }
          if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
              hv_IsOCRDetection)) != 0)
          {
            hv_DisplayDirectionTemp.Dispose();
            hv_DisplayDirectionTemp = -1;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxLabelIndex.Dispose();
          dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple(
              "line_width"), hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple(
              "bbox_label_color"), hv_WindowImageRatio, hv_Params.TupleGetDictTuple(
              "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
              hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
          }
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
              -1))) != 0)
          {
            hv_BboxConfidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "bbox_confidence", 
                out hv_BboxConfidences);
          }
          else
          {
            throw new HalconException("Result data could not be found in DLResult.");
          }
          if ((int)(hv_Params.TupleGetDictTuple("bbox_display_confidence")) != 0)
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
                ".2f")))+")";
            }
          }
          else
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = HTuple.TupleGenConst(
                new HTuple(hv_BboxConfidences.TupleLength()),"");
            }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxClassIndex.Dispose();
          dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, hv_Params.TupleGetDictTuple(
              "line_width"), hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple(
              "bbox_label_color"), hv_WindowImageRatio, "bottom", hv_Params.TupleGetDictTuple(
              "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
              hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxClassIndex);
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth and results "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          hv_Text.Dispose();
          hv_Text = "Ground truth and";
          if (hv_Text == null)
            hv_Text = new HTuple();
          hv_Text[new HTuple(hv_Text.TupleLength())] = "results "+hv_ImageIDStringBraces;
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_BboxColorsBoth.Dispose();
            hv_BboxColorsBoth = new HTuple();
            hv_BboxColorsBoth[0] = "white";
            hv_BboxColorsBoth[1] = "white";
            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                ))+(new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
            {
              hv_BboxClassLabelIndexUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                  hv_BboxLabelIndex))).TupleSort())).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
              hv_BboxColorsBoth.Dispose();
              hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No ground truth nor results present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColorsBoth, "box", "false");
            }
          }
        }
        else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("bbox_ground_truth"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_detection_ground_truth")))) != 0)
        {
          //
          //Sample bounding boxes on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if ((int)(hv_IsOCRDetection) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display smaller arrow for ocr_detection
          hv_DisplayDirectionTemp.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
              "display_direction");
          }
          if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
              hv_IsOCRDetection)) != 0)
          {
            hv_DisplayDirectionTemp.Dispose();
            hv_DisplayDirectionTemp = -1;
          }
          //
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxIDs.Dispose();
          dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple(
              "line_width"), hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple(
              "bbox_label_color"), hv_WindowImageRatio, hv_Params.TupleGetDictTuple(
              "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
              hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxIDs);
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_BboxColors.Dispose();
            hv_BboxColors = "white";
            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
            {
              hv_BboxIDsUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                  )).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxIDsUniq));
              hv_BboxColors.Dispose();
              hv_BboxColors = ExpTmpLocalVar_BboxColors;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No ground truth present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColors, "box", "false");
            }
          }
        }
        else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("bbox_result"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_detection_result")))) != 0)
        {
          //
          //Result bounding boxes on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if ((int)(hv_IsOCRDetection) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display smaller arrow for ocr_detection
          hv_DisplayDirectionTemp.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
              "display_direction");
          }
          if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
              hv_IsOCRDetection)) != 0)
          {
            hv_DisplayDirectionTemp.Dispose();
            hv_DisplayDirectionTemp = -1;
          }
          //
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
              -1))) != 0)
          {
            hv_BboxConfidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "bbox_confidence", 
                out hv_BboxConfidences);
          }
          else
          {
            throw new HalconException("Result data could not be found in DLResult.");
          }
          if ((int)(hv_Params.TupleGetDictTuple("bbox_display_confidence")) != 0)
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
                ".2f")))+")";
            }
          }
          else
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = HTuple.TupleGenConst(
                new HTuple(hv_BboxConfidences.TupleLength()),"");
            }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxClassIndex.Dispose();
          dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, hv_Params.TupleGetDictTuple(
              "line_width"), hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple(
              "bbox_label_color"), hv_WindowImageRatio, "top", hv_Params.TupleGetDictTuple(
              "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"), 
              hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxClassIndex);
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Result "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_BboxColorsResults.Dispose();
            hv_BboxColorsResults = "white";
            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                0))) != 0)
            {
              hv_BboxClassIndexUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                  )).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
              hv_BboxColorsResults.Dispose();
              hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No results present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColorsResults, "box", "false");
            }
          }
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_detection_score_map_character"))).TupleOr(
            new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
            "ocr_detection_score_map_link"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_detection_score_map_orientation")))) != 0)
        {
          //
          //Extract score maps
          ho_ScoreMaps.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ScoreMaps = hv_OcrResult.TupleGetDictObject(
              "score_maps");
          }
          ho_CharacterScoreMap.Dispose();ho_LinkScoreMap.Dispose();ho_OrientationSinScoreMap.Dispose();ho_OrientationCosScoreMap.Dispose();
          HOperatorSet.Decompose4(ho_ScoreMaps, out ho_CharacterScoreMap, out ho_LinkScoreMap, 
              out ho_OrientationSinScoreMap, out ho_OrientationCosScoreMap);
          //
          //Select score map to display
          if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
              "ocr_detection_score_map_character"))) != 0)
          {
            ho_ScoreMap.Dispose();
            ho_ScoreMap = new HObject(ho_CharacterScoreMap);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Character score "+hv_ImageIDStringBraces;
            }
          }
          else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_detection_score_map_link"))) != 0)
          {
            ho_ScoreMap.Dispose();
            ho_ScoreMap = new HObject(ho_LinkScoreMap);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Link score "+hv_ImageIDStringBraces;
            }
          }
          else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_detection_score_map_orientation"))) != 0)
          {
            ho_OrientationScoreMap.Dispose();
            HOperatorSet.Compose2(ho_OrientationSinScoreMap, ho_OrientationCosScoreMap, 
                out ho_OrientationScoreMap);
            ho_ScoreMap.Dispose();
            ho_ScoreMap = new HObject(ho_OrientationScoreMap);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = new HTuple("Orientation (sin,cos) ")+hv_ImageIDStringBraces;
            }
          }
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ScoreMap, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Make sure the minimum and maximum gray values of the score map image
          //are 0 and 1, respectively. This is necessary to get the correct color
          //range from the 'jet' color map.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetGrayval(ho_ScoreMap, (new HTuple(0)).TupleConcat(hv_HeightImage-1), 
              (new HTuple(0)).TupleConcat(hv_WidthImage-1), (new HTuple(0)).TupleConcat(
              1));
          }
          //
          //Display the score maps using the 'jet' color map.
          HOperatorSet.SetLut(hv_CurrentWindowHandle, "jet");
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ScoreMap, HDevWindowStack.GetActive());
          }
          //
          //Display text
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("classification_both"))) != 0)
        {
          //
          //Ground truth and result classification image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          hv_ClassificationLabelIDGroundTruth.Dispose();
          get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
          hv_ClassificationLabelIDResult.Dispose();
          get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, out hv_ClassificationLabelIDResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Get prediction color.
          hv_PredictionColor.Dispose();
          hv_PredictionColor = "white";
          if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
          {
            hv_PredictionText.Dispose();
            hv_PredictionText = "Correct";
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "green";
          }
          else
          {
            hv_PredictionText.Dispose();
            hv_PredictionText = "Wrong";
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "red";
          }
          //
          //Generate prediction color frame and show image.
          if ((int)(hv_Params.TupleGetDictTuple("display_classification_color_frame")) != 0)
          {
            //Create a frame with line width 7 that is completely displayed in the window.
            hv_BoarderOffset.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffset = 7/2.0;
            }
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            hv_WindowImageRatioHeight.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height", 
                out hv_WindowImageRatioHeight);
            hv_WindowImageRatioWidth.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width", 
                out hv_WindowImageRatioWidth);
            hv_BoarderOffsetRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffsetRow = hv_BoarderOffset/hv_WindowImageRatioHeight;
            }
            hv_BoarderOffsetCol.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffsetCol = hv_BoarderOffset/hv_WindowImageRatioWidth;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_PredictionColorFrame.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow-0.5)).TupleConcat(
                hv_BoarderOffsetRow-0.5))).TupleConcat((hv_HeightImage+0.5)-hv_BoarderOffsetRow))).TupleConcat(
                (hv_HeightImage+0.5)-hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow-0.5), 
                ((((((((hv_BoarderOffsetCol-0.5)).TupleConcat((hv_WidthImage+0.5)-hv_BoarderOffsetCol))).TupleConcat(
                (hv_WidthImage+0.5)-hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol-0.5))).TupleConcat(
                hv_BoarderOffsetCol-0.5));
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                  );
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
          {
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MarginBottom.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                hv_KeyIndex))+"_margin_bottom", out hv_MarginBottom);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowCoordinates.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                hv_KeyIndex))+"_window_coordinates", out hv_WindowCoordinates);
            }
            hv_CurrentWindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                3))-(hv_WindowCoordinates.TupleSelect(0));
            }
            hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_MaxHeight.Dispose();
            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__, 
                out hv__, out hv_MaxHeight);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
            }
            if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
            {
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), "left", 
                    "white", "box", "false");
                }
              }
            }
            else
            {
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    "bottom", "left", "white", "box", "false");
              }
            }
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result/GT classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                hv_ClassificationLabelIDGroundTruth);
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                  hv_ClassificationLabelIDResult);
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            if (hv_LineColors == null)
              hv_LineColors = new HTuple();
            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
            {
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[9] = hv_PredictionColor;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("classification_ground_truth"))) != 0)
        {
          //
          //Ground truth classification image and class label.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          hv_ClassificationLabelIDGroundTruth.Dispose();
          get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ClassificationLabelIDGroundTruth)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("classification_result"))) != 0)
        {
          //
          //Ground truth classification image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          hv_ClassificationLabelIDResult.Dispose();
          get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, out hv_ClassificationLabelIDResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display the class IDs.
          if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
          {
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            hv_MarginBottom.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom", 
                out hv_MarginBottom);
            hv_WindowCoordinates.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates", 
                out hv_WindowCoordinates);
            hv_CurrentWindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                3))-(hv_WindowCoordinates.TupleSelect(0));
            }
            hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_MaxHeight.Dispose();
            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__, 
                out hv__, out hv_MaxHeight);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
            }
            if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
            {
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), "left", 
                    "white", "box", "false");
                }
              }
            }
            else
            {
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    "bottom", "left", "white", "box", "false");
              }
            }
          }
          //
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID "+hv_ImageIDStringBraces;
            }
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ClassificationLabelIDResult)), "box", "false");
              }
            }
          }
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("heatmap_guided_grad_cam"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
        {
          //
          //Display the heatmap image (method 'heatmap_grad_cam', 'heatmap_guided_grad_cam',
          //or 'heatmap_confidence_based') in the selected color scheme.
          //Retrieve heatmap image, inferred image, and inference results.
          hv_SelectedHeatmapMethod.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedHeatmapMethod = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex);
          }
          if ((int)((new HTuple((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
              -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_guided_grad_cam"))).TupleNotEqual(
              -1))))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
              -1)))) != 0)
          {
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
            {
              hv_DictHeatmap.Dispose();
              HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_grad_cam", 
                  out hv_DictHeatmap);
              hv_MethodName.Dispose();
              hv_MethodName = "Grad-CAM";
            }
            else if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual(
                "heatmap_guided_grad_cam"))) != 0)
            {
              hv_DictHeatmap.Dispose();
              HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_guided_grad_cam", 
                  out hv_DictHeatmap);
              hv_MethodName.Dispose();
              hv_MethodName = "Guided-Grad-CAM";
            }
            else
            {
              hv_DictHeatmap.Dispose();
              HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_confidence_based", 
                  out hv_DictHeatmap);
              hv_MethodName.Dispose();
              hv_MethodName = "Confidence based";
            }
            hv_HeatmapKeys.Dispose();
            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
            //
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_guided_grad_cam"))) != 0)
            {
              hv_HeatmapImageName.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                  "guided_grad_cam_image_class_[0-9]*");
              }
              hv_TargetClassID.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                  "guided_grad_cam_image_class_([0-9]+)$");
              }
            }
            else
            {
              hv_HeatmapImageName.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                  "heatmap_image_class_[0-9]*");
              }
              hv_TargetClassID.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                  "heatmap_image_class_([0-9]+)$");
              }
            }
            ho_ImageHeatmap.Dispose();
            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
          }
          else
          {
            throw new HalconException("Heatmap image could not be found in DLResult.");
          }
          //
          //Only for the Grad-Cam heatmap the input image is shown.
          if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
          {
            //Read in input image.
            ho_Image.Dispose();
            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
            //Add the heatmap to the input image.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0, 
                hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
            ho_ImageHeatmap.Dispose();
            ho_ImageHeatmap = ExpTmpOutVar_0;
            }
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Classification heatmap "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_ClassNames.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_class_names", 
                out hv_ClassNames);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_class_ids", 
                out hv_ClassIDs);
            hv_Confidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_confidences", 
                out hv_Confidences);
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
            {
              hv_MaxDeviation.Dispose();
              HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation", 
                  out hv_MaxDeviation);
            }
            hv_ClassificationLabelNameResult.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                0);
            }
            hv_ClassificationLabelIDResult.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                0);
            }
            hv_TargetClassConfidence.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
            }
            hv_Text.Dispose();
            hv_Text = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
              hv_ClassificationLabelIDGroundTruth.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
              hv_ClassificationLabelNamesGroundTruth.Dispose();
              HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
              //Get prediction color.
              if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                  hv_ClassificationLabelIDResult))) != 0)
              {
                hv_PredictionColor.Dispose();
                hv_PredictionColor = "green";
              }
              else
              {
                hv_PredictionColor.Dispose();
                hv_PredictionColor = "red";
              }
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                  hv_ClassificationLabelIDGroundTruth);
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: "+(((hv_Confidences.TupleSelect(
                0))).TupleString(".2f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: "+hv_MethodName;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: "+hv_TargetClassID;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: "+(hv_TargetClassConfidence.TupleString(
                ".2f"));
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: "+(hv_MaxDeviation.TupleString(
                  ".2f"));
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[8] = hv_PredictionColor;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
        }
        else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_recognition_ground_truth"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_recognition_result"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("ocr_recognition_both")))) != 0)
        {
          //
          //OCR Recognition.
          hv_ShowGT.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ShowGT = (new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_recognition_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_recognition_ground_truth")));
          }
          hv_ShowResult.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ShowResult = (new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_recognition_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex))).TupleEqual("ocr_recognition_result")));
          }
          hv_NumLines.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumLines = hv_ShowGT+hv_ShowResult;
          }
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_NumLines*(hv_Params.TupleGetDictTuple("display_bottom_desc")), 
              hv_WidthImage, hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), 
              hv_Params.TupleGetDictTuple("threshold_width"), hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
              out hv_CurrentWindowHandle, out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
          hv_Type.Dispose();
          HOperatorSet.GetImageType(ho_Image, out hv_Type);
          if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
          {
            //We assume that real images have been preprocessed
            //to the range -1,1 already. Hence, we need to rescale
            //them back to a visible range in byte.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, 255.0/2, 127);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "byte");
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            hv_Text = new HTuple();
            //Ground truth.
            if ((int)(hv_ShowGT) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = (("Ground truth: \""+(hv_DLSample.TupleGetDictTuple(
                  "word")))+"\" ")+hv_ImageIDStringBraces;
            }
            //Result.
            if ((int)(hv_ShowResult) != 0)
            {
              hv_GTWordKeyExists.Dispose();
              HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "word", out hv_GTWordKeyExists);
              if ((int)(hv_GTWordKeyExists) != 0)
              {
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", 
                    out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_WindowCoordinates.Dispose();
                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                    hv_KeyIndex))+"_window_coordinates", out hv_WindowCoordinates);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_MarginBottom.Dispose();
                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                    hv_KeyIndex))+"_margin_bottom", out hv_MarginBottom);
                }
                hv_HeightWindow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_HeightWindow = hv_WindowCoordinates.TupleSelect(
                    3);
                }
                hv_HeightMarginBottom.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_HeightMarginBottom = (hv_HeightImage*hv_MarginBottom)/(hv_HeightWindow-hv_MarginBottom);
                }
                hv_Size.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Size = hv_HeightMarginBottom/2;
                }
                hv_Length.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Length = hv_Size/2;
                }
                hv_Row.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Row = hv_HeightImage+(hv_HeightMarginBottom/2);
                }
                hv_Column.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Column = hv_WidthImage-(1.5*hv_Size);
                }
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_HomMat2DRotate.Dispose();
                HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, (new HTuple(45)).TupleRad()
                    , 0, 0, out hv_HomMat2DRotate);
                }
                hv_HomMat2DCompose.Dispose();
                HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row, hv_Column, 
                    out hv_HomMat2DCompose);
                if ((int)(((hv_DLResult_COPY_INP_TMP.TupleConcat(hv_DLSample))).TupleTestEqualDictItem(
                    "word","word")) != 0)
                {
                  hv_PredictionForegroundColor.Dispose();
                  hv_PredictionForegroundColor = "green";
                  hv_PredictionBackgroundColor.Dispose();
                  hv_PredictionBackgroundColor = "#008000";
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  ho_PredictionSymbol.Dispose();
                  HOperatorSet.GenContourPolygonXld(out ho_PredictionSymbol, ((-0.75*hv_Length)).TupleConcat(
                      (new HTuple(0)).TupleConcat(0)), ((((-hv_Length)).TupleConcat(
                      -hv_Length))).TupleConcat(hv_Length));
                  }
                }
                else
                {
                  hv_PredictionForegroundColor.Dispose();
                  hv_PredictionForegroundColor = "red";
                  hv_PredictionBackgroundColor.Dispose();
                  hv_PredictionBackgroundColor = "#800000";
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  ho_CrossLineH.Dispose();
                  HOperatorSet.GenContourPolygonXld(out ho_CrossLineH, (new HTuple(0)).TupleConcat(
                      0), ((-hv_Length)).TupleConcat(hv_Length));
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  ho_CrossLineV.Dispose();
                  HOperatorSet.GenContourPolygonXld(out ho_CrossLineV, ((-hv_Length)).TupleConcat(
                      hv_Length), (new HTuple(0)).TupleConcat(0));
                  }
                  ho_PredictionSymbol.Dispose();
                  HOperatorSet.ConcatObj(ho_CrossLineH, ho_CrossLineV, out ho_PredictionSymbol
                      );
                }
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.AffineTransContourXld(ho_PredictionSymbol, out ExpTmpOutVar_0, 
                    hv_HomMat2DCompose);
                ho_PredictionSymbol.Dispose();
                ho_PredictionSymbol = ExpTmpOutVar_0;
                }
                HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "background_color", 
                    hv_PredictionBackgroundColor);
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 5);
                }
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionForegroundColor);
                }
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.DispObj(ho_PredictionSymbol, HDevWindowStack.GetActive()
                      );
                }
              }
              else
              {
                hv_PredictionForegroundColor.Dispose();
                hv_PredictionForegroundColor = "white";
              }
              if ((int)(hv_ShowGT) != 0)
              {
                hv_Spaces.Dispose();
                hv_Spaces = "    ";
              }
              else
              {
                hv_Spaces.Dispose();
                hv_Spaces = "";
              }
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = ((("Deep OCR:"+hv_Spaces)+" \"")+(hv_DLResult_COPY_INP_TMP.TupleGetDictTuple(
                  "word")))+"\"";
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_confidence"))) != 0)
        {
          //
          //Segmentation confidences.
          ho_ImageConfidence.Dispose();
          get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_confidence_map"))) != 0)
        {
          //
          //Segmentation confidence map on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_ImageConfidence.Dispose();
          get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"), 
              hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ConfidenceColors.Dispose();
          dev_display_confidence_regions(ho_ImageConfidence, hv_Params.TupleGetDictTuple(
              "map_transparency"), out hv_ConfidenceColors);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple(
              "map_color_bar_width"), hv_ConfidenceColors, 1.0, hv_WindowImageRatio, 
              hv_CurrentWindowHandle);
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_image_both"))) != 0)
        {
          //
          //Ground truth and result segmentation on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult_COPY_INP_TMP);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display regions.
          hv_ColorsResults.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsResults = hv_Colors+(hv_Params.TupleGetDictTuple(
              "segmentation_transparency"));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GroundTruthIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
              hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
              out hv_GroundTruthIDs);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ResultIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
              hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
              out hv_ResultIDs);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth and result segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                hv_ResultIDs))).TupleSort())).TupleUniq();
            }
            //Get Indices according to image class IDs.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsIndices.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ), 0, out hv_ImageClassIDsIndices);
            }
            for (hv_ImageClassIDsIndex=0; (int)hv_ImageClassIDsIndex<=(int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ))-1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
            {
              if (hv_ImageClassIDsIndices == null)
                hv_ImageClassIDsIndices = new HTuple();
              hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                  hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[(new HTuple(hv_Text.TupleLength()))+1] = new HTuple("- thicker line: result, thinner lines: ground truth");
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
            hv_StringSegExcludeClassIDs.Dispose();
            hv_StringSegExcludeClassIDs = "";
            for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(((hv_Params.TupleGetDictTuple(
                "segmentation_exclude_class_ids"))).TupleLength()))-1); hv_StringIndex = (int)hv_StringIndex + 1)
            {
              if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(((hv_Params.TupleGetDictTuple(
                  "segmentation_exclude_class_ids"))).TupleLength()))-1))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs+(((hv_Params.TupleGetDictTuple(
                    "segmentation_exclude_class_ids"))).TupleSelect(hv_StringIndex));
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                }
                }
              }
              else
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs+(((hv_Params.TupleGetDictTuple(
                    "segmentation_exclude_class_ids"))).TupleSelect(hv_StringIndex)))+new HTuple(", ");
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                }
                }
              }
            }
            hv___Tmp_Ctrl_Dict_Init_6.Dispose();
            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_6);
            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_6, "comp", new HTuple());
            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_6))).TupleTestEqualDictItem(
                "segmentation_exclude_class_ids","comp"))).TupleNot()) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) "+hv_StringSegExcludeClassIDs)+" from visualization)";
            }
            hv___Tmp_Ctrl_Dict_Init_6.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv___Tmp_Ctrl_Dict_Init_6 = HTuple.TupleConstant(
                "HNULL");
            }
            //
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsIndices)))).TupleConcat(((new HTuple("white")).TupleConcat(
                  "white")).TupleConcat("white")), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_image_diff"))) != 0)
        {
          //
          //Difference of ground truth and result segmentation on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult_COPY_INP_TMP);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          ho_ImageAbsDiff.Dispose();
          HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult, 
              out ho_ImageAbsDiff, 1);
          hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0, 
              out hv_Min, out hv_Max, out hv_Range);
          if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
          {
            ho_DiffRegion.Dispose();
            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000"+(hv_Params.TupleGetDictTuple(
                  "segmentation_transparency")));
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.", 
                  "window", "top", "left", "black", new HTuple(), new HTuple());
            }
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Difference of ground truth and result segmentation "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_image_ground_truth"))) != 0)
        {
          //
          //Ground truth segmentation image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display segmentation regions.
          hv_ColorsSegmentation.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsSegmentation = hv_Colors+(hv_Params.TupleGetDictTuple(
              "segmentation_transparency"));
          }
          hv_DrawMode.Dispose();
          HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "segmentation_draw"));
            }
          }
          hv_Width.Dispose();
          HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "line_width"));
            }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
              hv_ColorsSegmentation, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
              out hv_ImageClassIDs);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                );
            }
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                )).TupleUniq();
            }
            //Get Indices according to image class IDs.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsIndices.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ), 0, out hv_ImageClassIDsIndices);
            }
            for (hv_ImageClassIDsIndex=0; (int)hv_ImageClassIDsIndex<=(int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ))-1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
            {
              if (hv_ImageClassIDsIndices == null)
                hv_ImageClassIDsIndices = new HTuple();
              hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                  hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsIndices)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_image_result"))) != 0)
        {
          //
          //Result segmentation on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult_COPY_INP_TMP);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display result segmentation regions.
          hv_ColorsResults.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsResults = hv_Colors+(hv_Params.TupleGetDictTuple(
              "segmentation_transparency"));
          }
          hv_DrawMode.Dispose();
          HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "segmentation_draw"));
            }
          }
          hv_Width.Dispose();
          HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                "line_width"));
            }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
              hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"), 
              out hv_ImageClassIDs);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                );
            }
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Result segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                )).TupleUniq();
            }
            //Get Indices according to image class IDs.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsIndices.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ), 0, out hv_ImageClassIDsIndices);
            }
            for (hv_ImageClassIDsIndex=0; (int)hv_ImageClassIDsIndex<=(int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                ))-1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
            {
              if (hv_ImageClassIDsIndices == null)
                hv_ImageClassIDsIndices = new HTuple();
              hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                  hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"), 
                hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsIndices)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_weight"))) != 0)
        {
          //
          //Weight image.
          ho_ImageWeight.Dispose();
          get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
            hv_KeyIndex))).TupleEqual("segmentation_weight_map"))) != 0)
        {
          //
          //Weight map on image.
          ho_Image.Dispose();
          get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
          ho_ImageWeight.Dispose();
          get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
          //
          hv___Tmp_Ctrl_Dict_Init_7.Dispose();
          HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_7);
          HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_7, "comp", 0);
          if ((int)(((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_7))).TupleTestEqualDictItem(
              "segmentation_max_weight","comp")) != 0)
          {
            //Calculate SegMaxWeight if not given in GenParam.
            hv_MinWeight.Dispose();hv___Tmp_Ctrl_1.Dispose();hv_Range.Dispose();
            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight, 
                out hv___Tmp_Ctrl_1, out hv_Range);
            HOperatorSet.SetDictTuple(hv_Params, "segmentation_max_weight", hv___Tmp_Ctrl_1);
          }
          hv___Tmp_Ctrl_Dict_Init_7.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv___Tmp_Ctrl_Dict_Init_7 = HTuple.TupleConstant(
              "HNULL");
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
              "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage, 
              hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"), 
              hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
              "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict, 
              hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WeightsColors.Dispose();
          dev_display_weight_regions(ho_ImageWeight, hv_Params.TupleGetDictTuple(
              "map_transparency"), hv_Params.TupleGetDictTuple("segmentation_max_weight"), 
              out hv_WeightsColors);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple(
              "map_color_bar_width"), hv_WeightsColors, hv_Params.TupleGetDictTuple(
              "segmentation_max_weight"), hv_WindowImageRatio, hv_CurrentWindowHandle);
          }
          if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else
        {
          //Reset flush buffer of existing windows before throwing an exception.
          hv_WindowHandleKeys.Dispose();
          HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            //Only consider the WindowHandleKeys that are needed for the current visualization.
            hv_Indices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Indices = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
                hv_WindowHandleKeys.TupleSelect(hv_Index));
            }
            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                new HTuple())))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_WindowHandles.Dispose();
              HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                  hv_Index), out hv_WindowHandles);
              }
              for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
                  ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
              {
                //Reset values of windows that have been changed temporarily.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                    "flush", hv_FlushValues.TupleSelect(hv_Index));
                }
              }
            }
          }
          throw new HalconException("Key for display unknown: "+(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
              hv_KeyIndex)));
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_KeyIndex = hv_KeyIndex+1;
        hv_KeyIndex.Dispose();
        hv_KeyIndex = ExpTmpLocalVar_KeyIndex;
        }
        }
      }
      //
      //Display results.
      hv_WindowHandleKeysNew.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Only consider the WindowHandleKeys that are needed for the current visualization.
        hv_KeyIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KeyIndex = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
        }
        if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
            new HTuple())))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandles.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
              hv_Index), out hv_WindowHandles);
          }
          for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
              ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
          {
            //Display content of window handle.
            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
            {
              //Reset values of windows that have been changed temporarily.
              if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                  "true"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                  "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
              }
            }
            else
            {
              //Per default, 'flush' of new windows should be set to 'true'.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                  "flush", "true");
              }
            }
          }
        }
      }
      //
      ho_Image.Dispose();
      ho_Domain.Dispose();
      ho_GrippingMapImageResult.Dispose();
      ho_Cross.Dispose();
      ho_GrippingMapGroundTruth.Dispose();
      ho_X.Dispose();
      ho_Y.Dispose();
      ho_Z.Dispose();
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();
      ho_ConfidenceImage.Dispose();
      ho_HeatmapScene.Dispose();
      ho_ScoreMaps.Dispose();
      ho_CharacterScoreMap.Dispose();
      ho_LinkScoreMap.Dispose();
      ho_OrientationSinScoreMap.Dispose();
      ho_OrientationCosScoreMap.Dispose();
      ho_ScoreMap.Dispose();
      ho_OrientationScoreMap.Dispose();
      ho_PredictionColorFrame.Dispose();
      ho_ImageHeatmap.Dispose();
      ho_PredictionSymbol.Dispose();
      ho_CrossLineH.Dispose();
      ho_CrossLineV.Dispose();
      ho_ImageConfidence.Dispose();
      ho_SegmentationImagGroundTruth.Dispose();
      ho_SegmentationImageResult.Dispose();
      ho_ImageAbsDiff.Dispose();
      ho_DiffRegion.Dispose();
      ho_ImageWeight.Dispose();

      hv_DLResult_COPY_INP_TMP.Dispose();
      hv_KeysForDisplay_COPY_INP_TMP.Dispose();
      hv_Params.Dispose();
      hv_GenParamNames.Dispose();
      hv_ParamIndex.Dispose();
      hv_GenParamName.Dispose();
      hv_KeyExists.Dispose();
      hv_SampleKeys.Dispose();
      hv_ResultKeys.Dispose();
      hv_ImageIDExists.Dispose();
      hv_ImageID.Dispose();
      hv_ImageIDString.Dispose();
      hv_ImageIDStringBraces.Dispose();
      hv_ImageIDStringCapital.Dispose();
      hv_IsOCRDetection.Dispose();
      hv_AdditionalGreenClassNames.Dispose();
      hv_KeyIndex.Dispose();
      hv_OcrResult.Dispose();
      hv_MaxClassIdSample.Dispose();
      hv_EmptySample.Dispose();
      hv_MaxClassIdResult.Dispose();
      hv_EmptyResult.Dispose();
      hv_MaxClassId.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNameKey.Dispose();
      hv_ClassIdKey.Dispose();
      hv_ResultClassNames.Dispose();
      hv_ResultClassIds.Dispose();
      hv_SortIndices.Dispose();
      hv_UniqueClassIds.Dispose();
      hv_UniqueClassNames.Dispose();
      hv_Colors.Dispose();
      hv_ClassesLegend.Dispose();
      hv_InvalidInput.Dispose();
      hv_ClassKeys.Dispose();
      hv_ClassKeysExist.Dispose();
      hv_DLDatasetInfoKeys.Dispose();
      hv_Index.Dispose();
      hv_PrevWindowCoordinates.Dispose();
      hv_Keys.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfoExists.Dispose();
      hv_FlushValues.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_WindowHandles.Dispose();
      hv_WindowIndex.Dispose();
      hv_FlushValue.Dispose();
      hv_WidthImage.Dispose();
      hv_HeightImage.Dispose();
      hv_CurrentWindowHandle.Dispose();
      hv_WindowImageRatio.Dispose();
      hv_ColorsGrippingGroundTruth.Dispose();
      hv_ImageClassIDs.Dispose();
      hv_GrippingPointsExists.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_AnomalyImages.Dispose();
      hv_PossibleKeysForDisplay.Dispose();
      hv_AddDisplayKey.Dispose();
      hv_AnomalyLabelGroundTruth.Dispose();
      hv_AnomalyLabelIDGroundTruth.Dispose();
      hv_AnomalyResultPostfix.Dispose();
      hv_AnomalyScore.Dispose();
      hv_AnomalyClassID.Dispose();
      hv_AnomalyClassThresholdDisplay.Dispose();
      hv_AnomalyRegionThresholdDisplay.Dispose();
      hv_WindowHandleName.Dispose();
      hv_AnomalyRegionGroundTruthExists.Dispose();
      hv_Text.Dispose();
      hv_PredictionColor.Dispose();
      hv_LineColors.Dispose();
      hv_ResultColorOffset.Dispose();
      hv_AnomalyRegionExists.Dispose();
      hv_AnomalyImageKey.Dispose();
      hv_AnomalyScoreKey.Dispose();
      hv_AnomalyResultKey.Dispose();
      hv_AnomalyRegionKey.Dispose();
      hv_DisplayDirectionTemp.Dispose();
      hv_BboxLabelIndex.Dispose();
      hv_BboxConfidences.Dispose();
      hv_TextConf.Dispose();
      hv_BboxClassIndex.Dispose();
      hv_BboxColorsBoth.Dispose();
      hv_BboxClassLabelIndexUniq.Dispose();
      hv_BboxIDs.Dispose();
      hv_BboxColors.Dispose();
      hv_BboxIDsUniq.Dispose();
      hv_BboxColorsResults.Dispose();
      hv_BboxClassIndexUniq.Dispose();
      hv_ClassificationLabelIDGroundTruth.Dispose();
      hv_ClassificationLabelIDResult.Dispose();
      hv_PredictionText.Dispose();
      hv_BoarderOffset.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowImageRatioHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_BoarderOffsetRow.Dispose();
      hv_BoarderOffsetCol.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowCoordinates.Dispose();
      hv_CurrentWindowHeight.Dispose();
      hv__.Dispose();
      hv_MaxHeight.Dispose();
      hv_SelectedHeatmapMethod.Dispose();
      hv_DictHeatmap.Dispose();
      hv_MethodName.Dispose();
      hv_HeatmapKeys.Dispose();
      hv_HeatmapImageName.Dispose();
      hv_TargetClassID.Dispose();
      hv_Confidences.Dispose();
      hv_MaxDeviation.Dispose();
      hv_ClassificationLabelNameResult.Dispose();
      hv_TargetClassConfidence.Dispose();
      hv_ClassificationLabelNamesGroundTruth.Dispose();
      hv_ShowGT.Dispose();
      hv_ShowResult.Dispose();
      hv_NumLines.Dispose();
      hv_Type.Dispose();
      hv_GTWordKeyExists.Dispose();
      hv_HeightWindow.Dispose();
      hv_HeightMarginBottom.Dispose();
      hv_Size.Dispose();
      hv_Length.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_HomMat2DCompose.Dispose();
      hv_PredictionForegroundColor.Dispose();
      hv_PredictionBackgroundColor.Dispose();
      hv_Spaces.Dispose();
      hv_ConfidenceColors.Dispose();
      hv_ColorsResults.Dispose();
      hv_GroundTruthIDs.Dispose();
      hv_ResultIDs.Dispose();
      hv_ImageClassIDsUniq.Dispose();
      hv_ImageClassIDsIndices.Dispose();
      hv_ImageClassIDsIndex.Dispose();
      hv_StringSegExcludeClassIDs.Dispose();
      hv_StringIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ColorsSegmentation.Dispose();
      hv_DrawMode.Dispose();
      hv_Width.Dispose();
      hv_MinWeight.Dispose();
      hv_WeightsColors.Dispose();
      hv_Indices.Dispose();
      hv_WindowHandleKeysNew.Dispose();
      hv___Tmp_Ctrl_Dict_Init_1.Dispose();
      hv___Tmp_Ctrl_Dict_Init_2.Dispose();
      hv___Tmp_Ctrl_Dict_Init_3.Dispose();
      hv___Tmp_Ctrl_Dict_Init_4.Dispose();
      hv___Tmp_Ctrl_Dict_Init_5.Dispose();
      hv___Tmp_Ctrl_Dict_Init_6.Dispose();
      hv___Tmp_Ctrl_Dict_Init_7.Dispose();
      hv___Tmp_Ctrl_1.Dispose();
      hv___Tmp_Ctrl_Type.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_Domain.Dispose();
      ho_GrippingMapImageResult.Dispose();
      ho_Cross.Dispose();
      ho_GrippingMapGroundTruth.Dispose();
      ho_X.Dispose();
      ho_Y.Dispose();
      ho_Z.Dispose();
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();
      ho_ConfidenceImage.Dispose();
      ho_HeatmapScene.Dispose();
      ho_ScoreMaps.Dispose();
      ho_CharacterScoreMap.Dispose();
      ho_LinkScoreMap.Dispose();
      ho_OrientationSinScoreMap.Dispose();
      ho_OrientationCosScoreMap.Dispose();
      ho_ScoreMap.Dispose();
      ho_OrientationScoreMap.Dispose();
      ho_PredictionColorFrame.Dispose();
      ho_ImageHeatmap.Dispose();
      ho_PredictionSymbol.Dispose();
      ho_CrossLineH.Dispose();
      ho_CrossLineV.Dispose();
      ho_ImageConfidence.Dispose();
      ho_SegmentationImagGroundTruth.Dispose();
      ho_SegmentationImageResult.Dispose();
      ho_ImageAbsDiff.Dispose();
      ho_DiffRegion.Dispose();
      ho_ImageWeight.Dispose();

      hv_DLResult_COPY_INP_TMP.Dispose();
      hv_KeysForDisplay_COPY_INP_TMP.Dispose();
      hv_Params.Dispose();
      hv_GenParamNames.Dispose();
      hv_ParamIndex.Dispose();
      hv_GenParamName.Dispose();
      hv_KeyExists.Dispose();
      hv_SampleKeys.Dispose();
      hv_ResultKeys.Dispose();
      hv_ImageIDExists.Dispose();
      hv_ImageID.Dispose();
      hv_ImageIDString.Dispose();
      hv_ImageIDStringBraces.Dispose();
      hv_ImageIDStringCapital.Dispose();
      hv_IsOCRDetection.Dispose();
      hv_AdditionalGreenClassNames.Dispose();
      hv_KeyIndex.Dispose();
      hv_OcrResult.Dispose();
      hv_MaxClassIdSample.Dispose();
      hv_EmptySample.Dispose();
      hv_MaxClassIdResult.Dispose();
      hv_EmptyResult.Dispose();
      hv_MaxClassId.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNameKey.Dispose();
      hv_ClassIdKey.Dispose();
      hv_ResultClassNames.Dispose();
      hv_ResultClassIds.Dispose();
      hv_SortIndices.Dispose();
      hv_UniqueClassIds.Dispose();
      hv_UniqueClassNames.Dispose();
      hv_Colors.Dispose();
      hv_ClassesLegend.Dispose();
      hv_InvalidInput.Dispose();
      hv_ClassKeys.Dispose();
      hv_ClassKeysExist.Dispose();
      hv_DLDatasetInfoKeys.Dispose();
      hv_Index.Dispose();
      hv_PrevWindowCoordinates.Dispose();
      hv_Keys.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfoExists.Dispose();
      hv_FlushValues.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_WindowHandles.Dispose();
      hv_WindowIndex.Dispose();
      hv_FlushValue.Dispose();
      hv_WidthImage.Dispose();
      hv_HeightImage.Dispose();
      hv_CurrentWindowHandle.Dispose();
      hv_WindowImageRatio.Dispose();
      hv_ColorsGrippingGroundTruth.Dispose();
      hv_ImageClassIDs.Dispose();
      hv_GrippingPointsExists.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_AnomalyImages.Dispose();
      hv_PossibleKeysForDisplay.Dispose();
      hv_AddDisplayKey.Dispose();
      hv_AnomalyLabelGroundTruth.Dispose();
      hv_AnomalyLabelIDGroundTruth.Dispose();
      hv_AnomalyResultPostfix.Dispose();
      hv_AnomalyScore.Dispose();
      hv_AnomalyClassID.Dispose();
      hv_AnomalyClassThresholdDisplay.Dispose();
      hv_AnomalyRegionThresholdDisplay.Dispose();
      hv_WindowHandleName.Dispose();
      hv_AnomalyRegionGroundTruthExists.Dispose();
      hv_Text.Dispose();
      hv_PredictionColor.Dispose();
      hv_LineColors.Dispose();
      hv_ResultColorOffset.Dispose();
      hv_AnomalyRegionExists.Dispose();
      hv_AnomalyImageKey.Dispose();
      hv_AnomalyScoreKey.Dispose();
      hv_AnomalyResultKey.Dispose();
      hv_AnomalyRegionKey.Dispose();
      hv_DisplayDirectionTemp.Dispose();
      hv_BboxLabelIndex.Dispose();
      hv_BboxConfidences.Dispose();
      hv_TextConf.Dispose();
      hv_BboxClassIndex.Dispose();
      hv_BboxColorsBoth.Dispose();
      hv_BboxClassLabelIndexUniq.Dispose();
      hv_BboxIDs.Dispose();
      hv_BboxColors.Dispose();
      hv_BboxIDsUniq.Dispose();
      hv_BboxColorsResults.Dispose();
      hv_BboxClassIndexUniq.Dispose();
      hv_ClassificationLabelIDGroundTruth.Dispose();
      hv_ClassificationLabelIDResult.Dispose();
      hv_PredictionText.Dispose();
      hv_BoarderOffset.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowImageRatioHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_BoarderOffsetRow.Dispose();
      hv_BoarderOffsetCol.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowCoordinates.Dispose();
      hv_CurrentWindowHeight.Dispose();
      hv__.Dispose();
      hv_MaxHeight.Dispose();
      hv_SelectedHeatmapMethod.Dispose();
      hv_DictHeatmap.Dispose();
      hv_MethodName.Dispose();
      hv_HeatmapKeys.Dispose();
      hv_HeatmapImageName.Dispose();
      hv_TargetClassID.Dispose();
      hv_Confidences.Dispose();
      hv_MaxDeviation.Dispose();
      hv_ClassificationLabelNameResult.Dispose();
      hv_TargetClassConfidence.Dispose();
      hv_ClassificationLabelNamesGroundTruth.Dispose();
      hv_ShowGT.Dispose();
      hv_ShowResult.Dispose();
      hv_NumLines.Dispose();
      hv_Type.Dispose();
      hv_GTWordKeyExists.Dispose();
      hv_HeightWindow.Dispose();
      hv_HeightMarginBottom.Dispose();
      hv_Size.Dispose();
      hv_Length.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_HomMat2DCompose.Dispose();
      hv_PredictionForegroundColor.Dispose();
      hv_PredictionBackgroundColor.Dispose();
      hv_Spaces.Dispose();
      hv_ConfidenceColors.Dispose();
      hv_ColorsResults.Dispose();
      hv_GroundTruthIDs.Dispose();
      hv_ResultIDs.Dispose();
      hv_ImageClassIDsUniq.Dispose();
      hv_ImageClassIDsIndices.Dispose();
      hv_ImageClassIDsIndex.Dispose();
      hv_StringSegExcludeClassIDs.Dispose();
      hv_StringIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ColorsSegmentation.Dispose();
      hv_DrawMode.Dispose();
      hv_Width.Dispose();
      hv_MinWeight.Dispose();
      hv_WeightsColors.Dispose();
      hv_Indices.Dispose();
      hv_WindowHandleKeysNew.Dispose();
      hv___Tmp_Ctrl_Dict_Init_1.Dispose();
      hv___Tmp_Ctrl_Dict_Init_2.Dispose();
      hv___Tmp_Ctrl_Dict_Init_3.Dispose();
      hv___Tmp_Ctrl_Dict_Init_4.Dispose();
      hv___Tmp_Ctrl_Dict_Init_5.Dispose();
      hv___Tmp_Ctrl_Dict_Init_6.Dispose();
      hv___Tmp_Ctrl_Dict_Init_7.Dispose();
      hv___Tmp_Ctrl_1.Dispose();
      hv___Tmp_Ctrl_Type.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Try to guess the maximum class id based on the given sample/result. 
  private void dev_display_dl_data_get_max_class_id (HTuple hv_DLSample, out HTuple hv_MaxClassId, 
      out HTuple hv_Empty)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Keys = new HTuple(), hv_Matches = new HTuple();
    HTuple hv_Length = new HTuple(), hv_Greatereq = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_LengthAll = new HTuple();
    HTuple hv_KeyIndex = new HTuple(), hv_Key = new HTuple();
    HTuple hv_KeyType = new HTuple(), hv_Tuple = new HTuple();
    HTuple hv_MaxTuple = new HTuple(), hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    hv_MaxClassId = new HTuple();
    hv_Empty = new HTuple();
    try
    {
      hv_MaxClassId.Dispose();
      hv_MaxClassId = -1;
      hv_Empty.Dispose();
      hv_Empty = 0;
      try
      {
        hv_Keys.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_Keys);
        //Find keys that end on '_id'. (They contain ids!)
        hv_Matches.Dispose();
        HOperatorSet.TupleRegexpMatch(hv_Keys, "_id", out hv_Matches);
        hv_Length.Dispose();
        HOperatorSet.TupleStrlen(hv_Matches, out hv_Length);
        hv_Greatereq.Dispose();
        HOperatorSet.TupleGreaterEqualElem(hv_Length, 1, out hv_Greatereq);
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_Greatereq, 1, out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleGreater(-1))) != 0)
        {
          //Find the maximum given class id.
          hv_LengthAll.Dispose();
          hv_LengthAll = 0;
          for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_Indices.TupleLength()
              ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
          {
            hv_Key.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Key = hv_Keys.TupleSelect(
                hv_Indices.TupleSelect(hv_KeyIndex));
            }
            //Skip image_id.
            if ((int)(new HTuple(hv_Key.TupleEqual("image_id"))) != 0)
            {
              continue;
            }
            hv_KeyType.Dispose();
            HOperatorSet.GetDictParam(hv_DLSample, "key_data_type", hv_Key, out hv_KeyType);
            if ((int)(new HTuple(hv_KeyType.TupleNotEqual("tuple"))) != 0)
            {
              continue;
            }
            hv_Tuple.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSample, hv_Key, out hv_Tuple);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_LengthAll = hv_LengthAll+(new HTuple(hv_Tuple.TupleLength()
                ));
            hv_LengthAll.Dispose();
            hv_LengthAll = ExpTmpLocalVar_LengthAll;
            }
            }
            if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(
                0))) != 0)
            {
              continue;
            }
            hv_MaxTuple.Dispose();
            HOperatorSet.TupleMax(hv_Tuple, out hv_MaxTuple);
            if ((int)(new HTuple(hv_MaxTuple.TupleGreater(hv_MaxClassId))) != 0)
            {
              hv_MaxClassId.Dispose();
              hv_MaxClassId = new HTuple(hv_MaxTuple);
            }
          }
          if ((int)(new HTuple(hv_LengthAll.TupleEqual(0))) != 0)
          {
            hv_Empty.Dispose();
            hv_Empty = 1;
          }
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //Ignore any exception.
      }

      hv_Keys.Dispose();
      hv_Matches.Dispose();
      hv_Length.Dispose();
      hv_Greatereq.Dispose();
      hv_Indices.Dispose();
      hv_LengthAll.Dispose();
      hv_KeyIndex.Dispose();
      hv_Key.Dispose();
      hv_KeyType.Dispose();
      hv_Tuple.Dispose();
      hv_MaxTuple.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Keys.Dispose();
      hv_Matches.Dispose();
      hv_Length.Dispose();
      hv_Greatereq.Dispose();
      hv_Indices.Dispose();
      hv_LengthAll.Dispose();
      hv_KeyIndex.Dispose();
      hv_Key.Dispose();
      hv_KeyType.Dispose();
      hv_Tuple.Dispose();
      hv_MaxTuple.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
  // Short Description: Display the ground truth anomaly regions of the given DLSample. 
  private void dev_display_ground_truth_anomaly_regions (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor, 
      HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
  {



    // Local iconic variables 

    HObject ho_AnomalyImage=null, ho_AnomalyRegion=null;

    // Local control variables 

    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
    HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
    HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    hv_AnomalyRegionExists = new HTuple();
    try
    {
      //
      //This procedure visualizes the ground truth anomalies
      //if there is an anomaly_ground_truth in DLSample.
      //
      //Get current set color.
      hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();hv_Alpha.Dispose();
      HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue, 
          out hv_Alpha);
      hv_InitialColor.Dispose();
      hv_InitialColor = new HTuple();
      for (hv_IndexColor=0; (int)hv_IndexColor<=(int)((new HTuple(hv_Red.TupleLength()
          ))-1); hv_IndexColor = (int)hv_IndexColor + 1)
      {
        hv_Color_RGBA.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Color_RGBA = ((("#"+(((hv_Red.TupleSelect(
            hv_IndexColor))).TupleString("2x")))+(((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
            "2x")))+(((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x")))+(((hv_Alpha.TupleSelect(
            hv_IndexColor))).TupleString("2x"));
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
            "replace_all"), "0", out ExpTmpOutVar_0);
        hv_Color_RGBA.Dispose();
        hv_Color_RGBA = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
            hv_Color_RGBA);
        hv_InitialColor.Dispose();
        hv_InitialColor = ExpTmpLocalVar_InitialColor;
        }
        }
      }
      //
      if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
          -1))) != 0)
      {
        ho_AnomalyImage.Dispose();
        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
        ho_AnomalyRegion.Dispose();
        HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
        //Get non-empty regions.
        hv_Area.Dispose();
        HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
        if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor+hv_AnomalyColorTransparency);
            }
          }
          //Display the anomaly region.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
          }
        }
        hv_AnomalyRegionExists.Dispose();
        hv_AnomalyRegionExists = "true";
      }
      else
      {
        hv_AnomalyRegionExists.Dispose();
        hv_AnomalyRegionExists = "false";
      }
      //
      //Reset colors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
      }
      //
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth bounding boxes of DLSample. 
  private void dev_display_ground_truth_detection (HTuple hv_DLSample, HTuple hv_SampleKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor, 
      HTuple hv_WindowImageRatio, HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, 
      HTuple hv_WindowHandle, out HTuple hv_BboxIDs)
  {



    // Local iconic variables 

    HObject ho_InstanceMask=null, ho_BboxRectangle=null;
    HObject ho_OrientationArrows=null, ho_RectangleSelected=null;
    HObject ho_MaskSelected=null, ho_ArrowSelected=null;

    // Local control variables 

    HTuple hv_InstanceType = new HTuple(), hv_MaskExists = new HTuple();
    HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
    HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
    HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
    HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
    HTuple hv_BboxPhi = new HTuple(), hv_BboxLabels = new HTuple();
    HTuple hv_Text = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv__ = new HTuple();
    HTuple hv_TextOffset = new HTuple(), hv_LabelRow = new HTuple();
    HTuple hv_LabelCol = new HTuple(), hv_ArrowSizeFactorLength = new HTuple();
    HTuple hv_ArrowSizeFactorHead = new HTuple(), hv_MaxLengthArrow = new HTuple();
    HTuple hv_HalfLengthArrow = new HTuple(), hv_ArrowBaseRow = new HTuple();
    HTuple hv_ArrowBaseCol = new HTuple(), hv_ArrowHeadRow = new HTuple();
    HTuple hv_ArrowHeadCol = new HTuple(), hv_ArrowHeadSize = new HTuple();
    HTuple hv_ContourStyle = new HTuple(), hv_Style = new HTuple();
    HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_TextColorClasses = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_InstanceMask);
    HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
    HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    HOperatorSet.GenEmptyObj(out ho_MaskSelected);
    HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
    hv_BboxIDs = new HTuple();
    try
    {
      //
      //This procedure displays the ground truth bounding boxes and masks (if present) of a DLSample.
      //
      hv_InstanceType.Dispose();
      hv_InstanceType = "";
      hv_MaskExists.Dispose();
      hv_MaskExists = 0;
      if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
        hv_BboxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
        hv_BboxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
        hv_BboxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle1";
      }
      else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
        hv_BboxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
        hv_BboxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
        hv_BboxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
        hv_BboxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle2";
      }
      else
      {
        throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
      }
      if ((int)(new HTuple(((hv_SampleKeys.TupleFind("mask"))).TupleNotEqual(-1))) != 0)
      {
        ho_InstanceMask.Dispose();
        HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLSample, "mask");
        hv_MaskExists.Dispose();
        hv_MaskExists = 1;
      }
      if ((int)((new HTuple((new HTuple(hv_InstanceType.TupleNotEqual("rectangle1"))).TupleAnd(
          new HTuple(hv_InstanceType.TupleNotEqual("rectangle2"))))).TupleAnd(hv_MaskExists.TupleNot()
          )) != 0)
      {
        throw new HalconException("Ground truth bounding box or mask data could not be found in DLSample.");
      }
      hv_BboxLabels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
      if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
          0))) != 0)
      {
        //
        //Get text and text size for correct positioning of label IDs.
        if ((int)(hv_ShowLabels) != 0)
        {
          hv_Text.Dispose();
          hv_Text = new HTuple(hv_BboxLabels);
          hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent, 
              out hv_Descent, out hv__, out hv__);
          hv_TextOffset.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextOffset = (hv_Ascent+hv_Descent)/hv_WindowImageRatio;
          }
        }
        //
        //Generate bounding box XLDs.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxPhi.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0, 
              out hv_BboxPhi);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 
              0.5*(hv_BboxCol1+hv_BboxCol2), hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 
              0.5*(hv_BboxRow2-hv_BboxRow1));
          }
          if ((int)(hv_ShowLabels) != 0)
          {
            hv_LabelRow.Dispose();
            hv_LabelRow = new HTuple(hv_BboxRow1);
            hv_LabelCol.Dispose();
            hv_LabelCol = new HTuple(hv_BboxCol1);
          }
        }
        else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow, 
              hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
          if ((int)(hv_ShowLabels) != 0)
          {
            hv_LabelRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LabelRow = hv_BboxRow-hv_TextOffset;
            }
            hv_LabelCol.Dispose();
            hv_LabelCol = new HTuple(hv_BboxCol);
          }
          if ((int)(hv_ShowDirection) != 0)
          {
            if ((int)(new HTuple(hv_ShowDirection.TupleEqual(-1))) != 0)
            {
              hv_ArrowSizeFactorLength.Dispose();
              hv_ArrowSizeFactorLength = 0.4;
              hv_ArrowSizeFactorHead.Dispose();
              hv_ArrowSizeFactorHead = 0.2;
              hv_MaxLengthArrow.Dispose();
              hv_MaxLengthArrow = 20;
              hv_HalfLengthArrow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(
                  hv_BboxLength1*hv_ArrowSizeFactorLength);
              }
              hv_ArrowBaseRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowBaseRow = hv_BboxRow-((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowBaseCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowBaseCol = hv_BboxCol+((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()
                  ));
              }
              hv_ArrowHeadRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowHeadCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()
                  ));
              }
              hv_ArrowHeadSize.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(
                  hv_BboxLength1.TupleMin2(hv_BboxLength2)))*hv_ArrowSizeFactorHead;
              }
            }
            else
            {
              hv_ArrowHeadSize.Dispose();
              hv_ArrowHeadSize = 20.0;
              hv_ArrowBaseRow.Dispose();
              hv_ArrowBaseRow = new HTuple(hv_BboxRow);
              hv_ArrowBaseCol.Dispose();
              hv_ArrowBaseCol = new HTuple(hv_BboxCol);
              hv_ArrowHeadRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowHeadCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleCos()
                  ));
              }
            }
            ho_OrientationArrows.Dispose();
            gen_arrow_contour_xld(out ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
                hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
          }
        }
        else if ((int)(hv_MaskExists) != 0)
        {
          if ((int)(hv_ShowLabels) != 0)
          {
            hv__.Dispose();hv_LabelRow.Dispose();hv_LabelCol.Dispose();
            HOperatorSet.AreaCenter(ho_InstanceMask, out hv__, out hv_LabelRow, out hv_LabelCol);
          }
        }
        else
        {
          throw new HalconException("Unknown instance_type: "+hv_InstanceType);
        }
        //
        //Collect the ClassIDs of the bounding boxes.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BboxIDs.Dispose();
        HOperatorSet.TupleGenConst(new HTuple(hv_BboxLabels.TupleLength()), 0, out hv_BboxIDs);
        }
        //
        //Draw the bounding boxes.
        hv_ContourStyle.Dispose();
        HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
        }
        hv_Style.Dispose();
        HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
        }
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxLabels.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_RectangleSelected.Dispose();
          HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox+1);
          }
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_ClassIDs.TupleFind(
              hv_BboxLabels.TupleSelect(hv_IndexBbox));
          }
          if (hv_BboxIDs == null)
            hv_BboxIDs = new HTuple();
          hv_BboxIDs[hv_IndexBbox] = hv_ClassID;
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                hv_ClassID))+"60");
            }
          }
          if ((int)(hv_MaskExists) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_MaskSelected.Dispose();
            HOperatorSet.SelectObj(ho_InstanceMask, out ho_MaskSelected, hv_IndexBbox+1);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_MaskSelected, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
            }
          }
          if ((int)(new HTuple(hv_InstanceType.TupleNotEqual(""))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_RectangleSelected.Dispose();
            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox+1);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                  );
            }
            if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                hv_ShowDirection)) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ArrowSelected.Dispose();
              HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, 
                  hv_IndexBbox+1);
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                    hv_ClassID))+"FF");
                }
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive()
                    );
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                    hv_ClassID))+"60");
                }
              }
            }
          }
        }
        //
        //Write text to the bounding boxes.
        if ((int)(hv_ShowLabels) != 0)
        {
          //For better visibility the text is displayed after all bounding boxes are drawn.
          //Select text color.
          if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
          {
            hv_TextColorClasses.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextColorClasses = hv_BboxColors.TupleSelect(
                hv_BboxIDs);
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextColorClasses.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_BboxIDs.TupleLength()), hv_TextColor, 
                out hv_TextColorClasses);
            }
          }
          //Display text.
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels, "image", 
                hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                (new HTuple("false")).TupleConcat(0)));
            }
          }
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
        }
        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
      }
      else
      {
        //Do nothing if there are no ground truth bounding boxes.
        hv_BboxIDs.Dispose();
        hv_BboxIDs = new HTuple();
      }
      //
      ho_InstanceMask.Dispose();
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_MaskSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_MaskExists.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_BboxLabels.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextOffset.Dispose();
      hv_LabelRow.Dispose();
      hv_LabelCol.Dispose();
      hv_ArrowSizeFactorLength.Dispose();
      hv_ArrowSizeFactorHead.Dispose();
      hv_MaxLengthArrow.Dispose();
      hv_HalfLengthArrow.Dispose();
      hv_ArrowBaseRow.Dispose();
      hv_ArrowBaseCol.Dispose();
      hv_ArrowHeadRow.Dispose();
      hv_ArrowHeadCol.Dispose();
      hv_ArrowHeadSize.Dispose();
      hv_ContourStyle.Dispose();
      hv_Style.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_TextColorClasses.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_InstanceMask.Dispose();
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_MaskSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_MaskExists.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_BboxLabels.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextOffset.Dispose();
      hv_LabelRow.Dispose();
      hv_LabelCol.Dispose();
      hv_ArrowSizeFactorLength.Dispose();
      hv_ArrowSizeFactorHead.Dispose();
      hv_MaxLengthArrow.Dispose();
      hv_HalfLengthArrow.Dispose();
      hv_ArrowBaseRow.Dispose();
      hv_ArrowBaseCol.Dispose();
      hv_ArrowHeadRow.Dispose();
      hv_ArrowHeadCol.Dispose();
      hv_ArrowHeadSize.Dispose();
      hv_ContourStyle.Dispose();
      hv_Style.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_TextColorClasses.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a color bar next to an image. 
  private void dev_display_map_color_bar (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio, 
      HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    HObject ho_Rectangle=null;

    // Local control variables 

    HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
    HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    try
    {
      //
      //This procedure displays a color bar next to the image
      //specified with ImageWidth and ImageHeight.
      //
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      //
      //Display the color bar.
      hv_ColorIndex.Dispose();
      hv_ColorIndex = 0;
      hv_RectHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RectHeight = (1.0*hv_ImageHeight)/(new HTuple(hv_Colors.TupleLength()
          ));
      }
      //Set draw mode to fill
      hv_DrawMode.Dispose();
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      HTuple end_val13 = 0;
      HTuple step_val13 = -hv_RectHeight;
      for (hv_Row=hv_ImageHeight-1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
      {
        //The color bar consists of multiple rectangle1.
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = hv_Row-hv_RectHeight;
        }
        hv_Column1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column1 = hv_ImageWidth+(20/hv_WindowImageRatio);
        }
        hv_Row2.Dispose();
        hv_Row2 = new HTuple(hv_Row);
        hv_Column2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column2 = (hv_ImageWidth+20)+(hv_MapColorBarWidth/hv_WindowImageRatio);
        }
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, 
            hv_Column2);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
              hv_ColorIndex));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ColorIndex = hv_ColorIndex+1;
        hv_ColorIndex.Dispose();
        hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
        }
        }
      }
      //
      //Display labels for color bar.
      hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__, 
          out hv__, out hv_TextHeight);
      for (hv_Index=(double)(0); (double)hv_Index<=1; hv_Index = (double)hv_Index + 0.2)
      {
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = ((hv_MaxValue-(hv_Index*hv_MaxValue))).TupleString(
            ".1f");
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index*(hv_ImageHeight-(2*(hv_TextHeight/hv_WindowImageRatio))), 
              hv_ImageWidth+(40/hv_WindowImageRatio), "black", "box", "false");
          }
        }
      }
      //
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
      }
      ho_Rectangle.Dispose();

      hv_ClipRegion.Dispose();
      hv_ColorIndex.Dispose();
      hv_RectHeight.Dispose();
      hv_DrawMode.Dispose();
      hv_Row.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv__.Dispose();
      hv_TextHeight.Dispose();
      hv_Index.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Rectangle.Dispose();

      hv_ClipRegion.Dispose();
      hv_ColorIndex.Dispose();
      hv_RectHeight.Dispose();
      hv_DrawMode.Dispose();
      hv_Row.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv__.Dispose();
      hv_TextHeight.Dispose();
      hv_Index.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
  // Short Description: Display the detected anomaly regions. 
  private void dev_display_result_anomaly_regions (HObject ho_AnomalyRegion, HTuple hv_CurrentWindowHandle, 
      HTuple hv_LineWidth, HTuple hv_AnomalyRegionResultColor)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
    HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
    HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure displays the result anomaly regions.
      //
      //Get current set color.
      hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();hv_Alpha.Dispose();
      HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue, 
          out hv_Alpha);
      hv_InitialColor.Dispose();
      hv_InitialColor = new HTuple();
      for (hv_IndexColor=0; (int)hv_IndexColor<=(int)((new HTuple(hv_Red.TupleLength()
          ))-1); hv_IndexColor = (int)hv_IndexColor + 1)
      {
        hv_Color_RGBA.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Color_RGBA = ((("#"+(((hv_Red.TupleSelect(
            hv_IndexColor))).TupleString("2x")))+(((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
            "2x")))+(((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x")))+(((hv_Alpha.TupleSelect(
            hv_IndexColor))).TupleString("2x"));
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
            "replace_all"), "0", out ExpTmpOutVar_0);
        hv_Color_RGBA.Dispose();
        hv_Color_RGBA = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
            hv_Color_RGBA);
        hv_InitialColor.Dispose();
        hv_InitialColor = ExpTmpLocalVar_InitialColor;
        }
        }
      }
      //
      //Display anomaly regions.
      //Get non-empty regions.
      hv_Area.Dispose();
      HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
      //
      //Display all non-empty class regions in distinct colors.
      if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
        }
      }
      //
      //Reset colors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
      }
      //

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display result bounding boxes. 
  private void dev_display_result_detection (HTuple hv_DLResult, HTuple hv_ResultKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors, 
      HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow, 
      HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle, 
      out HTuple hv_BboxClassIndices)
  {



    // Local iconic variables 

    HObject ho_InstanceMask=null, ho_BboxRectangle=null;
    HObject ho_OrientationArrows=null, ho_MaskSelected=null;
    HObject ho_RectangleSelected=null, ho_ArrowSelected=null;

    // Local control variables 

    HTuple hv_InstanceType = new HTuple(), hv_MaskExists = new HTuple();
    HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
    HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
    HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
    HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
    HTuple hv_BboxPhi = new HTuple(), hv_BboxClasses = new HTuple();
    HTuple hv_Text = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv__ = new HTuple();
    HTuple hv_TextOffset = new HTuple(), hv_LabelRowTop = new HTuple();
    HTuple hv_LabelRowBottom = new HTuple(), hv_LabelCol = new HTuple();
    HTuple hv_ArrowSizeFactorLength = new HTuple(), hv_ArrowSizeFactorHead = new HTuple();
    HTuple hv_MaxLengthArrow = new HTuple(), hv_HalfLengthArrow = new HTuple();
    HTuple hv_ArrowBaseRow = new HTuple(), hv_ArrowBaseCol = new HTuple();
    HTuple hv_ArrowHeadRow = new HTuple(), hv_ArrowHeadCol = new HTuple();
    HTuple hv_ArrowHeadSize = new HTuple(), hv_MaskRow = new HTuple();
    HTuple hv_MaskCol = new HTuple(), hv_ContourStyle = new HTuple();
    HTuple hv_Style = new HTuple(), hv_LineWidths = new HTuple();
    HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_CurrentColors = new HTuple(), hv_IndexStyle = new HTuple();
    HTuple hv_TextColorClasses = new HTuple(), hv_LabelRow = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_InstanceMask);
    HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
    HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
    HOperatorSet.GenEmptyObj(out ho_MaskSelected);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
    hv_BboxClassIndices = new HTuple();
    try
    {
      //
      //This procedure displays the bounding boxes and masks (if present) defined by a DLResult.
      //The ClassIDs are necessary to display bounding boxes from the same class
      //always with the same color.
      //
      hv_InstanceType.Dispose();
      hv_InstanceType = "";
      hv_MaskExists.Dispose();
      hv_MaskExists = 0;
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
        hv_BboxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
        hv_BboxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
        hv_BboxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle1";
      }
      else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
        hv_BboxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
        hv_BboxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
        hv_BboxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
        hv_BboxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
        hv_BboxClasses.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle2";
      }
      else
      {
        throw new HalconException("Result bounding box data could not be found in DLResult.");
      }
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("mask"))).TupleNotEqual(-1))) != 0)
      {
        ho_InstanceMask.Dispose();
        HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLResult, "mask");
        hv_MaskExists.Dispose();
        hv_MaskExists = 1;
      }
      if ((int)((new HTuple((new HTuple(hv_InstanceType.TupleNotEqual("rectangle1"))).TupleAnd(
          new HTuple(hv_InstanceType.TupleNotEqual("rectangle2"))))).TupleAnd(hv_MaskExists.TupleNot()
          )) != 0)
      {
        throw new HalconException("Result bounding box or mask data could not be found in DLSample.");
      }
      hv_BboxClasses.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
      if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
          0))) != 0)
      {
        //
        //Get text and text size for correct positioning of result class IDs.
        if ((int)(hv_ShowLabels) != 0)
        {
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = hv_BboxClasses+hv_TextConf;
          }
          hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent, 
              out hv_Descent, out hv__, out hv__);
          hv_TextOffset.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TextOffset = (hv_Ascent+hv_Descent)/hv_WindowImageRatio;
          }
        }
        //
        //Generate bounding box XLDs.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxPhi.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0, 
              out hv_BboxPhi);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 
              0.5*(hv_BboxCol1+hv_BboxCol2), hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 
              0.5*(hv_BboxRow2-hv_BboxRow1));
          }
          if ((int)(hv_ShowLabels) != 0)
          {
            hv_LabelRowTop.Dispose();
            hv_LabelRowTop = new HTuple(hv_BboxRow1);
            hv_LabelRowBottom.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LabelRowBottom = hv_BboxRow2-hv_TextOffset;
            }
            hv_LabelCol.Dispose();
            hv_LabelCol = new HTuple(hv_BboxCol1);
          }
        }
        else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow, 
              hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
          if ((int)(hv_ShowLabels) != 0)
          {
            hv_LabelRowTop.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LabelRowTop = hv_BboxRow-hv_TextOffset;
            }
            hv_LabelRowBottom.Dispose();
            hv_LabelRowBottom = new HTuple(hv_BboxRow);
            hv_LabelCol.Dispose();
            hv_LabelCol = new HTuple(hv_BboxCol);
          }
          if ((int)(hv_ShowDirection) != 0)
          {
            if ((int)(new HTuple(hv_ShowDirection.TupleEqual(-1))) != 0)
            {
              hv_ArrowSizeFactorLength.Dispose();
              hv_ArrowSizeFactorLength = 0.4;
              hv_ArrowSizeFactorHead.Dispose();
              hv_ArrowSizeFactorHead = 0.2;
              hv_MaxLengthArrow.Dispose();
              hv_MaxLengthArrow = 20;
              hv_HalfLengthArrow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(
                  hv_BboxLength1*hv_ArrowSizeFactorLength);
              }
              hv_ArrowBaseRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowBaseRow = hv_BboxRow-((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowBaseCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowBaseCol = hv_BboxCol+((hv_BboxLength1-hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()
                  ));
              }
              hv_ArrowHeadRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowHeadCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_HalfLengthArrow)*(hv_BboxPhi.TupleCos()
                  ));
              }
              hv_ArrowHeadSize.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(
                  hv_BboxLength1.TupleMin2(hv_BboxLength2)))*hv_ArrowSizeFactorHead;
              }
            }
            else
            {
              hv_ArrowHeadSize.Dispose();
              hv_ArrowHeadSize = 20.0;
              hv_ArrowBaseRow.Dispose();
              hv_ArrowBaseRow = new HTuple(hv_BboxRow);
              hv_ArrowBaseCol.Dispose();
              hv_ArrowBaseCol = new HTuple(hv_BboxCol);
              hv_ArrowHeadRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadRow = hv_BboxRow-((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleSin()
                  ));
              }
              hv_ArrowHeadCol.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ArrowHeadCol = hv_BboxCol+((hv_BboxLength1+hv_ArrowHeadSize)*(hv_BboxPhi.TupleCos()
                  ));
              }
            }
            ho_OrientationArrows.Dispose();
            gen_arrow_contour_xld(out ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol, 
                hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
          }
        }
        else if ((int)(hv_MaskExists) != 0)
        {
          hv__.Dispose();hv_MaskRow.Dispose();hv_MaskCol.Dispose();
          HOperatorSet.AreaCenter(ho_InstanceMask, out hv__, out hv_MaskRow, out hv_MaskCol);
          hv_LabelRowTop.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LabelRowTop = hv_MaskRow-hv_TextOffset;
          }
          hv_LabelRowBottom.Dispose();
          hv_LabelRowBottom = new HTuple(hv_MaskRow);
          hv_LabelCol.Dispose();
          hv_LabelCol = new HTuple(hv_MaskCol);
        }
        else
        {
          throw new HalconException("Unknown instance_type: "+hv_InstanceType);
        }
        //
        hv_ContourStyle.Dispose();
        HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
        }
        hv_Style.Dispose();
        HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
        hv_LineWidths.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LineWidths = new HTuple();
        hv_LineWidths = hv_LineWidths.TupleConcat(hv_LineWidthBbox+2);
        hv_LineWidths = hv_LineWidths.TupleConcat(hv_LineWidthBbox);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
        }
        //
        //Collect ClassIDs of the bounding boxes.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BboxClassIndices.Dispose();
        HOperatorSet.TupleGenConst(new HTuple(hv_BboxClasses.TupleLength()), 0, out hv_BboxClassIndices);
        }
        //
        //Draw bounding boxes.
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxClasses.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_ClassIDs.TupleFind(
              hv_BboxClasses.TupleSelect(hv_IndexBbox));
          }
          if (hv_BboxClassIndices == null)
            hv_BboxClassIndices = new HTuple();
          hv_BboxClassIndices[hv_IndexBbox] = hv_ClassID;
          //First draw in black to make the class-color visible.
          hv_CurrentColors.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentColors = new HTuple();
          hv_CurrentColors[0] = "black";
          hv_CurrentColors = hv_CurrentColors.TupleConcat(hv_Colors.TupleSelect(
              hv_ClassID));
          }
          if ((int)(hv_MaskExists) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_MaskSelected.Dispose();
            HOperatorSet.SelectObj(ho_InstanceMask, out ho_MaskSelected, hv_IndexBbox+1);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_Colors.TupleSelect(
                  hv_ClassID))+"80");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_MaskSelected, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
          }
          for (hv_IndexStyle=0; (int)hv_IndexStyle<=(int)((new HTuple(hv_CurrentColors.TupleLength()
              ))-1); hv_IndexStyle = (int)hv_IndexStyle + 1)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_CurrentColors.TupleSelect(
                  hv_IndexStyle));
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidths.TupleSelect(
                  hv_IndexStyle));
              }
            }
            if ((int)(new HTuple(hv_InstanceType.TupleNotEqual(""))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_RectangleSelected.Dispose();
              HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, 
                  hv_IndexBbox+1);
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                    );
              }
              if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                  hv_ShowDirection)) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                ho_ArrowSelected.Dispose();
                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, 
                    hv_IndexBbox+1);
                }
                if (HDevWindowStack.IsOpen())
                {
                  HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive()
                      );
                }
              }
            }
          }
        }
        //
        //Draw text of bounding boxes.
        if ((int)(hv_ShowLabels) != 0)
        {
          //For better visibility the text is displayed after all bounding boxes are drawn.
          //Get text and text size for correct positioning of result class IDs.
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = hv_BboxClasses+hv_TextConf;
          }
          //Select text color.
          if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
          {
            hv_TextColorClasses.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextColorClasses = hv_Colors.TupleSelect(
                hv_BboxClassIndices);
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextColorClasses.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_BboxClassIndices.TupleLength()
                ), hv_TextColor, out hv_TextColorClasses);
            }
          }
          //Select correct position of the text.
          hv_LabelRow.Dispose();
          hv_LabelRow = new HTuple(hv_LabelRowTop);
          if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
          {
            hv_LabelRow.Dispose();
            hv_LabelRow = new HTuple(hv_LabelRowBottom);
          }
          //Display text.
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", 
                hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                "shadow")).TupleConcat("border_radius"), hv_BoxLabelColor.TupleConcat(
                (new HTuple("false")).TupleConcat(0)));
            }
          }
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
        }
        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
      }
      else
      {
        //Do nothing if no results are present.
        hv_BboxClassIndices.Dispose();
        hv_BboxClassIndices = new HTuple();
      }
      //
      ho_InstanceMask.Dispose();
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_MaskSelected.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_MaskExists.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_BboxClasses.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextOffset.Dispose();
      hv_LabelRowTop.Dispose();
      hv_LabelRowBottom.Dispose();
      hv_LabelCol.Dispose();
      hv_ArrowSizeFactorLength.Dispose();
      hv_ArrowSizeFactorHead.Dispose();
      hv_MaxLengthArrow.Dispose();
      hv_HalfLengthArrow.Dispose();
      hv_ArrowBaseRow.Dispose();
      hv_ArrowBaseCol.Dispose();
      hv_ArrowHeadRow.Dispose();
      hv_ArrowHeadCol.Dispose();
      hv_ArrowHeadSize.Dispose();
      hv_MaskRow.Dispose();
      hv_MaskCol.Dispose();
      hv_ContourStyle.Dispose();
      hv_Style.Dispose();
      hv_LineWidths.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_CurrentColors.Dispose();
      hv_IndexStyle.Dispose();
      hv_TextColorClasses.Dispose();
      hv_LabelRow.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_InstanceMask.Dispose();
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_MaskSelected.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_MaskExists.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_BboxClasses.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextOffset.Dispose();
      hv_LabelRowTop.Dispose();
      hv_LabelRowBottom.Dispose();
      hv_LabelCol.Dispose();
      hv_ArrowSizeFactorLength.Dispose();
      hv_ArrowSizeFactorHead.Dispose();
      hv_MaxLengthArrow.Dispose();
      hv_HalfLengthArrow.Dispose();
      hv_ArrowBaseRow.Dispose();
      hv_ArrowBaseCol.Dispose();
      hv_ArrowHeadRow.Dispose();
      hv_ArrowHeadCol.Dispose();
      hv_ArrowHeadSize.Dispose();
      hv_MaskRow.Dispose();
      hv_MaskCol.Dispose();
      hv_ContourStyle.Dispose();
      hv_Style.Dispose();
      hv_LineWidths.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_CurrentColors.Dispose();
      hv_IndexStyle.Dispose();
      hv_TextColorClasses.Dispose();
      hv_LabelRow.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth/result segmentation as regions. 
  private void dev_display_segmentation_regions (HObject ho_SegmentationImage, HTuple hv_ClassIDs, 
      HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
  {




    // Local iconic variables 

    HObject ho_Regions, ho_SelectedRegion=null;

    // Local control variables 

    HTuple hv_IncludedClassIDs = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
    hv_ImageClassIDs = new HTuple();
    try
    {
      //
      //This procedure displays the ground truth/result segmentation
      //given in SegmentationImage as regions. The ClassIDs are necessary to
      //display ground truth/result segmentations from the same class
      //always with the same color. It is possible to exclude certain ClassIDs
      //from being displayed. The displayed classes are returned in ImageClassIDs.
      //
      //
      //Remove excluded class IDs from the list.
      hv_IncludedClassIDs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
          hv_ExcludeClassIDs);
      }
      //
      //Get a region for each class ID.
      ho_Regions.Dispose();
      HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs, 
          hv_IncludedClassIDs);
      //
      //Get classes with non-empty regions.
      hv_Area.Dispose();
      HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
      if ((int)(new HTuple((new HTuple(hv_Area.TupleLength())).TupleNotEqual(new HTuple(hv_IncludedClassIDs.TupleLength()
          )))) != 0)
      {
        throw new HalconException("No equal number of class IDs and segmentation regions.");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageClassIDs.Dispose();
      HOperatorSet.TupleSelectMask(hv_IncludedClassIDs, hv_Area.TupleGreaterElem(
          0), out hv_ImageClassIDs);
      }
      //
      //Display all non-empty class regions in distinct colors.
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_IncludedClassIDs.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
        {
          //Use class ID to determine region color.
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_IncludedClassIDs.TupleSelect(
              hv_Index);
          }
          hv_IndexColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndexColor = hv_ClassIDs.TupleFindFirst(
              hv_ClassID);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                hv_IndexColor));
            }
          }
          //Display the segmentation region.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_SelectedRegion.Dispose();
          HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index+1);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
          }
        }
      }
      ho_Regions.Dispose();
      ho_SelectedRegion.Dispose();

      hv_IncludedClassIDs.Dispose();
      hv_Area.Dispose();
      hv_Index.Dispose();
      hv_ClassID.Dispose();
      hv_IndexColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Regions.Dispose();
      ho_SelectedRegion.Dispose();

      hv_IncludedClassIDs.Dispose();
      hv_Area.Dispose();
      hv_Index.Dispose();
      hv_ClassID.Dispose();
      hv_IndexColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of weights. 
  private void dev_display_weight_regions (HObject ho_ImageWeight, HTuple hv_DrawTransparency, 
      HTuple hv_SegMaxWeight, out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Domain, ho_WeightsRegion=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure displays a map of the weights
      //given in ImageWeight as regions.
      //The transparency can be adjusted.
      //The used colors are returned.
      //
      //Define colors.
      hv_NumColors.Dispose();
      hv_NumColors = 20;
      hv_Colors.Dispose();
      get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
      hv_Colors.Dispose();
      hv_Colors = ExpTmpOutVar_0;
      }
      hv_WeightsColorsAlpha.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
      }
      //
      //Get gay values of ImageWeight.
      ho_Domain.Dispose();
      HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
      hv_GrayVal.Dispose();
      HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
      //
      //Check that the gray values of the image
      //are below the specified maximum.
      if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
      {
        throw new HalconException(((("The maximum weight ("+(hv_GrayVal.TupleMax()
            ))+") in the weight image is greater than the given SegMaxWeight (")+hv_SegMaxWeight)+").");
      }
      //
      while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
      {
        //Go through all gray value 'groups',
        //starting from the maximum.
        hv_GrayValWeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GrayValWeight = hv_GrayVal.TupleMax()
            ;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
            hv_GrayVal.TupleFind(hv_GrayValWeight));
        hv_GrayVal.Dispose();
        hv_GrayVal = ExpTmpLocalVar_GrayVal;
        }
        }
        ho_WeightsRegion.Dispose();
        HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight, 
            hv_GrayValWeight);
        //
        //Visualize the respective group.
        hv_ColorIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorIndex = (((((hv_GrayValWeight/hv_SegMaxWeight)*(hv_NumColors-1))).TupleCeil()
            )).TupleInt();
        }
        hv_ClassColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
            hv_ColorIndex);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
        }
      }
      ho_Domain.Dispose();
      ho_WeightsRegion.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_GrayVal.Dispose();
      hv_GrayValWeight.Dispose();
      hv_ColorIndex.Dispose();
      hv_ClassColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Domain.Dispose();
      ho_WeightsRegion.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_GrayVal.Dispose();
      hv_GrayValWeight.Dispose();
      hv_ColorIndex.Dispose();
      hv_ClassColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
  public void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
      HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    try
    {
      //This procedure open a new graphic window
      //such that it fits into the limits specified by WidthLimit
      //and HeightLimit, but also maintains the correct aspect ratio
      //given by Width and Height.
      //
      //If it is impossible to match the minimum and maximum extent requirements
      //at the same time (f.e. if the image is very long but narrow),
      //the maximum value gets a higher priority.
      //
      //Parse input tuple WidthLimit
      if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
          0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
      {
        hv_MinWidth.Dispose();
        hv_MinWidth = 500;
        hv_MaxWidth.Dispose();
        hv_MaxWidth = 800;
      }
      else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_MinWidth.Dispose();
        hv_MinWidth = 0;
        hv_MaxWidth.Dispose();
        hv_MaxWidth = new HTuple(hv_WidthLimit);
      }
      else
      {
        hv_MinWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinWidth = hv_WidthLimit.TupleSelect(
            0);
        }
        hv_MaxWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxWidth = hv_WidthLimit.TupleSelect(
            1);
        }
      }
      //Parse input tuple HeightLimit
      if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
          0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
      {
        hv_MinHeight.Dispose();
        hv_MinHeight = 400;
        hv_MaxHeight.Dispose();
        hv_MaxHeight = 600;
      }
      else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_MinHeight.Dispose();
        hv_MinHeight = 0;
        hv_MaxHeight.Dispose();
        hv_MaxHeight = new HTuple(hv_HeightLimit);
      }
      else
      {
        hv_MinHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinHeight = hv_HeightLimit.TupleSelect(
            0);
        }
        hv_MaxHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxHeight = hv_HeightLimit.TupleSelect(
            1);
        }
      }
      //
      //Test, if window size has to be changed.
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = 1;
      //First, expand window to the minimum extents (if necessary).
      if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
          hv_Height)))) != 0)
      {
        hv_ResizeFactor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
            )/hv_Width)).TupleConcat((hv_MinHeight.TupleReal())/hv_Height))).TupleMax()
            ;
        }
      }
      hv_TempWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TempWidth = hv_Width*hv_ResizeFactor;
      }
      hv_TempHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TempHeight = hv_Height*hv_ResizeFactor;
      }
      //Then, shrink window to maximum extents (if necessary).
      if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
          hv_TempHeight)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
            )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
            );
        hv_ResizeFactor.Dispose();
        hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
        }
        }
      }
      hv_WindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowWidth = hv_Width*hv_ResizeFactor;
      }
      hv_WindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHeight = hv_Height*hv_ResizeFactor;
      }
      //Resize window
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandle);
      HDevWindowStack.Push(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
        }
      }

      hv_MinWidth.Dispose();
      hv_MaxWidth.Dispose();
      hv_MinHeight.Dispose();
      hv_MaxHeight.Dispose();
      hv_ResizeFactor.Dispose();
      hv_TempWidth.Dispose();
      hv_TempHeight.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_MinWidth.Dispose();
      hv_MaxWidth.Dispose();
      hv_MinHeight.Dispose();
      hv_MaxHeight.Dispose();
      hv_ResizeFactor.Dispose();
      hv_TempWidth.Dispose();
      hv_TempHeight.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
  public void dev_update_off ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop


    return;
  }

  // Chapter: Deep Learning / Object Detection and Instance Segmentation
  // Short Description: Filter the instance segmentation masks of a DL sample based on a given selection. 
  private void filter_dl_sample_instance_segmentation_masks (HTuple hv_DLSample, 
      HTuple hv_BBoxSelectionMask)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_EmptyMasks=null, ho_Masks=null;

    // Local control variables 

    HTuple hv_MaskKeyExists = new HTuple(), hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_EmptyMasks);
    HOperatorSet.GenEmptyObj(out ho_Masks);
    try
    {
      hv_MaskKeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "mask", out hv_MaskKeyExists);
      if ((int)(hv_MaskKeyExists) != 0)
      {
        //Only if masks exist (-> instance segmentation).
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_BBoxSelectionMask, 1, out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
        {
          //We define here that this case will result in an empty object value
          //for the mask key. Another option would be to remove the
          //key 'mask'. However, this would be an unwanted big change in the dictionary.
          ho_EmptyMasks.Dispose();
          HOperatorSet.GenEmptyObj(out ho_EmptyMasks);
          HOperatorSet.SetDictObject(ho_EmptyMasks, hv_DLSample, "mask");
        }
        else
        {
          ho_Masks.Dispose();
          HOperatorSet.GetDictObject(out ho_Masks, hv_DLSample, "mask");
          //Remove all unused masks.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.SelectObj(ho_Masks, out ExpTmpOutVar_0, hv_Indices+1);
          ho_Masks.Dispose();
          ho_Masks = ExpTmpOutVar_0;
          }
          HOperatorSet.SetDictObject(ho_Masks, hv_DLSample, "mask");
        }
      }
      ho_EmptyMasks.Dispose();
      ho_Masks.Dispose();

      hv_MaskKeyExists.Dispose();
      hv_Indices.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_EmptyMasks.Dispose();
      ho_Masks.Dispose();

      hv_MaskKeyExists.Dispose();
      hv_Indices.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: XLD / Creation
  // Short Description: Create an arrow shaped XLD contour. 
  public void gen_arrow_contour_xld (out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
      HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TempArrow=null;

    // Local control variables 

    HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
    HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
    HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
    HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
    HTuple hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    HOperatorSet.GenEmptyObj(out ho_TempArrow);
    try
    {
      //This procedure generates arrow shaped XLD contours,
      //pointing from (Row1, Column1) to (Row2, Column2).
      //If starting and end point are identical, a contour consisting
      //of a single point is returned.
      //
      //input parameters:
      //Row1, Column1: Coordinates of the arrows' starting points
      //Row2, Column2: Coordinates of the arrows' end points
      //HeadLength, HeadWidth: Size of the arrow heads in pixels
      //
      //output parameter:
      //Arrow: The resulting XLD contour
      //
      //The input tuples Row1, Column1, Row2, and Column2 have to be of
      //the same length.
      //HeadLength and HeadWidth either have to be of the same length as
      //Row1, Column1, Row2, and Column2 or have to be a single element.
      //If one of the above restrictions is violated, an error will occur.
      //
      //
      //Initialization.
      ho_Arrow.Dispose();
      HOperatorSet.GenEmptyObj(out ho_Arrow);
      //
      //Calculate the arrow length
      hv_Length.Dispose();
      HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
      //
      //Mark arrows with identical start and end point
      //(set Length to -1 to avoid division-by-zero exception)
      hv_ZeroLengthIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZeroLengthIndices = hv_Length.TupleFind(
          0);
      }
      if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
      {
        if (hv_Length == null)
          hv_Length = new HTuple();
        hv_Length[hv_ZeroLengthIndices] = -1;
      }
      //
      //Calculate auxiliary variables.
      hv_DR.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
      }
      hv_DC.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
      }
      hv_HalfHeadWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HalfHeadWidth = hv_HeadWidth/2.0;
      }
      //
      //Calculate end points of the arrow head.
      hv_RowP1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
      }
      hv_ColP1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
      }
      hv_RowP2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
      }
      hv_ColP2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
      }
      //
      //Finally create output XLD contour for each input point pair
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
        {
          //Create_ single points for arrows with identical start and end point
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_TempArrow.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
              hv_Index), hv_Column1.TupleSelect(hv_Index));
          }
        }
        else
        {
          //Create arrow contour
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_TempArrow.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
              hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
              hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
              hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)), 
              ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
              hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
              hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
              hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
        ho_Arrow.Dispose();
        ho_Arrow = ExpTmpOutVar_0;
        }
      }
      ho_TempArrow.Dispose();

      hv_Length.Dispose();
      hv_ZeroLengthIndices.Dispose();
      hv_DR.Dispose();
      hv_DC.Dispose();
      hv_HalfHeadWidth.Dispose();
      hv_RowP1.Dispose();
      hv_ColP1.Dispose();
      hv_RowP2.Dispose();
      hv_ColP2.Dispose();
      hv_Index.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_TempArrow.Dispose();

      hv_Length.Dispose();
      hv_ZeroLengthIndices.Dispose();
      hv_DR.Dispose();
      hv_DC.Dispose();
      hv_HalfHeadWidth.Dispose();
      hv_RowP1.Dispose();
      hv_ColP1.Dispose();
      hv_RowP2.Dispose();
      hv_ColP2.Dispose();
      hv_Index.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate ground truth characters if they don't exist and words to characters mapping. 
  private void gen_dl_ocr_detection_gt_chars (HTuple hv_DLSampleTargets, HTuple hv_DLSample, 
      HTuple hv_ScaleWidth, HTuple hv_ScaleHeight, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordsCharsMapping)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_CharBoxIndex = new HTuple(), hv_WordLengths = new HTuple();
    HTuple hv_J = new HTuple(), hv_Start = new HTuple(), hv_End = new HTuple();
    HTuple hv_SplitRow = new HTuple(), hv_SplitColumn = new HTuple();
    HTuple hv_SplitPhi = new HTuple(), hv_SplitLength1 = new HTuple();
    HTuple hv_SplitLength2 = new HTuple(), hv_CharsIds = new HTuple();
    HTuple hv_EmptyWordStrings = new HTuple();
    // Initialize local and output iconic variables 
    hvec_WordsCharsMapping = new HTupleVector(1);
    try
    {
      hvec_WordsCharsMapping[0] = new HTupleVector(new HTuple());
      if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Check if chars GT exist otherwise generate them.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CharBoxIndex.Dispose();
        HOperatorSet.TupleFindFirst(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 
            1, out hv_CharBoxIndex);
        }
        if ((int)(new HTuple(hv_CharBoxIndex.TupleEqual(-1))) != 0)
        {
          hv_WordLengths.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WordLengths = ((hv_DLSample.TupleGetDictTuple(
              "word"))).TupleStrlen();
          }
          hvec_WordsCharsMapping[(new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
              ))-1] = new HTupleVector(new HTuple());
          for (hv_J=0; (int)hv_J<=(int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
              "bbox_label_id"))).TupleLength()))-1); hv_J = (int)hv_J + 1)
          {
            //For each word box
            if ((int)(new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
                hv_J))).TupleEqual(0))) != 0)
            {
              if ((int)(new HTuple(((hv_WordLengths.TupleSelect(hv_J))).TupleNotEqual(
                  0))) != 0)
              {
                hv_Start.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Start = new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_label_id"))).TupleLength());
                }
                hv_End.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_End = ((new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_label_id"))).TupleLength()))-1)+(hv_WordLengths.TupleSelect(
                    hv_J));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hvec_WordsCharsMapping[hv_J] = dh.Add(new HTupleVector(HTuple.TupleGenSequence(
                    hv_Start,hv_End,1)));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_SplitRow.Dispose();hv_SplitColumn.Dispose();hv_SplitPhi.Dispose();hv_SplitLength1.Dispose();hv_SplitLength2.Dispose();
                split_rectangle2(((hv_DLSample.TupleGetDictTuple("bbox_row"))).TupleSelect(
                    hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(
                    hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                    hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_length1"))).TupleSelect(
                    hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(
                    hv_J), hv_WordLengths.TupleSelect(hv_J), out hv_SplitRow, out hv_SplitColumn, 
                    out hv_SplitPhi, out hv_SplitLength1, out hv_SplitLength2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_CharsIds.Dispose();
                HOperatorSet.TupleGenConst(hv_WordLengths.TupleSelect(hv_J), 1, out hv_CharsIds);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_EmptyWordStrings.Dispose();
                HOperatorSet.TupleGenConst(hv_WordLengths.TupleSelect(hv_J), "", 
                    out hv_EmptyWordStrings);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_label_id", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_label_id"))).TupleConcat(hv_CharsIds));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_row", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_row"))).TupleConcat(hv_SplitRow));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_col", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_col"))).TupleConcat(hv_SplitColumn));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_phi", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_phi"))).TupleConcat(hv_SplitPhi));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_length1", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_length1"))).TupleConcat(hv_SplitLength1*hv_ScaleWidth));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_length2", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_length2"))).TupleConcat(hv_SplitLength2*hv_ScaleHeight));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSampleTargets, "word", ((hv_DLSampleTargets.TupleGetDictTuple(
                    "word"))).TupleConcat(hv_EmptyWordStrings));
                }
              }
              else
              {
                throw new HalconException(((("Sample with image id "+(hv_DLSample.TupleGetDictTuple(
                    "image_id")))+" is not valid. The word bounding box at index ")+hv_J)+" has an empty string as the ground truth. This is not allowed. Please assign a word label to every word bounding box.");
              }
            }
          }
        }
        else
        {
          hvec_WordsCharsMapping.Dispose();
          gen_words_chars_mapping(hv_DLSample, out hvec_WordsCharsMapping);
        }
      }

      hv_CharBoxIndex.Dispose();
      hv_WordLengths.Dispose();
      hv_J.Dispose();
      hv_Start.Dispose();
      hv_End.Dispose();
      hv_SplitRow.Dispose();
      hv_SplitColumn.Dispose();
      hv_SplitPhi.Dispose();
      hv_SplitLength1.Dispose();
      hv_SplitLength2.Dispose();
      hv_CharsIds.Dispose();
      hv_EmptyWordStrings.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_CharBoxIndex.Dispose();
      hv_WordLengths.Dispose();
      hv_J.Dispose();
      hv_Start.Dispose();
      hv_End.Dispose();
      hv_SplitRow.Dispose();
      hv_SplitColumn.Dispose();
      hv_SplitPhi.Dispose();
      hv_SplitLength1.Dispose();
      hv_SplitLength2.Dispose();
      hv_CharsIds.Dispose();
      hv_EmptyWordStrings.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate target link score map for ocr detection training. 
  private void gen_dl_ocr_detection_gt_link_map (out HObject ho_GtLinkMap, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, HTuple hv_DLSampleTargets, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordToCharVec, 
      HTuple hv_Alpha)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Lines=null, ho_Line=null, ho_LineDilated=null;

    // Local control variables 

    HTuple hv_InitImage = new HTuple(), hv_CRow = new HTuple();
    HTuple hv_CCol = new HTuple(), hv_DiameterC = new HTuple();
    HTuple hv_IndexW = new HTuple(), hv_CharBoxIndices = new HTuple();
    HTuple hv_CharCRows = new HTuple(), hv_CharCCols = new HTuple();
    HTuple hv_CharDistToWordCenter = new HTuple(), hv_ExtremeCharIndex = new HTuple();
    HTuple hv_DistToExtreme = new HTuple(), hv_CharIndexSorted = new HTuple();
    HTuple hv_Box1Idx = new HTuple(), hv_Box2Idx = new HTuple();
    HTuple hv_Diameter1 = new HTuple(), hv_Diameter2 = new HTuple();
    HTuple hv_DilationRadius = new HTuple(), hv_NumLines = new HTuple();
    HTuple hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_GtLinkMap);
    HOperatorSet.GenEmptyObj(out ho_Lines);
    HOperatorSet.GenEmptyObj(out ho_Line);
    HOperatorSet.GenEmptyObj(out ho_LineDilated);
    try
    {
      ho_GtLinkMap.Dispose();
      HOperatorSet.GenImageConst(out ho_GtLinkMap, "real", hv_ImageWidth, hv_ImageHeight);
      hv_InitImage.Dispose();
      HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
      if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
      {
        HOperatorSet.OverpaintRegion(ho_GtLinkMap, ho_GtLinkMap, 0.0, "fill");
      }
      //Compute box centers.
      hv_CRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CRow = hv_DLSampleTargets.TupleGetDictTuple(
          "bbox_row");
      }
      hv_CCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CCol = hv_DLSampleTargets.TupleGetDictTuple(
          "bbox_col");
      }
      hv_DiameterC.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DiameterC = 2*(((hv_DLSampleTargets.TupleGetDictTuple(
          "bbox_length1"))).TupleHypot(hv_DLSampleTargets.TupleGetDictTuple("bbox_length2")));
      }
      //Loop over word boxes.
      for (hv_IndexW=0; (int)hv_IndexW<=(int)((new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
          "bbox_label_id"))).TupleLength()))-1); hv_IndexW = (int)hv_IndexW + 1)
      {
        //For each word box
        if ((int)(new HTuple(((((hv_DLSampleTargets.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
            hv_IndexW))).TupleEqual(0))) != 0)
        {
          hv_CharBoxIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CharBoxIndices = new HTuple(hvec_WordToCharVec[hv_IndexW].T);
          }
          if ((int)(new HTuple((new HTuple(hv_CharBoxIndices.TupleLength())).TupleEqual(
              0))) != 0)
          {
            continue;
          }
          else if ((int)(new HTuple((new HTuple(hv_CharBoxIndices.TupleLength()
              )).TupleEqual(1))) != 0)
          {
            //Generate a dot in the char center.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Lines.Dispose();
            HOperatorSet.GenCircle(out ho_Lines, hv_CRow.TupleSelect(hv_CharBoxIndices), 
                hv_CCol.TupleSelect(hv_CharBoxIndices), ((((0.5*hv_Alpha)*(hv_DiameterC.TupleSelect(
                hv_CharBoxIndices)))).TupleRound())+0.5);
            }
          }
          else
          {
            //Generate link lines between chars.
            hv_CharCRows.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CharCRows = hv_CRow.TupleSelect(
                hv_CharBoxIndices);
            }
            hv_CharCCols.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CharCCols = hv_CCol.TupleSelect(
                hv_CharBoxIndices);
            }
            //Sort the char boxes within the word.
            hv_CharDistToWordCenter.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CharDistToWordCenter = ((hv_CharCRows-(hv_CRow.TupleSelect(
                hv_IndexW)))).TupleHypot(hv_CharCCols-(hv_CCol.TupleSelect(hv_IndexW)));
            }
            hv_ExtremeCharIndex.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ExtremeCharIndex = (new HTuple(hv_CharDistToWordCenter.TupleSortIndex()
                )).TupleSelect((new HTuple(hv_CharDistToWordCenter.TupleLength()))-1);
            }
            hv_DistToExtreme.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DistToExtreme = ((hv_CharCRows-(hv_CharCRows.TupleSelect(
                hv_ExtremeCharIndex)))).TupleHypot(hv_CharCCols-(hv_CharCCols.TupleSelect(
                hv_ExtremeCharIndex)));
            }
            hv_CharIndexSorted.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CharIndexSorted = hv_DistToExtreme.TupleSortIndex()
                ;
            }
            //Get the indices of adjacent characters.
            hv_Box1Idx.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Box1Idx = hv_CharIndexSorted.TupleSelectRange(
                0,(new HTuple(hv_CharIndexSorted.TupleLength()))-2);
            }
            hv_Box2Idx.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Box2Idx = hv_CharIndexSorted.TupleSelectRange(
                1,(new HTuple(hv_CharIndexSorted.TupleLength()))-1);
            }
            //Generate link lines between each pair of adjacent characters.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_Lines.Dispose();
            HOperatorSet.GenRegionLine(out ho_Lines, hv_CharCRows.TupleSelect(hv_Box1Idx), 
                hv_CharCCols.TupleSelect(hv_Box1Idx), hv_CharCRows.TupleSelect(hv_Box2Idx), 
                hv_CharCCols.TupleSelect(hv_Box2Idx));
            }
            //Dilate the lines by 0.5/1.5/2.5/... pixels, such that the line thickness is approximately Alpha*mean(D1, D2)
            hv_Diameter1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Diameter1 = hv_DiameterC.TupleSelect(
                hv_CharBoxIndices.TupleSelect(hv_Box1Idx));
            }
            hv_Diameter2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Diameter2 = hv_DiameterC.TupleSelect(
                hv_CharBoxIndices.TupleSelect(hv_Box2Idx));
            }
            hv_DilationRadius.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DilationRadius = ((((0.25*hv_Alpha)*(hv_Diameter1+hv_Diameter2))).TupleRound()
                )+0.5;
            }
            //dilation_circle only accepts a single radius, so we need to loop over the lines.
            hv_NumLines.Dispose();
            HOperatorSet.CountObj(ho_Lines, out hv_NumLines);
            HTuple end_val39 = hv_NumLines;
            HTuple step_val39 = 1;
            for (hv_Index=1; hv_Index.Continue(end_val39, step_val39); hv_Index = hv_Index.TupleAdd(step_val39))
            {
              ho_Line.Dispose();
              HOperatorSet.SelectObj(ho_Lines, out ho_Line, hv_Index);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_LineDilated.Dispose();
              HOperatorSet.DilationCircle(ho_Line, out ho_LineDilated, hv_DilationRadius.TupleSelect(
                  hv_Index-1));
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ReplaceObj(ho_Lines, ho_LineDilated, out ExpTmpOutVar_0, 
                  hv_Index);
              ho_Lines.Dispose();
              ho_Lines = ExpTmpOutVar_0;
              }
            }
          }
          HOperatorSet.OverpaintRegion(ho_GtLinkMap, ho_Lines, 1.0, "fill");
        }
      }
      ho_Lines.Dispose();
      ho_Line.Dispose();
      ho_LineDilated.Dispose();

      hv_InitImage.Dispose();
      hv_CRow.Dispose();
      hv_CCol.Dispose();
      hv_DiameterC.Dispose();
      hv_IndexW.Dispose();
      hv_CharBoxIndices.Dispose();
      hv_CharCRows.Dispose();
      hv_CharCCols.Dispose();
      hv_CharDistToWordCenter.Dispose();
      hv_ExtremeCharIndex.Dispose();
      hv_DistToExtreme.Dispose();
      hv_CharIndexSorted.Dispose();
      hv_Box1Idx.Dispose();
      hv_Box2Idx.Dispose();
      hv_Diameter1.Dispose();
      hv_Diameter2.Dispose();
      hv_DilationRadius.Dispose();
      hv_NumLines.Dispose();
      hv_Index.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Lines.Dispose();
      ho_Line.Dispose();
      ho_LineDilated.Dispose();

      hv_InitImage.Dispose();
      hv_CRow.Dispose();
      hv_CCol.Dispose();
      hv_DiameterC.Dispose();
      hv_IndexW.Dispose();
      hv_CharBoxIndices.Dispose();
      hv_CharCRows.Dispose();
      hv_CharCCols.Dispose();
      hv_CharDistToWordCenter.Dispose();
      hv_ExtremeCharIndex.Dispose();
      hv_DistToExtreme.Dispose();
      hv_CharIndexSorted.Dispose();
      hv_Box1Idx.Dispose();
      hv_Box2Idx.Dispose();
      hv_Diameter1.Dispose();
      hv_Diameter2.Dispose();
      hv_DilationRadius.Dispose();
      hv_NumLines.Dispose();
      hv_Index.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate target orientation score maps for ocr detection training. 
  private void gen_dl_ocr_detection_gt_orientation_map (out HObject ho_GtOrientationMaps, 
      HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_DLSample)
  {



    // Local iconic variables 

    HObject ho_GtOrientationSin, ho_GtOrientationCos;
    HObject ho_Region=null;

    // Local control variables 

    HTuple hv_InitImage = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_Phi = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_GtOrientationMaps);
    HOperatorSet.GenEmptyObj(out ho_GtOrientationSin);
    HOperatorSet.GenEmptyObj(out ho_GtOrientationCos);
    HOperatorSet.GenEmptyObj(out ho_Region);
    try
    {
      ho_GtOrientationSin.Dispose();
      HOperatorSet.GenImageConst(out ho_GtOrientationSin, "real", hv_ImageWidth, 
          hv_ImageHeight);
      ho_GtOrientationCos.Dispose();
      HOperatorSet.GenImageConst(out ho_GtOrientationCos, "real", hv_ImageWidth, 
          hv_ImageHeight);
      hv_InitImage.Dispose();
      HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
      if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
      {
        HOperatorSet.OverpaintRegion(ho_GtOrientationSin, ho_GtOrientationSin, 0.0, 
            "fill");
        HOperatorSet.OverpaintRegion(ho_GtOrientationCos, ho_GtOrientationCos, 0.0, 
            "fill");
      }
      if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Process char boxes
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1, 
            out hv_Indices);
        }
        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
        {
          hv_Phi.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Phi = hv_DLSample.TupleGetDictTuple(
              "bbox_phi");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Region.Dispose();
          HOperatorSet.GenRectangle2(out ho_Region, ((hv_DLSample.TupleGetDictTuple(
              "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_Indices));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.OverpaintRegion(ho_GtOrientationSin, ho_Region, ((hv_Phi.TupleSelect(
              hv_Indices))).TupleSin(), "fill");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.OverpaintRegion(ho_GtOrientationCos, ho_Region, ((hv_Phi.TupleSelect(
              hv_Indices))).TupleCos(), "fill");
          }
        }
      }
      ho_GtOrientationMaps.Dispose();
      HOperatorSet.Compose2(ho_GtOrientationSin, ho_GtOrientationCos, out ho_GtOrientationMaps
          );
      ho_GtOrientationSin.Dispose();
      ho_GtOrientationCos.Dispose();
      ho_Region.Dispose();

      hv_InitImage.Dispose();
      hv_Indices.Dispose();
      hv_Phi.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_GtOrientationSin.Dispose();
      ho_GtOrientationCos.Dispose();
      ho_Region.Dispose();

      hv_InitImage.Dispose();
      hv_Indices.Dispose();
      hv_Phi.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate target text score map for ocr detection training. 
  private void gen_dl_ocr_detection_gt_score_map (out HObject ho_TargetText, HTuple hv_DLSample, 
      HTuple hv_BoxCutoff, HTuple hv_RenderCutoff, HTuple hv_ImageWidth, HTuple hv_ImageHeight)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ExtendedRectangle=null;

    // Local control variables 

    HTuple hv_InitImage = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Sigma1 = new HTuple(), hv_Sigma2 = new HTuple();
    HTuple hv_ExtendedLength1 = new HTuple(), hv_ExtendedLength2 = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_HomMat2D = new HTuple(), hv_DistRow = new HTuple();
    HTuple hv_DistCol = new HTuple(), hv_ScaledGaussian = new HTuple();
    HTuple hv_Grayval = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_TargetText);
    HOperatorSet.GenEmptyObj(out ho_ExtendedRectangle);
    try
    {
      ho_TargetText.Dispose();
      HOperatorSet.GenImageConst(out ho_TargetText, "real", hv_ImageWidth, hv_ImageHeight);
      hv_InitImage.Dispose();
      HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
      if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
      {
        HOperatorSet.OverpaintRegion(ho_TargetText, ho_TargetText, 0.0, "fill");
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
          "bbox_label_id"))).TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        //For each char box
        if ((int)((new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
            hv_Index))).TupleEqual(1))).TupleAnd(new HTuple(hv_BoxCutoff.TupleNotEqual(
            0)))) != 0)
        {
          //Compute the sigma of an unnormalized normal distribution, such that
          //a certain threshold value is reached at the interval of a certain size.
          hv_Sigma1.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Sigma1 = (((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_Index))*(((-0.5/(hv_BoxCutoff.TupleLog()
              ))).TupleSqrt());
          }
          hv_Sigma2.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Sigma2 = (((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_Index))*(((-0.5/(hv_BoxCutoff.TupleLog()
              ))).TupleSqrt());
          }
          if ((int)((new HTuple((new HTuple(hv_Sigma1.TupleNotEqual(0))).TupleAnd(
              new HTuple(hv_Sigma2.TupleNotEqual(0))))).TupleAnd(new HTuple(hv_RenderCutoff.TupleNotEqual(
              0)))) != 0)
          {
            //Compute the radius of an unnormalized normal distribution,
            //where a certain threshold value is reached at the end.
            hv_ExtendedLength1.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ExtendedLength1 = hv_Sigma1*(((-2*(hv_RenderCutoff.TupleLog()
                ))).TupleSqrt());
            }
            hv_ExtendedLength2.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ExtendedLength2 = hv_Sigma2*(((-2*(hv_RenderCutoff.TupleLog()
                ))).TupleSqrt());
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ExtendedRectangle.Dispose();
            HOperatorSet.GenRectangle2(out ho_ExtendedRectangle, ((hv_DLSample.TupleGetDictTuple(
                "bbox_row"))).TupleSelect(hv_Index), ((hv_DLSample.TupleGetDictTuple(
                "bbox_col"))).TupleSelect(hv_Index), ((hv_DLSample.TupleGetDictTuple(
                "bbox_phi"))).TupleSelect(hv_Index), hv_ExtendedLength1, hv_ExtendedLength2);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ClipRegion(ho_ExtendedRectangle, out ExpTmpOutVar_0, 0, 
                0, hv_ImageHeight-1, hv_ImageWidth-1);
            ho_ExtendedRectangle.Dispose();
            ho_ExtendedRectangle = ExpTmpOutVar_0;
            }
            hv_Rows.Dispose();hv_Columns.Dispose();
            HOperatorSet.GetRegionPoints(ho_ExtendedRectangle, out hv_Rows, out hv_Columns);
            //Verify that the bounding box has an area to plot a gaussian
            hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
            HOperatorSet.AreaCenter(ho_ExtendedRectangle, out hv_Area, out hv_Row, 
                out hv_Column);
            if ((int)(new HTuple(hv_Area.TupleGreater(1))) != 0)
            {
              hv_HomMat2D.Dispose();
              HOperatorSet.HomMat2dIdentity(out hv_HomMat2D);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HTuple ExpTmpOutVar_0;
              HOperatorSet.HomMat2dTranslate(hv_HomMat2D, -(((hv_DLSample.TupleGetDictTuple(
                  "bbox_row"))).TupleSelect(hv_Index)), -(((hv_DLSample.TupleGetDictTuple(
                  "bbox_col"))).TupleSelect(hv_Index)), out ExpTmpOutVar_0);
              hv_HomMat2D.Dispose();
              hv_HomMat2D = ExpTmpOutVar_0;
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HTuple ExpTmpOutVar_0;
              HOperatorSet.HomMat2dRotate(hv_HomMat2D, -(((hv_DLSample.TupleGetDictTuple(
                  "bbox_phi"))).TupleSelect(hv_Index)), 0, 0, out ExpTmpOutVar_0);
              hv_HomMat2D.Dispose();
              hv_HomMat2D = ExpTmpOutVar_0;
              }
              hv_DistRow.Dispose();hv_DistCol.Dispose();
              HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_Rows, hv_Columns, out hv_DistRow, 
                  out hv_DistCol);
              hv_ScaledGaussian.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ScaledGaussian = ((-0.5*(((hv_DistCol*hv_DistCol)/(hv_Sigma1*hv_Sigma1))+((hv_DistRow*hv_DistRow)/(hv_Sigma2*hv_Sigma2))))).TupleExp()
                  ;
              }
              hv_Grayval.Dispose();
              HOperatorSet.GetGrayval(ho_TargetText, hv_Rows, hv_Columns, out hv_Grayval);
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetGrayval(ho_TargetText, hv_Rows, hv_Columns, hv_ScaledGaussian.TupleMax2(
                  hv_Grayval));
              }
            }
          }
        }
      }
      ho_ExtendedRectangle.Dispose();

      hv_InitImage.Dispose();
      hv_Index.Dispose();
      hv_Sigma1.Dispose();
      hv_Sigma2.Dispose();
      hv_ExtendedLength1.Dispose();
      hv_ExtendedLength2.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_HomMat2D.Dispose();
      hv_DistRow.Dispose();
      hv_DistCol.Dispose();
      hv_ScaledGaussian.Dispose();
      hv_Grayval.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ExtendedRectangle.Dispose();

      hv_InitImage.Dispose();
      hv_Index.Dispose();
      hv_Sigma1.Dispose();
      hv_Sigma2.Dispose();
      hv_ExtendedLength1.Dispose();
      hv_ExtendedLength2.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_HomMat2D.Dispose();
      hv_DistRow.Dispose();
      hv_DistCol.Dispose();
      hv_ScaledGaussian.Dispose();
      hv_Grayval.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Preprocess dl samples and generate targets and weights for ocr detection training. 
  private void gen_dl_ocr_detection_targets (HTuple hv_DLSampleOriginal, HTuple hv_DLPreprocessParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TargetText, ho_TargetLink, ho_TargetOrientation;
    HObject ho_TargetWeightText, ho_TargetWeightLink, ho_WeightedCharScore;
    HObject ho_TargetWeightOrientation, ho_OriginalDomain, ho_Image=null;
    HObject ho_DomainWeight=null, ho_Domain=null, ho_TargetOrientationOut=null;
    HObject ho_TargetWeightOrientationOut=null, ho_TargetOrientationChannel=null;
    HObject ho_TargetWeightOrientationChannel=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_Stride = new HTuple(), hv_ScaleHeight = new HTuple();
    HTuple hv_ScaleWidth = new HTuple(), hv_BoxCutoff = new HTuple();
    HTuple hv_RenderCutoff = new HTuple(), hv_Alpha = new HTuple();
    HTuple hv_WSWeightRenderThreshold = new HTuple(), hv_LinkZeroWeightRadius = new HTuple();
    HTuple hv_Confidence = new HTuple(), hv_ScoreMapsWidth = new HTuple();
    HTuple hv_ScoreMapsHeight = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DScale = new HTuple();
    HTuple hv_DLSampleTargets = new HTuple(), hv_OriginalDomainArea = new HTuple();
    HTuple hv__ = new HTuple(), hv_OriginalWidth = new HTuple();
    HTuple hv_OriginalHeight = new HTuple(), hv_IsOriginalDomainFull = new HTuple();
    HTuple hv_ChannelIdx = new HTuple(), hv___Tmp_Ctrl_0 = new HTuple();
    HTuple hv___Tmp_Ctrl_1 = new HTuple();

    HTupleVector hvec_WordsCharsMapping = new HTupleVector(1);
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_TargetText);
    HOperatorSet.GenEmptyObj(out ho_TargetLink);
    HOperatorSet.GenEmptyObj(out ho_TargetOrientation);
    HOperatorSet.GenEmptyObj(out ho_TargetWeightText);
    HOperatorSet.GenEmptyObj(out ho_TargetWeightLink);
    HOperatorSet.GenEmptyObj(out ho_WeightedCharScore);
    HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientation);
    HOperatorSet.GenEmptyObj(out ho_OriginalDomain);
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_DomainWeight);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_TargetOrientationOut);
    HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationOut);
    HOperatorSet.GenEmptyObj(out ho_TargetOrientationChannel);
    HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationChannel);
    try
    {
      check_dl_preprocess_param(hv_DLPreprocessParam);
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_Stride.Dispose();
      hv_Stride = 2;
      //Parameters used in the fallback weak supervision case.
      //They make the the uniformly sized char boxes a bit smaller, as we can expect a spacing between the characters.
      hv_ScaleHeight.Dispose();
      hv_ScaleHeight = 0.9;
      hv_ScaleWidth.Dispose();
      hv_ScaleWidth = 0.8;
      //Parameters relevant to plot the gaussian blobs in the score map.
      hv_BoxCutoff.Dispose();
      hv_BoxCutoff = 0.3;
      hv_RenderCutoff.Dispose();
      hv_RenderCutoff = 0.01;
      //Parameter used to determine the dilation of lines in link map.
      hv_Alpha.Dispose();
      hv_Alpha = 0.1;
      //Parameter used to determine the dilation radius of word boxes in the weight score map.
      hv_WSWeightRenderThreshold.Dispose();
      hv_WSWeightRenderThreshold = 0.05;
      //Parameter represents the dilation radius of word lines in the weight link map.
      hv_LinkZeroWeightRadius.Dispose();
      hv_LinkZeroWeightRadius = 2.5;
      //Confidence is here only a place holder for the fallback weak supervision case.
      hv_Confidence.Dispose();
      hv_Confidence = 1.0;
      if ((int)(new HTuple(hv_Stride.TupleEqual(0))) != 0)
      {
        throw new HalconException("Stride must be greater than 0.");
      }
      //Calculate the size of score maps.
      hv_ScoreMapsWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScoreMapsWidth = hv_ImageWidth/hv_Stride;
      }
      hv_ScoreMapsHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScoreMapsHeight = hv_ImageHeight/hv_Stride;
      }
      //Copy DLSample to maintain the original bounding boxes dimensions.
      hv_DLSample.Dispose();
      HOperatorSet.CopyDict(hv_DLSampleOriginal, new HTuple(), new HTuple(), out hv_DLSample);
      //Preprocess bounding boxes to match targets dimensions.
      hv_HomMat2DIdentity.Dispose();
      HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat2DScale.Dispose();
      HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, 1.0/hv_Stride, 1.0/hv_Stride, 
          0, 0, out hv_HomMat2DScale);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv___Tmp_Ctrl_0.Dispose();hv___Tmp_Ctrl_1.Dispose();
      HOperatorSet.AffineTransPoint2d(hv_HomMat2DScale, hv_DLSample.TupleGetDictTuple(
          "bbox_col"), hv_DLSample.TupleGetDictTuple("bbox_row"), out hv___Tmp_Ctrl_0, 
          out hv___Tmp_Ctrl_1);
      }
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv___Tmp_Ctrl_1);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv___Tmp_Ctrl_0);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", (hv_DLSample.TupleGetDictTuple(
          "bbox_length1"))/hv_Stride);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", (hv_DLSample.TupleGetDictTuple(
          "bbox_length2"))/hv_Stride);
      }
      hv_DLSampleTargets.Dispose();
      HOperatorSet.CopyDict(hv_DLSample, new HTuple(), new HTuple(), out hv_DLSampleTargets);
      hvec_WordsCharsMapping.Dispose();
      gen_dl_ocr_detection_gt_chars(hv_DLSampleTargets, hv_DLSample, hv_ScaleWidth, 
          hv_ScaleHeight, out hvec_WordsCharsMapping);
      //Generate target maps from WordRegions and CharBoxes.
      ho_TargetText.Dispose();
      gen_dl_ocr_detection_gt_score_map(out ho_TargetText, hv_DLSampleTargets, hv_BoxCutoff, 
          hv_RenderCutoff, hv_ScoreMapsWidth, hv_ScoreMapsHeight);
      ho_TargetLink.Dispose();
      gen_dl_ocr_detection_gt_link_map(out ho_TargetLink, hv_ScoreMapsWidth, hv_ScoreMapsHeight, 
          hv_DLSampleTargets, hvec_WordsCharsMapping, hv_Alpha);
      ho_TargetOrientation.Dispose();
      gen_dl_ocr_detection_gt_orientation_map(out ho_TargetOrientation, hv_ScoreMapsWidth, 
          hv_ScoreMapsHeight, hv_DLSampleTargets);
      //Generate weight maps from WordRegions and CharBoxes.
      ho_TargetWeightText.Dispose();
      gen_dl_ocr_detection_weight_score_map(out ho_TargetWeightText, hv_ScoreMapsWidth, 
          hv_ScoreMapsHeight, hv_DLSampleTargets, hv_BoxCutoff, hv_WSWeightRenderThreshold, 
          hv_Confidence);
      ho_TargetWeightLink.Dispose();
      gen_dl_ocr_detection_weight_link_map(ho_TargetLink, ho_TargetWeightText, out ho_TargetWeightLink, 
          hv_LinkZeroWeightRadius);
      ho_WeightedCharScore.Dispose();
      HOperatorSet.MultImage(ho_TargetText, ho_TargetWeightText, out ho_WeightedCharScore, 
          1, 0);
      ho_TargetWeightOrientation.Dispose();
      gen_dl_ocr_detection_weight_orientation_map(ho_WeightedCharScore, out ho_TargetWeightOrientation, 
          hv_DLSampleTargets);
      //Take account of the image domain in DLSampleOriginal.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_OriginalDomain.Dispose();
      HOperatorSet.GetDomain(hv_DLSampleOriginal.TupleGetDictObject("image"), out ho_OriginalDomain
          );
      }
      hv_OriginalDomainArea.Dispose();hv__.Dispose();hv__.Dispose();
      HOperatorSet.AreaCenter(ho_OriginalDomain, out hv_OriginalDomainArea, out hv__, 
          out hv__);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OriginalWidth.Dispose();hv_OriginalHeight.Dispose();
      HOperatorSet.GetImageSize(hv_DLSampleOriginal.TupleGetDictObject("image"), 
          out hv_OriginalWidth, out hv_OriginalHeight);
      }
      hv_IsOriginalDomainFull.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IsOriginalDomainFull = new HTuple(hv_OriginalDomainArea.TupleEqual(
          hv_OriginalWidth*hv_OriginalHeight));
      }
      if ((int)(hv_IsOriginalDomainFull.TupleNot()) != 0)
      {
        //Calculate the domain weight.
        ho_Image.Dispose();
        HOperatorSet.GenImageConst(out ho_Image, "real", hv_OriginalWidth, hv_OriginalHeight);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ChangeDomain(ho_Image, ho_OriginalDomain, out ExpTmpOutVar_0
            );
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        ho_DomainWeight.Dispose();
        HOperatorSet.ZoomImageSize(ho_Image, out ho_DomainWeight, hv_ScoreMapsWidth, 
            hv_ScoreMapsHeight, "constant");
        ho_Domain.Dispose();
        HOperatorSet.GetDomain(ho_DomainWeight, out ho_Domain);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_DomainWeight, out ExpTmpOutVar_0);
        ho_DomainWeight.Dispose();
        ho_DomainWeight = ExpTmpOutVar_0;
        }
        HOperatorSet.OverpaintRegion(ho_DomainWeight, ho_DomainWeight, 0.0, "fill");
        HOperatorSet.OverpaintRegion(ho_DomainWeight, ho_Domain, 1.0, "fill");
        //Apply the domain weight.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetText, out ExpTmpOutVar_0, 
            1, 0);
        ho_TargetText.Dispose();
        ho_TargetText = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetLink, out ExpTmpOutVar_0, 
            1, 0);
        ho_TargetLink.Dispose();
        ho_TargetLink = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightText, out ExpTmpOutVar_0, 
            1, 0);
        ho_TargetWeightText.Dispose();
        ho_TargetWeightText = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightLink, out ExpTmpOutVar_0, 
            1, 0);
        ho_TargetWeightLink.Dispose();
        ho_TargetWeightLink = ExpTmpOutVar_0;
        }
        ho_TargetOrientationOut.Dispose();
        HOperatorSet.GenEmptyObj(out ho_TargetOrientationOut);
        ho_TargetWeightOrientationOut.Dispose();
        HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationOut);
        for (hv_ChannelIdx=1; (int)hv_ChannelIdx<=2; hv_ChannelIdx = (int)hv_ChannelIdx + 1)
        {
          ho_TargetOrientationChannel.Dispose();
          HOperatorSet.AccessChannel(ho_TargetOrientation, out ho_TargetOrientationChannel, 
              hv_ChannelIdx);
          ho_TargetWeightOrientationChannel.Dispose();
          HOperatorSet.AccessChannel(ho_TargetWeightOrientation, out ho_TargetWeightOrientationChannel, 
              hv_ChannelIdx);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MultImage(ho_DomainWeight, ho_TargetOrientationChannel, out ExpTmpOutVar_0, 
              1, 0);
          ho_TargetOrientationChannel.Dispose();
          ho_TargetOrientationChannel = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightOrientationChannel, 
              out ExpTmpOutVar_0, 1, 0);
          ho_TargetWeightOrientationChannel.Dispose();
          ho_TargetWeightOrientationChannel = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.AppendChannel(ho_TargetOrientationOut, ho_TargetOrientationChannel, 
              out ExpTmpOutVar_0);
          ho_TargetOrientationOut.Dispose();
          ho_TargetOrientationOut = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.AppendChannel(ho_TargetWeightOrientationOut, ho_TargetWeightOrientationChannel, 
              out ExpTmpOutVar_0);
          ho_TargetWeightOrientationOut.Dispose();
          ho_TargetWeightOrientationOut = ExpTmpOutVar_0;
          }
        }
        ho_TargetOrientation.Dispose();
        ho_TargetOrientation = new HObject(ho_TargetOrientationOut);
        ho_TargetWeightOrientation.Dispose();
        ho_TargetWeightOrientation = new HObject(ho_TargetWeightOrientationOut);
      }
      //Set targets in output sample.
      HOperatorSet.SetDictObject(ho_TargetText, hv_DLSampleOriginal, "target_text");
      HOperatorSet.SetDictObject(ho_TargetLink, hv_DLSampleOriginal, "target_link");
      HOperatorSet.SetDictObject(ho_TargetOrientation, hv_DLSampleOriginal, "target_orientation");
      HOperatorSet.SetDictObject(ho_TargetWeightText, hv_DLSampleOriginal, "target_weight_text");
      HOperatorSet.SetDictObject(ho_TargetWeightLink, hv_DLSampleOriginal, "target_weight_link");
      HOperatorSet.SetDictObject(ho_TargetWeightOrientation, hv_DLSampleOriginal, 
          "target_weight_orientation");
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_TargetText.Dispose();
      ho_TargetLink.Dispose();
      ho_TargetOrientation.Dispose();
      ho_TargetWeightText.Dispose();
      ho_TargetWeightLink.Dispose();
      ho_WeightedCharScore.Dispose();
      ho_TargetWeightOrientation.Dispose();
      ho_OriginalDomain.Dispose();
      ho_Image.Dispose();
      ho_DomainWeight.Dispose();
      ho_Domain.Dispose();
      ho_TargetOrientationOut.Dispose();
      ho_TargetWeightOrientationOut.Dispose();
      ho_TargetOrientationChannel.Dispose();
      ho_TargetWeightOrientationChannel.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_Stride.Dispose();
      hv_ScaleHeight.Dispose();
      hv_ScaleWidth.Dispose();
      hv_BoxCutoff.Dispose();
      hv_RenderCutoff.Dispose();
      hv_Alpha.Dispose();
      hv_WSWeightRenderThreshold.Dispose();
      hv_LinkZeroWeightRadius.Dispose();
      hv_Confidence.Dispose();
      hv_ScoreMapsWidth.Dispose();
      hv_ScoreMapsHeight.Dispose();
      hv_DLSample.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv_DLSampleTargets.Dispose();
      hv_OriginalDomainArea.Dispose();
      hv__.Dispose();
      hv_OriginalWidth.Dispose();
      hv_OriginalHeight.Dispose();
      hv_IsOriginalDomainFull.Dispose();
      hv_ChannelIdx.Dispose();
      hv___Tmp_Ctrl_0.Dispose();
      hv___Tmp_Ctrl_1.Dispose();
      hvec_WordsCharsMapping.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate link score map weight for ocr detection training. 
  private void gen_dl_ocr_detection_weight_link_map (HObject ho_LinkMap, HObject ho_TargetWeight, 
      out HObject ho_TargetWeightLink, HTuple hv_LinkZeroWeightRadius)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_LinkRegion=null, ho_RegionDilation=null;
    HObject ho_RegionComplement=null, ho_RegionUnion=null, ho_RegionBorder=null;

    // Local control variables 

    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_TargetWeightLink);
    HOperatorSet.GenEmptyObj(out ho_LinkRegion);
    HOperatorSet.GenEmptyObj(out ho_RegionDilation);
    HOperatorSet.GenEmptyObj(out ho_RegionComplement);
    HOperatorSet.GenEmptyObj(out ho_RegionUnion);
    HOperatorSet.GenEmptyObj(out ho_RegionBorder);
    try
    {
      if ((int)(new HTuple(hv_LinkZeroWeightRadius.TupleGreater(0))) != 0)
      {
        //Set zero weight around the link regions.
        ho_LinkRegion.Dispose();
        HOperatorSet.Threshold(ho_LinkMap, out ho_LinkRegion, 0.01, "max");
        ho_RegionDilation.Dispose();
        HOperatorSet.DilationCircle(ho_LinkRegion, out ho_RegionDilation, hv_LinkZeroWeightRadius);
        ho_RegionComplement.Dispose();
        HOperatorSet.Complement(ho_RegionDilation, out ho_RegionComplement);
        hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetImageSize(ho_TargetWeight, out hv_Width, out hv_Height);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ClipRegion(ho_RegionComplement, out ExpTmpOutVar_0, 0, 0, hv_Height-1, 
            hv_Width-1);
        ho_RegionComplement.Dispose();
        ho_RegionComplement = ExpTmpOutVar_0;
        }
        ho_RegionUnion.Dispose();
        HOperatorSet.Union2(ho_LinkRegion, ho_RegionComplement, out ho_RegionUnion
            );
        ho_RegionBorder.Dispose();
        HOperatorSet.Complement(ho_RegionUnion, out ho_RegionBorder);
        ho_TargetWeightLink.Dispose();
        HOperatorSet.PaintRegion(ho_RegionBorder, ho_TargetWeight, out ho_TargetWeightLink, 
            0, "fill");
      }
      else
      {
        //Just copy the original weight map.
        ho_TargetWeightLink.Dispose();
        HOperatorSet.CopyObj(ho_TargetWeight, out ho_TargetWeightLink, 1, 1);
      }
      ho_LinkRegion.Dispose();
      ho_RegionDilation.Dispose();
      ho_RegionComplement.Dispose();
      ho_RegionUnion.Dispose();
      ho_RegionBorder.Dispose();

      hv_Width.Dispose();
      hv_Height.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_LinkRegion.Dispose();
      ho_RegionDilation.Dispose();
      ho_RegionComplement.Dispose();
      ho_RegionUnion.Dispose();
      ho_RegionBorder.Dispose();

      hv_Width.Dispose();
      hv_Height.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate orientation score map weight for ocr detection training. 
  private void gen_dl_ocr_detection_weight_orientation_map (HObject ho_InitialWeight, 
      out HObject ho_OrientationTargetWeight, HTuple hv_DLSample)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_CharRegions=null, ho_CharRegion=null;
    HObject ho_BackgroundRegion=null;

    // Local control variables 

    HTuple hv_Indices = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_OrientationTargetWeight);
    HOperatorSet.GenEmptyObj(out ho_CharRegions);
    HOperatorSet.GenEmptyObj(out ho_CharRegion);
    HOperatorSet.GenEmptyObj(out ho_BackgroundRegion);
    try
    {
      //Inside the valid regions, the inital weight is set to the initial weight.
      ho_OrientationTargetWeight.Dispose();
      HOperatorSet.CopyImage(ho_InitialWeight, out ho_OrientationTargetWeight);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_OrientationTargetWeight, out ExpTmpOutVar_0);
      ho_OrientationTargetWeight.Dispose();
      ho_OrientationTargetWeight = ExpTmpOutVar_0;
      }
      //Set orientation weight to 0 outside the valid regions.
      if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Process char boxes
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1, 
            out hv_Indices);
        }
        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_CharRegions.Dispose();
          HOperatorSet.GenRectangle2(out ho_CharRegions, ((hv_DLSample.TupleGetDictTuple(
              "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_Indices));
          }
          ho_CharRegion.Dispose();
          HOperatorSet.Union1(ho_CharRegions, out ho_CharRegion);
          ho_BackgroundRegion.Dispose();
          HOperatorSet.Complement(ho_CharRegion, out ho_BackgroundRegion);
          HOperatorSet.OverpaintRegion(ho_OrientationTargetWeight, ho_BackgroundRegion, 
              0, "fill");
        }
      }
      //We need two channels: for Sin and Cos
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.Compose2(ho_OrientationTargetWeight, ho_OrientationTargetWeight, 
          out ExpTmpOutVar_0);
      ho_OrientationTargetWeight.Dispose();
      ho_OrientationTargetWeight = ExpTmpOutVar_0;
      }
      ho_CharRegions.Dispose();
      ho_CharRegion.Dispose();
      ho_BackgroundRegion.Dispose();

      hv_Indices.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_CharRegions.Dispose();
      ho_CharRegion.Dispose();
      ho_BackgroundRegion.Dispose();

      hv_Indices.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate text score map weight for ocr detection training. 
  private void gen_dl_ocr_detection_weight_score_map (out HObject ho_TargetWeightText, 
      HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_DLSample, HTuple hv_BoxCutoff, 
      HTuple hv_WSWeightRenderThreshold, HTuple hv_Confidence)
  {



    // Local iconic variables 

    HObject ho_IgnoreRegion=null, ho_WordRegion=null;
    HObject ho_WordRegionDilated=null;

    // Local control variables 

    HTuple hv_Indices = new HTuple(), hv_WordIndex = new HTuple();
    HTuple hv_SigmaL2 = new HTuple(), hv_WordLength2Ext = new HTuple();
    HTuple hv_DilationRadius = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_TargetWeightText);
    HOperatorSet.GenEmptyObj(out ho_IgnoreRegion);
    HOperatorSet.GenEmptyObj(out ho_WordRegion);
    HOperatorSet.GenEmptyObj(out ho_WordRegionDilated);
    try
    {
      ho_TargetWeightText.Dispose();
      HOperatorSet.GenImageConst(out ho_TargetWeightText, "real", hv_ImageWidth, 
          hv_ImageHeight);
      HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_TargetWeightText, 1.0, 
          "fill");
      if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Process ignore boxes
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 2, 
            out hv_Indices);
        }
        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_IgnoreRegion.Dispose();
          HOperatorSet.GenRectangle2(out ho_IgnoreRegion, ((hv_DLSample.TupleGetDictTuple(
              "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_Indices));
          }
          HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_IgnoreRegion, 0.0, 
              "fill");
        }
        for (hv_WordIndex=0; (int)hv_WordIndex<=(int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
            "bbox_label_id"))).TupleLength()))-1); hv_WordIndex = (int)hv_WordIndex + 1)
        {
          //For each word box
          if ((int)(new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
              hv_WordIndex))).TupleEqual(0))) != 0)
          {
            if ((int)((new HTuple((new HTuple(hv_BoxCutoff.TupleEqual(0))).TupleOr(
                new HTuple(hv_WSWeightRenderThreshold.TupleEqual(0))))).TupleNot()
                ) != 0)
            {
              hv_SigmaL2.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SigmaL2 = (((hv_DLSample.TupleGetDictTuple(
                  "bbox_length2"))).TupleSelect(hv_WordIndex))*(((-0.5/(hv_BoxCutoff.TupleLog()
                  ))).TupleSqrt());
              }
              hv_WordLength2Ext.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_WordLength2Ext = hv_SigmaL2*(((-2*(hv_WSWeightRenderThreshold.TupleLog()
                  ))).TupleSqrt());
              }
              hv_DilationRadius.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_DilationRadius = hv_WordLength2Ext-(((hv_DLSample.TupleGetDictTuple(
                  "bbox_length2"))).TupleSelect(hv_WordIndex));
              }
            }
            else
            {
              hv_DilationRadius.Dispose();
              hv_DilationRadius = 0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_WordRegion.Dispose();
            HOperatorSet.GenRectangle2(out ho_WordRegion, ((hv_DLSample.TupleGetDictTuple(
                "bbox_row"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                "bbox_col"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                "bbox_phi"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                "bbox_length1"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                "bbox_length2"))).TupleSelect(hv_WordIndex));
            }
            //Slightly enlarge the weight region to suppress halos at the box borders.
            if ((int)(new HTuple(hv_DilationRadius.TupleGreaterEqual(0.5))) != 0)
            {
              ho_WordRegionDilated.Dispose();
              HOperatorSet.DilationCircle(ho_WordRegion, out ho_WordRegionDilated, 
                  hv_DilationRadius);
            }
            else
            {
              ho_WordRegionDilated.Dispose();
              ho_WordRegionDilated = new HObject(ho_WordRegion);
            }
            //Set the confidence as weight for the word region.
            HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_WordRegionDilated, 
                hv_Confidence, "fill");
          }
        }
      }
      ho_IgnoreRegion.Dispose();
      ho_WordRegion.Dispose();
      ho_WordRegionDilated.Dispose();

      hv_Indices.Dispose();
      hv_WordIndex.Dispose();
      hv_SigmaL2.Dispose();
      hv_WordLength2Ext.Dispose();
      hv_DilationRadius.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_IgnoreRegion.Dispose();
      ho_WordRegion.Dispose();
      ho_WordRegionDilated.Dispose();

      hv_Indices.Dispose();
      hv_WordIndex.Dispose();
      hv_SigmaL2.Dispose();
      hv_WordLength2Ext.Dispose();
      hv_DilationRadius.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Store the given images in a tuple of dictionaries DLSamples. 
  public void gen_dl_samples_from_images (HObject ho_Images, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    HObject ho_Image=null;

    // Local control variables 

    HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_DLSample = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    hv_DLSampleBatch = new HTuple();
    try
    {
      //
      //This procedure creates DLSampleBatch, a tuple
      //containing a dictionary DLSample
      //for every image given in Images.
      //
      //Initialize output tuple.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images, out hv_NumImages);
      hv_DLSampleBatch.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSampleBatch = HTuple.TupleGenConst(
          hv_NumImages,-1);
      }
      //
      //Loop through all given images.
      HTuple end_val10 = hv_NumImages-1;
      HTuple step_val10 = 1;
      for (hv_ImageIndex=0; hv_ImageIndex.Continue(end_val10, step_val10); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val10))
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.SelectObj(ho_Images, out ho_Image, hv_ImageIndex+1);
        }
        //Create DLSample from image.
        hv_DLSample.Dispose();
        HOperatorSet.CreateDict(out hv_DLSample);
        HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
        //
        //Collect the DLSamples.
        if (hv_DLSampleBatch == null)
          hv_DLSampleBatch = new HTuple();
        hv_DLSampleBatch[hv_ImageIndex] = hv_DLSample;
      }
      ho_Image.Dispose();

      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_DLSample.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();

      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_DLSample.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Generate a word to characters mapping. 
  private void gen_words_chars_mapping (HTuple hv_DLSample, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordsCharsMapping)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WordsIndices = new HTuple(), hv_CharsIndices = new HTuple();
    HTuple hv_WordLengths = new HTuple(), hv_WordArea = new HTuple();
    HTuple hv_CharArea = new HTuple(), hv_CharAreaThreshold = new HTuple();
    HTuple hv_WordIndex = new HTuple(), hv_AreaIntersection = new HTuple();
    HTuple hv_CIsInsideW = new HTuple(), hv_CIndex = new HTuple();
    // Initialize local and output iconic variables 
    hvec_WordsCharsMapping = new HTupleVector(1);
    try
    {
      //Procedure to generate the mapping: gen_words_chars_mapping
      if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
          )).TupleGreater(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WordsIndices.Dispose();
        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 0, 
            out hv_WordsIndices);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CharsIndices.Dispose();
        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1, 
            out hv_CharsIndices);
        }
        if ((int)((new HTuple(hv_CharsIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_WordsIndices.TupleNotEqual(
            -1)))) != 0)
        {
          hv_WordLengths.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WordLengths = ((((hv_DLSample.TupleGetDictTuple(
              "word"))).TupleSelect(hv_WordsIndices))).TupleStrlen();
          }
          //Init vector.
          hvec_WordsCharsMapping[(new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
              ))-1] = new HTupleVector(new HTuple());
          hv_WordArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WordArea = (4*(((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_WordsIndices)))*(((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_WordsIndices));
          }
          hv_CharArea.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CharArea = (4*(((hv_DLSample.TupleGetDictTuple(
              "bbox_length1"))).TupleSelect(hv_CharsIndices)))*(((hv_DLSample.TupleGetDictTuple(
              "bbox_length2"))).TupleSelect(hv_CharsIndices));
          }
          //TODO: This threshold is quite arbitrary and not stable.
          hv_CharAreaThreshold.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CharAreaThreshold = hv_CharArea*0.8;
          }
          for (hv_WordIndex=0; (int)hv_WordIndex<=(int)((new HTuple(hv_WordsIndices.TupleLength()
              ))-1); hv_WordIndex = (int)hv_WordIndex + 1)
          {
            if ((int)(new HTuple(((hv_WordLengths.TupleSelect(hv_WordIndex))).TupleNotEqual(
                0))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_AreaIntersection.Dispose();
              HOperatorSet.AreaIntersectionRectangle2(((hv_DLSample.TupleGetDictTuple(
                  "bbox_row"))).TupleSelect(hv_WordsIndices.TupleSelect(hv_WordIndex)), 
                  ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(hv_WordsIndices.TupleSelect(
                  hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                  hv_WordsIndices.TupleSelect(hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple(
                  "bbox_length1"))).TupleSelect(hv_WordsIndices.TupleSelect(hv_WordIndex)), 
                  ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(hv_WordsIndices.TupleSelect(
                  hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple("bbox_row"))).TupleSelect(
                  hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(
                  hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                  hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_length1"))).TupleSelect(
                  hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(
                  hv_CharsIndices), out hv_AreaIntersection);
              }
              hv_CIsInsideW.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CIsInsideW = hv_AreaIntersection.TupleGreaterElem(
                  hv_CharAreaThreshold);
              }
              hv_CIndex.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_CIndex = hv_CIsInsideW.TupleFind(
                  1);
              }
              if ((int)(new HTuple(hv_CIndex.TupleNotEqual(-1))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hvec_WordsCharsMapping[hv_WordsIndices.TupleSelect(
                    hv_WordIndex)] = dh.Add(new HTupleVector(hv_CharsIndices.TupleSelect(
                    hv_CIndex)));
                }
              }
            }
            else
            {
              throw new HalconException(((("Sample with image id "+(hv_DLSample.TupleGetDictTuple(
                  "image_id")))+" is not valid. The word bounding box at index ")+hv_WordIndex)+" has an empty string as the ground truth. This is not allowed. Please assign a word label to every word bounding box.");
            }
          }
        }
      }

      hv_WordsIndices.Dispose();
      hv_CharsIndices.Dispose();
      hv_WordLengths.Dispose();
      hv_WordArea.Dispose();
      hv_CharArea.Dispose();
      hv_CharAreaThreshold.Dispose();
      hv_WordIndex.Dispose();
      hv_AreaIntersection.Dispose();
      hv_CIsInsideW.Dispose();
      hv_CIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WordsIndices.Dispose();
      hv_CharsIndices.Dispose();
      hv_WordLengths.Dispose();
      hv_WordArea.Dispose();
      hv_CharArea.Dispose();
      hv_CharAreaThreshold.Dispose();
      hv_WordIndex.Dispose();
      hv_AreaIntersection.Dispose();
      hv_CIsInsideW.Dispose();
      hv_CIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
  // Short Description: Get the ground truth anomaly label and label ID. 
  private void get_anomaly_ground_truth_label (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
  {


    // Initialize local and output iconic variables 
    hv_AnomalyLabelGroundTruth = new HTuple();
    hv_AnomalyLabelIDGroundTruth = new HTuple();
    //
    //This procedure returns the anomaly ground truth label.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_AnomalyLabelGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label cannot be found in DLSample.");
    }
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_AnomalyLabelIDGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label id cannot be found in DLSample.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
  // Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). 
  private void get_anomaly_result (out HObject ho_AnomalyImage, out HObject ho_AnomalyRegion, 
      HTuple hv_DLResult, HTuple hv_AnomalyClassThreshold, HTuple hv_AnomalyRegionThreshold, 
      HTuple hv_AnomalyResultPostfix, out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID, 
      out HTuple hv_AnomalyClassThresholdDisplay, out HTuple hv_AnomalyRegionThresholdDisplay)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_AnomalyImageKey = new HTuple(), hv_AnomalyScoreKey = new HTuple();
    HTuple hv_AnomalyRegionKey = new HTuple(), hv_AnomalyClassIdKey = new HTuple();
    HTuple hv_ErrorMsgPostfix = new HTuple(), hv_ResultKeys = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    hv_AnomalyScore = new HTuple();
    hv_AnomalyClassID = new HTuple();
    hv_AnomalyClassThresholdDisplay = new HTuple();
    hv_AnomalyRegionThresholdDisplay = new HTuple();
    try
    {
      //
      //This procedure returns the inference results in DLResult which are
      //the anomaly image and the anomaly score. It also returns the
      //classification of the anomaly score and segmentation of anomalous
      //pixels in the anomaly image by applying the specified thresholds if
      //given. Otherwise the results from DLResult are used.
      //
      //
      hv_AnomalyImageKey.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AnomalyImageKey = "anomaly_image"+hv_AnomalyResultPostfix;
      }
      hv_AnomalyScoreKey.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AnomalyScoreKey = "anomaly_score"+hv_AnomalyResultPostfix;
      }
      hv_AnomalyRegionKey.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AnomalyRegionKey = "anomaly_region"+hv_AnomalyResultPostfix;
      }
      hv_AnomalyClassIdKey.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_AnomalyClassIdKey = "anomaly_class_id"+hv_AnomalyResultPostfix;
      }
      //
      hv_ErrorMsgPostfix.Dispose();
      HOperatorSet.TupleRegexpReplace(hv_AnomalyResultPostfix, "_", " ", out hv_ErrorMsgPostfix);
      //
      hv_ResultKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
      if ((int)(new HTuple(hv_ResultKeys.TupleEqual(new HTuple()))) != 0)
      {
        throw new HalconException(("Result anomaly image"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
      }
      //
      if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyImageKey))).TupleNotEqual(
          -1))) != 0)
      {
        ho_AnomalyImage.Dispose();
        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, hv_AnomalyImageKey);
      }
      else
      {
        throw new HalconException(("Result anomaly image"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
      }
      //
      if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyScoreKey))).TupleNotEqual(
          -1))) != 0)
      {
        hv_AnomalyScore.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, hv_AnomalyScoreKey, out hv_AnomalyScore);
      }
      else
      {
        throw new HalconException(("Result anomaly score"+hv_ErrorMsgPostfix)+" could not be found in DLResult.");
      }
      //
      hv_AnomalyRegionThresholdDisplay.Dispose();
      hv_AnomalyRegionThresholdDisplay = -1;
      if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
      {
        //Apply threshold for segmentation result.
        if ((int)(new HTuple((new HTuple(hv_AnomalyRegionThreshold.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Selected 'anomaly_region_threshold' must be specified by exactly one value.");
        }
        ho_AnomalyRegion.Dispose();
        HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold, 
            "max");
        hv_AnomalyRegionThresholdDisplay.Dispose();
        hv_AnomalyRegionThresholdDisplay = new HTuple(hv_AnomalyRegionThreshold);
      }
      else
      {
        //If no threshold is given, use the threshold and resulting anomaly region out of DLResult.
        if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyRegionKey))).TupleNotEqual(
            -1))) != 0)
        {
          ho_AnomalyRegion.Dispose();
          HOperatorSet.GetDictObject(out ho_AnomalyRegion, hv_DLResult, hv_AnomalyRegionKey);
        }
        else
        {
          ho_AnomalyRegion.Dispose();
          HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
        }
        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_segmentation_threshold"))).TupleNotEqual(
            -1))) != 0)
        {
          hv_AnomalyRegionThresholdDisplay.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_segmentation_threshold", 
              out hv_AnomalyRegionThresholdDisplay);
        }
      }
      //
      hv_AnomalyClassThresholdDisplay.Dispose();
      hv_AnomalyClassThresholdDisplay = -1;
      hv_AnomalyClassID.Dispose();
      hv_AnomalyClassID = -1;
      if ((int)(new HTuple(hv_AnomalyClassThreshold.TupleNotEqual(-1))) != 0)
      {
        //Apply threshold for classification result.
        if ((int)(new HTuple((new HTuple(hv_AnomalyClassThreshold.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Selected 'anomaly_classification_threshold' must be specified by exactly one value.");
        }
        if ((int)(new HTuple(hv_AnomalyScore.TupleLess(hv_AnomalyClassThreshold))) != 0)
        {
          hv_AnomalyClassID.Dispose();
          hv_AnomalyClassID = 0;
        }
        else
        {
          hv_AnomalyClassID.Dispose();
          hv_AnomalyClassID = 1;
        }
        hv_AnomalyClassThresholdDisplay.Dispose();
        hv_AnomalyClassThresholdDisplay = new HTuple(hv_AnomalyClassThreshold);
      }
      else
      {
        //If no threshold is given, use the threshold and resulting class id out of DLResult.
        if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyClassIdKey))).TupleNotEqual(
            -1))) != 0)
        {
          hv_AnomalyClassID.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult, hv_AnomalyClassIdKey, out hv_AnomalyClassID);
        }
        else
        {
          hv_AnomalyClassID.Dispose();
          hv_AnomalyClassID = -1;
        }
        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_classification_threshold"))).TupleNotEqual(
            -1))) != 0)
        {
          hv_AnomalyClassThresholdDisplay.Dispose();
          HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_classification_threshold", 
              out hv_AnomalyClassThresholdDisplay);
        }
      }
      //

      hv_AnomalyImageKey.Dispose();
      hv_AnomalyScoreKey.Dispose();
      hv_AnomalyRegionKey.Dispose();
      hv_AnomalyClassIdKey.Dispose();
      hv_ErrorMsgPostfix.Dispose();
      hv_ResultKeys.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_AnomalyImageKey.Dispose();
      hv_AnomalyScoreKey.Dispose();
      hv_AnomalyRegionKey.Dispose();
      hv_AnomalyClassIdKey.Dispose();
      hv_ErrorMsgPostfix.Dispose();
      hv_ResultKeys.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Get the next child window that can be used for visualization. 
  private void get_child_window (HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatio = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure returns the next child window that
      //is used for visualization. If ReuseWindows is true
      //and WindowHandleList is suitable, the window handles
      //that are passed over are used. Else, this procedure
      //opens a new window, either next to the last ones, or
      //in a new row.
      //
      //First, check if the requested window is already available.
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 0;
      try
      {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
        hv_ParentWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
            0);
        }
        hv_ChildWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
            1);
        }
        //Check if window handle is valid.
        try
        {
          HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          //Since there is something wrong with the current window, create a new one.
          hv_OpenNewWindow.Dispose();
          hv_OpenNewWindow = 1;
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
      }
      //
      //Get next child window.
      if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
      {
        //
        //If possible, reuse existing window handles.
        HDevWindowStack.SetActive(hv_ChildWindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
        //
        hv_MetaInfo.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
        //
        //Get previous window coordinates.
        hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn, 
            out hv_WindowWidth, out hv_WindowHeight);
        hv_WindowImageRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
        }
        //
        try
        {
          //
          //Get WindowImageRatio from parent window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();
          HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
              out hv_WindowImageRatio);
          }
          //
          //Get previous window coordinates.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PrevWindowCoordinatesOut.Dispose();
          HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
              out hv_PrevWindowCoordinatesOut);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //
          //Set WindowImageRatio from parent window.
          hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
          HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, 
              out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
          hv_WindowImageRatio.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
          }
          //
          //Set previous window coordinates.
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
        }
      }
      else
      {
        //
        //Open a new child window.
        hv_ChildWindowHandle.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
            hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
        HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
            hv_ChildWindowHandle));
        }
      }
      //

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_ParentWindowHandle.Dispose();
      hv_ChildWindowHandle.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_ParentWindowHandle.Dispose();
      hv_ChildWindowHandle.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Get the ground truth classification label id. 
  private void get_classification_ground_truth (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      out HTuple hv_ClassificationLabelIDGroundTruth)
  {


    // Initialize local and output iconic variables 
    hv_ClassificationLabelIDGroundTruth = new HTuple();
    //
    //This procedure returns the classification ground truth label ID.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_ClassificationLabelIDGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label cannot be found in DLSample.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Get the predicted classification class ID. 
  private void get_classification_result (HTuple hv_ResultKeys, HTuple hv_DLResult, 
      out HTuple hv_ClassificationClassID)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_ClassificationClassID = new HTuple();
    //
    //This procedure returns the predicted classification class ID.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_ClassificationClassID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
      if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
          0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
            0);
        hv_ClassificationClassID.Dispose();
        hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
        }
        }
      }
    }
    else
    {
      throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
  // Short Description: Get the confidences of the segmentation result. 
  private void get_confidence_image (out HObject ho_ImageConfidence, HTuple hv_ResultKeys, 
      HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    //
    //This procedure returns confidences of the segmentation result.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
    }
    else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
    }
    else
    {
      throw new HalconException("Confidence image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generate NumColors distinct colors 
  private void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
      HTuple hv_EndColor, out HTuple hv_Colors)
  {



      // Local iconic variables 

      HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
      HObject ho_ImageR, ho_ImageG, ho_ImageB;

      // Local control variables 

      HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
      HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
      HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
      HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
      HTuple hv_Blue = new HTuple();
      HTuple   hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
      HTuple   hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_HLSImageH);
      HOperatorSet.GenEmptyObj(out ho_HLSImageL);
      HOperatorSet.GenEmptyObj(out ho_HLSImageS);
      HOperatorSet.GenEmptyObj(out ho_ImageR);
      HOperatorSet.GenEmptyObj(out ho_ImageG);
      HOperatorSet.GenEmptyObj(out ho_ImageB);
      hv_Colors = new HTuple();
      try
      {
      //
      //We get distinct color-values first in HLS color-space.
      //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
      //
      //Parameter checks.
      //NumColors.
      if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
      {
        throw new HalconException("NumColors should be at least 1");
      }
      if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("NumColors should be of type int");
      }
      if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("NumColors should have length 1");
      }
      //Random.
      if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
          1)))) != 0)
      {
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
              "true"))).TupleOr("false");
          hv_Random_COPY_INP_TMP.Dispose();
          hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
          }
          }
        }
        else
        {
          throw new HalconException("Random should be either true or false");
        }
      }
      //StartColor.
      if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("StartColor should have length 1");
      }
      if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("StartColor should be of type int");
      }
      //EndColor.
      if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("EndColor should have length 1");
      }
      if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("EndColor should be of type int");
      }
      //
      //Color generation.
      if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP+255;
        hv_EndColor_COPY_INP_TMP.Dispose();
        hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
        }
        }
      }
      if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = (hv_StartColor+(((((hv_EndColor_COPY_INP_TMP-hv_StartColor)*((HTuple.TupleGenSequence(
            0,hv_NumColors-1,1)).TupleReal()))/(((hv_NumColors-1)).TupleReal()))).TupleInt()
            ))%255;
        }
      }
      else
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = ((hv_StartColor.TupleConcat(
            hv_EndColor_COPY_INP_TMP))).TupleMean();
        }
      }
      if ((int)(hv_Random_COPY_INP_TMP) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
            (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
        hv_Hue.Dispose();
        hv_Hue = ExpTmpLocalVar_Hue;
        }
        }
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((((5.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((((9.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
      }
      else
      {
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((HTuple.TupleGenConst(
            hv_NumColors,0.55)*255.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((HTuple.TupleGenConst(
            hv_NumColors,0.95)*255.0)).TupleInt();
        }
      }
      //
      //Write colors to a 3-channel image in order to transform easier.
      ho_HLSImageH.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
      ho_HLSImageL.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
      ho_HLSImageS.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
      HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
      HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
      HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
      //
      //Convert from HLS to RGB.
      ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
      HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR, 
          out ho_ImageG, out ho_ImageB, "hls");
      //
      //Get RGB-values and transform to Hex.
      hv_Red.Dispose();
      HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
      hv_Green.Dispose();
      HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
      hv_Blue.Dispose();
      HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = (("#"+(hv_Red.TupleString(
          "02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
      }
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;
      //
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generate certain colors for different ClassNames 
  private void get_dl_class_colors (HTuple hv_ClassNames, HTuple hv_AdditionalGreenClassNames, 
      out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
    HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
    HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
    HTuple hv_GreenIdx = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure returns for each class a certain color.
      //
      //Define distinct colors for the classes.
      hv_NumColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
          );
      }
      //Get distinct colors without randomness makes neighboring colors look very similar.
      //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
      hv_ColorsRainbow.Dispose();
      get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
      hv_ColorsRainbow.Dispose();
      hv_ColorsRainbow = ExpTmpOutVar_0;
      }
      hv_Colors.Dispose();
      make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
      //If a class 'OK','ok', 'good' or 'GOOD' or a class specified in AdditionalGreenClassNames is present set this class to green.
      //Only the first occurrence found is set to a green shade.
      hv_ClassNamesGood.Dispose();
      HOperatorSet.TupleUnion((((new HTuple("good")).TupleConcat("GOOD")).TupleConcat(
          "ok")).TupleConcat("OK"), hv_AdditionalGreenClassNames, out hv_ClassNamesGood);
      for (hv_IndexFind=0; (int)hv_IndexFind<=(int)((new HTuple(hv_ClassNamesGood.TupleLength()
          ))-1); hv_IndexFind = (int)hv_IndexFind + 1)
      {
        hv_GoodIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
        }
        if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
            )).TupleLessEqual(8)))) != 0)
        {
          //If number of classes is <= 8, swap color with a green color.
          hv_CurrentColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentColor = hv_Colors.TupleSelect(
              hv_GoodIdx);
          }
          hv_GreenIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
              ))/2.0)).TupleFloor();
          }
          //Set to pure green.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GoodIdx] = "#00ff00";
          //Write original color to a green entry.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GreenIdx] = hv_CurrentColor;
          break;
        }
        else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
            new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
        {
          //If number of classes is larger than 8, set the respective color to green.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GoodIdx] = "#00ff00";
          break;
        }
      }

      hv_NumColors.Dispose();
      hv_ColorsRainbow.Dispose();
      hv_ClassNamesGood.Dispose();
      hv_IndexFind.Dispose();
      hv_GoodIdx.Dispose();
      hv_CurrentColor.Dispose();
      hv_GreenIdx.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumColors.Dispose();
      hv_ColorsRainbow.Dispose();
      hv_ClassNamesGood.Dispose();
      hv_IndexFind.Dispose();
      hv_GoodIdx.Dispose();
      hv_CurrentColor.Dispose();
      hv_GreenIdx.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Get an image of a sample with a certain key. 
  public void get_dl_sample_image (out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample, 
      HTuple hv_Key)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    //This procedure returns an image with key Key of a sample.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind(hv_Key))).TupleNotEqual(-1))) != 0)
    {
      ho_Image.Dispose();
      HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, hv_Key);
    }
    else
    {
      throw new HalconException(("Image with key '"+hv_Key)+"' could not be found in DLSample.");
    }


    return;
  }

  // Chapter: 3D Matching / 3D Gripping Point Detection
  // Short Description: Extract gripping points from a dictionary. 
  private void get_gripping_points_from_dict (HTuple hv_DLResult, out HTuple hv_Rows, 
      out HTuple hv_Columns)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_KeyExists = new HTuple(), hv_GrippingPoints = new HTuple();
    HTuple hv_NumberOfResults = new HTuple(), hv_IndexGrippingPointsPoint = new HTuple();
    HTuple hv_GrippingPointCoordDict = new HTuple();
    // Initialize local and output iconic variables 
    hv_Rows = new HTuple();
    hv_Columns = new HTuple();
    try
    {
      if ((int)(new HTuple(hv_DLResult.TupleEqual(new HTuple()))) != 0)
      {
        throw new HalconException("DLResult dict is empty.");
      }
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "gripping_points", out hv_KeyExists);
      if ((int)(hv_KeyExists) != 0)
      {
        hv_GrippingPoints.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "gripping_points", out hv_GrippingPoints);
      }
      else
      {
        throw new HalconException("Result data could not be found in DLResult.");
      }
      hv_NumberOfResults.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumberOfResults = new HTuple(hv_GrippingPoints.TupleLength()
          );
      }
      hv_Rows.Dispose();
      HOperatorSet.TupleGenConst(hv_NumberOfResults, 0, out hv_Rows);
      hv_Columns.Dispose();
      HOperatorSet.TupleGenConst(hv_NumberOfResults, 0, out hv_Columns);
      for (hv_IndexGrippingPointsPoint=0; (int)hv_IndexGrippingPointsPoint<=(int)((new HTuple(hv_GrippingPoints.TupleLength()
          ))-1); hv_IndexGrippingPointsPoint = (int)hv_IndexGrippingPointsPoint + 1)
      {
        hv_GrippingPointCoordDict.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GrippingPointCoordDict = hv_GrippingPoints.TupleSelect(
            hv_IndexGrippingPointsPoint);
        }
        if (hv_Rows == null)
          hv_Rows = new HTuple();
        hv_Rows[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple(
            "row");
        if (hv_Columns == null)
          hv_Columns = new HTuple();
        hv_Columns[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple(
            "column");
      }

      hv_KeyExists.Dispose();
      hv_GrippingPoints.Dispose();
      hv_NumberOfResults.Dispose();
      hv_IndexGrippingPointsPoint.Dispose();
      hv_GrippingPointCoordDict.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_KeyExists.Dispose();
      hv_GrippingPoints.Dispose();
      hv_NumberOfResults.Dispose();
      hv_IndexGrippingPointsPoint.Dispose();
      hv_GrippingPointCoordDict.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Get the next window that can be used for visualization. 
  private void get_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_NumLines = new HTuple();
    HTuple hv_MarginBottom = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
    HTuple hv_SetPartRow2 = new HTuple(), hv_SetPartColumn2 = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_CurrentWindowHandle = new HTuple();
    hv_WindowImageRatioHeight = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure returns the next window that
      //is used for visualization. If ReuseWindows is true
      //and WindowHandleList is suitable, the window handles
      //that are passed over are used. Else, this procedure
      //opens a new window, either next to the last ones, or
      //in a new row.
      //
      //First, check if the requested window is already available.
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 0;
      try
      {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
        hv_CurrentWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
            0);
        }
        //Check if window handle is valid.
        try
        {
          hv_Value.Dispose();
          HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          //If there is something wrong with the current window, create a new one.
          hv_OpenNewWindow.Dispose();
          hv_OpenNewWindow = 1;
          HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
      }
      //
      //Get next window.
      if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
      {
        //
        //If possible, reuse existing window handles.
        HDevWindowStack.SetActive(hv_CurrentWindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
        //
        //Calculate MarginBottom.
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
          HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent, 
              out hv_Descent, out hv__, out hv__);
          hv_NumLines.Dispose();
          hv_NumLines = new HTuple(hv_ShowBottomDesc);
          hv_MarginBottom.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MarginBottom = (hv_NumLines*(hv_Ascent+hv_Descent))+(2*12);
          }
        }
        else
        {
          hv_MarginBottom.Dispose();
          hv_MarginBottom = 0;
        }
        //
        //Get and set meta information for current window.
        hv_WindowImageRatioHeight.Dispose();hv_WindowImageRatioWidth.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage, 
            0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight, 
            out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2, 
            out hv_PrevWindowCoordinatesOut);
        //
        //Update meta information.
        hv_MetaInfo.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
            hv_WindowImageRatioHeight);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", 
            hv_WindowImageRatioWidth);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
            hv_SetPartRow2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
            hv_SetPartColumn2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", 
            hv_MarginBottom);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
            hv_MapColorBarWidth);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
            hv_PrevWindowCoordinatesOut);
        }
      }
      else
      {
        //
        //Open a new window.
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatioHeight.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
            hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, 
            hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle, 
            out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
        HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
      }
      //

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_Value.Dispose();
      hv_Exception.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_NumLines.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_Value.Dispose();
      hv_Exception.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_NumLines.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
  // Short Description: Get the ground truth segmentation image. 
  private void get_segmentation_image_ground_truth (out HObject ho_SegmentationImagGroundTruth, 
      HTuple hv_SampleKeys, HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    //
    //This procedure returns the ground truth segmentation image.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImagGroundTruth.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample, 
          "segmentation_image");
    }
    else
    {
      throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
  // Short Description: Get the predicted segmentation result image. 
  private void get_segmentation_image_result (out HObject ho_SegmentationImageResult, 
      HTuple hv_ResultKeys, HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    //
    //This procedure returns the predicted segmentation result image.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImageResult.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
    }
    else
    {
      throw new HalconException("Result segmentation data could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
  // Short Description: Get the weight image of a sample. 
  private void get_weight_image (out HObject ho_ImageWeight, HTuple hv_SampleKeys, 
      HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    //
    //This procedure returns the segmentation weight image of a sample.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageWeight.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
    }
    else
    {
      throw new HalconException("Weight image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Shuffle the input colors in a deterministic way 
  private void make_neighboring_colors_distinguishable (HTuple hv_ColorsRainbow, 
      out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
    HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
    HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
    HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
    HTuple hv_IdxsRight = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    try
    {
      //
      //Shuffle the input colors in a deterministic way
      //to make adjacent colors more distinguishable.
      //Neighboring colors from the input are distributed to every NumChunks
      //position in the output.
      //Depending on the number of colors, increase NumChunks.
      hv_NumColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
          );
      }
      if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
      {
        hv_NumChunks.Dispose();
        hv_NumChunks = 3;
        if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
        {
          hv_NumChunks.Dispose();
          hv_NumChunks = 6;
        }
        else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
        {
          hv_NumChunks.Dispose();
          hv_NumChunks = 4;
        }
        hv_Colors.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Colors = HTuple.TupleGenConst(
            hv_NumColors,-1);
        }
        //Check if the Number of Colors is dividable by NumChunks.
        hv_NumLeftOver.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumLeftOver = hv_NumColors%hv_NumChunks;
        }
        hv_ColorsPerChunk.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorsPerChunk = ((hv_NumColors/hv_NumChunks)).TupleInt()
            ;
        }
        hv_StartIdx.Dispose();
        hv_StartIdx = 0;
        HTuple end_val19 = hv_NumChunks-1;
        HTuple step_val19 = 1;
        for (hv_S=0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
        {
          hv_EndIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_EndIdx = (hv_StartIdx+hv_ColorsPerChunk)-1;
          }
          if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_EndIdx = hv_EndIdx+1;
            hv_EndIdx.Dispose();
            hv_EndIdx = ExpTmpLocalVar_EndIdx;
            }
            }
          }
          hv_IdxsLeft.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsLeft = HTuple.TupleGenSequence(
              hv_S,hv_NumColors-1,hv_NumChunks);
          }
          hv_IdxsRight.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsRight = HTuple.TupleGenSequence(
              hv_StartIdx,hv_EndIdx,1);
          }
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[HTuple.TupleGenSequence(hv_S,hv_NumColors-1,hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
              hv_StartIdx,hv_EndIdx);
          hv_StartIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_StartIdx = hv_EndIdx+1;
          }
        }
      }
      else
      {
        hv_Colors.Dispose();
        hv_Colors = new HTuple(hv_ColorsRainbow);
      }

      hv_NumColors.Dispose();
      hv_NumChunks.Dispose();
      hv_NumLeftOver.Dispose();
      hv_ColorsPerChunk.Dispose();
      hv_StartIdx.Dispose();
      hv_S.Dispose();
      hv_EndIdx.Dispose();
      hv_IdxsLeft.Dispose();
      hv_IdxsRight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumColors.Dispose();
      hv_NumChunks.Dispose();
      hv_NumLeftOver.Dispose();
      hv_ColorsPerChunk.Dispose();
      hv_StartIdx.Dispose();
      hv_S.Dispose();
      hv_EndIdx.Dispose();
      hv_IdxsLeft.Dispose();
      hv_IdxsRight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Open a window next to the given WindowHandleFather.  
  private void open_child_window (HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleChild = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure opens a window next to the given WindowHandleFather.
      //
      //Get the maximum width of the text to be displayed.
      //The width should be at least 200.
      hv_StringWidth.Dispose();
      hv_StringWidth = 150;
      for (hv_IndexText=0; (int)hv_IndexText<=(int)((new HTuple(hv_Text.TupleLength()
          ))-1); hv_IndexText = (int)hv_IndexText + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv__.Dispose();hv__.Dispose();hv_TextWidth.Dispose();hv__.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
            hv_TextWidth);
        hv_StringWidth.Dispose();
        hv_StringWidth = ExpTmpLocalVar_StringWidth;
        }
        }
      }
      //
      //Define window coordinates.
      hv_WindowRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
          0);
      }
      hv_WindowColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
          1))+(hv_PrevWindowCoordinates.TupleSelect(2)))+5;
      }
      hv_WindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowWidth = hv_StringWidth+(2*12.0);
      }
      hv_WindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
          3);
      }
      //
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_WindowRow,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandleChild);
      HDevWindowStack.Push(hv_WindowHandleChild);
      set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
      //
      //Return the coordinates of the new window.
      hv_PrevWindowCoordinatesOut.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowCoordinatesOut = new HTuple();
      hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
      }
      //
      //Set some meta information about the new child window handle.
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
          hv_PrevWindowCoordinatesOut);
      }
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      //

      hv_StringWidth.Dispose();
      hv_IndexText.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_StringWidth.Dispose();
      hv_IndexText.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Open a new window, either next to the last ones, or in a new row. 
  private void open_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
    HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_NumLines = new HTuple();
    HTuple hv_MarginBottom = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
    HTuple hv_SetPartRow2 = new HTuple(), hv_SetPartColumn2 = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleNew = new HTuple();
    hv_WindowImageRatioHeight = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure opens a new window, either next to
      //the last ones, or in a new row.
      //
      //Get coordinates of previous window.
      hv_PrevWindowRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
          0);
      }
      hv_PrevWindowColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
          1);
      }
      hv_PrevWindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
          2);
      }
      hv_PrevWindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
          3);
      }
      //
      if ((int)(new HTuple(((hv_PrevWindowColumn+hv_PrevWindowWidth)).TupleGreater(
          hv_ThresholdWidth))) != 0)
      {
        //Open window in new row.
        hv_WindowRow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowRow = (hv_PrevWindowRow+hv_PrevWindowHeight)+55;
        }
        hv_WindowColumn.Dispose();
        hv_WindowColumn = 0;
      }
      else
      {
        //Open window in same row.
        hv_WindowRow.Dispose();
        hv_WindowRow = new HTuple(hv_PrevWindowRow);
        hv_WindowColumn.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowColumn = hv_PrevWindowColumn+hv_PrevWindowWidth;
        }
        if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_WindowColumn = hv_WindowColumn+5;
          hv_WindowColumn.Dispose();
          hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
          }
          }
        }
      }
      //
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHandleNew.Dispose();
      dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage, 
          (new HTuple(500)).TupleConcat(800)*hv_ScaleWindows, (new HTuple(400)).TupleConcat(
          600)*hv_ScaleWindows, out hv_WindowHandleNew);
      }
      set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
      //
      //Add MarginBottom and MapColorBarWidth to window.
      if ((int)(hv_ShowBottomDesc) != 0)
      {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent, 
            out hv_Descent, out hv__, out hv__);
        hv_NumLines.Dispose();
        hv_NumLines = new HTuple(hv_ShowBottomDesc);
        hv_MarginBottom.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MarginBottom = (hv_NumLines*(hv_Ascent+hv_Descent))+(2*12);
        }
      }
      else
      {
        hv_MarginBottom.Dispose();
        hv_MarginBottom = 0;
      }
      hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth, 
          out hv_WindowHeight);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow, 
            hv_WindowColumn, hv_WindowWidth+hv_MapColorBarWidth, hv_WindowHeight+hv_MarginBottom);
        }
      }
      //
      //Get and set meta information of new window handle.
      hv_WindowImageRatioHeight.Dispose();hv_WindowImageRatioWidth.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
      update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage, 
          hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight, 
          out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2, 
          out hv_PrevWindowCoordinatesOut);
      //
      //Set window handle and some meta information about the new window handle.
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
          hv_WindowImageRatioHeight);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", 
          hv_WindowImageRatioWidth);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
          hv_SetPartRow2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
          hv_SetPartColumn2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", 
          hv_MarginBottom);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
          hv_MapColorBarWidth);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
          hv_PrevWindowCoordinatesOut);
      }
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      //

      hv_PrevWindowRow.Dispose();
      hv_PrevWindowColumn.Dispose();
      hv_PrevWindowWidth.Dispose();
      hv_PrevWindowHeight.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_NumLines.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_PrevWindowRow.Dispose();
      hv_PrevWindowColumn.Dispose();
      hv_PrevWindowWidth.Dispose();
      hv_PrevWindowHeight.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_NumLines.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess 3D data for deep-learning-based training and inference. 
  public void preprocess_dl_model_3d_data (HTuple hv_DLSample, HTuple hv_DLPreprocessParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageZ=null, ho_Domain, ho_Region=null;
    HObject ho_ImageReduced=null, ho_DomainComplement, ho_ImageX=null;
    HObject ho_ImageY=null, ho_ImageXYZ=null, ho_NXImage=null;
    HObject ho_NYImage=null, ho_NZImage=null, ho_MultiChannelImage;
    HObject ho___Tmp_Obj_0;

    // Local control variables 

    HTuple hv_HasNormals = new HTuple(), hv_XYZKeys = new HTuple();
    HTuple hv_HasXYZ = new HTuple(), hv_HasX = new HTuple();
    HTuple hv_HasY = new HTuple(), hv_HasZ = new HTuple();
    HTuple hv_HasFullXYZ = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_Type = new HTuple(), hv_Index = new HTuple();
    HTuple hv_Key = new HTuple(), hv_ZMinMaxExist = new HTuple();
    HTuple hv_GrayvalOutsideInit = new HTuple(), hv_NormalSizeExists = new HTuple();
    HTuple hv_NormalWidth = new HTuple(), hv_NormalHeight = new HTuple();
    HTuple hv_WidthZ = new HTuple(), hv_HeightZ = new HTuple();
    HTuple hv_ZoomNormals = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_ScaleWidth = new HTuple();
    HTuple hv_ScaleHeight = new HTuple(), hv_XIndex = new HTuple();
    HTuple hv_YIndex = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageZ);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_DomainComplement);
    HOperatorSet.GenEmptyObj(out ho_ImageX);
    HOperatorSet.GenEmptyObj(out ho_ImageY);
    HOperatorSet.GenEmptyObj(out ho_ImageXYZ);
    HOperatorSet.GenEmptyObj(out ho_NXImage);
    HOperatorSet.GenEmptyObj(out ho_NYImage);
    HOperatorSet.GenEmptyObj(out ho_NZImage);
    HOperatorSet.GenEmptyObj(out ho_MultiChannelImage);
    HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
    try
    {
      //
      //This procedure preprocesses 3D data of a DLSample.
      //
      //Check presence of inputs in DLSample.
      //
      hv_HasNormals.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "normals", out hv_HasNormals);
      hv_XYZKeys.Dispose();
      hv_XYZKeys = new HTuple();
      hv_XYZKeys[0] = "x";
      hv_XYZKeys[1] = "y";
      hv_XYZKeys[2] = "z";
      hv_HasXYZ.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", hv_XYZKeys, out hv_HasXYZ);
      hv_HasX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HasX = hv_HasXYZ.TupleSelect(
          0);
      }
      hv_HasY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HasY = hv_HasXYZ.TupleSelect(
          1);
      }
      hv_HasZ.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HasZ = hv_HasXYZ.TupleSelect(
          2);
      }
      hv_HasFullXYZ.Dispose();
      HOperatorSet.TupleMin(hv_HasXYZ, out hv_HasFullXYZ);
      if ((int)(hv_HasNormals.TupleNot()) != 0)
      {
        //XYZ are required because normals would need to be computed.
        if ((int)(hv_HasFullXYZ.TupleNot()) != 0)
        {
          throw new HalconException(new HTuple("The given input DLSample does not contain necessary images 'x','y' and 'z'. This is required if no normals are provided."));
        }
      }
      else
      {
        //At least Z is required if normals are given.
        if ((int)(hv_HasZ.TupleNot()) != 0)
        {
          throw new HalconException(new HTuple("The given input DLSample does not contain at least the depth image 'z'. This is required because normals are provided. Optionally, 'x' and 'y' images might be provided additionally."));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumChannels.Dispose();
        HOperatorSet.CountChannels(hv_DLSample.TupleGetDictObject("normals"), out hv_NumChannels);
        }
        if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
        {
          throw new HalconException("The given input DLSample.normals has to have three channels.");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Type.Dispose();
        HOperatorSet.GetImageType(hv_DLSample.TupleGetDictObject("normals"), out hv_Type);
        }
        if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
        {
          throw new HalconException("The given input DLSample.normals is not a real image.");
        }
      }
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_HasXYZ.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(hv_HasXYZ.TupleSelect(hv_Index)) != 0)
        {
          hv_Key.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Key = hv_XYZKeys.TupleSelect(
              hv_Index);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumChannels.Dispose();
          HOperatorSet.CountChannels(hv_DLSample.TupleGetDictObject(hv_Key), out hv_NumChannels);
          }
          if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(1))) != 0)
          {
            throw new HalconException(("The given input DLSample."+hv_Key)+" needs to have a single channel.");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Type.Dispose();
          HOperatorSet.GetImageType(hv_DLSample.TupleGetDictObject(hv_Key), out hv_Type);
          }
          if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
          {
            throw new HalconException(("The given input DLSample."+hv_Key)+" is not a real image.");
          }
        }
      }
      //
      ho_ImageZ.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageZ = hv_DLSample.TupleGetDictObject(
          "z");
      }
      ho_Domain.Dispose();
      HOperatorSet.GetDomain(ho_ImageZ, out ho_Domain);
      //Reduce Z domain to user-defined min/max values for Z.
      hv_ZMinMaxExist.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("min_z")).TupleConcat(
          "max_z"), out hv_ZMinMaxExist);
      if ((int)(hv_ZMinMaxExist.TupleSelect(0)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Region.Dispose();
        HOperatorSet.Threshold(ho_ImageZ, out ho_Region, "min", hv_DLPreprocessParam.TupleGetDictTuple(
            "min_z"));
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.Difference(ho_Domain, ho_Region, out ExpTmpOutVar_0);
        ho_Domain.Dispose();
        ho_Domain = ExpTmpOutVar_0;
        }
      }
      if ((int)(hv_ZMinMaxExist.TupleSelect(1)) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Region.Dispose();
        HOperatorSet.Threshold(ho_ImageZ, out ho_Region, hv_DLPreprocessParam.TupleGetDictTuple(
            "max_z"), "max");
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.Difference(ho_Domain, ho_Region, out ExpTmpOutVar_0);
        ho_Domain.Dispose();
        ho_Domain = ExpTmpOutVar_0;
        }
      }
      //Reduce domain because it might have changed
      if ((int)(hv_ZMinMaxExist.TupleMax()) != 0)
      {
        ho_ImageReduced.Dispose();
        HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ho_ImageReduced);
      }
      ho_DomainComplement.Dispose();
      HOperatorSet.Complement(ho_Domain, out ho_DomainComplement);
      //
      //Before we zoom any 3D images we want to set all pixels outside of the domain to
      //an invalid value.
      hv_GrayvalOutsideInit.Dispose();
      hv_GrayvalOutsideInit = 0;

      if ((int)(hv_HasFullXYZ) != 0)
      {
        ho_ImageX.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ImageX = hv_DLSample.TupleGetDictObject(
            "x");
        }
        ho_ImageY.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ImageY = hv_DLSample.TupleGetDictObject(
            "y");
        }
        ho_ImageZ.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ImageZ = hv_DLSample.TupleGetDictObject(
            "z");
        }

        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_ImageX, out ExpTmpOutVar_0);
        ho_ImageX.Dispose();
        ho_ImageX = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_ImageY, out ExpTmpOutVar_0);
        ho_ImageY.Dispose();
        ho_ImageY = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_ImageZ, out ExpTmpOutVar_0);
        ho_ImageZ.Dispose();
        ho_ImageZ = ExpTmpOutVar_0;
        }

        HOperatorSet.OverpaintRegion(ho_ImageX, ho_DomainComplement, hv_GrayvalOutsideInit, 
            "fill");
        HOperatorSet.OverpaintRegion(ho_ImageY, ho_DomainComplement, hv_GrayvalOutsideInit, 
            "fill");
        HOperatorSet.OverpaintRegion(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit, 
            "fill");

        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReduceDomain(ho_ImageX, ho_Domain, out ExpTmpOutVar_0);
        ho_ImageX.Dispose();
        ho_ImageX = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReduceDomain(ho_ImageY, ho_Domain, out ExpTmpOutVar_0);
        ho_ImageY.Dispose();
        ho_ImageY = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ExpTmpOutVar_0);
        ho_ImageZ.Dispose();
        ho_ImageZ = ExpTmpOutVar_0;
        }

        if ((int)(hv_HasNormals.TupleNot()) != 0)
        {
          //Get optional user-defined resolution of normal computation.
          hv_NormalSizeExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("normal_image_width")).TupleConcat(
              "normal_image_height"), out hv_NormalSizeExists);
          if ((int)(((hv_NormalSizeExists.TupleSelect(0))).TupleNot()) != 0)
          {
            hv_NormalWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NormalWidth = (((hv_DLPreprocessParam.TupleGetDictTuple(
                "image_width"))*1.5)).TupleInt();
            }
          }
          else
          {
            hv_NormalWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NormalWidth = hv_DLPreprocessParam.TupleGetDictTuple(
                "normal_image_width");
            }
          }
          if ((int)(((hv_NormalSizeExists.TupleSelect(1))).TupleNot()) != 0)
          {
            hv_NormalHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NormalHeight = (((hv_DLPreprocessParam.TupleGetDictTuple(
                "image_height"))*1.5)).TupleInt();
            }
          }
          else
          {
            hv_NormalHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NormalHeight = hv_DLPreprocessParam.TupleGetDictTuple(
                "normal_image_height");
            }
          }

          hv_WidthZ.Dispose();hv_HeightZ.Dispose();
          HOperatorSet.GetImageSize(ho_ImageZ, out hv_WidthZ, out hv_HeightZ);
          hv_ZoomNormals.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ZoomNormals = (new HTuple(hv_NormalWidth.TupleNotEqual(
              hv_WidthZ))).TupleOr(new HTuple(hv_NormalHeight.TupleNotEqual(hv_HeightZ)));
          }

          if ((int)(hv_ZoomNormals) != 0)
          {
            ho_ImageXYZ.Dispose();
            HOperatorSet.Compose3(ho_ImageX, ho_ImageY, ho_ImageZ, out ho_ImageXYZ
                );
            hv_Width.Dispose();hv_Height.Dispose();
            HOperatorSet.GetImageSize(ho_ImageXYZ, out hv_Width, out hv_Height);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ZoomImageSize(ho_ImageXYZ, out ExpTmpOutVar_0, hv_NormalWidth, 
                hv_NormalHeight, "nearest_neighbor");
            ho_ImageXYZ.Dispose();
            ho_ImageXYZ = ExpTmpOutVar_0;
            }
            ho_ImageX.Dispose();
            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageX, 1);
            ho_ImageY.Dispose();
            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageY, 2);
            ho_ImageZ.Dispose();
            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageZ, 3);
            hv_ScaleWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ScaleWidth = hv_NormalWidth/(hv_Width.TupleReal()
                );
            }
            hv_ScaleHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ScaleHeight = hv_NormalHeight/(hv_Height.TupleReal()
                );
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ZoomRegion(ho_Domain, out ExpTmpOutVar_0, hv_ScaleWidth, 
                hv_ScaleHeight);
            ho_Domain.Dispose();
            ho_Domain = ExpTmpOutVar_0;
            }
            {
            HObject ExpTmpOutVar_0;
            remove_invalid_3d_pixels(ho_ImageX, ho_ImageY, ho_ImageZ, ho_Domain, 
                out ExpTmpOutVar_0, hv_GrayvalOutsideInit);
            ho_Domain.Dispose();
            ho_Domain = ExpTmpOutVar_0;
            }
            ho_DomainComplement.Dispose();
            HOperatorSet.Complement(ho_Domain, out ho_DomainComplement);
          }

          ho_NXImage.Dispose();ho_NYImage.Dispose();ho_NZImage.Dispose();
          compute_normals_xyz(ho_ImageX, ho_ImageY, ho_ImageZ, out ho_NXImage, out ho_NYImage, 
              out ho_NZImage, 1);
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_NXImage.Dispose();
          HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NXImage, 
              1);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_NYImage.Dispose();
          HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NYImage, 
              2);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_NZImage.Dispose();
          HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NZImage, 
              3);
          }
        }
      }
      else
      {
        ho_ImageX.Dispose();
        HOperatorSet.GenEmptyObj(out ho_ImageX);
        ho_ImageY.Dispose();
        HOperatorSet.GenEmptyObj(out ho_ImageY);

        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_NXImage.Dispose();
        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NXImage, 
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_NYImage.Dispose();
        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NYImage, 
            2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_NZImage.Dispose();
        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NZImage, 
            3);
        }
      }

      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_ImageZ, out ExpTmpOutVar_0);
      ho_ImageZ.Dispose();
      ho_ImageZ = ExpTmpOutVar_0;
      }

      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_NXImage, out ExpTmpOutVar_0);
      ho_NXImage.Dispose();
      ho_NXImage = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_NYImage, out ExpTmpOutVar_0);
      ho_NYImage.Dispose();
      ho_NYImage = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.FullDomain(ho_NZImage, out ExpTmpOutVar_0);
      ho_NZImage.Dispose();
      ho_NZImage = ExpTmpOutVar_0;
      }

      //full_domain does not change the pixels outside of the existing domain.
      //Hence we have to set a specific value
      HOperatorSet.OverpaintRegion(ho_NXImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
          "fill");
      HOperatorSet.OverpaintRegion(ho_NYImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
          "fill");
      HOperatorSet.OverpaintRegion(ho_NZImage, ho_DomainComplement, hv_GrayvalOutsideInit, 
          "fill");
      HOperatorSet.OverpaintRegion(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit, 
          "fill");

      ho_MultiChannelImage.Dispose();
      HOperatorSet.Compose4(ho_NXImage, ho_NYImage, ho_NZImage, ho_ImageZ, out ho_MultiChannelImage
          );

      hv_HasX.Dispose();
      HOperatorSet.CountObj(ho_ImageX, out hv_HasX);
      if ((int)(hv_HasX) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_ImageX, out ExpTmpOutVar_0);
        ho_ImageX.Dispose();
        ho_ImageX = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.AppendChannel(ho_MultiChannelImage, ho_ImageX, out ExpTmpOutVar_0
            );
        ho_MultiChannelImage.Dispose();
        ho_MultiChannelImage = ExpTmpOutVar_0;
        }
        hv_XIndex.Dispose();
        HOperatorSet.CountChannels(ho_MultiChannelImage, out hv_XIndex);
      }
      hv_HasY.Dispose();
      HOperatorSet.CountObj(ho_ImageY, out hv_HasY);
      if ((int)(hv_HasY) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_ImageY, out ExpTmpOutVar_0);
        ho_ImageY.Dispose();
        ho_ImageY = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.AppendChannel(ho_MultiChannelImage, ho_ImageY, out ExpTmpOutVar_0
            );
        ho_MultiChannelImage.Dispose();
        ho_MultiChannelImage = ExpTmpOutVar_0;
        }
        hv_YIndex.Dispose();
        HOperatorSet.CountChannels(ho_MultiChannelImage, out hv_YIndex);
      }
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_MultiChannelImage, out hv_Width, out hv_Height);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_MultiChannelImage, out ExpTmpOutVar_0, hv_DLPreprocessParam.TupleGetDictTuple(
          "image_width"), hv_DLPreprocessParam.TupleGetDictTuple("image_height"), 
          "nearest_neighbor");
      ho_MultiChannelImage.Dispose();
      ho_MultiChannelImage = ExpTmpOutVar_0;
      }

      ho_NXImage.Dispose();ho_NYImage.Dispose();ho_NZImage.Dispose();ho_ImageZ.Dispose();
      HOperatorSet.Decompose4(ho_MultiChannelImage, out ho_NXImage, out ho_NYImage, 
          out ho_NZImage, out ho_ImageZ);
      if ((int)(hv_HasX) != 0)
      {
        ho_ImageX.Dispose();
        HOperatorSet.AccessChannel(ho_MultiChannelImage, out ho_ImageX, hv_XIndex);
      }
      if ((int)(hv_HasY) != 0)
      {
        ho_ImageY.Dispose();
        HOperatorSet.AccessChannel(ho_MultiChannelImage, out ho_ImageY, hv_YIndex);
      }


      //Zoom the domain
      hv_ScaleWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleWidth = (hv_DLPreprocessParam.TupleGetDictTuple(
          "image_width"))/(hv_Width.TupleReal());
      }
      hv_ScaleHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ScaleHeight = (hv_DLPreprocessParam.TupleGetDictTuple(
          "image_height"))/(hv_Height.TupleReal());
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomRegion(ho_Domain, out ExpTmpOutVar_0, hv_ScaleWidth, hv_ScaleHeight);
      ho_Domain.Dispose();
      ho_Domain = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      remove_invalid_3d_pixels(ho_NXImage, ho_NYImage, ho_NZImage, ho_Domain, out ExpTmpOutVar_0, 
          hv_GrayvalOutsideInit);
      ho_Domain.Dispose();
      ho_Domain = ExpTmpOutVar_0;
      }

      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageX, ho_Domain, out ExpTmpOutVar_0);
      ho_ImageX.Dispose();
      ho_ImageX = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageY, ho_Domain, out ExpTmpOutVar_0);
      ho_ImageY.Dispose();
      ho_ImageY = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ExpTmpOutVar_0);
      ho_ImageZ.Dispose();
      ho_ImageZ = ExpTmpOutVar_0;
      }
      ho___Tmp_Obj_0.Dispose();
      HOperatorSet.Compose3(ho_NXImage, ho_NYImage, ho_NZImage, out ho___Tmp_Obj_0
          );
      HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, "normals");
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho___Tmp_Obj_0.Dispose();
      HOperatorSet.ReduceDomain(hv_DLSample.TupleGetDictObject("normals"), ho_Domain, 
          out ho___Tmp_Obj_0);
      }
      HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, "normals");

      //Overwrite preprocessed 3D data
      if ((int)(hv_HasX) != 0)
      {
        HOperatorSet.SetDictObject(ho_ImageX, hv_DLSample, "x");
      }
      if ((int)(hv_HasY) != 0)
      {
        HOperatorSet.SetDictObject(ho_ImageY, hv_DLSample, "y");
      }
      if ((int)(hv_HasZ) != 0)
      {
        HOperatorSet.SetDictObject(ho_ImageZ, hv_DLSample, "z");
      }

      ho_ImageZ.Dispose();
      ho_Domain.Dispose();
      ho_Region.Dispose();
      ho_ImageReduced.Dispose();
      ho_DomainComplement.Dispose();
      ho_ImageX.Dispose();
      ho_ImageY.Dispose();
      ho_ImageXYZ.Dispose();
      ho_NXImage.Dispose();
      ho_NYImage.Dispose();
      ho_NZImage.Dispose();
      ho_MultiChannelImage.Dispose();
      ho___Tmp_Obj_0.Dispose();

      hv_HasNormals.Dispose();
      hv_XYZKeys.Dispose();
      hv_HasXYZ.Dispose();
      hv_HasX.Dispose();
      hv_HasY.Dispose();
      hv_HasZ.Dispose();
      hv_HasFullXYZ.Dispose();
      hv_NumChannels.Dispose();
      hv_Type.Dispose();
      hv_Index.Dispose();
      hv_Key.Dispose();
      hv_ZMinMaxExist.Dispose();
      hv_GrayvalOutsideInit.Dispose();
      hv_NormalSizeExists.Dispose();
      hv_NormalWidth.Dispose();
      hv_NormalHeight.Dispose();
      hv_WidthZ.Dispose();
      hv_HeightZ.Dispose();
      hv_ZoomNormals.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_ScaleWidth.Dispose();
      hv_ScaleHeight.Dispose();
      hv_XIndex.Dispose();
      hv_YIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageZ.Dispose();
      ho_Domain.Dispose();
      ho_Region.Dispose();
      ho_ImageReduced.Dispose();
      ho_DomainComplement.Dispose();
      ho_ImageX.Dispose();
      ho_ImageY.Dispose();
      ho_ImageXYZ.Dispose();
      ho_NXImage.Dispose();
      ho_NYImage.Dispose();
      ho_NZImage.Dispose();
      ho_MultiChannelImage.Dispose();
      ho___Tmp_Obj_0.Dispose();

      hv_HasNormals.Dispose();
      hv_XYZKeys.Dispose();
      hv_HasXYZ.Dispose();
      hv_HasX.Dispose();
      hv_HasY.Dispose();
      hv_HasZ.Dispose();
      hv_HasFullXYZ.Dispose();
      hv_NumChannels.Dispose();
      hv_Type.Dispose();
      hv_Index.Dispose();
      hv_Key.Dispose();
      hv_ZMinMaxExist.Dispose();
      hv_GrayvalOutsideInit.Dispose();
      hv_NormalSizeExists.Dispose();
      hv_NormalWidth.Dispose();
      hv_NormalHeight.Dispose();
      hv_WidthZ.Dispose();
      hv_HeightZ.Dispose();
      hv_ZoomNormals.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_ScaleWidth.Dispose();
      hv_ScaleHeight.Dispose();
      hv_XIndex.Dispose();
      hv_YIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess anomaly images for evaluation and visualization of deep-learning-based anomaly detection or Global Context Anomaly Detection. 
  public void preprocess_dl_model_anomaly (HObject ho_AnomalyImages, out HObject ho_AnomalyImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    // Local copy input parameter variables 
    HObject ho_AnomalyImages_COPY_INP_TMP;
    ho_AnomalyImages_COPY_INP_TMP = new HObject(ho_AnomalyImages);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_Min = new HTuple();
    HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_ImageWidthInput = new HTuple(), hv_ImageHeightInput = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_NumMatches = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_EqualByte = new HTuple();
    HTuple hv_NumChannelsAllImages = new HTuple(), hv_ImageNumChannelsTuple = new HTuple();
    HTuple hv_IndicesWrongChannels = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImagesPreprocessed);
    try
    {
      //
      //This procedure preprocesses the anomaly images given by AnomalyImages
      //according to the parameters in the dictionary DLPreprocessParam.
      //Note that depending on the images,
      //additional preprocessing steps might be beneficial.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      hv_ImageNumChannels.Dispose();
      hv_ImageNumChannels = 1;
      //
      //Preprocess the images.
      //
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.CropDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
          new HTuple(hv_ModelType.TupleEqual("anomaly_detection")))) != 0)
      {
        //The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection'
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
      HOperatorSet.MinMaxGray(ho_AnomalyImages_COPY_INP_TMP, ho_AnomalyImages_COPY_INP_TMP, 
          0, out hv_Min, out hv_Max, out hv_Range);
      if ((int)(new HTuple(hv_Min.TupleLess(0.0))) != 0)
      {
        throw new HalconException("Values of anomaly image must not be smaller than 0.0.");
      }
      //
      //Zoom images only if they have a different size than the specified size.
      hv_ImageWidthInput.Dispose();hv_ImageHeightInput.Dispose();
      HOperatorSet.GetImageSize(ho_AnomalyImages_COPY_INP_TMP, out hv_ImageWidthInput, 
          out hv_ImageHeightInput);
      hv_EqualWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
          hv_ImageWidthInput);
      }
      hv_EqualHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
          hv_ImageHeightInput);
      }
      if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
          new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the type of the input images.
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_AnomalyImages_COPY_INP_TMP, out hv_Type);
      hv_NumMatches.Dispose();
      HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
      if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
      {
        throw new HalconException("Please provide only images of type 'byte' or 'real'.");
      }
      //
      //If the type is 'byte', convert it to 'real' and scale it.
      //The gray value scaling does not work on 'byte' images.
      //For 'real' images it is assumed that the range is already correct.
      hv_EqualByte.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualByte = hv_Type.TupleEqualElem(
          "byte");
      }
      if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
      {
        if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
        {
          throw new HalconException("Passing mixed type images is not supported.");
        }
        //Convert the image type from 'byte' to 'real',
        //because the model expects 'real' images.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the number of channels.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
      //Check all images for number of channels.
      hv_NumChannelsAllImages.Dispose();
      HOperatorSet.CountChannels(ho_AnomalyImages_COPY_INP_TMP, out hv_NumChannelsAllImages);
      hv_ImageNumChannelsTuple.Dispose();
      HOperatorSet.TupleGenConst(hv_NumImages, hv_ImageNumChannels, out hv_ImageNumChannelsTuple);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesWrongChannels.Dispose();
      HOperatorSet.TupleFind(hv_NumChannelsAllImages.TupleNotEqualElem(hv_ImageNumChannelsTuple), 
          1, out hv_IndicesWrongChannels);
      }
      //
      //Check for anomaly image channels.
      //Only single channel images are accepted.
      if ((int)(new HTuple(hv_IndicesWrongChannels.TupleNotEqual(-1))) != 0)
      {
        throw new HalconException("Number of channels in anomaly image is not supported. Please check for anomaly images with a number of channels different from 1.");
      }
      //
      //Write preprocessed image to output variable.
      ho_AnomalyImagesPreprocessed.Dispose();
      ho_AnomalyImagesPreprocessed = new HObject(ho_AnomalyImages_COPY_INP_TMP);
      //
      ho_AnomalyImages_COPY_INP_TMP.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_ModelType.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_EqualByte.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_AnomalyImages_COPY_INP_TMP.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_ModelType.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_EqualByte.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess the provided DLSample image for augmentation purposes. 
  public void preprocess_dl_model_augmentation_data (HTuple hv_DLSample, HTuple hv_DLPreprocessParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_InputImage=null, ho_ImageHighRes=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_AugmentationKeyExists = new HTuple(), hv_ImageKeyExists = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ImageType = new HTuple(), hv_InputImageWidth = new HTuple();
    HTuple hv_InputImageHeight = new HTuple(), hv_InputImageWidthHeightRatio = new HTuple();
    HTuple hv_ZoomHeight = new HTuple(), hv_ZoomWidth = new HTuple();
    HTuple hv_HasPadding = new HTuple(), hv_ZoomFactorWidth = new HTuple();
    HTuple hv_ZoomFactorHeight = new HTuple(), hv_UseZoomImage = new HTuple();
    HTuple hv_DLSampleHighRes = new HTuple(), hv_DLPreprocessParamHighRes = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
    HTuple hv___Tmp_Ctrl_Dict_Init_2 = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_InputImage);
    HOperatorSet.GenEmptyObj(out ho_ImageHighRes);
    try
    {
      //This procedure preprocesses the provided DLSample image for augmentation purposes.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the required preprocessing parameters.
      hv_ImageWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageWidth = hv_DLPreprocessParam.TupleGetDictTuple(
          "image_width");
      }
      hv_ImageHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageHeight = hv_DLPreprocessParam.TupleGetDictTuple(
          "image_height");
      }
      hv_ImageNumChannels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageNumChannels = hv_DLPreprocessParam.TupleGetDictTuple(
          "image_num_channels");
      }
      hv_ModelType.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ModelType = hv_DLPreprocessParam.TupleGetDictTuple(
          "model_type");
      }
      //
      //Determine whether the preprocessing is required or not.
      hv_AugmentationKeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "augmentation", 
          out hv_AugmentationKeyExists);
      if ((int)(hv_AugmentationKeyExists.TupleNot()) != 0)
      {
        ho_InputImage.Dispose();
        ho_ImageHighRes.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageNumChannels.Dispose();
        hv_ModelType.Dispose();
        hv_AugmentationKeyExists.Dispose();
        hv_ImageKeyExists.Dispose();
        hv_NumImages.Dispose();
        hv_NumChannels.Dispose();
        hv_ImageType.Dispose();
        hv_InputImageWidth.Dispose();
        hv_InputImageHeight.Dispose();
        hv_InputImageWidthHeightRatio.Dispose();
        hv_ZoomHeight.Dispose();
        hv_ZoomWidth.Dispose();
        hv_HasPadding.Dispose();
        hv_ZoomFactorWidth.Dispose();
        hv_ZoomFactorHeight.Dispose();
        hv_UseZoomImage.Dispose();
        hv_DLSampleHighRes.Dispose();
        hv_DLPreprocessParamHighRes.Dispose();
        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
        hv___Tmp_Ctrl_Dict_Init_2.Dispose();

        return;
      }
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
      HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "true");
      if ((int)(((((hv_DLPreprocessParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
          "augmentation","comp"))).TupleNot()) != 0)
      {
        ho_InputImage.Dispose();
        ho_ImageHighRes.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageNumChannels.Dispose();
        hv_ModelType.Dispose();
        hv_AugmentationKeyExists.Dispose();
        hv_ImageKeyExists.Dispose();
        hv_NumImages.Dispose();
        hv_NumChannels.Dispose();
        hv_ImageType.Dispose();
        hv_InputImageWidth.Dispose();
        hv_InputImageHeight.Dispose();
        hv_InputImageWidthHeightRatio.Dispose();
        hv_ZoomHeight.Dispose();
        hv_ZoomWidth.Dispose();
        hv_HasPadding.Dispose();
        hv_ZoomFactorWidth.Dispose();
        hv_ZoomFactorHeight.Dispose();
        hv_UseZoomImage.Dispose();
        hv_DLSampleHighRes.Dispose();
        hv_DLPreprocessParamHighRes.Dispose();
        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
        hv___Tmp_Ctrl_Dict_Init_2.Dispose();

        return;
      }
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
          "HNULL");
      }
      if ((int)((new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))).TupleAnd(
          new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition")))) != 0)
      {
        ho_InputImage.Dispose();
        ho_ImageHighRes.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageNumChannels.Dispose();
        hv_ModelType.Dispose();
        hv_AugmentationKeyExists.Dispose();
        hv_ImageKeyExists.Dispose();
        hv_NumImages.Dispose();
        hv_NumChannels.Dispose();
        hv_ImageType.Dispose();
        hv_InputImageWidth.Dispose();
        hv_InputImageHeight.Dispose();
        hv_InputImageWidthHeightRatio.Dispose();
        hv_ZoomHeight.Dispose();
        hv_ZoomWidth.Dispose();
        hv_HasPadding.Dispose();
        hv_ZoomFactorWidth.Dispose();
        hv_ZoomFactorHeight.Dispose();
        hv_UseZoomImage.Dispose();
        hv_DLSampleHighRes.Dispose();
        hv_DLPreprocessParamHighRes.Dispose();
        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
        hv___Tmp_Ctrl_Dict_Init_2.Dispose();

        return;
      }
      //
      //Get the input image and its properties.
      hv_ImageKeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image", out hv_ImageKeyExists);
      if ((int)(hv_ImageKeyExists.TupleNot()) != 0)
      {
        throw new HalconException("The sample to process needs to include an image.");
      }
      ho_InputImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_InputImage = hv_DLSample.TupleGetDictObject(
          "image");
      }
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_InputImage, out hv_NumImages);
      if ((int)(new HTuple(hv_NumImages.TupleNotEqual(1))) != 0)
      {
        throw new HalconException("The sample to process needs to include exactly 1 image.");
      }
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_InputImage, out hv_NumChannels);
      hv_ImageType.Dispose();
      HOperatorSet.GetImageType(ho_InputImage, out hv_ImageType);
      hv_InputImageWidth.Dispose();hv_InputImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_InputImage, out hv_InputImageWidth, out hv_InputImageHeight);
      //
      //Execute model specific preprocessing.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
      {
        if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(1))) != 0)
        {
          throw new HalconException("The only 'image_num_channels' value supported for ocr_recognition models is 1.");
        }
        if ((int)(new HTuple((new HTuple(hv_ImageType.TupleRegexpTest("byte|real"))).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Please provide only images of type 'byte' or 'real' for ocr_recognition models.");
        }
        if ((int)(new HTuple((new HTuple((new HTuple(((hv_NumChannels.TupleEqualElem(
            1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Please provide only 1- or 3-channels images for ocr_recognition models.");
        }
        //
        ho_ImageHighRes.Dispose();
        HOperatorSet.FullDomain(ho_InputImage, out ho_ImageHighRes);
        if ((int)(new HTuple(hv_NumChannels.TupleEqual(3))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.Rgb1ToGray(ho_ImageHighRes, out ExpTmpOutVar_0);
          ho_ImageHighRes.Dispose();
          ho_ImageHighRes = ExpTmpOutVar_0;
          }
        }
        hv_InputImageWidthHeightRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageWidthHeightRatio = hv_InputImageWidth/(hv_InputImageHeight.TupleReal()
            );
        }
        hv_ZoomHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomHeight = hv_InputImageHeight.TupleMin2(
            2*hv_ImageHeight);
        }
        hv_ZoomWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomWidth = ((hv_ZoomHeight*hv_InputImageWidthHeightRatio)).TupleInt()
            ;
        }
        hv_HasPadding.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HasPadding = new HTuple(((((hv_ImageHeight*hv_InputImageWidthHeightRatio)).TupleInt()
            )).TupleLess(hv_ImageWidth));
        }
        if ((int)((new HTuple(hv_ZoomHeight.TupleGreater(hv_ImageHeight))).TupleOr(
            hv_HasPadding)) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ZoomImageSize(ho_ImageHighRes, out ExpTmpOutVar_0, hv_ZoomWidth, 
              hv_ZoomHeight, "constant");
          ho_ImageHighRes.Dispose();
          ho_ImageHighRes = ExpTmpOutVar_0;
          }
          hv___Tmp_Ctrl_Dict_Init_1.Dispose();
          HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
          HOperatorSet.SetDictTuple(hv_DLSample, "augmentation_data", hv___Tmp_Ctrl_Dict_Init_1);
          hv___Tmp_Ctrl_Dict_Init_1.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
              "HNULL");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(ho_ImageHighRes, hv_DLSample.TupleGetDictTuple(
              "augmentation_data"), "image_high_res");
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"), 
              "preprocess_params", hv_DLPreprocessParam);
          }
        }
      }
      else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
      {
        if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(3))) != 0)
        {
          throw new HalconException("The only 'image_num_channels' value supported for ocr_detection models is 3.");
        }
        if ((int)(new HTuple((new HTuple(hv_ImageType.TupleRegexpTest("byte|real"))).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Please provide only images of type 'byte' or 'real' for ocr_detection models.");
        }
        if ((int)(new HTuple((new HTuple((new HTuple(((hv_NumChannels.TupleEqualElem(
            1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Please provide only 1- or 3-channels images for ocr_detection models.");
        }
        //
        //Calculate aspect-ratio preserving zoom dimensions for high resolution.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomFactorWidth.Dispose();hv_ZoomFactorHeight.Dispose();
        calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight, 
            2*hv_ImageWidth, 2*hv_ImageHeight, hv_DLPreprocessParam, out hv_ZoomFactorWidth, 
            out hv_ZoomFactorHeight);
        }
        hv_ZoomHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomHeight = ((hv_ZoomFactorHeight*hv_InputImageHeight)).TupleRound()
            ;
        }
        hv_ZoomWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomWidth = ((hv_ZoomFactorWidth*hv_InputImageWidth)).TupleRound()
            ;
        }
        //
        //Use the better size for high resolution: 2x resolution size of preprocess image or input image size.
        hv_UseZoomImage.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UseZoomImage = (new HTuple(hv_ZoomWidth.TupleLess(
            hv_InputImageWidth))).TupleOr(new HTuple(hv_ZoomHeight.TupleLess(hv_InputImageHeight)));
        }
        hv_DLSampleHighRes.Dispose();
        HOperatorSet.CopyDict(hv_DLSample, new HTuple(), new HTuple(), out hv_DLSampleHighRes);
        hv_DLPreprocessParamHighRes.Dispose();
        HOperatorSet.CopyDict(hv_DLPreprocessParam, new HTuple(), new HTuple(), out hv_DLPreprocessParamHighRes);
        //
        ho_ImageHighRes.Dispose();
        HOperatorSet.FullDomain(ho_InputImage, out ho_ImageHighRes);
        if ((int)(hv_UseZoomImage) != 0)
        {
          HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_width", hv_ZoomWidth);
          HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_height", 
              hv_ZoomHeight);
          preprocess_dl_model_bbox_rect2(ho_ImageHighRes, hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
          gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ZoomImageSize(ho_ImageHighRes, out ExpTmpOutVar_0, hv_ZoomWidth, 
              hv_ZoomHeight, "constant");
          ho_ImageHighRes.Dispose();
          ho_ImageHighRes = ExpTmpOutVar_0;
          }
        }
        else
        {
          HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_width", hv_InputImageWidth);
          HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_height", 
              hv_InputImageHeight);
          gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
        }
        HOperatorSet.SetDictObject(ho_ImageHighRes, hv_DLSampleHighRes, "image");
        //
        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_2);
        HOperatorSet.SetDictTuple(hv_DLSample, "augmentation_data", hv___Tmp_Ctrl_Dict_Init_2);
        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv___Tmp_Ctrl_Dict_Init_2 = HTuple.TupleConstant(
            "HNULL");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"), 
            "sample_high_res", hv_DLSampleHighRes);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"), 
            "preprocess_params", hv_DLPreprocessParam);
        }
      }
      //
      ho_InputImage.Dispose();
      ho_ImageHighRes.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ModelType.Dispose();
      hv_AugmentationKeyExists.Dispose();
      hv_ImageKeyExists.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageType.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_InputImageWidthHeightRatio.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_HasPadding.Dispose();
      hv_ZoomFactorWidth.Dispose();
      hv_ZoomFactorHeight.Dispose();
      hv_UseZoomImage.Dispose();
      hv_DLSampleHighRes.Dispose();
      hv_DLPreprocessParamHighRes.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      hv___Tmp_Ctrl_Dict_Init_1.Dispose();
      hv___Tmp_Ctrl_Dict_Init_2.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_InputImage.Dispose();
      ho_ImageHighRes.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ModelType.Dispose();
      hv_AugmentationKeyExists.Dispose();
      hv_ImageKeyExists.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageType.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_InputImageWidthHeightRatio.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_HasPadding.Dispose();
      hv_ZoomFactorWidth.Dispose();
      hv_ZoomFactorHeight.Dispose();
      hv_UseZoomImage.Dispose();
      hv_DLSampleHighRes.Dispose();
      hv_DLPreprocessParamHighRes.Dispose();
      hv___Tmp_Ctrl_Dict_Init_0.Dispose();
      hv___Tmp_Ctrl_Dict_Init_1.Dispose();
      hv___Tmp_Ctrl_Dict_Init_2.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection and Instance Segmentation
  // Short Description: Preprocess the bounding boxes of type 'rectangle1' for a given sample. 
  private void preprocess_dl_model_bbox_rect1 (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho_DomainRaw=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_BBoxCol1 = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow1 = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxLabel = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
    HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
    HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
    HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
    HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
    HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
    HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
    HTuple hv_BBoxLabelNew = new HTuple(), hv_FactorResampleWidth = new HTuple();
    HTuple hv_FactorResampleHeight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainRaw);
    try
    {
      //
      //This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //
      //Get bounding box coordinates and labels.
      try
      {
        hv_BBoxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
        hv_BBoxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
        hv_BBoxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
        hv_BBoxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
        hv_BBoxLabel.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_ImageId.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
        {
          hv_ExceptionMessage.Dispose();
          hv_ExceptionMessage = "A bounding box coordinate key is missing.";
        }
        else
        {
          hv_ExceptionMessage.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ExceptionMessage = hv_Exception.TupleSelect(
              2);
          }
        }
        throw new HalconException((("An error has occurred during preprocessing image_id "+hv_ImageId)+" when getting bounding box coordinates : ")+hv_ExceptionMessage);
      }
      //
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow1.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = ((hv_BBoxRow1.TupleGreaterEqualElem(
            hv_BBoxRow2))).TupleOr(hv_BBoxCol1.TupleGreaterEqualElem(hv_BBoxCol2));
        }
        if ((int)(new HTuple(((hv_BoxesInvalid.TupleSum())).TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_col1 >= bbox_col2 or bbox_row1 >= bbox_row2."));
        }
      }
      else
      {
        //There are no bounding boxes, hence nothing to do.
        ho_DomainRaw.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_DomainHandling.Dispose();
        hv_BBoxCol1.Dispose();
        hv_BBoxCol2.Dispose();
        hv_BBoxRow1.Dispose();
        hv_BBoxRow2.Dispose();
        hv_BBoxLabel.Dispose();
        hv_Exception.Dispose();
        hv_ImageId.Dispose();
        hv_ExceptionMessage.Dispose();
        hv_BoxesInvalid.Dispose();
        hv_DomainRow1.Dispose();
        hv_DomainColumn1.Dispose();
        hv_DomainRow2.Dispose();
        hv_DomainColumn2.Dispose();
        hv_WidthRaw.Dispose();
        hv_HeightRaw.Dispose();
        hv_Row1.Dispose();
        hv_Col1.Dispose();
        hv_Row2.Dispose();
        hv_Col2.Dispose();
        hv_MaskDelete.Dispose();
        hv_MaskNewBbox.Dispose();
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol2New.Dispose();
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow2New.Dispose();
        hv_BBoxLabelNew.Dispose();
        hv_FactorResampleWidth.Dispose();
        hv_FactorResampleHeight.Dispose();

        return;
      }
      //
      //If the domain is cropped, crop bounding boxes.
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //
        //Get domain.
        ho_DomainRaw.Dispose();
        HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
        //
        //Set the size of the raw image to the domain extensions.
        hv_DomainRow1.Dispose();hv_DomainColumn1.Dispose();hv_DomainRow2.Dispose();hv_DomainColumn2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_DomainRow1, out hv_DomainColumn1, 
            out hv_DomainRow2, out hv_DomainColumn2);
        //The domain is always given as a pixel-precise region.
        hv_WidthRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WidthRaw = (hv_DomainColumn2-hv_DomainColumn1)+1.0;
        }
        hv_HeightRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HeightRaw = (hv_DomainRow2-hv_DomainRow1)+1.0;
        }
        //
        //Crop the bounding boxes.
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = hv_BBoxRow1.TupleMax2(
            hv_DomainRow1-.5);
        }
        hv_Col1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col1 = hv_BBoxCol1.TupleMax2(
            hv_DomainColumn1-.5);
        }
        hv_Row2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row2 = hv_BBoxRow2.TupleMin2(
            hv_DomainRow2+.5);
        }
        hv_Col2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col2 = hv_BBoxCol2.TupleMin2(
            hv_DomainColumn2+.5);
        }
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = ((hv_Row1.TupleGreaterEqualElem(
            hv_Row2))).TupleOr(hv_Col1.TupleGreaterEqualElem(hv_Col2));
        }
        hv_MaskNewBbox.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskNewBbox = 1-hv_MaskDelete;
        }
        //Store the preprocessed bounding box entries.
        hv_BBoxCol1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxCol1New = (hv_Col1.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainColumn1;
        }
        hv_BBoxCol2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxCol2New = (hv_Col2.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainColumn1;
        }
        hv_BBoxRow1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRow1New = (hv_Row1.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainRow1;
        }
        hv_BBoxRow2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRow2New = (hv_Row2.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainRow1;
        }
        hv_BBoxLabelNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
            hv_MaskNewBbox);
        }
        //
        //If we remove/select bounding boxes we also need to filter the corresponding
        //instance segmentation masks if they exist.
        filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        //If the entire image is used, set the variables accordingly.
        //Get the original size.
        hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
        HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
        //Set new coordinates to input coordinates.
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = new HTuple(hv_BBoxCol1);
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = new HTuple(hv_BBoxCol2);
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = new HTuple(hv_BBoxRow1);
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = new HTuple(hv_BBoxRow2);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Rescale the bounding boxes.
      //
      //Get required images width and height.
      //
      //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
      if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
          new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
      {
        //Calculate rescaling factor.
        hv_FactorResampleWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
            )/hv_WidthRaw;
        }
        hv_FactorResampleHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
            )/hv_HeightRaw;
        }
        //Rescale the bounding box coordinates.
        //As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.
        //Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used
        //for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol1New = ((hv_BBoxCol1New+.5)*hv_FactorResampleWidth)-.5;
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol2New = ((hv_BBoxCol2New+.5)*hv_FactorResampleWidth)-.5;
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow1New = ((hv_BBoxRow1New+.5)*hv_FactorResampleHeight)-.5;
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow2New = ((hv_BBoxRow2New+.5)*hv_FactorResampleHeight)-.5;
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
        }
        }
        //
      }
      //
      //Make a final check and remove bounding boxes that have zero area.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow1New.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = ((hv_BBoxRow1New.TupleGreaterEqualElem(
            hv_BBoxRow2New))).TupleOr(hv_BBoxCol1New.TupleGreaterEqualElem(hv_BBoxCol2New));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol1New = hv_BBoxCol1New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol2New = hv_BBoxCol2New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow1New = hv_BBoxRow1New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow2New = hv_BBoxRow2New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxLabelNew = hv_BBoxLabelNew.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = ExpTmpLocalVar_BBoxLabelNew;
        }
        }
        //
        //If we remove/select bounding boxes we also need to filter the corresponding
        //instance segmentation masks if they exist.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        filter_dl_sample_instance_segmentation_masks(hv_DLSample, 1-hv_MaskDelete);
        }
      }
      //
      //Set new bounding box coordinates in the dictionary.
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
      //
      ho_DomainRaw.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_DomainRaw.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection and Instance Segmentation
  // Short Description: Preprocess the bounding boxes of type 'rectangle2' for a given sample. 
  private void preprocess_dl_model_bbox_rect2 (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho_DomainRaw=null, ho_Rectangle2XLD=null;
    HObject ho_Rectangle2XLDSheared=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_IgnoreDirection = new HTuple();
    HTuple hv_ClassIDsNoOrientation = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
    HTuple hv_BBoxLength1 = new HTuple(), hv_BBoxLength2 = new HTuple();
    HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabel = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
    HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
    HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
    HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
    HTuple hv_BBoxRowNew = new HTuple(), hv_BBoxColNew = new HTuple();
    HTuple hv_BBoxLength1New = new HTuple(), hv_BBoxLength2New = new HTuple();
    HTuple hv_BBoxPhiNew = new HTuple(), hv_BBoxLabelNew = new HTuple();
    HTuple hv_ClassIDsNoOrientationIndices = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ClassIDsNoOrientationIndicesTmp = new HTuple();
    HTuple hv_DirectionLength1Row = new HTuple(), hv_DirectionLength1Col = new HTuple();
    HTuple hv_DirectionLength2Row = new HTuple(), hv_DirectionLength2Col = new HTuple();
    HTuple hv_Corner1Row = new HTuple(), hv_Corner1Col = new HTuple();
    HTuple hv_Corner2Row = new HTuple(), hv_Corner2Col = new HTuple();
    HTuple hv_FactorResampleWidth = new HTuple(), hv_FactorResampleHeight = new HTuple();
    HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxCol1 = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxCol2 = new HTuple();
    HTuple hv_BBoxRow3 = new HTuple(), hv_BBoxCol3 = new HTuple();
    HTuple hv_BBoxRow4 = new HTuple(), hv_BBoxCol4 = new HTuple();
    HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
    HTuple hv_BBoxCol3New = new HTuple(), hv_BBoxCol4New = new HTuple();
    HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
    HTuple hv_BBoxRow3New = new HTuple(), hv_BBoxRow4New = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DScale = new HTuple();
    HTuple hv__ = new HTuple(), hv_BBoxPhiTmp = new HTuple();
    HTuple hv_PhiDelta = new HTuple(), hv_PhiDeltaNegativeIndices = new HTuple();
    HTuple hv_IndicesRot90 = new HTuple(), hv_IndicesRot180 = new HTuple();
    HTuple hv_IndicesRot270 = new HTuple(), hv_SwapIndices = new HTuple();
    HTuple hv_Tmp = new HTuple(), hv_BBoxPhiNewIndices = new HTuple();
    HTuple hv_PhiThreshold = new HTuple(), hv_PhiToCorrect = new HTuple();
    HTuple hv_NumCorrections = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainRaw);
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLD);
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLDSheared);
    try
    {
      //This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.
      //
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get preprocess parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.
      hv_IgnoreDirection.Dispose();
      hv_IgnoreDirection = 0;
      hv_ClassIDsNoOrientation.Dispose();
      hv_ClassIDsNoOrientation = new HTuple();
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("ignore_direction")).TupleConcat(
          "class_ids_no_orientation"), out hv_KeyExists);
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        hv_IgnoreDirection.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_direction", out hv_IgnoreDirection);
        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
        {
          hv_IgnoreDirection.Dispose();
          hv_IgnoreDirection = 1;
        }
        else if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
        {
          hv_IgnoreDirection.Dispose();
          hv_IgnoreDirection = 0;
        }
      }
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        hv_ClassIDsNoOrientation.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_no_orientation", 
            out hv_ClassIDsNoOrientation);
      }
      //
      //Get bounding box coordinates and labels.
      try
      {
        hv_BBoxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
        hv_BBoxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
        hv_BBoxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BBoxLength1);
        hv_BBoxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BBoxLength2);
        hv_BBoxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
        hv_BBoxLabel.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_ImageId.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
        {
          hv_ExceptionMessage.Dispose();
          hv_ExceptionMessage = "A bounding box coordinate key is missing.";
        }
        else
        {
          hv_ExceptionMessage.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ExceptionMessage = hv_Exception.TupleSelect(
              2);
          }
        }
        throw new HalconException((("An error has occurred during preprocessing image_id "+hv_ImageId)+" when getting bounding box coordinates : ")+hv_ExceptionMessage);
      }
      //
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = (((hv_BBoxLength1.TupleEqualElem(
            0))).TupleSum())+(((hv_BBoxLength2.TupleEqualElem(0))).TupleSum());
        }
        if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one bounding box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
        }
      }
      else
      {
        //There are no bounding boxes, hence nothing to do.
        ho_DomainRaw.Dispose();
        ho_Rectangle2XLD.Dispose();
        ho_Rectangle2XLDSheared.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_DomainHandling.Dispose();
        hv_IgnoreDirection.Dispose();
        hv_ClassIDsNoOrientation.Dispose();
        hv_KeyExists.Dispose();
        hv_BBoxRow.Dispose();
        hv_BBoxCol.Dispose();
        hv_BBoxLength1.Dispose();
        hv_BBoxLength2.Dispose();
        hv_BBoxPhi.Dispose();
        hv_BBoxLabel.Dispose();
        hv_Exception.Dispose();
        hv_ImageId.Dispose();
        hv_ExceptionMessage.Dispose();
        hv_BoxesInvalid.Dispose();
        hv_DomainRow1.Dispose();
        hv_DomainColumn1.Dispose();
        hv_DomainRow2.Dispose();
        hv_DomainColumn2.Dispose();
        hv_WidthRaw.Dispose();
        hv_HeightRaw.Dispose();
        hv_MaskDelete.Dispose();
        hv_MaskNewBbox.Dispose();
        hv_BBoxRowNew.Dispose();
        hv_BBoxColNew.Dispose();
        hv_BBoxLength1New.Dispose();
        hv_BBoxLength2New.Dispose();
        hv_BBoxPhiNew.Dispose();
        hv_BBoxLabelNew.Dispose();
        hv_ClassIDsNoOrientationIndices.Dispose();
        hv_Index.Dispose();
        hv_ClassIDsNoOrientationIndicesTmp.Dispose();
        hv_DirectionLength1Row.Dispose();
        hv_DirectionLength1Col.Dispose();
        hv_DirectionLength2Row.Dispose();
        hv_DirectionLength2Col.Dispose();
        hv_Corner1Row.Dispose();
        hv_Corner1Col.Dispose();
        hv_Corner2Row.Dispose();
        hv_Corner2Col.Dispose();
        hv_FactorResampleWidth.Dispose();
        hv_FactorResampleHeight.Dispose();
        hv_BBoxRow1.Dispose();
        hv_BBoxCol1.Dispose();
        hv_BBoxRow2.Dispose();
        hv_BBoxCol2.Dispose();
        hv_BBoxRow3.Dispose();
        hv_BBoxCol3.Dispose();
        hv_BBoxRow4.Dispose();
        hv_BBoxCol4.Dispose();
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol3New.Dispose();
        hv_BBoxCol4New.Dispose();
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow3New.Dispose();
        hv_BBoxRow4New.Dispose();
        hv_HomMat2DIdentity.Dispose();
        hv_HomMat2DScale.Dispose();
        hv__.Dispose();
        hv_BBoxPhiTmp.Dispose();
        hv_PhiDelta.Dispose();
        hv_PhiDeltaNegativeIndices.Dispose();
        hv_IndicesRot90.Dispose();
        hv_IndicesRot180.Dispose();
        hv_IndicesRot270.Dispose();
        hv_SwapIndices.Dispose();
        hv_Tmp.Dispose();
        hv_BBoxPhiNewIndices.Dispose();
        hv_PhiThreshold.Dispose();
        hv_PhiToCorrect.Dispose();
        hv_NumCorrections.Dispose();

        return;
      }
      //
      //If the domain is cropped, crop bounding boxes.
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //
        //Get domain.
        ho_DomainRaw.Dispose();
        HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
        //
        //Set the size of the raw image to the domain extensions.
        hv_DomainRow1.Dispose();hv_DomainColumn1.Dispose();hv_DomainRow2.Dispose();hv_DomainColumn2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_DomainRow1, out hv_DomainColumn1, 
            out hv_DomainRow2, out hv_DomainColumn2);
        hv_WidthRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WidthRaw = (hv_DomainColumn2-hv_DomainColumn1)+1;
        }
        hv_HeightRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HeightRaw = (hv_DomainRow2-hv_DomainRow1)+1;
        }
        //
        //Crop the bounding boxes.
        //Remove the boxes with center outside of the domain.
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = (new HTuple((new HTuple(((hv_BBoxRow.TupleLessElem(
            hv_DomainRow1))).TupleOr(hv_BBoxCol.TupleLessElem(hv_DomainColumn1)))).TupleOr(
            hv_BBoxRow.TupleGreaterElem(hv_DomainRow2)))).TupleOr(hv_BBoxCol.TupleGreaterElem(
            hv_DomainColumn2));
        }
        hv_MaskNewBbox.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskNewBbox = 1-hv_MaskDelete;
        }
        //Store the preprocessed bounding box entries.
        hv_BBoxRowNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRowNew = (hv_BBoxRow.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainRow1;
        }
        hv_BBoxColNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxColNew = (hv_BBoxCol.TupleSelectMask(
            hv_MaskNewBbox))-hv_DomainColumn1;
        }
        hv_BBoxLength1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLength1New = hv_BBoxLength1.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxLength2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLength2New = hv_BBoxLength2.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxPhiNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxPhiNew = hv_BBoxPhi.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxLabelNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
            hv_MaskNewBbox);
        }
        //
        //If we remove/select bounding boxes we also need to filter the corresponding
        //instance segmentation masks if they exist.
        filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);
        //
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        //If the entire image is used, set the variables accordingly.
        //Get the original size.
        hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
        HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
        //Set new coordinates to input coordinates.
        hv_BBoxRowNew.Dispose();
        hv_BBoxRowNew = new HTuple(hv_BBoxRow);
        hv_BBoxColNew.Dispose();
        hv_BBoxColNew = new HTuple(hv_BBoxCol);
        hv_BBoxLength1New.Dispose();
        hv_BBoxLength1New = new HTuple(hv_BBoxLength1);
        hv_BBoxLength2New.Dispose();
        hv_BBoxLength2New = new HTuple(hv_BBoxLength2);
        hv_BBoxPhiNew.Dispose();
        hv_BBoxPhiNew = new HTuple(hv_BBoxPhi);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_ClassIDsNoOrientationIndices = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ClassIDsNoOrientation.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_ClassIDsNoOrientationIndicesTmp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassIDsNoOrientationIndicesTmp = ((hv_BBoxLabelNew.TupleEqualElem(
            hv_ClassIDsNoOrientation.TupleSelect(hv_Index)))).TupleFind(1);
        }
        if ((int)(new HTuple(hv_ClassIDsNoOrientationIndicesTmp.TupleNotEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ClassIDsNoOrientationIndices = hv_ClassIDsNoOrientationIndices.TupleConcat(
              hv_ClassIDsNoOrientationIndicesTmp);
          hv_ClassIDsNoOrientationIndices.Dispose();
          hv_ClassIDsNoOrientationIndices = ExpTmpLocalVar_ClassIDsNoOrientationIndices;
          }
          }
        }
      }
      if ((int)(new HTuple((new HTuple(hv_ClassIDsNoOrientationIndices.TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Calculate length1 and length2 using position of corners.
        hv_DirectionLength1Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength1Row = -(((hv_BBoxPhiNew.TupleSelect(
            hv_ClassIDsNoOrientationIndices))).TupleSin());
        }
        hv_DirectionLength1Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength1Col = ((hv_BBoxPhiNew.TupleSelect(
            hv_ClassIDsNoOrientationIndices))).TupleCos();
        }
        hv_DirectionLength2Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength2Row = -hv_DirectionLength1Col;
        }
        hv_DirectionLength2Col.Dispose();
        hv_DirectionLength2Col = new HTuple(hv_DirectionLength1Row);
        hv_Corner1Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner1Row = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Row)+((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Row);
        }
        hv_Corner1Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner1Col = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Col)+((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Col);
        }
        hv_Corner2Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner2Row = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Row)-((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Row);
        }
        hv_Corner2Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner2Col = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Col)-((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Col);
        }
        //
        if (hv_BBoxPhiNew == null)
          hv_BBoxPhiNew = new HTuple();
        hv_BBoxPhiNew[hv_ClassIDsNoOrientationIndices] = 0.0;
        if (hv_BBoxLength1New == null)
          hv_BBoxLength1New = new HTuple();
        hv_BBoxLength1New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Col.TupleAbs()
            )).TupleMax2(hv_Corner2Col.TupleAbs());
        if (hv_BBoxLength2New == null)
          hv_BBoxLength2New = new HTuple();
        hv_BBoxLength2New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Row.TupleAbs()
            )).TupleMax2(hv_Corner2Row.TupleAbs());
      }
      //
      //Rescale bounding boxes.
      //
      //Get required images width and height.
      //
      //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
      if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
          new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
      {
        //
        //Calculate rescaling factor.
        hv_FactorResampleWidth.Dispose();hv_FactorResampleHeight.Dispose();
        calculate_dl_image_zoom_factors(hv_WidthRaw, hv_HeightRaw, hv_ImageWidth, 
            hv_ImageHeight, hv_DLPreprocessParam, out hv_FactorResampleWidth, out hv_FactorResampleHeight);
        //
        if ((int)((new HTuple(hv_FactorResampleHeight.TupleNotEqual(hv_FactorResampleWidth))).TupleAnd(
            new HTuple((new HTuple(hv_BBoxRowNew.TupleLength())).TupleGreater(0)))) != 0)
        {
          //In order to preserve the correct orientation we have to transform the points individually.
          //Get the coordinates of the four corner points.
          hv_BBoxRow1.Dispose();hv_BBoxCol1.Dispose();hv_BBoxRow2.Dispose();hv_BBoxCol2.Dispose();hv_BBoxRow3.Dispose();hv_BBoxCol3.Dispose();hv_BBoxRow4.Dispose();hv_BBoxCol4.Dispose();
          convert_rect2_5to8param(hv_BBoxRowNew, hv_BBoxColNew, hv_BBoxLength1New, 
              hv_BBoxLength2New, hv_BBoxPhiNew, out hv_BBoxRow1, out hv_BBoxCol1, 
              out hv_BBoxRow2, out hv_BBoxCol2, out hv_BBoxRow3, out hv_BBoxCol3, 
              out hv_BBoxRow4, out hv_BBoxCol4);
          //
          //Rescale the coordinates.
          hv_BBoxCol1New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol1New = hv_BBoxCol1*hv_FactorResampleWidth;
          }
          hv_BBoxCol2New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol2New = hv_BBoxCol2*hv_FactorResampleWidth;
          }
          hv_BBoxCol3New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol3New = hv_BBoxCol3*hv_FactorResampleWidth;
          }
          hv_BBoxCol4New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol4New = hv_BBoxCol4*hv_FactorResampleWidth;
          }
          hv_BBoxRow1New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow1New = hv_BBoxRow1*hv_FactorResampleHeight;
          }
          hv_BBoxRow2New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow2New = hv_BBoxRow2*hv_FactorResampleHeight;
          }
          hv_BBoxRow3New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow3New = hv_BBoxRow3*hv_FactorResampleHeight;
          }
          hv_BBoxRow4New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow4New = hv_BBoxRow4*hv_FactorResampleHeight;
          }
          //
          //The rectangles will get sheared, that is why new rectangles have to be found.
          //Generate homography to scale rectangles.
          hv_HomMat2DIdentity.Dispose();
          HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
          hv_HomMat2DScale.Dispose();
          HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_FactorResampleHeight, 
              hv_FactorResampleWidth, 0, 0, out hv_HomMat2DScale);
          //Generate XLD contours for the rectangles.
          ho_Rectangle2XLD.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2XLD, hv_BBoxRowNew, 
              hv_BBoxColNew, hv_BBoxPhiNew, hv_BBoxLength1New, hv_BBoxLength2New);
          //Scale the XLD contours --> results in sheared regions.
          ho_Rectangle2XLDSheared.Dispose();
          HOperatorSet.AffineTransContourXld(ho_Rectangle2XLD, out ho_Rectangle2XLDSheared, 
              hv_HomMat2DScale);
          hv_BBoxRowNew.Dispose();hv_BBoxColNew.Dispose();hv_BBoxPhiNew.Dispose();hv_BBoxLength1New.Dispose();hv_BBoxLength2New.Dispose();
          HOperatorSet.SmallestRectangle2Xld(ho_Rectangle2XLDSheared, out hv_BBoxRowNew, 
              out hv_BBoxColNew, out hv_BBoxPhiNew, out hv_BBoxLength1New, out hv_BBoxLength2New);
          //
          //smallest_rectangle2_xld might change the orientation of the bounding box.
          //Hence, take the orientation that is closest to the one obtained out of the 4 corner points.
          hv__.Dispose();hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_BBoxPhiTmp.Dispose();
          convert_rect2_8to5param(hv_BBoxRow1New, hv_BBoxCol1New, hv_BBoxRow2New, 
              hv_BBoxCol2New, hv_BBoxRow3New, hv_BBoxCol3New, hv_BBoxRow4New, hv_BBoxCol4New, 
              hv_IgnoreDirection, out hv__, out hv__, out hv__, out hv__, out hv_BBoxPhiTmp);
          hv_PhiDelta.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PhiDelta = ((hv_BBoxPhiTmp-hv_BBoxPhiNew)).TupleFmod(
              (new HTuple(360)).TupleRad());
          }
          //Guarantee that angles are positive.
          hv_PhiDeltaNegativeIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PhiDeltaNegativeIndices = ((hv_PhiDelta.TupleLessElem(
              0.0))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_PhiDeltaNegativeIndices.TupleNotEqual(-1))) != 0)
          {
            if (hv_PhiDelta == null)
              hv_PhiDelta = new HTuple();
            hv_PhiDelta[hv_PhiDeltaNegativeIndices] = (hv_PhiDelta.TupleSelect(hv_PhiDeltaNegativeIndices))+((new HTuple(360)).TupleRad()
                );
          }
          hv_IndicesRot90.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot90 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(45)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(135)).TupleRad())))).TupleFind(1);
          }
          hv_IndicesRot180.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot180 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(135)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(225)).TupleRad())))).TupleFind(1);
          }
          hv_IndicesRot270.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot270 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(225)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(315)).TupleRad())))).TupleFind(1);
          }
          hv_SwapIndices.Dispose();
          hv_SwapIndices = new HTuple();
          if ((int)(new HTuple(hv_IndicesRot90.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot90] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot90))+((new HTuple(90)).TupleRad()
                );
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                hv_IndicesRot90);
            hv_SwapIndices.Dispose();
            hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
            }
            }
          }
          if ((int)(new HTuple(hv_IndicesRot180.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot180] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot180))+((new HTuple(180)).TupleRad()
                );
          }
          if ((int)(new HTuple(hv_IndicesRot270.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot270] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot270))+((new HTuple(270)).TupleRad()
                );
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                hv_IndicesRot270);
            hv_SwapIndices.Dispose();
            hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
            }
            }
          }
          if ((int)(new HTuple(hv_SwapIndices.TupleNotEqual(new HTuple()))) != 0)
          {
            hv_Tmp.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Tmp = hv_BBoxLength1New.TupleSelect(
                hv_SwapIndices);
            }
            if (hv_BBoxLength1New == null)
              hv_BBoxLength1New = new HTuple();
            hv_BBoxLength1New[hv_SwapIndices] = hv_BBoxLength2New.TupleSelect(hv_SwapIndices);
            if (hv_BBoxLength2New == null)
              hv_BBoxLength2New = new HTuple();
            hv_BBoxLength2New[hv_SwapIndices] = hv_Tmp;
          }
          //Change angles such that they lie in the range (-180, 180].
          hv_BBoxPhiNewIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxPhiNewIndices = ((hv_BBoxPhiNew.TupleGreaterElem(
              (new HTuple(180)).TupleRad()))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_BBoxPhiNewIndices.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_BBoxPhiNewIndices] = (hv_BBoxPhiNew.TupleSelect(hv_BBoxPhiNewIndices))-((new HTuple(360)).TupleRad()
                );
          }
          //
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxColNew = hv_BBoxColNew*hv_FactorResampleWidth;
          hv_BBoxColNew.Dispose();
          hv_BBoxColNew = ExpTmpLocalVar_BBoxColNew;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxRowNew = hv_BBoxRowNew*hv_FactorResampleWidth;
          hv_BBoxRowNew.Dispose();
          hv_BBoxRowNew = ExpTmpLocalVar_BBoxRowNew;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxLength1New = hv_BBoxLength1New*hv_FactorResampleWidth;
          hv_BBoxLength1New.Dispose();
          hv_BBoxLength1New = ExpTmpLocalVar_BBoxLength1New;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxLength2New = hv_BBoxLength2New*hv_FactorResampleWidth;
          hv_BBoxLength2New.Dispose();
          hv_BBoxLength2New = ExpTmpLocalVar_BBoxLength2New;
          }
          }
          //Phi stays the same.
        }
        //
      }
      //
      //Adapt the bounding box angles such that they are within the correct range,
      //which is (-180,180] for 'ignore_direction'==false and (-90,90] else.
      hv_PhiThreshold.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PhiThreshold = ((new HTuple(180)).TupleRad()
          )-(hv_IgnoreDirection*((new HTuple(90)).TupleRad()));
      }
      hv_PhiDelta.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PhiDelta = 2*hv_PhiThreshold;
      }
      //Correct angles that are too large.
      hv_PhiToCorrect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PhiToCorrect = ((hv_BBoxPhiNew.TupleGreaterElem(
          hv_PhiThreshold))).TupleFind(1);
      }
      if ((int)((new HTuple(hv_PhiToCorrect.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PhiToCorrect.TupleNotEqual(
          new HTuple())))) != 0)
      {
        hv_NumCorrections.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumCorrections = (((((hv_BBoxPhiNew.TupleSelect(
            hv_PhiToCorrect))-hv_PhiThreshold)/hv_PhiDelta)).TupleInt())+1;
        }
        if (hv_BBoxPhiNew == null)
          hv_BBoxPhiNew = new HTuple();
        hv_BBoxPhiNew[hv_PhiToCorrect] = (hv_BBoxPhiNew.TupleSelect(hv_PhiToCorrect))-(hv_NumCorrections*hv_PhiDelta);
      }
      //Correct angles that are too small.
      hv_PhiToCorrect.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PhiToCorrect = ((hv_BBoxPhiNew.TupleLessEqualElem(
          -hv_PhiThreshold))).TupleFind(1);
      }
      if ((int)((new HTuple(hv_PhiToCorrect.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PhiToCorrect.TupleNotEqual(
          new HTuple())))) != 0)
      {
        hv_NumCorrections.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumCorrections = (((((((hv_BBoxPhiNew.TupleSelect(
            hv_PhiToCorrect))+hv_PhiThreshold)).TupleAbs())/hv_PhiDelta)).TupleInt()
            )+1;
        }
        if (hv_BBoxPhiNew == null)
          hv_BBoxPhiNew = new HTuple();
        hv_BBoxPhiNew[hv_PhiToCorrect] = (hv_BBoxPhiNew.TupleSelect(hv_PhiToCorrect))+(hv_NumCorrections*hv_PhiDelta);
      }
      //
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRowNew.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = (((hv_BBoxLength1New.TupleEqualElem(
            0))).TupleSum())+(((hv_BBoxLength2New.TupleEqualElem(0))).TupleSum());
        }
        if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
        }
      }
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_BBoxRowNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_BBoxColNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv_BBoxLength1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv_BBoxLength2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhiNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
      //
      ho_DomainRaw.Dispose();
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_KeyExists.Dispose();
      hv_BBoxRow.Dispose();
      hv_BBoxCol.Dispose();
      hv_BBoxLength1.Dispose();
      hv_BBoxLength2.Dispose();
      hv_BBoxPhi.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxRowNew.Dispose();
      hv_BBoxColNew.Dispose();
      hv_BBoxLength1New.Dispose();
      hv_BBoxLength2New.Dispose();
      hv_BBoxPhiNew.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_Index.Dispose();
      hv_ClassIDsNoOrientationIndicesTmp.Dispose();
      hv_DirectionLength1Row.Dispose();
      hv_DirectionLength1Col.Dispose();
      hv_DirectionLength2Row.Dispose();
      hv_DirectionLength2Col.Dispose();
      hv_Corner1Row.Dispose();
      hv_Corner1Col.Dispose();
      hv_Corner2Row.Dispose();
      hv_Corner2Col.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow3.Dispose();
      hv_BBoxCol3.Dispose();
      hv_BBoxRow4.Dispose();
      hv_BBoxCol4.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol3New.Dispose();
      hv_BBoxCol4New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow3New.Dispose();
      hv_BBoxRow4New.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv__.Dispose();
      hv_BBoxPhiTmp.Dispose();
      hv_PhiDelta.Dispose();
      hv_PhiDeltaNegativeIndices.Dispose();
      hv_IndicesRot90.Dispose();
      hv_IndicesRot180.Dispose();
      hv_IndicesRot270.Dispose();
      hv_SwapIndices.Dispose();
      hv_Tmp.Dispose();
      hv_BBoxPhiNewIndices.Dispose();
      hv_PhiThreshold.Dispose();
      hv_PhiToCorrect.Dispose();
      hv_NumCorrections.Dispose();

      return;

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_DomainRaw.Dispose();
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_KeyExists.Dispose();
      hv_BBoxRow.Dispose();
      hv_BBoxCol.Dispose();
      hv_BBoxLength1.Dispose();
      hv_BBoxLength2.Dispose();
      hv_BBoxPhi.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxRowNew.Dispose();
      hv_BBoxColNew.Dispose();
      hv_BBoxLength1New.Dispose();
      hv_BBoxLength2New.Dispose();
      hv_BBoxPhiNew.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_Index.Dispose();
      hv_ClassIDsNoOrientationIndicesTmp.Dispose();
      hv_DirectionLength1Row.Dispose();
      hv_DirectionLength1Col.Dispose();
      hv_DirectionLength2Row.Dispose();
      hv_DirectionLength2Col.Dispose();
      hv_Corner1Row.Dispose();
      hv_Corner1Col.Dispose();
      hv_Corner2Row.Dispose();
      hv_Corner2Col.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow3.Dispose();
      hv_BBoxCol3.Dispose();
      hv_BBoxRow4.Dispose();
      hv_BBoxCol4.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol3New.Dispose();
      hv_BBoxCol4New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow3New.Dispose();
      hv_BBoxRow4New.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv__.Dispose();
      hv_BBoxPhiTmp.Dispose();
      hv_PhiDelta.Dispose();
      hv_PhiDeltaNegativeIndices.Dispose();
      hv_IndicesRot90.Dispose();
      hv_IndicesRot180.Dispose();
      hv_IndicesRot270.Dispose();
      hv_SwapIndices.Dispose();
      hv_Tmp.Dispose();
      hv_BBoxPhiNewIndices.Dispose();
      hv_PhiThreshold.Dispose();
      hv_PhiToCorrect.Dispose();
      hv_NumCorrections.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess images for deep-learning-based training and inference. 
  public void preprocess_dl_model_images (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_PreservedDomains=null, ho_ImageSelected=null;
    HObject ho_DomainSelected=null, ho_ImagesScaled=null, ho_ImageScaled=null;
    HObject ho_Channel=null, ho_ChannelScaled=null, ho_ThreeChannelImage=null;
    HObject ho_SingleChannelImage=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
    HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_Type = new HTuple();
    HTuple hv_NumMatches = new HTuple(), hv_InputNumChannels = new HTuple();
    HTuple hv_OutputNumChannels = new HTuple(), hv_NumChannels1 = new HTuple();
    HTuple hv_NumChannels3 = new HTuple(), hv_AreInputNumChannels1 = new HTuple();
    HTuple hv_AreInputNumChannels3 = new HTuple(), hv_AreInputNumChannels1Or3 = new HTuple();
    HTuple hv_ValidNumChannels = new HTuple(), hv_ValidNumChannelsText = new HTuple();
    HTuple hv_PreserveDomain = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
    HTuple hv_Column2 = new HTuple(), hv_UniqRow1 = new HTuple();
    HTuple hv_UniqColumn1 = new HTuple(), hv_UniqRow2 = new HTuple();
    HTuple hv_UniqColumn2 = new HTuple(), hv_RectangleIndex = new HTuple();
    HTuple hv_OriginalWidth = new HTuple(), hv_OriginalHeight = new HTuple();
    HTuple hv_UniqWidth = new HTuple(), hv_UniqHeight = new HTuple();
    HTuple hv_ScaleWidth = new HTuple(), hv_ScaleHeight = new HTuple();
    HTuple hv_ScaleIndex = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_NumChannels = new HTuple(), hv_ChannelIndex = new HTuple();
    HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_Scale = new HTuple(), hv_Shift = new HTuple();
    HTuple hv_MeanValues = new HTuple(), hv_DeviationValues = new HTuple();
    HTuple hv_UseDefaultNormalizationValues = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_RescaleRange = new HTuple(), hv_CurrentNumChannels = new HTuple();
    HTuple hv_DiffNumChannelsIndices = new HTuple(), hv_Index = new HTuple();
    HTuple hv_DiffNumChannelsIndex = new HTuple(), hv_NumDomains = new HTuple();
    HTuple hv_DomainIndex = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_PreservedDomains);
    HOperatorSet.GenEmptyObj(out ho_ImageSelected);
    HOperatorSet.GenEmptyObj(out ho_DomainSelected);
    HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
    HOperatorSet.GenEmptyObj(out ho_ThreeChannelImage);
    HOperatorSet.GenEmptyObj(out ho_SingleChannelImage);
    try
    {
      //
      //This procedure preprocesses the provided Images according to the parameters in
      //the dictionary DLPreprocessParam. Note that depending on the images, additional
      //preprocessing steps might be beneficial.
      //
      //Validate the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_NormalizationType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      //Validate the type of the input images.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
      if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
      {
        throw new HalconException("Please provide some images to preprocess.");
      }
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
      hv_NumMatches.Dispose();
      HOperatorSet.TupleRegexpTest(hv_Type, "byte|int|real", out hv_NumMatches);
      if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
      {
        throw new HalconException(new HTuple("Please provide only images of type 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8', or 'real'."));
      }
      //
      //Handle ocr_recognition models.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
      {
        ho_ImagesPreprocessed.Dispose();
        preprocess_dl_model_images_ocr_recognition(ho_Images_COPY_INP_TMP, out ho_ImagesPreprocessed, 
            hv_DLPreprocessParam);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_PreservedDomains.Dispose();
        ho_ImageSelected.Dispose();
        ho_DomainSelected.Dispose();
        ho_ImagesScaled.Dispose();
        ho_ImageScaled.Dispose();
        ho_Channel.Dispose();
        ho_ChannelScaled.Dispose();
        ho_ThreeChannelImage.Dispose();
        ho_SingleChannelImage.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageNumChannels.Dispose();
        hv_ImageRangeMin.Dispose();
        hv_ImageRangeMax.Dispose();
        hv_DomainHandling.Dispose();
        hv_NormalizationType.Dispose();
        hv_ModelType.Dispose();
        hv_NumImages.Dispose();
        hv_Type.Dispose();
        hv_NumMatches.Dispose();
        hv_InputNumChannels.Dispose();
        hv_OutputNumChannels.Dispose();
        hv_NumChannels1.Dispose();
        hv_NumChannels3.Dispose();
        hv_AreInputNumChannels1.Dispose();
        hv_AreInputNumChannels3.Dispose();
        hv_AreInputNumChannels1Or3.Dispose();
        hv_ValidNumChannels.Dispose();
        hv_ValidNumChannelsText.Dispose();
        hv_PreserveDomain.Dispose();
        hv_Row1.Dispose();
        hv_Column1.Dispose();
        hv_Row2.Dispose();
        hv_Column2.Dispose();
        hv_UniqRow1.Dispose();
        hv_UniqColumn1.Dispose();
        hv_UniqRow2.Dispose();
        hv_UniqColumn2.Dispose();
        hv_RectangleIndex.Dispose();
        hv_OriginalWidth.Dispose();
        hv_OriginalHeight.Dispose();
        hv_UniqWidth.Dispose();
        hv_UniqHeight.Dispose();
        hv_ScaleWidth.Dispose();
        hv_ScaleHeight.Dispose();
        hv_ScaleIndex.Dispose();
        hv_ImageIndex.Dispose();
        hv_NumChannels.Dispose();
        hv_ChannelIndex.Dispose();
        hv_Min.Dispose();
        hv_Max.Dispose();
        hv_Range.Dispose();
        hv_Scale.Dispose();
        hv_Shift.Dispose();
        hv_MeanValues.Dispose();
        hv_DeviationValues.Dispose();
        hv_UseDefaultNormalizationValues.Dispose();
        hv_Exception.Dispose();
        hv_Indices.Dispose();
        hv_RescaleRange.Dispose();
        hv_CurrentNumChannels.Dispose();
        hv_DiffNumChannelsIndices.Dispose();
        hv_Index.Dispose();
        hv_DiffNumChannelsIndex.Dispose();
        hv_NumDomains.Dispose();
        hv_DomainIndex.Dispose();

        return;
      }
      //
      //Handle ocr_detection models.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
      {
        ho_ImagesPreprocessed.Dispose();
        preprocess_dl_model_images_ocr_detection(ho_Images_COPY_INP_TMP, out ho_ImagesPreprocessed, 
            hv_DLPreprocessParam);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_PreservedDomains.Dispose();
        ho_ImageSelected.Dispose();
        ho_DomainSelected.Dispose();
        ho_ImagesScaled.Dispose();
        ho_ImageScaled.Dispose();
        ho_Channel.Dispose();
        ho_ChannelScaled.Dispose();
        ho_ThreeChannelImage.Dispose();
        ho_SingleChannelImage.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageNumChannels.Dispose();
        hv_ImageRangeMin.Dispose();
        hv_ImageRangeMax.Dispose();
        hv_DomainHandling.Dispose();
        hv_NormalizationType.Dispose();
        hv_ModelType.Dispose();
        hv_NumImages.Dispose();
        hv_Type.Dispose();
        hv_NumMatches.Dispose();
        hv_InputNumChannels.Dispose();
        hv_OutputNumChannels.Dispose();
        hv_NumChannels1.Dispose();
        hv_NumChannels3.Dispose();
        hv_AreInputNumChannels1.Dispose();
        hv_AreInputNumChannels3.Dispose();
        hv_AreInputNumChannels1Or3.Dispose();
        hv_ValidNumChannels.Dispose();
        hv_ValidNumChannelsText.Dispose();
        hv_PreserveDomain.Dispose();
        hv_Row1.Dispose();
        hv_Column1.Dispose();
        hv_Row2.Dispose();
        hv_Column2.Dispose();
        hv_UniqRow1.Dispose();
        hv_UniqColumn1.Dispose();
        hv_UniqRow2.Dispose();
        hv_UniqColumn2.Dispose();
        hv_RectangleIndex.Dispose();
        hv_OriginalWidth.Dispose();
        hv_OriginalHeight.Dispose();
        hv_UniqWidth.Dispose();
        hv_UniqHeight.Dispose();
        hv_ScaleWidth.Dispose();
        hv_ScaleHeight.Dispose();
        hv_ScaleIndex.Dispose();
        hv_ImageIndex.Dispose();
        hv_NumChannels.Dispose();
        hv_ChannelIndex.Dispose();
        hv_Min.Dispose();
        hv_Max.Dispose();
        hv_Range.Dispose();
        hv_Scale.Dispose();
        hv_Shift.Dispose();
        hv_MeanValues.Dispose();
        hv_DeviationValues.Dispose();
        hv_UseDefaultNormalizationValues.Dispose();
        hv_Exception.Dispose();
        hv_Indices.Dispose();
        hv_RescaleRange.Dispose();
        hv_CurrentNumChannels.Dispose();
        hv_DiffNumChannelsIndices.Dispose();
        hv_Index.Dispose();
        hv_DiffNumChannelsIndex.Dispose();
        hv_NumDomains.Dispose();
        hv_DomainIndex.Dispose();

        return;
      }
      //
      //Validate the number channels of the input images.
      hv_InputNumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_InputNumChannels);
      hv_OutputNumChannels.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_OutputNumChannels = HTuple.TupleGenConst(
          hv_NumImages,hv_ImageNumChannels);
      }
      //Only for 'image_num_channels' 1 and 3 combinations of 1- and 3-channel images are allowed.
      if ((int)((new HTuple(hv_ImageNumChannels.TupleEqual(1))).TupleOr(new HTuple(hv_ImageNumChannels.TupleEqual(
          3)))) != 0)
      {
        hv_NumChannels1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumChannels1 = HTuple.TupleGenConst(
            hv_NumImages,1);
        }
        hv_NumChannels3.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumChannels3 = HTuple.TupleGenConst(
            hv_NumImages,3);
        }
        hv_AreInputNumChannels1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AreInputNumChannels1 = hv_InputNumChannels.TupleEqualElem(
            hv_NumChannels1);
        }
        hv_AreInputNumChannels3.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AreInputNumChannels3 = hv_InputNumChannels.TupleEqualElem(
            hv_NumChannels3);
        }
        hv_AreInputNumChannels1Or3.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AreInputNumChannels1Or3 = hv_AreInputNumChannels1+hv_AreInputNumChannels3;
        }
        hv_ValidNumChannels.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValidNumChannels = new HTuple(hv_AreInputNumChannels1Or3.TupleEqual(
            hv_NumChannels1));
        }
        hv_ValidNumChannelsText.Dispose();
        hv_ValidNumChannelsText = "Valid numbers of channels for the specified model are 1 or 3.";
      }
      else
      {
        hv_ValidNumChannels.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValidNumChannels = new HTuple(hv_InputNumChannels.TupleEqual(
            hv_OutputNumChannels));
        }
        hv_ValidNumChannelsText.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ValidNumChannelsText = ("Valid number of channels for the specified model is "+hv_ImageNumChannels)+".";
        }
      }
      if ((int)(hv_ValidNumChannels.TupleNot()) != 0)
      {
        throw new HalconException("Please provide images with a valid number of channels. "+hv_ValidNumChannelsText);
      }
      //Preprocess the images.
      //
      //For models of type '3d_gripping_point_detection', the preprocessing steps need to be performed on full
      //domain images while the domains are preserved and set back into the images after the preprocessing.
      hv_PreserveDomain.Dispose();
      hv_PreserveDomain = 0;
      if ((int)((new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))).TupleAnd(
          (new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))).TupleOr(new HTuple(hv_DomainHandling.TupleEqual(
          "keep_domain"))))) != 0)
      {
        hv_PreserveDomain.Dispose();
        hv_PreserveDomain = 1;
        ho_PreservedDomains.Dispose();
        HOperatorSet.GetDomain(ho_Images_COPY_INP_TMP, out ho_PreservedDomains);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Apply the domain to the images.
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        if ((int)(hv_PreserveDomain) != 0)
        {
          //In case of preserved domain, the crop is performed with the smallest rectangle of the
          //domain to avoid out of domain pixels being set to 0.
          hv_Row1.Dispose();hv_Column1.Dispose();hv_Row2.Dispose();hv_Column2.Dispose();
          HOperatorSet.SmallestRectangle1(ho_PreservedDomains, out hv_Row1, out hv_Column1, 
              out hv_Row2, out hv_Column2);
          hv_UniqRow1.Dispose();
          HOperatorSet.TupleUniq(hv_Row1, out hv_UniqRow1);
          hv_UniqColumn1.Dispose();
          HOperatorSet.TupleUniq(hv_Column1, out hv_UniqColumn1);
          hv_UniqRow2.Dispose();
          HOperatorSet.TupleUniq(hv_Row2, out hv_UniqRow2);
          hv_UniqColumn2.Dispose();
          HOperatorSet.TupleUniq(hv_Column2, out hv_UniqColumn2);
          if ((int)((new HTuple((new HTuple((new HTuple((new HTuple(hv_UniqRow1.TupleLength()
              )).TupleEqual(1))).TupleAnd(new HTuple((new HTuple(hv_UniqColumn1.TupleLength()
              )).TupleEqual(1))))).TupleAnd(new HTuple((new HTuple(hv_UniqRow2.TupleLength()
              )).TupleEqual(1))))).TupleAnd(new HTuple((new HTuple(hv_UniqColumn2.TupleLength()
              )).TupleEqual(1)))) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.CropRectangle1(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
                hv_UniqRow1, hv_UniqColumn1, hv_UniqRow2, hv_UniqColumn2);
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.MoveRegion(ho_PreservedDomains, out ExpTmpOutVar_0, -hv_UniqRow1, 
                -hv_UniqColumn1);
            ho_PreservedDomains.Dispose();
            ho_PreservedDomains = ExpTmpOutVar_0;
            }
          }
          else
          {
            for (hv_RectangleIndex=0; (int)hv_RectangleIndex<=(int)((new HTuple(hv_Row1.TupleLength()
                ))-1); hv_RectangleIndex = (int)hv_RectangleIndex + 1)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ImageSelected.Dispose();
              HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, 
                  hv_RectangleIndex+1);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.CropRectangle1(ho_ImageSelected, out ExpTmpOutVar_0, hv_Row1.TupleSelect(
                  hv_RectangleIndex), hv_Column1.TupleSelect(hv_RectangleIndex), 
                  hv_Row2.TupleSelect(hv_RectangleIndex), hv_Column2.TupleSelect(
                  hv_RectangleIndex));
              ho_ImageSelected.Dispose();
              ho_ImageSelected = ExpTmpOutVar_0;
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0, 
                  hv_RectangleIndex+1);
              ho_Images_COPY_INP_TMP.Dispose();
              ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_DomainSelected.Dispose();
              HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected, 
                  hv_RectangleIndex+1);
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.MoveRegion(ho_DomainSelected, out ExpTmpOutVar_0, -(hv_Row1.TupleSelect(
                  hv_RectangleIndex)), -(hv_Column1.TupleSelect(hv_RectangleIndex)));
              ho_DomainSelected.Dispose();
              ho_DomainSelected = ExpTmpOutVar_0;
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ReplaceObj(ho_PreservedDomains, ho_DomainSelected, out ExpTmpOutVar_0, 
                  hv_RectangleIndex+1);
              ho_PreservedDomains.Dispose();
              ho_PreservedDomains = ExpTmpOutVar_0;
              }
            }
          }
        }
        else
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.CropDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
      }
      else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
          (new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
          "3d_gripping_point_detection"))))) != 0)
      {
        //The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection' or '3d_gripping_point_detection'.
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'.");
      }
      //
      //Zoom preserved domains before zooming the images.
      if ((int)(hv_PreserveDomain) != 0)
      {
        hv_OriginalWidth.Dispose();hv_OriginalHeight.Dispose();
        HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_OriginalWidth, out hv_OriginalHeight);
        hv_UniqWidth.Dispose();
        HOperatorSet.TupleUniq(hv_OriginalWidth, out hv_UniqWidth);
        hv_UniqHeight.Dispose();
        HOperatorSet.TupleUniq(hv_OriginalHeight, out hv_UniqHeight);
        if ((int)((new HTuple((new HTuple(hv_UniqWidth.TupleLength())).TupleEqual(
            1))).TupleAnd(new HTuple((new HTuple(hv_UniqHeight.TupleLength())).TupleEqual(
            1)))) != 0)
        {
          hv_ScaleWidth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ScaleWidth = hv_ImageWidth/(hv_UniqWidth.TupleReal()
              );
          }
          hv_ScaleHeight.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ScaleHeight = hv_ImageHeight/(hv_UniqHeight.TupleReal()
              );
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ZoomRegion(ho_PreservedDomains, out ExpTmpOutVar_0, hv_ScaleWidth, 
              hv_ScaleHeight);
          ho_PreservedDomains.Dispose();
          ho_PreservedDomains = ExpTmpOutVar_0;
          }
        }
        else
        {
          hv_ScaleWidth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ScaleWidth = hv_ImageWidth/(hv_OriginalWidth.TupleReal()
              );
          }
          hv_ScaleHeight.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ScaleHeight = hv_ImageHeight/(hv_OriginalHeight.TupleReal()
              );
          }
          for (hv_ScaleIndex=0; (int)hv_ScaleIndex<=(int)((new HTuple(hv_ScaleWidth.TupleLength()
              ))-1); hv_ScaleIndex = (int)hv_ScaleIndex + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_DomainSelected.Dispose();
            HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected, hv_ScaleIndex+1);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ZoomRegion(ho_DomainSelected, out ExpTmpOutVar_0, hv_ScaleWidth.TupleSelect(
                hv_ScaleIndex), hv_ScaleHeight.TupleSelect(hv_ScaleIndex));
            ho_DomainSelected.Dispose();
            ho_DomainSelected = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ReplaceObj(ho_PreservedDomains, ho_DomainSelected, out ExpTmpOutVar_0, 
                hv_ScaleIndex+1);
            ho_PreservedDomains.Dispose();
            ho_PreservedDomains = ExpTmpOutVar_0;
            }
          }
        }
      }
      //
      //Convert the images to real and zoom the images.
      //Zoom first to speed up if all image types are supported by zoom_image_size.
      if ((int)(new HTuple((new HTuple(hv_Type.TupleRegexpTest("int1|int4|int8"))).TupleEqual(
          0))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth, 
            hv_ImageHeight, "constant");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth, 
            hv_ImageHeight, "constant");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      if ((int)(new HTuple(hv_NormalizationType.TupleEqual("all_channels"))) != 0)
      {
        //Scale for each image the gray values of all channels to ImageRangeMin-ImageRangeMax.
        ho_ImagesScaled.Dispose();
        HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
        HTuple end_val138 = hv_NumImages;
        HTuple step_val138 = 1;
        for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val138, step_val138); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val138))
        {
          ho_ImageSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
          hv_NumChannels.Dispose();
          HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
          ho_ImageScaled.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImageScaled);
          HTuple end_val142 = hv_NumChannels;
          HTuple step_val142 = 1;
          for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val142, step_val142); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val142))
          {
            ho_Channel.Dispose();
            HOperatorSet.AccessChannel(ho_ImageSelected, out ho_Channel, hv_ChannelIndex);
            hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
            HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_Min, out hv_Max, 
                out hv_Range);
            if ((int)(new HTuple(((hv_Max-hv_Min)).TupleEqual(0))) != 0)
            {
              hv_Scale.Dispose();
              hv_Scale = 1;
            }
            else
            {
              hv_Scale.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Scale = (hv_ImageRangeMax-hv_ImageRangeMin)/(hv_Max-hv_Min);
              }
            }
            hv_Shift.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Shift = ((-hv_Scale)*hv_Min)+hv_ImageRangeMin;
            }
            ho_ChannelScaled.Dispose();
            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                );
            ho_ImageScaled.Dispose();
            ho_ImageScaled = ExpTmpOutVar_0;
            }
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageScaled, out ExpTmpOutVar_0
              );
          ho_ImagesScaled.Dispose();
          ho_ImagesScaled = ExpTmpOutVar_0;
          }
        }
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("first_channel"))) != 0)
      {
        //Scale for each image the gray values of first channel to ImageRangeMin-ImageRangeMax.
        ho_ImagesScaled.Dispose();
        HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
        HTuple end_val160 = hv_NumImages;
        HTuple step_val160 = 1;
        for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val160, step_val160); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val160))
        {
          ho_ImageSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
          hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_ImageSelected, ho_ImageSelected, 0, out hv_Min, 
              out hv_Max, out hv_Range);
          if ((int)(new HTuple(((hv_Max-hv_Min)).TupleEqual(0))) != 0)
          {
            hv_Scale.Dispose();
            hv_Scale = 1;
          }
          else
          {
            hv_Scale.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Scale = (hv_ImageRangeMax-hv_ImageRangeMin)/(hv_Max-hv_Min);
            }
          }
          hv_Shift.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Shift = ((-hv_Scale)*hv_Min)+hv_ImageRangeMin;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImage(ho_ImageSelected, out ExpTmpOutVar_0, hv_Scale, 
              hv_Shift);
          ho_ImageSelected.Dispose();
          ho_ImageSelected = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageSelected, out ExpTmpOutVar_0
              );
          ho_ImagesScaled.Dispose();
          ho_ImagesScaled = ExpTmpOutVar_0;
          }
        }
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("constant_values"))) != 0)
      {
        //Scale for each image the gray values of all channels to the corresponding channel DeviationValues[].
        try
        {
          hv_MeanValues.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "mean_values_normalization", 
              out hv_MeanValues);
          hv_DeviationValues.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "deviation_values_normalization", 
              out hv_DeviationValues);
          hv_UseDefaultNormalizationValues.Dispose();
          hv_UseDefaultNormalizationValues = 0;
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_MeanValues.Dispose();
          hv_MeanValues = new HTuple();
          hv_MeanValues[0] = 123.675;
          hv_MeanValues[1] = 116.28;
          hv_MeanValues[2] = 103.53;
          hv_DeviationValues.Dispose();
          hv_DeviationValues = new HTuple();
          hv_DeviationValues[0] = 58.395;
          hv_DeviationValues[1] = 57.12;
          hv_DeviationValues[2] = 57.375;
          hv_UseDefaultNormalizationValues.Dispose();
          hv_UseDefaultNormalizationValues = 1;
        }
        ho_ImagesScaled.Dispose();
        HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
        HTuple end_val185 = hv_NumImages;
        HTuple step_val185 = 1;
        for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val185, step_val185); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val185))
        {
          ho_ImageSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
          hv_NumChannels.Dispose();
          HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
          //Ensure that the number of channels is equal |DeviationValues| and |MeanValues|
          if ((int)(hv_UseDefaultNormalizationValues) != 0)
          {
            if ((int)(new HTuple(hv_NumChannels.TupleEqual(1))) != 0)
            {
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.Compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected, 
                  out ExpTmpOutVar_0);
              ho_ImageSelected.Dispose();
              ho_ImageSelected = ExpTmpOutVar_0;
              }
              hv_NumChannels.Dispose();
              HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
            }
            else if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(
                3))) != 0)
            {
              throw new HalconException("Using default values for normalization type 'constant_values' is allowed only for 1- and 3-channel images.");
            }
          }
          if ((int)((new HTuple((new HTuple(hv_MeanValues.TupleLength())).TupleNotEqual(
              hv_NumChannels))).TupleOr(new HTuple((new HTuple(hv_DeviationValues.TupleLength()
              )).TupleNotEqual(hv_NumChannels)))) != 0)
          {
            throw new HalconException("The length of mean and deviation values for normalization type 'constant_values' have to be the same size as the number of channels of the image.");
          }
          ho_ImageScaled.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImageScaled);
          HTuple end_val201 = hv_NumChannels;
          HTuple step_val201 = 1;
          for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val201, step_val201); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val201))
          {
            ho_Channel.Dispose();
            HOperatorSet.AccessChannel(ho_ImageSelected, out ho_Channel, hv_ChannelIndex);
            hv_Scale.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Scale = 1.0/(hv_DeviationValues.TupleSelect(
                hv_ChannelIndex-1));
            }
            hv_Shift.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Shift = (-hv_Scale)*(hv_MeanValues.TupleSelect(
                hv_ChannelIndex-1));
            }
            ho_ChannelScaled.Dispose();
            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                );
            ho_ImageScaled.Dispose();
            ho_ImageScaled = ExpTmpOutVar_0;
            }
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageScaled, out ExpTmpOutVar_0
              );
          ho_ImagesScaled.Dispose();
          ho_ImagesScaled = ExpTmpOutVar_0;
          }
        }
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
      {
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_Type, "byte", out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
        {
          //Shift the gray values from [0-255] to the expected range for byte images.
          hv_RescaleRange.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RescaleRange = (hv_ImageRangeMax-hv_ImageRangeMin)/255.0;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ImageSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_Indices+1);
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImage(ho_ImageSelected, out ExpTmpOutVar_0, hv_RescaleRange, 
              hv_ImageRangeMin);
          ho_ImageSelected.Dispose();
          ho_ImageSelected = ExpTmpOutVar_0;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0, 
              hv_Indices+1);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleNotEqual("none"))) != 0)
      {
        throw new HalconException("Unsupported parameter value for 'normalization_type'");
      }
      //
      //Ensure that the number of channels of the resulting images is consistent with the
      //number of channels of the given model. The only exceptions that are adapted below
      //are combinations of 1- and 3-channel images if ImageNumChannels is either 1 or 3.
      if ((int)((new HTuple(hv_ImageNumChannels.TupleEqual(1))).TupleOr(new HTuple(hv_ImageNumChannels.TupleEqual(
          3)))) != 0)
      {
        hv_CurrentNumChannels.Dispose();
        HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_CurrentNumChannels);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DiffNumChannelsIndices.Dispose();
        HOperatorSet.TupleFind(hv_CurrentNumChannels.TupleNotEqualElem(hv_OutputNumChannels), 
            1, out hv_DiffNumChannelsIndices);
        }
        if ((int)(new HTuple(hv_DiffNumChannelsIndices.TupleNotEqual(-1))) != 0)
        {
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_DiffNumChannelsIndices.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            hv_DiffNumChannelsIndex.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DiffNumChannelsIndex = hv_DiffNumChannelsIndices.TupleSelect(
                hv_Index);
            }
            hv_ImageIndex.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageIndex = hv_DiffNumChannelsIndex+1;
            }
            hv_NumChannels.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumChannels = hv_CurrentNumChannels.TupleSelect(
                hv_ImageIndex-1);
            }
            ho_ImageSelected.Dispose();
            HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, 
                hv_ImageIndex);
            if ((int)((new HTuple(hv_NumChannels.TupleEqual(1))).TupleAnd(new HTuple(hv_ImageNumChannels.TupleEqual(
                3)))) != 0)
            {
              //Conversion from 1- to 3-channel image required
              ho_ThreeChannelImage.Dispose();
              HOperatorSet.Compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected, 
                  out ho_ThreeChannelImage);
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage, 
                  out ExpTmpOutVar_0, hv_ImageIndex);
              ho_Images_COPY_INP_TMP.Dispose();
              ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
              }
            }
            else if ((int)((new HTuple(hv_NumChannels.TupleEqual(3))).TupleAnd(
                new HTuple(hv_ImageNumChannels.TupleEqual(1)))) != 0)
            {
              //Conversion from 3- to 1-channel image required
              ho_SingleChannelImage.Dispose();
              HOperatorSet.Rgb1ToGray(ho_ImageSelected, out ho_SingleChannelImage
                  );
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage, 
                  out ExpTmpOutVar_0, hv_ImageIndex);
              ho_Images_COPY_INP_TMP.Dispose();
              ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
              }
            }
            else
            {
              throw new HalconException(((("Unexpected error adapting the number of channels. The number of channels of the resulting image is "+hv_NumChannels)+new HTuple(", but the number of channels of the model is "))+hv_ImageNumChannels)+".");
            }
          }
        }
      }
      //
      //In case the image domains were preserved, they need to be set back into the images.
      if ((int)(hv_PreserveDomain) != 0)
      {
        hv_NumDomains.Dispose();
        HOperatorSet.CountObj(ho_PreservedDomains, out hv_NumDomains);
        HTuple end_val254 = hv_NumDomains;
        HTuple step_val254 = 1;
        for (hv_DomainIndex=1; hv_DomainIndex.Continue(end_val254, step_val254); hv_DomainIndex = hv_DomainIndex.TupleAdd(step_val254))
        {
          ho_ImageSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_DomainIndex);
          ho_DomainSelected.Dispose();
          HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected, hv_DomainIndex);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReduceDomain(ho_ImageSelected, ho_DomainSelected, out ExpTmpOutVar_0
              );
          ho_ImageSelected.Dispose();
          ho_ImageSelected = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0, 
              hv_DomainIndex);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
      }
      //
      //Write preprocessed images to output variable.
      ho_ImagesPreprocessed.Dispose();
      ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
      //
      ho_Images_COPY_INP_TMP.Dispose();
      ho_PreservedDomains.Dispose();
      ho_ImageSelected.Dispose();
      ho_DomainSelected.Dispose();
      ho_ImagesScaled.Dispose();
      ho_ImageScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ThreeChannelImage.Dispose();
      ho_SingleChannelImage.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_InputNumChannels.Dispose();
      hv_OutputNumChannels.Dispose();
      hv_NumChannels1.Dispose();
      hv_NumChannels3.Dispose();
      hv_AreInputNumChannels1.Dispose();
      hv_AreInputNumChannels3.Dispose();
      hv_AreInputNumChannels1Or3.Dispose();
      hv_ValidNumChannels.Dispose();
      hv_ValidNumChannelsText.Dispose();
      hv_PreserveDomain.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv_UniqRow1.Dispose();
      hv_UniqColumn1.Dispose();
      hv_UniqRow2.Dispose();
      hv_UniqColumn2.Dispose();
      hv_RectangleIndex.Dispose();
      hv_OriginalWidth.Dispose();
      hv_OriginalHeight.Dispose();
      hv_UniqWidth.Dispose();
      hv_UniqHeight.Dispose();
      hv_ScaleWidth.Dispose();
      hv_ScaleHeight.Dispose();
      hv_ScaleIndex.Dispose();
      hv_ImageIndex.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();
      hv_MeanValues.Dispose();
      hv_DeviationValues.Dispose();
      hv_UseDefaultNormalizationValues.Dispose();
      hv_Exception.Dispose();
      hv_Indices.Dispose();
      hv_RescaleRange.Dispose();
      hv_CurrentNumChannels.Dispose();
      hv_DiffNumChannelsIndices.Dispose();
      hv_Index.Dispose();
      hv_DiffNumChannelsIndex.Dispose();
      hv_NumDomains.Dispose();
      hv_DomainIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Images_COPY_INP_TMP.Dispose();
      ho_PreservedDomains.Dispose();
      ho_ImageSelected.Dispose();
      ho_DomainSelected.Dispose();
      ho_ImagesScaled.Dispose();
      ho_ImageScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ThreeChannelImage.Dispose();
      ho_SingleChannelImage.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_InputNumChannels.Dispose();
      hv_OutputNumChannels.Dispose();
      hv_NumChannels1.Dispose();
      hv_NumChannels3.Dispose();
      hv_AreInputNumChannels1.Dispose();
      hv_AreInputNumChannels3.Dispose();
      hv_AreInputNumChannels1Or3.Dispose();
      hv_ValidNumChannels.Dispose();
      hv_ValidNumChannelsText.Dispose();
      hv_PreserveDomain.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv_UniqRow1.Dispose();
      hv_UniqColumn1.Dispose();
      hv_UniqRow2.Dispose();
      hv_UniqColumn2.Dispose();
      hv_RectangleIndex.Dispose();
      hv_OriginalWidth.Dispose();
      hv_OriginalHeight.Dispose();
      hv_UniqWidth.Dispose();
      hv_UniqHeight.Dispose();
      hv_ScaleWidth.Dispose();
      hv_ScaleHeight.Dispose();
      hv_ScaleIndex.Dispose();
      hv_ImageIndex.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();
      hv_MeanValues.Dispose();
      hv_DeviationValues.Dispose();
      hv_UseDefaultNormalizationValues.Dispose();
      hv_Exception.Dispose();
      hv_Indices.Dispose();
      hv_RescaleRange.Dispose();
      hv_CurrentNumChannels.Dispose();
      hv_DiffNumChannelsIndices.Dispose();
      hv_Index.Dispose();
      hv_DiffNumChannelsIndex.Dispose();
      hv_NumDomains.Dispose();
      hv_DomainIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR detection models. 
  public void preprocess_dl_model_images_ocr_detection (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image=null, ho_ImageScaled=null;
    HObject ho_Channel=null, ho_ChannelScaled=null, ho_ImageG=null;
    HObject ho_ImageB=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
    HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ImageTypes = new HTuple(), hv_InputImageWidths = new HTuple();
    HTuple hv_InputImageHeights = new HTuple(), hv_ImageRange = new HTuple();
    HTuple hv_I = new HTuple(), hv_InputImageWidth = new HTuple();
    HTuple hv_InputImageHeight = new HTuple(), hv_ZoomFactorWidth = new HTuple();
    HTuple hv_ZoomFactorHeight = new HTuple(), hv_ZoomHeight = new HTuple();
    HTuple hv_ZoomWidth = new HTuple(), hv_ChannelIndex = new HTuple();
    HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_Scale = new HTuple(), hv_Shift = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
    HOperatorSet.GenEmptyObj(out ho_ImageG);
    HOperatorSet.GenEmptyObj(out ho_ImageB);
    try
    {
      //This procedure preprocesses the provided images according to the parameters
      //in the dictionary DLPreprocessParam for an ocr_detection model.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_NormalizationType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      //Check the preprocessing parameters.
      if ((int)(new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))) != 0)
      {
        throw new HalconException("The only 'model_type' value supported is'ocr_detection'.");
      }
      if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(3))) != 0)
      {
        throw new HalconException("The only 'image_num_channels' value supported for ocr_detection models is 3.");
      }
      if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
      {
        throw new HalconException("The only 'domain_handling' value supported for ocr_detection models is 'full_domain'.");
      }
      if ((int)((new HTuple(hv_NormalizationType.TupleNotEqual("none"))).TupleAnd(
          new HTuple(hv_NormalizationType.TupleNotEqual("all_channels")))) != 0)
      {
        throw new HalconException("The 'normalization_type' values supported for ocr_detection models are 'all_channels' and 'none'.");
      }
      //
      //Get the image properties.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
      hv_ImageTypes.Dispose();
      HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_ImageTypes);
      hv_InputImageWidths.Dispose();hv_InputImageHeights.Dispose();
      HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_InputImageWidths, 
          out hv_InputImageHeights);
      //
      //Check the image properties.
      if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
      {
        throw new HalconException("Please provide some images to preprocess.");
      }
      if ((int)(new HTuple(hv_NumImages.TupleNotEqual(new HTuple(hv_ImageTypes.TupleRegexpTest(
          "byte"))))) != 0)
      {
        throw new HalconException("Please provide only images of type 'byte'.");
      }
      if ((int)(new HTuple(hv_NumImages.TupleNotEqual((new HTuple(((hv_NumChannels.TupleEqualElem(
          1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum()))) != 0)
      {
        throw new HalconException("Please provide only 1- or 3-channels images for ocr_detection models.");
      }
      //
      //Preprocess the images.
      hv_ImageRange.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRange = ((hv_ImageRangeMax-hv_ImageRangeMin)).TupleReal()
          ;
      }
      HTuple end_val49 = hv_NumImages-1;
      HTuple step_val49 = 1;
      for (hv_I=0; hv_I.Continue(end_val49, step_val49); hv_I = hv_I.TupleAdd(step_val49))
      {
        hv_InputImageWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageWidth = hv_InputImageWidths.TupleSelect(
            hv_I);
        }
        hv_InputImageHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageHeight = hv_InputImageHeights.TupleSelect(
            hv_I);
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_Image, hv_I+1);
        }
        //
        //Calculate aspect-ratio preserving zoom factors
        hv_ZoomFactorWidth.Dispose();hv_ZoomFactorHeight.Dispose();
        calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight, 
            hv_ImageWidth, hv_ImageHeight, hv_DLPreprocessParam, out hv_ZoomFactorWidth, 
            out hv_ZoomFactorHeight);
        //
        //Zoom image
        hv_ZoomHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomHeight = ((hv_ZoomFactorHeight*hv_InputImageHeight)).TupleRound()
            ;
        }
        hv_ZoomWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomWidth = ((hv_ZoomFactorWidth*hv_InputImageWidth)).TupleRound()
            ;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ZoomWidth, hv_ZoomHeight, 
            "constant");
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        //
        //Convert to real and normalize
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "real");
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        if ((int)(new HTuple(hv_NormalizationType.TupleEqual("all_channels"))) != 0)
        {
          ho_ImageScaled.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImageScaled);
          HTuple end_val67 = hv_NumChannels.TupleSelect(
              hv_I);
          HTuple step_val67 = 1;
          for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val67, step_val67); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val67))
          {
            ho_Channel.Dispose();
            HOperatorSet.AccessChannel(ho_Image, out ho_Channel, hv_ChannelIndex);
            hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
            HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_Min, out hv_Max, 
                out hv_Range);
            if ((int)(new HTuple(((hv_Max-hv_Min)).TupleEqual(0))) != 0)
            {
              hv_Scale.Dispose();
              hv_Scale = 1;
            }
            else
            {
              hv_Scale.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Scale = (hv_ImageRangeMax-hv_ImageRangeMin)/(hv_Max-hv_Min);
              }
            }
            hv_Shift.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Shift = ((-hv_Scale)*hv_Min)+hv_ImageRangeMin;
            }
            ho_ChannelScaled.Dispose();
            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                );
            ho_ImageScaled.Dispose();
            ho_ImageScaled = ExpTmpOutVar_0;
            }
          }
          ho_Image.Dispose();
          ho_Image = new HObject(ho_ImageScaled);
        }
        else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_ImageRange/255.0, 
              hv_ImageRangeMin);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
        }
        //
        //Obtain an RGB image.
        if ((int)(new HTuple(((hv_NumChannels.TupleSelect(hv_I))).TupleEqual(1))) != 0)
        {
          ho_ImageG.Dispose();
          HOperatorSet.CopyImage(ho_Image, out ho_ImageG);
          ho_ImageB.Dispose();
          HOperatorSet.CopyImage(ho_Image, out ho_ImageB);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.Compose3(ho_Image, ho_ImageG, ho_ImageB, out ExpTmpOutVar_0
              );
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
        }
        //
        //Apply padding to fit the desired image size.
        //The padding value is zero, corresponding to the
        //border handling of the convolution layers.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ChangeFormat(ho_Image, out ExpTmpOutVar_0, hv_ImageWidth, hv_ImageHeight);
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_Image, out ExpTmpOutVar_0, 
            hv_I+1);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Return the preprocessed images.
      ho_ImagesPreprocessed.Dispose();
      ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Image.Dispose();
      ho_ImageScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageTypes.Dispose();
      hv_InputImageWidths.Dispose();
      hv_InputImageHeights.Dispose();
      hv_ImageRange.Dispose();
      hv_I.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_ZoomFactorWidth.Dispose();
      hv_ZoomFactorHeight.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_ChannelIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Images_COPY_INP_TMP.Dispose();
      ho_Image.Dispose();
      ho_ImageScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageTypes.Dispose();
      hv_InputImageWidths.Dispose();
      hv_InputImageHeights.Dispose();
      hv_ImageRange.Dispose();
      hv_I.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_ZoomFactorWidth.Dispose();
      hv_ZoomFactorHeight.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_ChannelIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR recognition models. 
  public void preprocess_dl_model_images_ocr_recognition (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TargetImage, ho_Image=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
    HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ImageTypes = new HTuple(), hv_InputImageWidths = new HTuple();
    HTuple hv_InputImageHeights = new HTuple(), hv_PaddingGrayval = new HTuple();
    HTuple hv_ImageRange = new HTuple(), hv_I = new HTuple();
    HTuple hv_InputImageWidth = new HTuple(), hv_InputImageHeight = new HTuple();
    HTuple hv_InputImageWidthHeightRatio = new HTuple(), hv_ZoomHeight = new HTuple();
    HTuple hv_ZoomWidth = new HTuple(), hv_GrayvalMin = new HTuple();
    HTuple hv_GrayvalMax = new HTuple(), hv_Range = new HTuple();
    HTuple hv_GrayvalRange = new HTuple(), hv_Scale = new HTuple();
    HTuple hv_Shift = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_TargetImage);
    HOperatorSet.GenEmptyObj(out ho_Image);
    try
    {
      //This procedure preprocesses the provided Images according to the parameters
      //in the dictionary DLPreprocessParam for an ocr_recognition model.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_NormalizationType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      //Check the preprocessing parameters.
      if ((int)(new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition"))) != 0)
      {
        throw new HalconException("The only 'model_type' value supported is'ocr_recognition'.");
      }
      if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(1))) != 0)
      {
        throw new HalconException("The only 'image_num_channels' value supported for ocr_recognition models is 1.");
      }
      if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
      {
        throw new HalconException("The only 'domain_handling' value supported for ocr_recognition models is 'full_domain'.");
      }
      if ((int)((new HTuple((new HTuple(hv_NormalizationType.TupleNotEqual("none"))).TupleAnd(
          new HTuple(hv_NormalizationType.TupleNotEqual("first_channel"))))).TupleAnd(
          new HTuple(hv_NormalizationType.TupleNotEqual("all_channels")))) != 0)
      {
        throw new HalconException(new HTuple("The 'normalization_type' values supported for ocr_recognition models are 'first_channel', 'all_channels' and 'none'."));
      }
      //
      //Get the image properties.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
      hv_ImageTypes.Dispose();
      HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_ImageTypes);
      hv_InputImageWidths.Dispose();hv_InputImageHeights.Dispose();
      HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_InputImageWidths, 
          out hv_InputImageHeights);
      //
      //Check the image properties.
      if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
      {
        throw new HalconException("Please provide some images to preprocess.");
      }
      if ((int)(new HTuple(hv_NumImages.TupleNotEqual(new HTuple(hv_ImageTypes.TupleRegexpTest(
          "byte|real"))))) != 0)
      {
        throw new HalconException("Please provide only images of type 'byte' or 'real'.");
      }
      if ((int)(new HTuple(hv_NumImages.TupleNotEqual((new HTuple(((hv_NumChannels.TupleEqualElem(
          1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum()))) != 0)
      {
        throw new HalconException("Please provide only 1- or 3-channels images for ocr_recognition models.");
      }
      //
      //Preprocess the images.
      hv_PaddingGrayval.Dispose();
      hv_PaddingGrayval = 0.0;
      hv_ImageRange.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRange = ((hv_ImageRangeMax-hv_ImageRangeMin)).TupleReal()
          ;
      }
      ho_TargetImage.Dispose();
      HOperatorSet.GenImageConst(out ho_TargetImage, "real", hv_ImageWidth, hv_ImageHeight);
      HOperatorSet.OverpaintRegion(ho_TargetImage, ho_TargetImage, hv_PaddingGrayval, 
          "fill");
      HTuple end_val52 = hv_NumImages-1;
      HTuple step_val52 = 1;
      for (hv_I=0; hv_I.Continue(end_val52, step_val52); hv_I = hv_I.TupleAdd(step_val52))
      {
        hv_InputImageWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageWidth = hv_InputImageWidths.TupleSelect(
            hv_I);
        }
        hv_InputImageHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageHeight = hv_InputImageHeights.TupleSelect(
            hv_I);
        }
        hv_InputImageWidthHeightRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_InputImageWidthHeightRatio = hv_InputImageWidth/(hv_InputImageHeight.TupleReal()
            );
        }
        //
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_Image, hv_I+1);
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        if ((int)(new HTuple(((hv_NumChannels.TupleSelect(hv_I))).TupleEqual(3))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.Rgb1ToGray(ho_Image, out ExpTmpOutVar_0);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
        }
        //
        hv_ZoomHeight.Dispose();
        hv_ZoomHeight = new HTuple(hv_ImageHeight);
        hv_ZoomWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomWidth = hv_ImageWidth.TupleMin2(
            ((hv_ImageHeight*hv_InputImageWidthHeightRatio)).TupleInt());
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ZoomWidth, hv_ZoomHeight, 
            "constant");
        ho_Image.Dispose();
        ho_Image = ExpTmpOutVar_0;
        }
        if ((int)(new HTuple(((hv_ImageTypes.TupleSelect(hv_I))).TupleEqual("byte"))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "real");
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
        }
        if ((int)((new HTuple(hv_NormalizationType.TupleEqual("first_channel"))).TupleOr(
            new HTuple(hv_NormalizationType.TupleEqual("all_channels")))) != 0)
        {
          hv_GrayvalMin.Dispose();hv_GrayvalMax.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_Image, ho_Image, 0, out hv_GrayvalMin, out hv_GrayvalMax, 
              out hv_Range);
          hv_GrayvalRange.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GrayvalRange = ((hv_GrayvalMax-hv_GrayvalMin)).TupleReal()
              ;
          }
          if ((int)(new HTuple(hv_GrayvalRange.TupleEqual(0.0))) != 0)
          {
            hv_Scale.Dispose();
            hv_Scale = 1.0;
          }
          else
          {
            hv_Scale.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Scale = hv_ImageRange/hv_GrayvalRange;
            }
          }
          hv_Shift.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Shift = ((-hv_Scale)*hv_GrayvalMin)+hv_ImageRangeMin;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_Scale, hv_Shift);
          ho_Image.Dispose();
          ho_Image = ExpTmpOutVar_0;
          }
        }
        else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
        {
          if ((int)(new HTuple(((hv_ImageTypes.TupleSelect(hv_I))).TupleEqual("byte"))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_ImageRange/255.0, 
                hv_ImageRangeMin);
            ho_Image.Dispose();
            ho_Image = ExpTmpOutVar_0;
            }
          }
        }
        //
        HOperatorSet.OverpaintGray(ho_TargetImage, ho_Image);
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReduceDomain(ho_TargetImage, ho_Image, out ExpTmpOutVar_0);
        ho_TargetImage.Dispose();
        ho_TargetImage = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_TargetImage, out ExpTmpOutVar_0, 
            hv_I+1);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Return the preprocessed images.
      ho_ImagesPreprocessed.Dispose();
      ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
      ho_Images_COPY_INP_TMP.Dispose();
      ho_TargetImage.Dispose();
      ho_Image.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageTypes.Dispose();
      hv_InputImageWidths.Dispose();
      hv_InputImageHeights.Dispose();
      hv_PaddingGrayval.Dispose();
      hv_ImageRange.Dispose();
      hv_I.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_InputImageWidthHeightRatio.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_GrayvalMin.Dispose();
      hv_GrayvalMax.Dispose();
      hv_Range.Dispose();
      hv_GrayvalRange.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Images_COPY_INP_TMP.Dispose();
      ho_TargetImage.Dispose();
      ho_Image.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_NumImages.Dispose();
      hv_NumChannels.Dispose();
      hv_ImageTypes.Dispose();
      hv_InputImageWidths.Dispose();
      hv_InputImageHeights.Dispose();
      hv_PaddingGrayval.Dispose();
      hv_ImageRange.Dispose();
      hv_I.Dispose();
      hv_InputImageWidth.Dispose();
      hv_InputImageHeight.Dispose();
      hv_InputImageWidthHeightRatio.Dispose();
      hv_ZoomHeight.Dispose();
      hv_ZoomWidth.Dispose();
      hv_GrayvalMin.Dispose();
      hv_GrayvalMax.Dispose();
      hv_Range.Dispose();
      hv_GrayvalRange.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection and Instance Segmentation
  // Short Description: Preprocess the instance segmentation masks for a sample given by the dictionary DLSample. 
  private void preprocess_dl_model_instance_masks (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_InstanceMasks, ho_Domain=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_NumMasks = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
    HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
    HTuple hv_FactorResampleWidth = new HTuple(), hv_FactorResampleHeight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_InstanceMasks);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    try
    {
      //
      //This procedure preprocesses the instance masks of a DLSample.
      //
      //Check preprocess parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get relevant preprocess parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //
      //Get the preprocessed instance masks.
      ho_InstanceMasks.Dispose();
      HOperatorSet.GetDictObject(out ho_InstanceMasks, hv_DLSample, "mask");
      //
      //Get the number of instance masks.
      hv_NumMasks.Dispose();
      HOperatorSet.CountObj(ho_InstanceMasks, out hv_NumMasks);
      //
      //Domain handling of the image to be preprocessed.
      //
      hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
      HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //Clip and translate masks w.r.t. the image domain
        ho_Domain.Dispose();
        HOperatorSet.GetDomain(ho_ImageRaw, out ho_Domain);
        hv_DomainRow1.Dispose();hv_DomainColumn1.Dispose();hv_DomainRow2.Dispose();hv_DomainColumn2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_Domain, out hv_DomainRow1, out hv_DomainColumn1, 
            out hv_DomainRow2, out hv_DomainColumn2);
        //
        //Clip the remaining regions to the domain.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ClipRegion(ho_InstanceMasks, out ExpTmpOutVar_0, hv_DomainRow1, 
            hv_DomainColumn1, hv_DomainRow2, hv_DomainColumn2);
        ho_InstanceMasks.Dispose();
        ho_InstanceMasks = ExpTmpOutVar_0;
        }
        hv_WidthRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WidthRaw = (hv_DomainColumn2-hv_DomainColumn1)+1.0;
        }
        hv_HeightRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HeightRaw = (hv_DomainRow2-hv_DomainRow1)+1.0;
        }
        //We need to move the remaining regions back to the origin,
        //because crop_domain will be applied to the image
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.MoveRegion(ho_InstanceMasks, out ExpTmpOutVar_0, -hv_DomainRow1, 
            -hv_DomainColumn1);
        ho_InstanceMasks.Dispose();
        ho_InstanceMasks = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Zoom masks only if the image has a different size than the specified size.
      if ((int)(((hv_ImageWidth.TupleNotEqualElem(hv_WidthRaw))).TupleOr(hv_ImageHeight.TupleNotEqualElem(
          hv_HeightRaw))) != 0)
      {
        //Calculate rescaling factor.
        hv_FactorResampleWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
            )/hv_WidthRaw;
        }
        hv_FactorResampleHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
            )/hv_HeightRaw;
        }

        //Zoom the masks.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomRegion(ho_InstanceMasks, out ExpTmpOutVar_0, hv_FactorResampleWidth, 
            hv_FactorResampleHeight);
        ho_InstanceMasks.Dispose();
        ho_InstanceMasks = ExpTmpOutVar_0;
        }
      }
      //
      //Set the preprocessed instance masks.
      HOperatorSet.SetDictObject(ho_InstanceMasks, hv_DLSample, "mask");
      //
      //
      ho_InstanceMasks.Dispose();
      ho_Domain.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_NumMasks.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_InstanceMasks.Dispose();
      ho_Domain.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_NumMasks.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_DomainRow1.Dispose();
      hv_DomainColumn1.Dispose();
      hv_DomainRow2.Dispose();
      hv_DomainColumn2.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
  // Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. 
  public void preprocess_dl_model_segmentations (HObject ho_ImagesRaw, HObject ho_Segmentations, 
      out HObject ho_SegmentationsPreprocessed, HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Domain=null, ho_SelectedSeg=null;
    HObject ho_SelectedDomain=null;

    // Local copy input parameter variables 
    HObject ho_Segmentations_COPY_INP_TMP;
    ho_Segmentations_COPY_INP_TMP = new HObject(ho_Segmentations);



    // Local control variables 

    HTuple hv_NumberImages = new HTuple(), hv_NumberSegmentations = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WidthSeg = new HTuple(), hv_HeightSeg = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_ClassesToBackground = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_IsInt = new HTuple(), hv_IndexImage = new HTuple();
    HTuple hv_ImageWidthRaw = new HTuple(), hv_ImageHeightRaw = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_EqualReal = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationsPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_SelectedSeg);
    HOperatorSet.GenEmptyObj(out ho_SelectedDomain);
    try
    {
      //
      //This procedure preprocesses the segmentation or weight images
      //given by Segmentations so that they can be handled by
      //train_dl_model_batch and apply_dl_model.
      //
      //Check input data.
      //Examine number of images.
      hv_NumberImages.Dispose();
      HOperatorSet.CountObj(ho_ImagesRaw, out hv_NumberImages);
      hv_NumberSegmentations.Dispose();
      HOperatorSet.CountObj(ho_Segmentations_COPY_INP_TMP, out hv_NumberSegmentations);
      if ((int)(new HTuple(hv_NumberImages.TupleNotEqual(hv_NumberSegmentations))) != 0)
      {
        throw new HalconException("Equal number of images given in ImagesRaw and Segmentations required");
      }
      //Size of images.
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_ImagesRaw, out hv_Width, out hv_Height);
      hv_WidthSeg.Dispose();hv_HeightSeg.Dispose();
      HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_WidthSeg, out hv_HeightSeg);
      if ((int)((new HTuple(hv_Width.TupleNotEqual(hv_WidthSeg))).TupleOr(new HTuple(hv_Height.TupleNotEqual(
          hv_HeightSeg)))) != 0)
      {
        throw new HalconException("Equal size of the images given in ImagesRaw and Segmentations required.");
      }
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the relevant preprocessing parameters.
      hv_DLModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //Segmentation specific parameters.
      hv_SetBackgroundID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
      hv_ClassesToBackground.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassesToBackground);
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
      //
      //Check the input parameter for setting the background ID.
      if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
      {
        //Check that the model is a segmentation model.
        if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
        {
          throw new HalconException("Setting class IDs to background is only implemented for segmentation.");
        }
        //Check the background ID.
        hv_IsInt.Dispose();
        HOperatorSet.TupleIsIntElem(hv_SetBackgroundID, out hv_IsInt);
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Only one class_id as 'set_background_id' allowed.");
        }
        else if ((int)(hv_IsInt.TupleNot()) != 0)
        {
          //Given class_id has to be of type int.
          throw new HalconException("The class_id given as 'set_background_id' has to be of type int.");
        }
        //Check the values of ClassesToBackground.
        if ((int)(new HTuple((new HTuple(hv_ClassesToBackground.TupleLength())).TupleEqual(
            0))) != 0)
        {
          //Check that the given classes are of length > 0.
          throw new HalconException(new HTuple("If 'set_background_id' is given, 'class_ids_background' must at least contain this class ID."));
        }
        else if ((int)(new HTuple(((hv_ClassesToBackground.TupleIntersection(
            hv_IgnoreClassIDs))).TupleNotEqual(new HTuple()))) != 0)
        {
          //Check that class_ids_background is not included in the ignore_class_ids of the DLModel.
          throw new HalconException("The given 'class_ids_background' must not be included in the 'ignore_class_ids' of the model.");
        }
      }
      //
      //Domain handling of the image to be preprocessed.
      //
      if ((int)((new HTuple(hv_DomainHandling.TupleEqual("full_domain"))).TupleOr(
          new HTuple(hv_DomainHandling.TupleEqual("keep_domain")))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //If the domain should be cropped the domain has to be transferred
        //from the raw image to the segmentation image.
        ho_Domain.Dispose();
        HOperatorSet.GetDomain(ho_ImagesRaw, out ho_Domain);
        HTuple end_val66 = hv_NumberImages;
        HTuple step_val66 = 1;
        for (hv_IndexImage=1; hv_IndexImage.Continue(end_val66, step_val66); hv_IndexImage = hv_IndexImage.TupleAdd(step_val66))
        {
          ho_SelectedSeg.Dispose();
          HOperatorSet.SelectObj(ho_Segmentations_COPY_INP_TMP, out ho_SelectedSeg, 
              hv_IndexImage);
          ho_SelectedDomain.Dispose();
          HOperatorSet.SelectObj(ho_Domain, out ho_SelectedDomain, hv_IndexImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ChangeDomain(ho_SelectedSeg, ho_SelectedDomain, out ExpTmpOutVar_0
              );
          ho_SelectedSeg.Dispose();
          ho_SelectedSeg = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Segmentations_COPY_INP_TMP, ho_SelectedSeg, 
              out ExpTmpOutVar_0, hv_IndexImage);
          ho_Segmentations_COPY_INP_TMP.Dispose();
          ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.CropDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Preprocess the segmentation images.
      //
      //Set all background classes to the given background class ID.
      if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        reassign_pixel_values(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ClassesToBackground, hv_SetBackgroundID);
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Zoom images only if they have a different size than the specified size.
      hv_ImageWidthRaw.Dispose();hv_ImageHeightRaw.Dispose();
      HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_ImageWidthRaw, 
          out hv_ImageHeightRaw);
      hv_EqualWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
          hv_ImageWidthRaw);
      }
      hv_EqualHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
          hv_ImageHeightRaw);
      }
      if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
          new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the type of the input images
      //and convert if necessary.
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_Segmentations_COPY_INP_TMP, out hv_Type);
      hv_EqualReal.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualReal = hv_Type.TupleEqualElem(
          "real");
      }
      //
      if ((int)(new HTuple(((hv_EqualReal.TupleMin())).TupleEqual(0))) != 0)
      {
        //Convert the image type to 'real',
        //because the model expects 'real' images.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Write preprocessed Segmentations to output variable.
      ho_SegmentationsPreprocessed.Dispose();
      ho_SegmentationsPreprocessed = new HObject(ho_Segmentations_COPY_INP_TMP);
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Domain.Dispose();
      ho_SelectedSeg.Dispose();
      ho_SelectedDomain.Dispose();

      hv_NumberImages.Dispose();
      hv_NumberSegmentations.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WidthSeg.Dispose();
      hv_HeightSeg.Dispose();
      hv_DLModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassesToBackground.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_IsInt.Dispose();
      hv_IndexImage.Dispose();
      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_EqualReal.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Domain.Dispose();
      ho_SelectedSeg.Dispose();
      ho_SelectedDomain.Dispose();

      hv_NumberImages.Dispose();
      hv_NumberSegmentations.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WidthSeg.Dispose();
      hv_HeightSeg.Dispose();
      hv_DLModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassesToBackground.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_IsInt.Dispose();
      hv_IndexImage.Dispose();
      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_EqualReal.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. 
  public void preprocess_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    HObject ho_ImageRaw=null, ho_ImagePreprocessed=null;
    HObject ho_AnomalyImageRaw=null, ho_AnomalyImagePreprocessed=null;
    HObject ho_SegmentationRaw=null, ho_SegmentationPreprocessed=null;
    HObject ho_ImageRawDomain=null;

    // Local control variables 

    HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_ImageExists = new HTuple(), hv_KeysExists = new HTuple();
    HTuple hv_AnomalyParamExist = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
    HTuple hv_Rectangle2ParamExist = new HTuple(), hv_InstanceMaskParamExist = new HTuple();
    HTuple hv_SegmentationParamExist = new HTuple(), hv_OCRParamExist = new HTuple();
    HTuple   hv_DLPreprocessParam_COPY_INP_TMP = new HTuple(hv_DLPreprocessParam);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRaw);
    HOperatorSet.GenEmptyObj(out ho_ImagePreprocessed);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImageRaw);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImagePreprocessed);
    HOperatorSet.GenEmptyObj(out ho_SegmentationRaw);
    HOperatorSet.GenEmptyObj(out ho_SegmentationPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_ImageRawDomain);
    try
    {
      //
      //This procedure preprocesses all images of the sample dictionaries
      //in the tuple DLSampleBatch.
      //The images are preprocessed according to the parameters provided
      //in DLPreprocessParam.
      //
      //Check the validity of the preprocessing parameters.
      //The procedure check_dl_preprocess_param might change DLPreprocessParam.
      //To avoid race conditions when preprocess_dl_samples is used from
      //multiple threads with the same DLPreprocessParam dictionary,
      //work on a copy.
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.CopyDict(hv_DLPreprocessParam_COPY_INP_TMP, new HTuple(), new HTuple(), 
          out ExpTmpOutVar_0);
      hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
      hv_DLPreprocessParam_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      check_dl_preprocess_param(hv_DLPreprocessParam_COPY_INP_TMP);
      //
      //
      //
      //Preprocess the sample entries.
      //
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_DLSampleBatch.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        hv_DLSample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample = hv_DLSampleBatch.TupleSelect(
            hv_SampleIndex);
        }
        //
        //Preprocess augmentation data.
        preprocess_dl_model_augmentation_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
        //
        //Check the existence of the sample keys.
        hv_ImageExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image", out hv_ImageExists);
        //
        //Preprocess the images.
        if ((int)(hv_ImageExists) != 0)
        {
          //
          //Get the image.
          ho_ImageRaw.Dispose();
          HOperatorSet.GetDictObject(out ho_ImageRaw, hv_DLSample, "image");
          //
          //Preprocess the image.
          ho_ImagePreprocessed.Dispose();
          preprocess_dl_model_images(ho_ImageRaw, out ho_ImagePreprocessed, hv_DLPreprocessParam_COPY_INP_TMP);
          //
          //Replace the image in the dictionary.
          HOperatorSet.SetDictObject(ho_ImagePreprocessed, hv_DLSample, "image");
          //
          //Check existence of model specific sample keys:
          //- 'anomaly_ground_truth':
          //  For model 'type' = 'anomaly_detection' and
          //  model 'type' = 'gc_anomaly_detection'
          //- 'bbox_row1':
          //  For 'instance_type' = 'rectangle1' and
          //  model 'type' = 'detection'
          //- 'bbox_phi':
          //  For 'instance_type' = 'rectangle2' and
          //  model 'type' = 'detection'
          //- 'mask':
          //  For 'instance_type' = 'rectangle1',
          //  model 'type' = 'detection', and
          //  'instance_segmentation' = true
          //- 'segmentation_image':
          //  For model 'type' = 'segmentation'
          hv_KeysExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSample, "key_exists", (((((new HTuple("anomaly_ground_truth")).TupleConcat(
              "bbox_row1")).TupleConcat("bbox_phi")).TupleConcat("mask")).TupleConcat(
              "segmentation_image")).TupleConcat("word"), out hv_KeysExists);
          hv_AnomalyParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnomalyParamExist = hv_KeysExists.TupleSelect(
              0);
          }
          hv_Rectangle1ParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Rectangle1ParamExist = hv_KeysExists.TupleSelect(
              1);
          }
          hv_Rectangle2ParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Rectangle2ParamExist = hv_KeysExists.TupleSelect(
              2);
          }
          hv_InstanceMaskParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_InstanceMaskParamExist = hv_KeysExists.TupleSelect(
              3);
          }
          hv_SegmentationParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SegmentationParamExist = hv_KeysExists.TupleSelect(
              4);
          }
          hv_OCRParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_OCRParamExist = hv_KeysExists.TupleSelect(
              5);
          }
          //
          //Preprocess the anomaly ground truth for
          //model 'type' = 'anomaly_detection' or
          //model 'type' = 'gc_anomaly_detection' if present.
          if ((int)(hv_AnomalyParamExist) != 0)
          {
            //
            //Get the anomaly image.
            ho_AnomalyImageRaw.Dispose();
            HOperatorSet.GetDictObject(out ho_AnomalyImageRaw, hv_DLSample, "anomaly_ground_truth");
            //
            //Preprocess the anomaly image.
            ho_AnomalyImagePreprocessed.Dispose();
            preprocess_dl_model_anomaly(ho_AnomalyImageRaw, out ho_AnomalyImagePreprocessed, 
                hv_DLPreprocessParam_COPY_INP_TMP);
            //
            //Set preprocessed anomaly image.
            HOperatorSet.SetDictObject(ho_AnomalyImagePreprocessed, hv_DLSample, 
                "anomaly_ground_truth");
          }
          //
          //Preprocess depending on the model type.
          //If bounding boxes are given, rescale them as well.
          if ((int)(hv_Rectangle1ParamExist) != 0)
          {
            //
            //Preprocess the bounding boxes of type 'rectangle1'.
            preprocess_dl_model_bbox_rect1(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
          }
          else if ((int)(hv_Rectangle2ParamExist) != 0)
          {
            //
            //Preprocess the bounding boxes of type 'rectangle2'.
            preprocess_dl_model_bbox_rect2(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
          }
          if ((int)(hv_InstanceMaskParamExist) != 0)
          {
            //
            //Preprocess the instance masks.
            preprocess_dl_model_instance_masks(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
          }
          //
          //Preprocess the segmentation image if present.
          if ((int)(hv_SegmentationParamExist) != 0)
          {
            //
            //Get the segmentation image.
            ho_SegmentationRaw.Dispose();
            HOperatorSet.GetDictObject(out ho_SegmentationRaw, hv_DLSample, "segmentation_image");
            //
            //Preprocess the segmentation image.
            ho_SegmentationPreprocessed.Dispose();
            preprocess_dl_model_segmentations(ho_ImageRaw, ho_SegmentationRaw, out ho_SegmentationPreprocessed, 
                hv_DLPreprocessParam_COPY_INP_TMP);
            //
            //Set preprocessed segmentation image.
            HOperatorSet.SetDictObject(ho_SegmentationPreprocessed, hv_DLSample, 
                "segmentation_image");
          }
          //
          //Preprocess the word bounding boxes and generate targets.
          if ((int)(hv_OCRParamExist.TupleAnd(hv_Rectangle2ParamExist)) != 0)
          {
            //
            //Preprocess Sample.
            gen_dl_ocr_detection_targets(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
          }
          //
          //Preprocess 3D relevant data if present.
          hv_KeysExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSample, "key_exists", (((new HTuple("x")).TupleConcat(
              "y")).TupleConcat("z")).TupleConcat("normals"), out hv_KeysExists);
          if ((int)(hv_KeysExists.TupleMax()) != 0)
          {
            //We need to handle crop_domain before preprocess_dl_model_3d_data
            //if it is necessary.
            //Note, we are not cropping the image of DLSample because it has
            //been done by preprocess_dl_model_images.
            //Since we always keep the domain of 3D data we do not need to handle
            //'keep_domain' or 'full_domain'.
            ho_ImageRawDomain.Dispose();
            HOperatorSet.GetDomain(ho_ImageRaw, out ho_ImageRawDomain);
            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "x", hv_DLPreprocessParam_COPY_INP_TMP);
            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "y", hv_DLPreprocessParam_COPY_INP_TMP);
            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "z", hv_DLPreprocessParam_COPY_INP_TMP);
            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "normals", hv_DLPreprocessParam_COPY_INP_TMP);
            //
            preprocess_dl_model_3d_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
          }
        }
        else
        {
          throw new HalconException((new HTuple("All samples processed need to include an image, but the sample with index ")+hv_SampleIndex)+" does not.");
        }
      }
      //
      ho_ImageRaw.Dispose();
      ho_ImagePreprocessed.Dispose();
      ho_AnomalyImageRaw.Dispose();
      ho_AnomalyImagePreprocessed.Dispose();
      ho_SegmentationRaw.Dispose();
      ho_SegmentationPreprocessed.Dispose();
      ho_ImageRawDomain.Dispose();

      hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageExists.Dispose();
      hv_KeysExists.Dispose();
      hv_AnomalyParamExist.Dispose();
      hv_Rectangle1ParamExist.Dispose();
      hv_Rectangle2ParamExist.Dispose();
      hv_InstanceMaskParamExist.Dispose();
      hv_SegmentationParamExist.Dispose();
      hv_OCRParamExist.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageRaw.Dispose();
      ho_ImagePreprocessed.Dispose();
      ho_AnomalyImageRaw.Dispose();
      ho_AnomalyImagePreprocessed.Dispose();
      ho_SegmentationRaw.Dispose();
      ho_SegmentationPreprocessed.Dispose();
      ho_ImageRawDomain.Dispose();

      hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageExists.Dispose();
      hv_KeysExists.Dispose();
      hv_AnomalyParamExist.Dispose();
      hv_Rectangle1ParamExist.Dispose();
      hv_Rectangle2ParamExist.Dispose();
      hv_InstanceMaskParamExist.Dispose();
      hv_SegmentationParamExist.Dispose();
      hv_OCRParamExist.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Image / Manipulation
  // Short Description: Change value of ValuesToChange in Image to NewValue. 
  private void reassign_pixel_values (HObject ho_Image, out HObject ho_ImageOut, 
      HTuple hv_ValuesToChange, HTuple hv_NewValue)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RegionToChange, ho_RegionClass=null;

    // Local control variables 

    HTuple hv_IndexReset = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageOut);
    HOperatorSet.GenEmptyObj(out ho_RegionToChange);
    HOperatorSet.GenEmptyObj(out ho_RegionClass);
    try
    {
      //
      //This procedure sets all pixels of Image
      //with the values given in ValuesToChange to the given value NewValue.
      //
      ho_RegionToChange.Dispose();
      HOperatorSet.GenEmptyRegion(out ho_RegionToChange);
      for (hv_IndexReset=0; (int)hv_IndexReset<=(int)((new HTuple(hv_ValuesToChange.TupleLength()
          ))-1); hv_IndexReset = (int)hv_IndexReset + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_RegionClass.Dispose();
        HOperatorSet.Threshold(ho_Image, out ho_RegionClass, hv_ValuesToChange.TupleSelect(
            hv_IndexReset), hv_ValuesToChange.TupleSelect(hv_IndexReset));
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.Union2(ho_RegionToChange, ho_RegionClass, out ExpTmpOutVar_0
            );
        ho_RegionToChange.Dispose();
        ho_RegionToChange = ExpTmpOutVar_0;
        }
      }
      HOperatorSet.OverpaintRegion(ho_Image, ho_RegionToChange, hv_NewValue, "fill");
      ho_ImageOut.Dispose();
      ho_ImageOut = new HObject(ho_Image);
      ho_RegionToChange.Dispose();
      ho_RegionClass.Dispose();

      hv_IndexReset.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_RegionToChange.Dispose();
      ho_RegionClass.Dispose();

      hv_IndexReset.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Remove invalid 3D pixels from a given domain. 
  private void remove_invalid_3d_pixels (HObject ho_ImageX, HObject ho_ImageY, HObject ho_ImageZ, 
      HObject ho_Domain, out HObject ho_DomainOut, HTuple hv_InvalidPixelValue)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImageXOut=null, ho_ImageYOut=null;
    HObject ho_ImageZOut=null, ho_RegionInvalX, ho_RegionInvalY;
    HObject ho_RegionInvalZ, ho_RegionInvalXY, ho_RegionInval;
    HObject ho_RegionInvalComplement;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainOut);
    HOperatorSet.GenEmptyObj(out ho_ImageXOut);
    HOperatorSet.GenEmptyObj(out ho_ImageYOut);
    HOperatorSet.GenEmptyObj(out ho_ImageZOut);
    HOperatorSet.GenEmptyObj(out ho_RegionInvalX);
    HOperatorSet.GenEmptyObj(out ho_RegionInvalY);
    HOperatorSet.GenEmptyObj(out ho_RegionInvalZ);
    HOperatorSet.GenEmptyObj(out ho_RegionInvalXY);
    HOperatorSet.GenEmptyObj(out ho_RegionInval);
    HOperatorSet.GenEmptyObj(out ho_RegionInvalComplement);
    try
    {
      ho_DomainOut.Dispose();
      ho_DomainOut = new HObject(ho_Domain);
      ho_ImageXOut.Dispose();
      ho_ImageXOut = new HObject(ho_ImageX);
      ho_ImageYOut.Dispose();
      ho_ImageYOut = new HObject(ho_ImageY);
      ho_ImageZOut.Dispose();
      ho_ImageZOut = new HObject(ho_ImageZ);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageXOut, ho_DomainOut, out ExpTmpOutVar_0);
      ho_ImageXOut.Dispose();
      ho_ImageXOut = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageYOut, ho_DomainOut, out ExpTmpOutVar_0);
      ho_ImageYOut.Dispose();
      ho_ImageYOut = ExpTmpOutVar_0;
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ReduceDomain(ho_ImageZOut, ho_DomainOut, out ExpTmpOutVar_0);
      ho_ImageZOut.Dispose();
      ho_ImageZOut = ExpTmpOutVar_0;
      }
      ho_RegionInvalX.Dispose();
      HOperatorSet.Threshold(ho_ImageXOut, out ho_RegionInvalX, hv_InvalidPixelValue, 
          hv_InvalidPixelValue);
      ho_RegionInvalY.Dispose();
      HOperatorSet.Threshold(ho_ImageYOut, out ho_RegionInvalY, hv_InvalidPixelValue, 
          hv_InvalidPixelValue);
      ho_RegionInvalZ.Dispose();
      HOperatorSet.Threshold(ho_ImageZOut, out ho_RegionInvalZ, hv_InvalidPixelValue, 
          hv_InvalidPixelValue);
      ho_RegionInvalXY.Dispose();
      HOperatorSet.Intersection(ho_RegionInvalX, ho_RegionInvalY, out ho_RegionInvalXY
          );
      ho_RegionInval.Dispose();
      HOperatorSet.Intersection(ho_RegionInvalXY, ho_RegionInvalZ, out ho_RegionInval
          );
      ho_RegionInvalComplement.Dispose();
      HOperatorSet.Complement(ho_RegionInval, out ho_RegionInvalComplement);
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.Intersection(ho_DomainOut, ho_RegionInvalComplement, out ExpTmpOutVar_0
          );
      ho_DomainOut.Dispose();
      ho_DomainOut = ExpTmpOutVar_0;
      }
      ho_ImageXOut.Dispose();
      ho_ImageYOut.Dispose();
      ho_ImageZOut.Dispose();
      ho_RegionInvalX.Dispose();
      ho_RegionInvalY.Dispose();
      ho_RegionInvalZ.Dispose();
      ho_RegionInvalXY.Dispose();
      ho_RegionInval.Dispose();
      ho_RegionInvalComplement.Dispose();


      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageXOut.Dispose();
      ho_ImageYOut.Dispose();
      ho_ImageZOut.Dispose();
      ho_RegionInvalX.Dispose();
      ho_RegionInvalY.Dispose();
      ho_RegionInvalZ.Dispose();
      ho_RegionInvalXY.Dispose();
      ho_RegionInval.Dispose();
      ho_RegionInvalComplement.Dispose();


      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Replace legacy preprocessing parameters or values. 
  private void replace_legacy_preprocessing_parameters (HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Exception = new HTuple(), hv_NormalizationTypeExists = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_LegacyNormalizationKeyExists = new HTuple();
    HTuple hv_ContrastNormalization = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure adapts the dictionary DLPreprocessParam
      //if a legacy preprocessing parameter is set.
      //
      //Map legacy value set to new parameter.
      hv_Exception.Dispose();
      hv_Exception = 0;
      try
      {
        hv_NormalizationTypeExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "normalization_type", 
            out hv_NormalizationTypeExists);
        //
        if ((int)(hv_NormalizationTypeExists) != 0)
        {
          hv_NormalizationType.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
          if ((int)(new HTuple(hv_NormalizationType.TupleEqual("true"))) != 0)
          {
            hv_NormalizationType.Dispose();
            hv_NormalizationType = "first_channel";
          }
          else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("false"))) != 0)
          {
            hv_NormalizationType.Dispose();
            hv_NormalizationType = "none";
          }
          HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", hv_NormalizationType);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //
      //Map legacy parameter to new parameter and corresponding value.
      hv_Exception.Dispose();
      hv_Exception = 0;
      try
      {
        hv_LegacyNormalizationKeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "contrast_normalization", 
            out hv_LegacyNormalizationKeyExists);
        if ((int)(hv_LegacyNormalizationKeyExists) != 0)
        {
          hv_ContrastNormalization.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "contrast_normalization", 
              out hv_ContrastNormalization);
          //Replace 'contrast_normalization' by 'normalization_type'.
          if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual("false"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", 
                "none");
          }
          else if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual(
              "true"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", 
                "first_channel");
          }
          HOperatorSet.RemoveDictKey(hv_DLPreprocessParam, "contrast_normalization");
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }

      hv_Exception.Dispose();
      hv_NormalizationTypeExists.Dispose();
      hv_NormalizationType.Dispose();
      hv_LegacyNormalizationKeyExists.Dispose();
      hv_ContrastNormalization.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Exception.Dispose();
      hv_NormalizationTypeExists.Dispose();
      hv_NormalizationType.Dispose();
      hv_LegacyNormalizationKeyExists.Dispose();
      hv_ContrastNormalization.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Filters / Arithmetic
  // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
  public void scale_image_range (HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, 
      HTuple hv_Max)
  {




      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_ImageSelected=null, ho_SelectedChannel=null;
      HObject ho_LowerRegion=null, ho_UpperRegion=null, ho_ImageSelectedScaled=null;

      // Local copy input parameter variables 
      HObject ho_Image_COPY_INP_TMP;
      ho_Image_COPY_INP_TMP = new HObject(ho_Image);



      // Local control variables 

      HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
      HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
      HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
      HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
      HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
      HTuple   hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
      HTuple   hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_ImageSelected);
      HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
      HOperatorSet.GenEmptyObj(out ho_LowerRegion);
      HOperatorSet.GenEmptyObj(out ho_UpperRegion);
      HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
      try
      {
      //Convenience procedure to scale the gray values of the
      //input image Image from the interval [Min,Max]
      //to the interval [0,255] (default).
      //Gray values < 0 or > 255 (after scaling) are clipped.
      //
      //If the image shall be scaled to an interval different from [0,255],
      //this can be achieved by passing tuples with 2 values [From, To]
      //as Min and Max.
      //Example:
      //scale_image_range(Image:ImageScaled:[100,50],[200,250])
      //maps the gray values of Image from the interval [100,200] to [50,250].
      //All other gray values will be clipped.
      //
      //input parameters:
      //Image: the input image
      //Min: the minimum gray value which will be mapped to 0
      //     If a tuple with two values is given, the first value will
      //     be mapped to the second value.
      //Max: The maximum gray value which will be mapped to 255
      //     If a tuple with two values is given, the first value will
      //     be mapped to the second value.
      //
      //Output parameter:
      //ImageScale: the resulting scaled image.
      //
      if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
          2))) != 0)
      {
        hv_LowerLimit.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
            0);
        hv_Min_COPY_INP_TMP.Dispose();
        hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
        }
        }
      }
      else
      {
        hv_LowerLimit.Dispose();
        hv_LowerLimit = 0.0;
      }
      if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
          2))) != 0)
      {
        hv_UpperLimit.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
            0);
        hv_Max_COPY_INP_TMP.Dispose();
        hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
        }
        }
      }
      else
      {
        hv_UpperLimit.Dispose();
        hv_UpperLimit = 255.0;
      }
      //
      //Calculate scaling parameters.
      //Only scale if the scaling range is not zero.
      if ((int)((new HTuple(((((hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP)).TupleAbs()
          )).TupleLess(1.0E-6))).TupleNot()) != 0)
      {
        hv_Mult.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Mult = (((hv_UpperLimit-hv_LowerLimit)).TupleReal()
            )/(hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP);
        }
        hv_Add.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Add = ((-hv_Mult)*hv_Min_COPY_INP_TMP)+hv_LowerLimit;
        }
        //Scale image.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, 
            hv_Add);
        ho_Image_COPY_INP_TMP.Dispose();
        ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Clip gray values if necessary.
      //This must be done for each image and channel separately.
      ho_ImageScaled.Dispose();
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
      HTuple end_val51 = hv_NumImages;
      HTuple step_val51 = 1;
      for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val51, step_val51); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val51))
      {
        ho_ImageSelected.Dispose();
        HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
        hv_Channels.Dispose();
        HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
        HTuple end_val54 = hv_Channels;
        HTuple step_val54 = 1;
        for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val54, step_val54); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val54))
        {
          ho_SelectedChannel.Dispose();
          HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
          hv_MinGray.Dispose();hv_MaxGray.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, 
              out hv_MaxGray, out hv_Range);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_LowerRegion.Dispose();
          HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
              hv_LowerLimit))).TupleMin(), hv_LowerLimit);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_UpperRegion.Dispose();
          HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit, 
              ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
              hv_LowerLimit, "fill");
          ho_SelectedChannel.Dispose();
          ho_SelectedChannel = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
              hv_UpperLimit, "fill");
          ho_SelectedChannel.Dispose();
          ho_SelectedChannel = ExpTmpOutVar_0;
          }
          if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
          {
            ho_ImageSelectedScaled.Dispose();
            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled, 
                1, 1);
          }
          else
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel, 
                out ExpTmpOutVar_0);
            ho_ImageSelectedScaled.Dispose();
            ho_ImageSelectedScaled = ExpTmpOutVar_0;
            }
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
            );
        ho_ImageScaled.Dispose();
        ho_ImageScaled = ExpTmpOutVar_0;
        }
      }
      ho_Image_COPY_INP_TMP.Dispose();
      ho_ImageSelected.Dispose();
      ho_SelectedChannel.Dispose();
      ho_LowerRegion.Dispose();
      ho_UpperRegion.Dispose();
      ho_ImageSelectedScaled.Dispose();

      hv_Max_COPY_INP_TMP.Dispose();
      hv_Min_COPY_INP_TMP.Dispose();
      hv_LowerLimit.Dispose();
      hv_UpperLimit.Dispose();
      hv_Mult.Dispose();
      hv_Add.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();
      hv_Range.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image_COPY_INP_TMP.Dispose();
      ho_ImageSelected.Dispose();
      ho_SelectedChannel.Dispose();
      ho_LowerRegion.Dispose();
      ho_UpperRegion.Dispose();
      ho_ImageSelectedScaled.Dispose();

      hv_Max_COPY_INP_TMP.Dispose();
      hv_Min_COPY_INP_TMP.Dispose();
      hv_LowerLimit.Dispose();
      hv_UpperLimit.Dispose();
      hv_Mult.Dispose();
      hv_Add.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();
      hv_Range.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
    HTuple hv_Indices = new HTuple();
    HTuple   hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
    HTuple   hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

    // Initialize local and output iconic variables 
    try
    {
      //This procedure sets the text font of the current window with
      //the specified attributes.
      //
      //Input parameters:
      //WindowHandle: The graphics window for which the font will be set
      //Size: The font size. If Size=-1, the default of 16 is used.
      //Bold: If set to 'true', a bold font is used
      //Slant: If set to 'true', a slanted font is used
      //
      hv_OS.Dispose();
      HOperatorSet.GetSystem("operating_system", out hv_OS);
      if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
          new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
      {
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = 16;
      }
      if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
      {
        //Restore previous behavior
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = ((1.13677*hv_Size_COPY_INP_TMP)).TupleInt()
            ;
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
            ;
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Courier";
        hv_Fonts[1] = "Courier 10 Pitch";
        hv_Fonts[2] = "Courier New";
        hv_Fonts[3] = "CourierNew";
        hv_Fonts[4] = "Liberation Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Consolas";
        hv_Fonts[1] = "Menlo";
        hv_Fonts[2] = "Courier";
        hv_Fonts[3] = "Courier 10 Pitch";
        hv_Fonts[4] = "FreeMono";
        hv_Fonts[5] = "Liberation Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Luxi Sans";
        hv_Fonts[1] = "DejaVu Sans";
        hv_Fonts[2] = "FreeSans";
        hv_Fonts[3] = "Arial";
        hv_Fonts[4] = "Liberation Sans";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Times New Roman";
        hv_Fonts[1] = "Luxi Serif";
        hv_Fonts[2] = "DejaVu Serif";
        hv_Fonts[3] = "FreeSerif";
        hv_Fonts[4] = "Utopia";
        hv_Fonts[5] = "Liberation Serif";
      }
      else
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
      }
      hv_Style.Dispose();
      hv_Style = "";
      if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Bold";
        hv_Style.Dispose();
        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Italic";
        hv_Style.Dispose();
        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
      {
        hv_Style.Dispose();
        hv_Style = "Normal";
      }
      hv_AvailableFonts.Dispose();
      HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
      hv_Font_COPY_INP_TMP.Dispose();
      hv_Font_COPY_INP_TMP = "";
      for (hv_Fdx=0; (int)hv_Fdx<=(int)((new HTuple(hv_Fonts.TupleLength()))-1); hv_Fdx = (int)hv_Fdx + 1)
      {
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_AvailableFonts.TupleFind(
            hv_Fonts.TupleSelect(hv_Fdx));
        }
        if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
          {
            hv_Font_COPY_INP_TMP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                hv_Fdx);
            }
            break;
          }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
      {
        throw new HalconException("Wrong value of control parameter Font");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP+"-")+hv_Style)+"-")+hv_Size_COPY_INP_TMP;
      hv_Font_COPY_INP_TMP.Dispose();
      hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
      }
      }
      HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

      hv_Font_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP.Dispose();
      hv_OS.Dispose();
      hv_Fonts.Dispose();
      hv_Style.Dispose();
      hv_Exception.Dispose();
      hv_AvailableFonts.Dispose();
      hv_Fdx.Dispose();
      hv_Indices.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Font_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP.Dispose();
      hv_OS.Dispose();
      hv_Fonts.Dispose();
      hv_Style.Dispose();
      hv_Exception.Dispose();
      hv_AvailableFonts.Dispose();
      hv_Fdx.Dispose();
      hv_Indices.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: OCR / Deep OCR
  // Short Description: Split rectangle2 into a number of rectangles. 
  private void split_rectangle2 (HTuple hv_Row, HTuple hv_Column, HTuple hv_Phi, 
      HTuple hv_Length1, HTuple hv_Length2, HTuple hv_NumSplits, out HTuple hv_SplitRow, 
      out HTuple hv_SplitColumn, out HTuple hv_SplitPhi, out HTuple hv_SplitLength1Out, 
      out HTuple hv_SplitLength2Out)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_SplitLength = new HTuple(), hv_TRow = new HTuple();
    HTuple hv_TCol = new HTuple(), hv_HomMat2D = new HTuple();
    // Initialize local and output iconic variables 
    hv_SplitRow = new HTuple();
    hv_SplitColumn = new HTuple();
    hv_SplitPhi = new HTuple();
    hv_SplitLength1Out = new HTuple();
    hv_SplitLength2Out = new HTuple();
    try
    {
      if ((int)(new HTuple(hv_NumSplits.TupleGreater(0))) != 0)
      {
        hv_SplitLength.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitLength = hv_Length1/(hv_NumSplits.TupleReal()
            );
        }
        //Assume center (0,0), transform afterwards.
        hv_TRow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TRow = HTuple.TupleGenConst(
            hv_NumSplits,0.0);
        }
        hv_TCol.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TCol = ((-hv_Length1)+hv_SplitLength)+((HTuple.TupleGenSequence(
            0,hv_NumSplits-1,1)*2)*hv_SplitLength);
        }
        hv_HomMat2D.Dispose();
        HOperatorSet.HomMat2dIdentity(out hv_HomMat2D);
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.HomMat2dRotate(hv_HomMat2D, hv_Phi, 0, 0, out ExpTmpOutVar_0);
        hv_HomMat2D.Dispose();
        hv_HomMat2D = ExpTmpOutVar_0;
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.HomMat2dTranslate(hv_HomMat2D, hv_Row, hv_Column, out ExpTmpOutVar_0);
        hv_HomMat2D.Dispose();
        hv_HomMat2D = ExpTmpOutVar_0;
        }
        hv_SplitLength1Out.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitLength1Out = HTuple.TupleGenConst(
            hv_NumSplits,hv_SplitLength);
        }
        hv_SplitLength2Out.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitLength2Out = HTuple.TupleGenConst(
            hv_NumSplits,hv_Length2);
        }
        hv_SplitPhi.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitPhi = HTuple.TupleGenConst(
            hv_NumSplits,hv_Phi);
        }
        hv_SplitRow.Dispose();hv_SplitColumn.Dispose();
        HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_TRow, hv_TCol, out hv_SplitRow, 
            out hv_SplitColumn);
      }
      else
      {
        throw new HalconException("Number of splits must be greater than 0.");
      }

      hv_SplitLength.Dispose();
      hv_TRow.Dispose();
      hv_TCol.Dispose();
      hv_HomMat2D.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_SplitLength.Dispose();
      hv_TRow.Dispose();
      hv_TCol.Dispose();
      hv_HomMat2D.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Set and return meta information to display images correctly. 
  private void update_window_meta_information (HTuple hv_WindowHandle, HTuple hv_WidthImage, 
      HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth, 
      HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth, 
      out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
    HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
    HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
    HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
    HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatioHeight = new HTuple();
    hv_WindowImageRatioWidth = new HTuple();
    hv_SetPartRow2 = new HTuple();
    hv_SetPartColumn2 = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure sets and returns meta information to display images correctly.
      //
      //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
      hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth, 
          out hv_WindowHeight);
      hv_WindowImageRatioHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioHeight = hv_WindowHeight/(hv_HeightImage*1.0);
      }
      hv_WindowImageRatioWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioWidth = hv_WindowWidth/(hv_WidthImage*1.0);
      }
      //
      //Set window part such that image is displayed undistorted.
      hv_WindowRow2.Dispose();
      hv_WindowRow2 = new HTuple(hv_WindowHeight);
      hv_WindowColumn2.Dispose();
      hv_WindowColumn2 = new HTuple(hv_WindowWidth);
      hv_WindowRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRatio = hv_WindowColumn2/(hv_WindowRow2*1.0);
      }
      //
      hv_ImageRow2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRow2 = hv_HeightImage+(hv_MarginBottom/hv_WindowImageRatioHeight);
      }
      hv_ImageColumn2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageColumn2 = hv_WidthImage+(hv_MapColorBarWidth/hv_WindowImageRatioWidth);
      }
      hv_ImageRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRatio = hv_ImageColumn2/(hv_ImageRow2*1.0);
      }
      if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
      {
        //
        //Extend image until right window border.
        hv_SetPartColumn2.Dispose();
        hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
        hv_ImageWindowRatioHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatioHeight = hv_ImageColumn2/(hv_WindowColumn2*1.0);
        }
        hv_ImageRow2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageRow2InWindow = hv_ImageRow2/hv_ImageWindowRatioHeight;
        }
        hv_SetPartRow2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartRow2 = hv_ImageRow2+((hv_WindowRow2-hv_ImageRow2InWindow)/hv_WindowImageRatioWidth);
        }
      }
      else
      {
        //
        //Extend image until bottom of window.
        hv_SetPartRow2.Dispose();
        hv_SetPartRow2 = new HTuple(hv_ImageRow2);
        hv_ImageWindowRatioHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatioHeight = hv_ImageRow2/(hv_WindowRow2*1.0);
        }
        hv_ImageCol2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageCol2InWindow = hv_ImageColumn2/hv_ImageWindowRatioHeight;
        }
        hv_SetPartColumn2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartColumn2 = hv_ImageColumn2+((hv_WindowColumn2-hv_ImageCol2InWindow)/hv_WindowImageRatioHeight);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2-1, 
            hv_SetPartColumn2-1);
        }
      }
      //
      //Return the coordinates of the new window.
      hv_PrevWindowCoordinatesOut.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowCoordinatesOut = new HTuple();
      hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
      }
      //

      hv__.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowRow2.Dispose();
      hv_WindowColumn2.Dispose();
      hv_WindowRatio.Dispose();
      hv_ImageRow2.Dispose();
      hv_ImageColumn2.Dispose();
      hv_ImageRatio.Dispose();
      hv_ImageWindowRatioHeight.Dispose();
      hv_ImageRow2InWindow.Dispose();
      hv_ImageCol2InWindow.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv__.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowRow2.Dispose();
      hv_WindowColumn2.Dispose();
      hv_WindowRatio.Dispose();
      hv_ImageRow2.Dispose();
      hv_ImageColumn2.Dispose();
      hv_ImageRatio.Dispose();
      hv_ImageWindowRatioHeight.Dispose();
      hv_ImageRow2InWindow.Dispose();
      hv_ImageCol2InWindow.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Local procedures 
  public void check_data_availability (HTuple hv_ExampleDataDir, HTuple hv_PreprocessParamFileName, 
      HTuple hv_TrainedModelFileName, HTuple hv_UsePretrainedModel)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_FileExists = new HTuple(), hv_Example1 = new HTuple();
    HTuple hv_Example2 = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure checks if all necessary files are available.

      hv_FileExists.Dispose();
      HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
      hv_Example1.Dispose();
      hv_Example1 = "segment_pill_defects_deep_learning_1_preprocess.hdev";
      hv_Example2.Dispose();
      hv_Example2 = "segment_pill_defects_deep_learning_2_train.hdev";
      if ((int)(hv_FileExists.TupleNot()) != 0)
      {
        throw new HalconException(((((hv_ExampleDataDir+" does not exist. Please run ")+hv_Example1)+" and ")+hv_Example2)+" of example series.");
      }

      hv_FileExists.Dispose();
      HOperatorSet.FileExists(hv_PreprocessParamFileName, out hv_FileExists);
      if ((int)(hv_FileExists.TupleNot()) != 0)
      {
        throw new HalconException(((hv_PreprocessParamFileName+" does not exist. Please run ")+hv_Example1)+" of example series.");
      }

      hv_FileExists.Dispose();
      HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_FileExists);
      if ((int)(hv_FileExists.TupleNot()) != 0)
      {
        if ((int)(hv_UsePretrainedModel) != 0)
        {
          throw new HalconException(hv_TrainedModelFileName+" does not exist. Please run the HALCON Deep Learning installer.");
        }
        else
        {
          throw new HalconException(((hv_TrainedModelFileName+" does not exist. Please run ")+hv_Example2)+" of example series.");
        }
      }


      hv_FileExists.Dispose();
      hv_Example1.Dispose();
      hv_Example2.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_FileExists.Dispose();
      hv_Example1.Dispose();
      hv_Example2.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_image_window (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_WindowHandleImages = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes the image window.

      try
      {
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }


      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_legend_window (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_WindowHandleLegend = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes the legend window.

      try
      {
        hv_WindowHandleLegend.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
        HDevWindowStack.SetActive(hv_WindowHandleLegend);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }


      hv_WindowHandleLegend.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleLegend.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_text_window (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_WindowHandleImages = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes the text window.

      try
      {
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_text");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }

      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_windows (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes all example windows.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();

        return;
      }

      dev_close_example_text_window(hv_ExampleInternals);
      dev_close_example_image_window(hv_ShowExampleScreens);
      dev_close_example_legend_window(hv_ShowExampleScreens);


      hv_ShowExampleScreens.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_example_reset_windows (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandlesToClose = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
    HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
    HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowHandleImages = new HTuple();
    HTuple hv_WindowLegendNeeded = new HTuple(), hv_WindowHandleLegend = new HTuple();
    HTuple hv_WindowHandleText = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure resets the graphics windows.

      //Close any windows that are listed in key 'window_handles_to_close'.
      try
      {
        hv_WindowHandlesToClose.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close", 
            out hv_WindowHandlesToClose);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_WindowHandlesToClose.Dispose();
        hv_WindowHandlesToClose = new HTuple();
      }
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
          ))-1); hv_I = (int)hv_I + 1)
      {
        HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
            hv_I));
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
      }
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());

      //Open image window if needed.
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
      hv_WindowImagesNeeded.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
      if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
      {
        //Open new window for images.
        dev_open_example_image_window(hv_ExampleInternals);
      }
      else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
          new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
      {
        //Window for images exists but is not needed -> close it.
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
      }

      //Open legend window if needed
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
      hv_WindowLegendNeeded.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
      if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
      {
        //Open new window for legend
        dev_open_example_legend_window(hv_ExampleInternals, 280);
      }
      else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
          new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
      {
        //Window for legend exists but is not needed -> close it
        dev_close_example_legend_window(hv_ExampleInternals);
      }


      //Set the correct area (part) of the image window.
      try
      {
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        //Set default window extents
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 500, 
              500);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //Set the correct area (part) of the legend window.
      try
      {
        hv_WindowHandleLegend.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
        HDevWindowStack.SetActive(hv_WindowHandleLegend);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }

      hv_WindowHandlesToClose.Dispose();
      hv_Exception.Dispose();
      hv_I.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowImagesNeeded.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowLegendNeeded.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleText.Dispose();

      return;

    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandlesToClose.Dispose();
      hv_Exception.Dispose();
      hv_I.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowImagesNeeded.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowLegendNeeded.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_model_output_image (HTuple hv_ExampleInternals)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image, ho_SegImage;

    // Local control variables 

    HTuple hv_PreprocessParamFileName = new HTuple();
    HTuple hv_DLPreprocessParam = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_SegImage);
    try
    {
      //This procedure visualizes the output of a segmentation model,
      //by displaying a segmentation image.

      //Read the preprocessed image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill/ginseng/contamination/pill_ginseng_contamination_007.png");
      ho_SegImage.Dispose();
      HOperatorSet.ReadImage(out ho_SegImage, "labels/pill/ginseng/contamination/pill_ginseng_contamination_007_gt.png");
      //Preprocess the segmentation image.
      hv_PreprocessParamFileName.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "preprocess_param_file_name", 
          out hv_PreprocessParamFileName);
      hv_DLPreprocessParam.Dispose();
      HOperatorSet.ReadDict(hv_PreprocessParamFileName, new HTuple(), new HTuple(), 
          out hv_DLPreprocessParam);
      {
      HObject ExpTmpOutVar_0;
      preprocess_dl_model_segmentations(ho_Image, ho_SegImage, out ExpTmpOutVar_0, 
          hv_DLPreprocessParam);
      ho_SegImage.Dispose();
      ho_SegImage = ExpTmpOutVar_0;
      }

      //Display segmentation image.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_SegImage, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Segmentation image \n(output of 'apply_dl_model')", 
            "window", "top", "left", "black", new HTuple(), new HTuple());
      }

      //Write segmentation image to file.
      HOperatorSet.SetDictObject(ho_SegImage, hv_ExampleInternals, "segmentation_image");

      ho_Image.Dispose();
      ho_SegImage.Dispose();

      hv_PreprocessParamFileName.Dispose();
      hv_DLPreprocessParam.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_SegImage.Dispose();

      hv_PreprocessParamFileName.Dispose();
      hv_DLPreprocessParam.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_ok_nok (HTuple hv_Areas, HTuple hv_WindowHandleImage)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Text = new HTuple(), hv_BoxColor = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedures displays OK if no defects are segmented and NOK otherwise.

      //The first entry of Area corresponds to class 'good'.
      if ((int)(new HTuple((((hv_Areas.TupleSum())-(hv_Areas.TupleSelect(0)))).TupleGreater(
          0))) != 0)
      {
        hv_Text.Dispose();
        hv_Text = "NOK";
        hv_BoxColor.Dispose();
        hv_BoxColor = "red";
      }
      else
      {
        hv_Text.Dispose();
        hv_Text = "OK";
        hv_BoxColor.Dispose();
        hv_BoxColor = "green";
      }
      set_display_font(hv_WindowHandleImage, 24, "mono", "true", "false");
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", (new HTuple("box_color")).TupleConcat("shadow"), hv_BoxColor.TupleConcat(
            "false"));
        }
      }
      set_display_font(hv_WindowHandleImage, 16, "mono", "true", "false");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "left", "black", "box", "true");
      }
      HOperatorSet.FlushBuffer(hv_WindowHandleImage);

      hv_Text.Dispose();
      hv_BoxColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Text.Dispose();
      hv_BoxColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_pills_example_dataset_preview ()
  {


    // Local iconic variables 

    HObject ho_Image=null, ho_TiledImage=null;
    HObject ho_ImageR=null, ho_ImageG=null, ho_ImageB=null;
    HObject ho_ImageRG=null, ho_ImageRGB=null;

    // Local control variables 

    HTuple hv_GinsengPath = new HTuple(), hv_MagnesiumPath = new HTuple();
    HTuple hv_MintPath = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_Width1 = new HTuple();
    HTuple hv_Height1 = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_ErrorAndAdviceText = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_TiledImage);
    HOperatorSet.GenEmptyObj(out ho_ImageR);
    HOperatorSet.GenEmptyObj(out ho_ImageG);
    HOperatorSet.GenEmptyObj(out ho_ImageB);
    HOperatorSet.GenEmptyObj(out ho_ImageRG);
    HOperatorSet.GenEmptyObj(out ho_ImageRGB);
    try
    {
      //This procedure displays a selection of pill images.

      try
      {
        //Read some example images.
        hv_GinsengPath.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GinsengPath = new HTuple("pill/ginseng/")+(
            (new HTuple("good/pill_ginseng_good_001")).TupleConcat("contamination/pill_ginseng_contamination_004")).TupleConcat(
            "crack/pill_ginseng_crack_001");
        }
        hv_MagnesiumPath.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MagnesiumPath = new HTuple("pill/magnesium/")+(
            (new HTuple("good/pill_magnesium_good_001")).TupleConcat("contamination/pill_magnesium_contamination_001")).TupleConcat(
            "crack/pill_magnesium_crack_001");
        }
        hv_MintPath.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MintPath = new HTuple("pill/mint/")+(
            (new HTuple("good/pill_mint_good_001")).TupleConcat("contamination/pill_mint_contamination_001")).TupleConcat(
            "crack/pill_mint_crack_009");
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, ((hv_GinsengPath.TupleConcat(hv_MagnesiumPath))).TupleConcat(
            hv_MintPath));
        }
        ho_TiledImage.Dispose();
        HOperatorSet.TileImages(ho_Image, out ho_TiledImage, 3, "horizontal");
        //Generate background image.
        hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
        ho_ImageR.Dispose();
        HOperatorSet.GenImageProto(ho_TiledImage, out ho_ImageR, 18);
        ho_ImageG.Dispose();
        HOperatorSet.GenImageProto(ho_TiledImage, out ho_ImageG, 22);
        ho_ImageB.Dispose();
        HOperatorSet.GenImageProto(ho_TiledImage, out ho_ImageB, 28);
        ho_ImageRG.Dispose();
        HOperatorSet.AppendChannel(ho_ImageR, ho_ImageG, out ho_ImageRG);
        ho_ImageRGB.Dispose();
        HOperatorSet.AppendChannel(ho_ImageRG, ho_ImageB, out ho_ImageRGB);
        //Display the background and the images.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 800, 
              400);
        }
        hv_Width1.Dispose();hv_Height1.Dispose();
        HOperatorSet.GetImageSize(ho_ImageRGB, out hv_Width1, out hv_Height1);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height1, hv_Width1);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ImageRGB, HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_TiledImage, HDevWindowStack.GetActive());
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //If the example image files are not found, an error message is displayed.
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = "The images required for this example could not be found.";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "These images are part of a separate installer. Please");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "refer to the Installation Guide for more information on");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "this topic!");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ErrorAndAdviceText, 
              "window", "center", "left", "red", new HTuple(), new HTuple());
        }
      }
      ho_Image.Dispose();
      ho_TiledImage.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();
      ho_ImageRG.Dispose();
      ho_ImageRGB.Dispose();

      hv_GinsengPath.Dispose();
      hv_MagnesiumPath.Dispose();
      hv_MintPath.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Width1.Dispose();
      hv_Height1.Dispose();
      hv_Exception.Dispose();
      hv_ErrorAndAdviceText.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_TiledImage.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();
      ho_ImageRG.Dispose();
      ho_ImageRGB.Dispose();

      hv_GinsengPath.Dispose();
      hv_MagnesiumPath.Dispose();
      hv_MintPath.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Width1.Dispose();
      hv_Height1.Dispose();
      hv_Exception.Dispose();
      hv_ErrorAndAdviceText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_preprocessed_image (HTuple hv_ExampleInternals)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image;

    // Local control variables 

    HTuple hv_PreprocessParamFileName = new HTuple();
    HTuple hv_DLPreprocessParam = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    try
    {
      //This procedure displays an example of a preprocessed image.

      //Read image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill/ginseng/contamination/pill_ginseng_contamination_007.png");

      //Preprocess image.
      hv_PreprocessParamFileName.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "preprocess_param_file_name", 
          out hv_PreprocessParamFileName);
      hv_DLPreprocessParam.Dispose();
      HOperatorSet.ReadDict(hv_PreprocessParamFileName, new HTuple(), new HTuple(), 
          out hv_DLPreprocessParam);

      {
      HObject ExpTmpOutVar_0;
      preprocess_dl_model_images(ho_Image, out ExpTmpOutVar_0, hv_DLPreprocessParam);
      ho_Image.Dispose();
      ho_Image = ExpTmpOutVar_0;
      }
      HOperatorSet.SetDictObject(ho_Image, hv_ExampleInternals, "preprocessed_image");

      //Display preprocessed image.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, 400, 400);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Preprocessed image", 
            "window", "top", "left", "black", new HTuple(), new HTuple());
      }
      ho_Image.Dispose();

      hv_PreprocessParamFileName.Dispose();
      hv_DLPreprocessParam.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();

      hv_PreprocessParamFileName.Dispose();
      hv_DLPreprocessParam.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_raw_image (HTuple hv_WindowHandleImages)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image;

    // Local control variables 

    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width1 = new HTuple(), hv_Height1 = new HTuple();
    HTuple hv_ZoomFactor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    try
    {
      //This procedure displays a raw image as inserted into the sample.

      HDevWindowStack.SetActive(hv_WindowHandleImages);
      //Read image and fit the window handle.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill/ginseng/contamination/pill_ginseng_contamination_007.png");

      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
      hv_Row.Dispose();hv_Column.Dispose();hv_Width1.Dispose();hv_Height1.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandleImages, out hv_Row, out hv_Column, 
          out hv_Width1, out hv_Height1);

      if ((int)(new HTuple(hv_Height.TupleLess(hv_Width))) != 0)
      {
        hv_ZoomFactor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomFactor = hv_Width1/(hv_Width.TupleReal()
            );
        }
      }
      else
      {
        hv_ZoomFactor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZoomFactor = hv_Height1/(hv_Height.TupleReal()
            );
        }
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageFactor(ho_Image, out ExpTmpOutVar_0, hv_ZoomFactor, hv_ZoomFactor, 
          "bilinear");
      ho_Image.Dispose();
      ho_Image = ExpTmpOutVar_0;
      }

      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, hv_ZoomFactor*hv_Width, 
            hv_ZoomFactor*hv_Height);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Raw image", "window", 
            "top", "left", "black", new HTuple(), new HTuple());
      }
      ho_Image.Dispose();

      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width1.Dispose();
      hv_Height1.Dispose();
      hv_ZoomFactor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();

      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width1.Dispose();
      hv_Height1.Dispose();
      hv_ZoomFactor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_device (HTuple hv_ExampleInternals, HTuple hv_DLDevice)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandleText = new HTuple();
    HTuple hv_DLDeviceType = new HTuple(), hv_DLDeviceName = new HTuple();
    HTuple hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure displays information about the used device.

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);

      //Display the explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      hv_DLDeviceType.Dispose();
      HOperatorSet.GetDlDeviceParam(hv_DLDevice, "type", out hv_DLDeviceType);
      hv_DLDeviceName.Dispose();
      HOperatorSet.GetDlDeviceParam(hv_DLDevice, "name", out hv_DLDeviceName);

      hv_Text.Dispose();
      hv_Text = "This example can be run on any deep learning device.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if ((int)(new HTuple(hv_DLDeviceType.TupleNotEqual("gpu"))) != 0)
      {
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[new HTuple(hv_Text.TupleLength())] = "No GPU with necessary drivers and libraries has been found.";
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      }
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "This example will run the deep learning operators";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "on the following device:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Device type: "+hv_DLDeviceType;
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Device name: "+hv_DLDeviceName;

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }


      hv_WindowHandleText.Dispose();
      hv_DLDeviceType.Dispose();
      hv_DLDeviceName.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleText.Dispose();
      hv_DLDeviceType.Dispose();
      hv_DLDeviceName.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_example_images (HTuple hv_ExampleInternals, HTuple hv_UsePretrainedModel)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_ExampleDataDir = new HTuple();
    HTuple hv_ExampleDataDirExists = new HTuple(), hv_PreprocessParamFileName = new HTuple();
    HTuple hv_DataDirectory = new HTuple(), hv_PreprocessParamsExist = new HTuple();
    HTuple hv_RetrainedModelFileName = new HTuple(), hv_ModelExists = new HTuple();
    HTuple hv_ExceptionText = new HTuple(), hv_NumMissing = new HTuple();
    HTuple hv_Text = new HTuple(), hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure introduces the task and displays some example images.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_ExampleDataDir.Dispose();
        hv_ExampleDataDirExists.Dispose();
        hv_PreprocessParamFileName.Dispose();
        hv_DataDirectory.Dispose();
        hv_PreprocessParamsExist.Dispose();
        hv_RetrainedModelFileName.Dispose();
        hv_ModelExists.Dispose();
        hv_ExceptionText.Dispose();
        hv_NumMissing.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);

      //Set text window handle.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Check if the trained model and preprocessing parameters exist.

      //Example data directory where the outputs of previous examples are saved.
      hv_ExampleDataDir.Dispose();
      hv_ExampleDataDir = "segment_pill_defects_data";
      hv_ExampleDataDirExists.Dispose();
      HOperatorSet.FileExists(hv_ExampleDataDir, out hv_ExampleDataDirExists);

      //Preprocessing parameters.
      if ((int)(hv_UsePretrainedModel) != 0)
      {
        hv_PreprocessParamFileName.Dispose();
        hv_PreprocessParamFileName = "segment_pill_defects_preprocess_param.hdict";
      }
      else
      {
        hv_DataDirectory.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DataDirectory = hv_ExampleDataDir+"/dldataset_pill_400x400";
        }
        hv_PreprocessParamFileName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_PreprocessParamFileName = hv_DataDirectory+"/dl_preprocess_param.hdict";
        }
      }
      hv_PreprocessParamsExist.Dispose();
      HOperatorSet.FileExists(hv_PreprocessParamFileName, out hv_PreprocessParamsExist);

      //Retrained model file name.
      if ((int)(hv_UsePretrainedModel) != 0)
      {
        hv_RetrainedModelFileName.Dispose();
        hv_RetrainedModelFileName = "segment_pill_defects.hdl";
      }
      else
      {
        hv_RetrainedModelFileName.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RetrainedModelFileName = hv_ExampleDataDir+"/best_dl_model_segmentation.hdl";
        }
      }
      hv_ModelExists.Dispose();
      HOperatorSet.FileExists(hv_RetrainedModelFileName, out hv_ModelExists);
      if ((int)(hv_UsePretrainedModel) != 0)
      {
        if ((int)((new HTuple(hv_ModelExists.TupleNot())).TupleOr(hv_PreprocessParamsExist.TupleNot()
            )) != 0)
        {
          hv_WindowHandleText.Dispose();
          HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
          HDevWindowStack.SetActive(hv_WindowHandleText);

          hv_ExceptionText.Dispose();
          hv_ExceptionText = "To run this example you need the output of:";
          if (hv_ExceptionText == null)
            hv_ExceptionText = new HTuple();
          hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = new HTuple(" - Deep learning installer, see Installation Guide.");
          if (hv_ExceptionText == null)
            hv_ExceptionText = new HTuple();
          hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "";
          //Display warning.
          set_display_font(hv_WindowHandleText, 20, "mono", "true", "false");
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ExceptionText, 
                "window", "top", "left", "red", "box", "true");
          }

          hv_ShowExampleScreens.Dispose();
          hv_WindowHandleText.Dispose();
          hv_ExampleDataDir.Dispose();
          hv_ExampleDataDirExists.Dispose();
          hv_PreprocessParamFileName.Dispose();
          hv_DataDirectory.Dispose();
          hv_PreprocessParamsExist.Dispose();
          hv_RetrainedModelFileName.Dispose();
          hv_ModelExists.Dispose();
          hv_ExceptionText.Dispose();
          hv_NumMissing.Dispose();
          hv_Text.Dispose();
          hv_WindowHandleImages.Dispose();

          return;
        }
      }
      else
      {
        if ((int)((new HTuple((new HTuple(hv_ExampleDataDirExists.TupleNot())).TupleOr(
            hv_ModelExists.TupleNot()))).TupleOr(hv_PreprocessParamsExist.TupleNot()
            )) != 0)
        {
          hv_ExceptionText.Dispose();
          hv_ExceptionText = "To run this example you need the output of:";
          hv_NumMissing.Dispose();
          hv_NumMissing = 0;
          if ((int)((new HTuple(hv_PreprocessParamsExist.TupleNot())).TupleOr(hv_ExampleDataDirExists.TupleNot()
              )) != 0)
          {
            if (hv_ExceptionText == null)
              hv_ExceptionText = new HTuple();
            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = " - 'segment_pill_defects_deep_learning_1_preprocess.hdev'";
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_NumMissing = hv_NumMissing+1;
            hv_NumMissing.Dispose();
            hv_NumMissing = ExpTmpLocalVar_NumMissing;
            }
            }
          }
          if ((int)(hv_ModelExists.TupleNot()) != 0)
          {
            if (hv_ExceptionText == null)
              hv_ExceptionText = new HTuple();
            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = " - 'segment_pill_defects_deep_learning_2_train.hdev'";
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_NumMissing = hv_NumMissing+1;
            hv_NumMissing.Dispose();
            hv_NumMissing = ExpTmpLocalVar_NumMissing;
            }
            }
          }
          if (hv_ExceptionText == null)
            hv_ExceptionText = new HTuple();
          hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "";
          if ((int)(new HTuple(hv_NumMissing.TupleEqual(1))) != 0)
          {
            if (hv_ExceptionText == null)
              hv_ExceptionText = new HTuple();
            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "Please run this example first.";
          }
          else if ((int)(new HTuple(hv_NumMissing.TupleGreater(1))) != 0)
          {
            if (hv_ExceptionText == null)
              hv_ExceptionText = new HTuple();
            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "Please run these examples first.";
          }
          if (hv_ExceptionText == null)
            hv_ExceptionText = new HTuple();
          hv_ExceptionText[HTuple.TupleGenSequence(new HTuple(hv_ExceptionText.TupleLength()
              ),(new HTuple(hv_ExceptionText.TupleLength()))+2,1)] = ((new HTuple("Alternatively, you can set 'UsePretrainedModel := true' ")).TupleConcat(
              "at the top of the example script to use an already trained")).TupleConcat(
              "model shipped with the HALCON installation.");

          //Display the warning.
          set_display_font(hv_WindowHandleText, 20, "mono", "true", "false");
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ExceptionText, 
                "window", "top", "left", "red", "box", "true");
          }
          set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");

          hv_ShowExampleScreens.Dispose();
          hv_WindowHandleText.Dispose();
          hv_ExampleDataDir.Dispose();
          hv_ExampleDataDirExists.Dispose();
          hv_PreprocessParamFileName.Dispose();
          hv_DataDirectory.Dispose();
          hv_PreprocessParamsExist.Dispose();
          hv_RetrainedModelFileName.Dispose();
          hv_ModelExists.Dispose();
          hv_ExceptionText.Dispose();
          hv_NumMissing.Dispose();
          hv_Text.Dispose();
          hv_WindowHandleImages.Dispose();

          return;
        }
      }

      //Set preprocess param file to dict to be read later.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "preprocess_param_file_name", 
          hv_PreprocessParamFileName);

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);

      //Display instruction text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      hv_Text.Dispose();
      hv_Text = new HTuple("We now have a trained segmentation model,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "which is ready to be applied to new images.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below, you see a few example images.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("These images represent newly incoming images,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("i.e., they are not part of the preprocessed dataset.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("The images have to be preprocessed in the same way as the DLDataset,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "which was used for training.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      //Display example images.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      dev_display_pills_example_dataset_preview();


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_ExampleDataDir.Dispose();
      hv_ExampleDataDirExists.Dispose();
      hv_PreprocessParamFileName.Dispose();
      hv_DataDirectory.Dispose();
      hv_PreprocessParamsExist.Dispose();
      hv_RetrainedModelFileName.Dispose();
      hv_ModelExists.Dispose();
      hv_ExceptionText.Dispose();
      hv_NumMissing.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_ExampleDataDir.Dispose();
      hv_ExampleDataDirExists.Dispose();
      hv_PreprocessParamFileName.Dispose();
      hv_DataDirectory.Dispose();
      hv_PreprocessParamsExist.Dispose();
      hv_RetrainedModelFileName.Dispose();
      hv_ModelExists.Dispose();
      hv_ExceptionText.Dispose();
      hv_NumMissing.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_final (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure shows the final screen to conclude this example.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }

      dev_open_example_text_window(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display instruction text.
      hv_Text.Dispose();
      hv_Text = "Congratulations!";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "You have finished the series of examples for DL segmentation.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "You can now train a segmentation model on your own data.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "End of program.", "window", 
            "bottom", "right", "black", "box", "true");
      }


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_inference_step_1 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure explains the step of sample generation.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display first part of inference instruction.
      hv_Text.Dispose();
      hv_Text = "Inference steps for one image:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Generate a DLSample for the image";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'gen_dl_samples_from_images'.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      //Display raw image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      dev_display_raw_image(hv_WindowHandleImages);


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_inference_step_2 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure explains the preprocessing step during inference.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display second part of inference instruction.
      hv_Text.Dispose();
      hv_Text = "Inference steps for one image:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Generate a DLSample for the image";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'gen_dl_samples_from_images'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Preprocess the image to fulfill the requirements of the trained model";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'preprocess_dl_samples'.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      //Display preprocessed image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      dev_display_preprocessed_image(hv_ExampleInternals);


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_inference_step_3 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure visualizes the apply step.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display third part of inference instruction.
      hv_Text.Dispose();
      hv_Text = "Inference steps for one image:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Generate a DLSample for the image";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'gen_dl_samples_from_images'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Preprocess the image to fulfill the requirements of the trained model";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'preprocess_dl_samples'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Apply the model using the operator 'apply_dl_model'.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      //Display output image of the model.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      dev_display_model_output_image(hv_ExampleInternals);


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_inference_step_4 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure lists the postprocessing as step and displays an example.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display fourth part of inference instruction.
      hv_Text.Dispose();
      hv_Text = "Inference steps for one image:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Generate a DLSample for the image";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'gen_dl_samples_from_images'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Preprocess the image to fulfill the requirements of the trained model";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   using the procedure 'preprocess_dl_samples'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Apply the model using the operator 'apply_dl_model'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Postprocess the output segmentation image";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   to get segmented regions for each class.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      //Display segmented regions.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      dev_display_segmented_regions(hv_ExampleInternals);


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_introduction (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure shows an overview on all example parts.

      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display introduction text.
      hv_Text.Dispose();
      hv_Text = new HTuple("This example is part of a series of examples, which summarize ");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "the workflow for DL segmentation.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The four parts are: ";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Dataset preprocessing.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Training of the model.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Evaluation of the trained model.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Inference on new images.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "This example covers part 4: 'Inference on new images'.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_ready_to_infer (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure informs, that the execution will start in the next step
      //and what will be done.
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }

      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);

      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);

      //Display instruction text.
      hv_Text.Dispose();
      hv_Text = "We will now apply the trained model from example part 2 ";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "(segment_pill_defects_deep_learning_2_train.hdev)";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "to some new images using 'apply_dl_model'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Additionally, we apply postprocessing steps to the");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "output segmentation image:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " 1. Get a segmented region for each class.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " 2. Split the segmented regions into connected components.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " 3. Compute the area of each defect instance.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The final result will be displayed for each image.";

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }

      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", hv_WindowHandleText);


      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_segmented_regions (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    HObject ho_Image, ho_SegImage, ho_Defect;

    // Local control variables 

    HTuple hv_Area = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Info = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_Sample = new HTuple(), hv_Result = new HTuple();
    HTuple hv_GenParam = new HTuple(), hv_WindowHandleDict = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleLegend = new HTuple();
    HTuple hv_WindowHandles = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_SegImage);
    HOperatorSet.GenEmptyObj(out ho_Defect);
    try
    {
      //This procedure displays an example of extracted regions.

      //Get preprocessed image and segmentation image.
      ho_Image.Dispose();
      HOperatorSet.GetDictObject(out ho_Image, hv_ExampleInternals, "preprocessed_image");
      ho_SegImage.Dispose();
      HOperatorSet.GetDictObject(out ho_SegImage, hv_ExampleInternals, "segmentation_image");

      //Get defect region and compute its area.
      ho_Defect.Dispose();
      HOperatorSet.Threshold(ho_SegImage, out ho_Defect, 1, 1);
      hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
      HOperatorSet.AreaCenter(ho_Defect, out hv_Area, out hv_Row, out hv_Column);

      //Display the image with overlayed regions.
      //Dataset info.
      hv_Info.Dispose();
      HOperatorSet.CreateDict(out hv_Info);
      hv_ClassIDs.Dispose();
      hv_ClassIDs = new HTuple();
      hv_ClassIDs[0] = 0;
      hv_ClassIDs[1] = 1;
      hv_ClassIDs[2] = 2;
      hv_ClassNames.Dispose();
      hv_ClassNames = new HTuple();
      hv_ClassNames[0] = "good";
      hv_ClassNames[1] = "contamination";
      hv_ClassNames[2] = "crack";
      HOperatorSet.SetDictTuple(hv_Info, "class_ids", hv_ClassIDs);
      HOperatorSet.SetDictTuple(hv_Info, "class_names", hv_ClassNames);
      //Sample.
      hv_Sample.Dispose();
      HOperatorSet.CreateDict(out hv_Sample);
      HOperatorSet.SetDictObject(ho_Image, hv_Sample, "image");
      //Result.
      hv_Result.Dispose();
      HOperatorSet.CreateDict(out hv_Result);
      HOperatorSet.SetDictObject(ho_SegImage, hv_Result, "segmentation_image");
      //GenParam.
      hv_GenParam.Dispose();
      HOperatorSet.CreateDict(out hv_GenParam);
      HOperatorSet.SetDictTuple(hv_GenParam, "segmentation_exclude_class_ids", 0);
      HOperatorSet.SetDictTuple(hv_GenParam, "segmentation_transparency", "80");
      HOperatorSet.SetDictTuple(hv_GenParam, "font_size", 16);
      //WindowHandleDict.
      hv_WindowHandleDict.Dispose();
      HOperatorSet.CreateDict(out hv_WindowHandleDict);
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      hv_WindowHandleLegend.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "segmentation_image_result", 
          hv_WindowHandleImages.TupleConcat(hv_WindowHandleLegend));
      }
      //Display results.
      dev_display_dl_data(hv_Sample, hv_Result, hv_Info, "segmentation_image_result", 
          hv_GenParam, hv_WindowHandleDict);

      //Display area.
      hv_WindowHandles.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "segmentation_image_result", 
          out hv_WindowHandles);
      HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
          0));
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), (((hv_ClassNames.TupleSelect(
            1))+"\narea: ")+hv_Area)+"px", "image", hv_Row-10, hv_Column+10, "black", 
            new HTuple(), new HTuple());
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Segmented defect regions", 
            "window", "top", "left", "black", new HTuple(), new HTuple());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(0));
      }

      ho_Image.Dispose();
      ho_SegImage.Dispose();
      ho_Defect.Dispose();

      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Info.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNames.Dispose();
      hv_Sample.Dispose();
      hv_Result.Dispose();
      hv_GenParam.Dispose();
      hv_WindowHandleDict.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandles.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_SegImage.Dispose();
      ho_Defect.Dispose();

      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Info.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNames.Dispose();
      hv_Sample.Dispose();
      hv_Result.Dispose();
      hv_GenParam.Dispose();
      hv_WindowHandleDict.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandles.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_example_init (HTuple hv_ShowExampleScreens, out HTuple hv_ExampleInternals)
  {


    // Initialize local and output iconic variables 
    hv_ExampleInternals = new HTuple();
    //This procedure initializes the graphic windows that are used for explanations during the example.

    //A dict that will be used/adapted by other example procedures.
    hv_ExampleInternals.Dispose();
    HOperatorSet.CreateDict(out hv_ExampleInternals);
    HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
    if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
    {


      return;
    }

    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.CloseWindow(HDevWindowStack.Pop());
    }
    dev_open_example_text_window(hv_ExampleInternals);

    HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
    HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);



    return;
  }

  public void dev_open_example_image_window (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHeightText = new HTuple();
    HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
    HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
    HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure initializes the graphic windows that are used to display example images.

      hv_WindowHeightText.Dispose();
      hv_WindowHeightText = 300;
      hv_WindowWidthImage.Dispose();
      hv_WindowWidthImage = 500;
      hv_WindowHeightImages.Dispose();
      hv_WindowHeightImages = 500;
      hv_WindowBGColor.Dispose();
      hv_WindowBGColor = "black";

      hv_WindowYImages.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowYImages = hv_WindowHeightText+60;
      }
      hv_WindowXImages.Dispose();
      hv_WindowXImages = 0;
      HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
      HOperatorSet.OpenWindow(hv_WindowYImages,hv_WindowXImages,hv_WindowWidthImage,hv_WindowHeightImages,0,"visible","",out hv_WindowHandleImages);
      HDevWindowStack.Push(hv_WindowHandleImages);
      set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

      hv_WindowHeightText.Dispose();
      hv_WindowWidthImage.Dispose();
      hv_WindowHeightImages.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowYImages.Dispose();
      hv_WindowXImages.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHeightText.Dispose();
      hv_WindowWidthImage.Dispose();
      hv_WindowHeightImages.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowYImages.Dispose();
      hv_WindowXImages.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_open_example_legend_window (HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
  {



    // Local control variables 

    HTuple hv_WindowImagesHeight = new HTuple();
    HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
    HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure initializes the graphic windows that are used to display a legend.

      hv_WindowImagesHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
      hv_WindowImagesWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
      hv_WindowImagesX.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
      hv_WindowImagesY.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_WindowImagesY,(hv_WindowImagesX+hv_WindowImagesWidth)+5,hv_WindowWidth,hv_WindowImagesHeight,0,"visible","",out hv_WindowHandleLegend);
      HDevWindowStack.Push(hv_WindowHandleLegend);
      set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

      hv_WindowImagesHeight.Dispose();
      hv_WindowImagesWidth.Dispose();
      hv_WindowImagesX.Dispose();
      hv_WindowImagesY.Dispose();
      hv_WindowHandleLegend.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowImagesHeight.Dispose();
      hv_WindowImagesWidth.Dispose();
      hv_WindowImagesX.Dispose();
      hv_WindowImagesY.Dispose();
      hv_WindowHandleLegend.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_open_example_text_window (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
    HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      hv_WindowWidthText.Dispose();
      hv_WindowWidthText = 800;
      hv_WindowHeightText.Dispose();
      hv_WindowHeightText = 300;
      hv_WindowBGColor.Dispose();
      hv_WindowBGColor = "gray";
      HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
      HOperatorSet.OpenWindow(0,0,hv_WindowWidthText,hv_WindowHeightText,0,"visible","",out hv_WindowHandleText);
      HDevWindowStack.Push(hv_WindowHandleText);
      set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);

      hv_WindowWidthText.Dispose();
      hv_WindowHeightText.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowHandleText.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowWidthText.Dispose();
      hv_WindowHeightText.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowHandleText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void get_inference_images (HTuple hv_ImageDir, out HTuple hv_ImageFiles)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_ImageFiles = new HTuple();
    //This procedure selects some images for the demonstration purposes of this example.

    hv_ImageFiles.Dispose();
    using (HDevDisposeHelper dh = new HDevDisposeHelper())
    {
    hv_ImageFiles = hv_ImageDir+"/ginseng/contamination/pill_ginseng_contamination_154";
    }
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/magnesium/crack/pill_magnesium_crack_036";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/mint/good/pill_mint_good_165";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/ginseng/crack/pill_ginseng_crack_004";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/magnesium/good/pill_magnesium_good_066";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/ginseng/contamination/pill_ginseng_contamination_244";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/mint/contamination/pill_mint_contamination_076";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/magnesium/contamination/pill_magnesium_contamination_011";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/ginseng/good/pill_ginseng_good_042";
    if (hv_ImageFiles == null)
      hv_ImageFiles = new HTuple();
    hv_ImageFiles[new HTuple(hv_ImageFiles.TupleLength())] = hv_ImageDir+"/mint/crack/pill_mint_crack_121";


    return;
  }

  public void identity (HObject ho_Image, out HObject ho_ClassRegions, out HObject ho_ClassRegion, 
      out HObject ho_ConnectedRegions, out HObject ho_CurrentRegion, HTuple hv_DLPreprocessParam, 
      HTuple hv_DLModelHandle, HTuple hv_BatchSizeInference, HTuple hv_ClassIDs, HTuple hv_DatasetInfo, 
      HTuple hv_GenParamDisplay, HTuple hv_WindowHandleDict, HTuple hv_ClassNames)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_DLSampleBatch = new HTuple(), hv_DLResultBatch = new HTuple();
    HTuple hv_SampleIndex = new HTuple(), hv_DLResultBatchDict = new HTuple();
    HTuple hv_WindowHandles = new HTuple(), hv_Areas = new HTuple();
    HTuple hv_ClassIndex = new HTuple(), hv_Area = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_ConnectIndex = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ClassRegions);
    HOperatorSet.GenEmptyObj(out ho_ClassRegion);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_CurrentRegion);
    try
    {
      hv_DLSampleBatch.Dispose();
      gen_dl_samples_from_images(ho_Image, out hv_DLSampleBatch);
      preprocess_dl_samples(hv_DLSampleBatch, hv_DLPreprocessParam);
      hv_DLResultBatch.Dispose();
      HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleBatch, (new HTuple("segmentation_image")).TupleConcat(
          "segmentation_confidence"), out hv_DLResultBatch);
      HTuple end_val3 = hv_BatchSizeInference-1;
      HTuple step_val3 = 1;
      for (hv_SampleIndex=0; hv_SampleIndex.Continue(end_val3, step_val3); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val3))
      {
        hv_DLResultBatchDict.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLResultBatchDict = hv_DLResultBatch.TupleSelect(
            hv_SampleIndex);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ClassRegions.Dispose();
        HOperatorSet.Threshold(hv_DLResultBatchDict.TupleGetDictObject("segmentation_image"), 
            out ho_ClassRegions, hv_ClassIDs, hv_ClassIDs);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        dev_display_dl_data(hv_DLSampleBatch.TupleSelect(hv_SampleIndex), hv_DLResultBatch.TupleSelect(
            hv_SampleIndex), hv_DatasetInfo, "segmentation_image_result", hv_GenParamDisplay, 
            hv_WindowHandleDict);
        }
        hv_WindowHandles.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowHandles = hv_WindowHandleDict.TupleGetDictTuple(
            "segmentation_image_result");
        }
        HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
            0));
        hv_Areas.Dispose();
        HOperatorSet.RegionFeatures(ho_ClassRegions, "area", out hv_Areas);
        for (hv_ClassIndex=1; (int)hv_ClassIndex<=(int)((new HTuple(hv_Areas.TupleLength()
            ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
        {
          if ((int)(new HTuple(((hv_Areas.TupleSelect(hv_ClassIndex))).TupleGreater(
              0))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ClassRegion.Dispose();
            HOperatorSet.SelectObj(ho_ClassRegions, out ho_ClassRegion, hv_ClassIndex+1);
            }
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_ClassRegion, out ho_ConnectedRegions);
            hv_Area.Dispose();hv_Row.Dispose();hv_Column.Dispose();
            HOperatorSet.AreaCenter(ho_ConnectedRegions, out hv_Area, out hv_Row, 
                out hv_Column);
            for (hv_ConnectIndex=0; (int)hv_ConnectIndex<=(int)((new HTuple(hv_Area.TupleLength()
                ))-1); hv_ConnectIndex = (int)hv_ConnectIndex + 1)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_CurrentRegion.Dispose();
              HOperatorSet.SelectObj(ho_ConnectedRegions, out ho_CurrentRegion, hv_ConnectIndex+1);
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), (((hv_ClassNames.TupleSelect(
                    hv_ClassIndex))+"\narea: ")+(hv_Area.TupleSelect(hv_ConnectIndex)))+"px", 
                    "image", (hv_Row.TupleSelect(hv_ConnectIndex))-10, (hv_Column.TupleSelect(
                    hv_ConnectIndex))+10, "black", new HTuple(), new HTuple());
                }
              }
            }
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        dev_display_ok_nok(hv_Areas, hv_WindowHandles.TupleSelect(0));
        }
        // stop(...); only in hdevelop
      }

      hv_DLSampleBatch.Dispose();
      hv_DLResultBatch.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLResultBatchDict.Dispose();
      hv_WindowHandles.Dispose();
      hv_Areas.Dispose();
      hv_ClassIndex.Dispose();
      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_ConnectIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_DLSampleBatch.Dispose();
      hv_DLResultBatch.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLResultBatchDict.Dispose();
      hv_WindowHandles.Dispose();
      hv_Areas.Dispose();
      hv_ClassIndex.Dispose();
      hv_Area.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_ConnectIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void init (out HTuple hv_BatchSizeInference, out HTuple hv_DLModelHandle, 
      out HTuple hv_ClassNames, out HTuple hv_ClassIDs, out HTuple hv_DLPreprocessParam, 
      out HTuple hv_WindowHandleDict, out HTuple hv_DatasetInfo, out HTuple hv_GenParamDisplay)
  {


    // Local iconic variables 

    // Local control variables 

    HTuple hv_PreprocessParamFileName = new HTuple();
    HTuple hv_RetrainedModelFileName = new HTuple(), hv_DLDeviceHandles = new HTuple();
    HTuple hv_DLDevice = new HTuple();
    // Initialize local and output iconic variables 
    hv_BatchSizeInference = new HTuple();
    hv_DLModelHandle = new HTuple();
    hv_ClassNames = new HTuple();
    hv_ClassIDs = new HTuple();
    hv_DLPreprocessParam = new HTuple();
    hv_WindowHandleDict = new HTuple();
    hv_DatasetInfo = new HTuple();
    hv_GenParamDisplay = new HTuple();
    try
    {
      hv_PreprocessParamFileName.Dispose();
      hv_PreprocessParamFileName = "D:/desk/qt/halcon_sourse/logs/segment_pill_defects_preprocess_param.hdict";
      hv_RetrainedModelFileName.Dispose();
      hv_RetrainedModelFileName = "D:/desk/qt/halcon_sourse/logs/segment_pill_defects.hdl";
      hv_DLDeviceHandles.Dispose();
      HOperatorSet.QueryAvailableDlDevices((new HTuple("runtime")).TupleConcat("runtime"), 
          (new HTuple("gpu")).TupleConcat("cpu"), out hv_DLDeviceHandles);
      if ((int)(new HTuple((new HTuple(hv_DLDeviceHandles.TupleLength())).TupleEqual(
          0))) != 0)
      {
        throw new HalconException("No supported device found to continue this example.");
      }
      hv_DLDevice.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLDevice = hv_DLDeviceHandles.TupleSelect(
          0);
      }
      hv_BatchSizeInference.Dispose();
      hv_BatchSizeInference = 1;
      hv_DLModelHandle.Dispose();
      HOperatorSet.ReadDlModel(hv_RetrainedModelFileName, out hv_DLModelHandle);
      hv_ClassNames.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSizeInference);
      HOperatorSet.SetDlModelParam(hv_DLModelHandle, "device", hv_DLDevice);
      hv_DLPreprocessParam.Dispose();
      HOperatorSet.ReadDict(hv_PreprocessParamFileName, new HTuple(), new HTuple(), 
          out hv_DLPreprocessParam);
      hv_WindowHandleDict.Dispose();
      HOperatorSet.CreateDict(out hv_WindowHandleDict);
      hv_DatasetInfo.Dispose();
      HOperatorSet.CreateDict(out hv_DatasetInfo);
      HOperatorSet.SetDictTuple(hv_DatasetInfo, "class_ids", hv_ClassIDs);
      HOperatorSet.SetDictTuple(hv_DatasetInfo, "class_names", hv_ClassNames);
      hv_GenParamDisplay.Dispose();
      HOperatorSet.CreateDict(out hv_GenParamDisplay);
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "segmentation_exclude_class_ids", 
          0);
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "segmentation_transparency", 
          "80");
      HOperatorSet.SetDictTuple(hv_GenParamDisplay, "font_size", 16);

      hv_PreprocessParamFileName.Dispose();
      hv_RetrainedModelFileName.Dispose();
      hv_DLDeviceHandles.Dispose();
      hv_DLDevice.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_PreprocessParamFileName.Dispose();
      hv_RetrainedModelFileName.Dispose();
      hv_DLDeviceHandles.Dispose();
      hv_DLDevice.Dispose();

      throw HDevExpDefaultException;
    }
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_ClassRegions, ho_ClassRegion;
    HObject ho_ConnectedRegions, ho_CurrentRegion;

    // Local control variables 

    HTuple hv_BatchSizeInference = new HTuple();
    HTuple hv_DLModelHandle = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_DLPreprocessParam = new HTuple();
    HTuple hv_WindowHandleDict = new HTuple(), hv_DatasetInfo = new HTuple();
    HTuple hv_GenParamDisplay = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ClassRegions);
    HOperatorSet.GenEmptyObj(out ho_ClassRegion);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_CurrentRegion);
    try
    {

      dev_update_off();
      hv_BatchSizeInference.Dispose();hv_DLModelHandle.Dispose();hv_ClassNames.Dispose();hv_ClassIDs.Dispose();hv_DLPreprocessParam.Dispose();hv_WindowHandleDict.Dispose();hv_DatasetInfo.Dispose();hv_GenParamDisplay.Dispose();
      init(out hv_BatchSizeInference, out hv_DLModelHandle, out hv_ClassNames, out hv_ClassIDs, 
          out hv_DLPreprocessParam, out hv_WindowHandleDict, out hv_DatasetInfo, 
          out hv_GenParamDisplay);
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "D:/desk/qt/halcon_sourse/imgs/1 (0).png");
      ho_ClassRegions.Dispose();ho_ClassRegion.Dispose();ho_ConnectedRegions.Dispose();ho_CurrentRegion.Dispose();
      identity(ho_Image, out ho_ClassRegions, out ho_ClassRegion, out ho_ConnectedRegions, 
          out ho_CurrentRegion, hv_DLPreprocessParam, hv_DLModelHandle, hv_BatchSizeInference, 
          hv_ClassIDs, hv_DatasetInfo, hv_GenParamDisplay, hv_WindowHandleDict, hv_ClassNames);
      dev_close_window_dict(hv_WindowHandleDict);

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_ClassRegions.Dispose();
      ho_ClassRegion.Dispose();
      ho_ConnectedRegions.Dispose();
      ho_CurrentRegion.Dispose();

      hv_BatchSizeInference.Dispose();
      hv_DLModelHandle.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDs.Dispose();
      hv_DLPreprocessParam.Dispose();
      hv_WindowHandleDict.Dispose();
      hv_DatasetInfo.Dispose();
      hv_GenParamDisplay.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Image.Dispose();
    ho_ClassRegions.Dispose();
    ho_ClassRegion.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_CurrentRegion.Dispose();

    hv_BatchSizeInference.Dispose();
    hv_DLModelHandle.Dispose();
    hv_ClassNames.Dispose();
    hv_ClassIDs.Dispose();
    hv_DLPreprocessParam.Dispose();
    hv_WindowHandleDict.Dispose();
    hv_DatasetInfo.Dispose();
    hv_GenParamDisplay.Dispose();

  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

