using HalconDotNet;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace identity
{
    public partial class Form1 : Form
    {
        HTuple handle, Width1, Height1;
        HObject ho_Image;
        bool input_btn = false;
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_DLModelHandle = new HTuple(), hv_DLPreprocessParam = new HTuple();
        HTuple hv_SegmentationThreshold = new HTuple(), hv_ClassificationThreshold = new HTuple();
        public Form1()
        {
            InitializeComponent();
            handle = hWindowControl1.HalconWindow;
            HOperatorSet.ReadImage(out ho_Image, "目标定位背景");
            HOperatorSet.GetImageSize(ho_Image, out Width1, out Height1);
            HOperatorSet.SetPart(handle, 0, 0, Height1 - 1, Width1 - 1);
            HOperatorSet.DispObj(ho_Image, handle);
        }

        private void inputbtn_Click(object sender, EventArgs e)
        {
            hv_DLModelHandle.Dispose();
            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Filter = "文本文件|*.hdl|所有文件|*.*"; // 设置文件过滤器，只允许选择文本文件
            openFileDialog.Multiselect = false; // 只允许选择一个文件
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                string filePath = openFileDialog.FileName; // 获取选择的文件路径
                HOperatorSet.ReadDlModel(filePath, out hv_DLModelHandle);
                MessageBox.Show("模型已导入！");
                input_btn = true;
            }
            else
            {
                MessageBox.Show("导入模型失败！");
            }
        }

        private void identitybtn_Click(object sender, EventArgs e)
        {

            HOperatorSet.GenEmptyObj(out ho_Image);
            hv_DLPreprocessParam.Dispose(); hv_SegmentationThreshold.Dispose(); hv_ClassificationThreshold.Dispose();
            init(hv_DLModelHandle, out hv_DLPreprocessParam, out hv_SegmentationThreshold,
                out hv_ClassificationThreshold);
            ho_Image.Dispose();
            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Filter = "图片文件|*.bmp; *.pcx; *.png; *.jpg; *.gif;*.tif; *.ico; *.dxf; *.cgm; *.cdr; *.wmf; *.eps; *.emf";
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                string filePath = openFileDialog.FileName;
                HOperatorSet.ReadImage(out ho_Image, filePath);
                //拿到实际图片大小
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                HOperatorSet.SetPart(handle, 0, 0, hv_Height - 1, hv_Width - 1);
                HDevWindowStack.Push(handle);
                HOperatorSet.DispObj(ho_Image, handle);
                identity(ho_Image, hv_DLPreprocessParam, hv_DLModelHandle, hv_SegmentationThreshold,
                hv_ClassificationThreshold);
            }
                
              
        }

        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            ho_Image.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLPreprocessParam.Dispose();
            hv_SegmentationThreshold.Dispose();
            hv_ClassificationThreshold.Dispose();
        }

            private void add_colormap_to_image(HObject ho_GrayValueImage, HObject ho_Image,
      out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ChannelScaledByte = null;
            HObject ho_ImageByte, ho_ImageByteR = null, ho_ImageByteG = null;
            HObject ho_ImageByteB = null;

            // Local copy input parameter variables 
            HObject ho_GrayValueImage_COPY_INP_TMP;
            ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
            HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ColoredImage);
            HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
            HOperatorSet.GenEmptyObj(out ho_Channels);
            HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByteR);
            HOperatorSet.GenEmptyObj(out ho_ImageByteG);
            HOperatorSet.GenEmptyObj(out ho_ImageByteB);
            try
            {
                //
                //This procedure adds a gray-value image to a RGB image with a chosen color map.
                //
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
                //The image LUT needs a byte image. Rescale real images.
                if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0,
                            1);
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "byte");
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
                {
                    throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
                }
                //
                //Apply the chosen color scheme on the gray value.
                ho_RGBValueImage.Dispose();
                apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage,
                    hv_HeatmapColorScheme);
                //
                //Convert input image to byte image for visualization.
                ho_Channels.Dispose();
                HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                ho_ChannelsScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
                HTuple end_val19 = hv_NumChannels;
                HTuple step_val19 = 1;
                for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
                {
                    ho_Channel.Dispose();
                    HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
                    hv_ChannelMin.Dispose(); hv_ChannelMax.Dispose(); hv__.Dispose();
                    HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax,
                        out hv__);
                    ho_ChannelScaled.Dispose();
                    scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
                    ho_ChannelScaledByte.Dispose();
                    HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte,
                        "byte");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
                            );
                        ho_ChannelsScaled.Dispose();
                        ho_ChannelsScaled = ExpTmpOutVar_0;
                    }
                }
                ho_ImageByte.Dispose();
                HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
                //
                //Note that ImageByte needs to have the same number of channels as
                //RGBValueImage to display color map image correctly.
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                {
                    //Just take the first channel and use this to generate
                    //an image with 3 channels for visualization.
                    ho_ImageByteR.Dispose();
                    HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
                    ho_ImageByteG.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
                    ho_ImageByteB.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
                    ho_ImageByte.Dispose();
                    HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
                        );
                }
                //
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5,
                        0);
                    ho_RGBValueImage.Dispose();
                    ho_RGBValueImage = ExpTmpOutVar_0;
                }
                ho_ColoredImage.Dispose();
                ho_ColoredImage = new HObject(ho_RGBValueImage);
                //
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Image / Channel
        // Short Description: Create a lookup table and convert a gray scale image. 
        public void apply_colorscheme_on_gray_value_image(HObject ho_InputImage, out HObject ho_ResultImage,
            HTuple hv_Schema)
        {




            // Local iconic variables 

            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_X = new HTuple(), hv_Low = new HTuple();
            HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
            HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
            HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
            HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
            HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ResultImage);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            try
            {
                //
                //This procedure generates an RGB ResultImage for a gray-value InputImage.
                //In order to do so, create a color distribution as look up table
                //according to the Schema.
                //
                hv_X.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_X = HTuple.TupleGenSequence(
                        0, 255, 1);
                }
                hv_Low.Dispose();
                HOperatorSet.TupleGenConst(256, 0, out hv_Low);
                hv_High.Dispose();
                HOperatorSet.TupleGenConst(256, 255, out hv_High);
                //
                if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
                {
                    //Scheme Jet: from blue to red
                    hv_OffR.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffR = 3.0 * 64.0;
                    }
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2.0 * 64.0;
                    }
                    hv_OffB.Dispose();
                    hv_OffB = 64.0;
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
                {
                    //Scheme InvJet: from red to blue.
                    hv_OffR.Dispose();
                    hv_OffR = 64;
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2 * 64;
                    }
                    hv_OffB.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffB = 3 * 64;
                    }
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
                {
                    //Scheme Hot.
                    hv_A1.Dispose();
                    hv_A1 = 3.0;
                    hv_A0R.Dispose();
                    hv_A0R = 0.0;
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
                {
                    //Scheme Inverse Hot.
                    hv_A1.Dispose();
                    hv_A1 = -3.0;
                    hv_A0R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0R = hv_A1 * 255.0;
                    }
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else
                {
                    //
                    throw new HalconException(("Unknown color schema: " + hv_Schema) + ".");
                    //
                }
                //
                ho_ImageR.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
                ho_ImageG.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
                ho_ImageB.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
                ho_ResultImage.Dispose();
                HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
                //
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        private void area_iou(HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType,
            HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea,
            out HTuple hv_IoU)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_GtMask = null, ho_ResMask = null, ho_CurrentGtMask = null;
            HObject ho_ValidResMask = null, ho_RegionIntersection = null;

            // Local control variables 

            HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
            HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
            HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
            HTuple hv_GtRow = new HTuple(), hv_GtCol = new HTuple();
            HTuple hv_GtLength1 = new HTuple(), hv_GtLength2 = new HTuple();
            HTuple hv_GtPhi = new HTuple(), hv_ResRow = new HTuple();
            HTuple hv_ResCol = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            HTuple hv__ = new HTuple(), hv_NumGt = new HTuple(), hv_NumRes = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_GtMask);
            HOperatorSet.GenEmptyObj(out ho_ResMask);
            HOperatorSet.GenEmptyObj(out ho_CurrentGtMask);
            HOperatorSet.GenEmptyObj(out ho_ValidResMask);
            HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
            hv_SampleArea = new HTuple();
            hv_ResultArea = new HTuple();
            hv_IoU = new HTuple();
            try
            {
                //
                //Compute the intersection over union (IoU) between
                //the ground truth and the inferred bounding box or instance
                //segmentation mask of the object instances.
                //The instance type is determined over the InstanceType.
                //
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
                    hv_GtCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
                    hv_GtRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
                    hv_GtCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
                    hv_ResRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
                    hv_ResCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
                    hv_ResRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
                    hv_ResCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
                    //
                    //Sort the results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow1.Dispose();
                            hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol1.Dispose();
                            hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow2.Dispose();
                            hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol2.Dispose();
                            hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                        }
                    }
                    //
                    //Compute areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (hv_GtRow2 - hv_GtRow1) * (hv_GtCol2 - hv_GtCol1);
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (hv_ResRow2 - hv_ResRow1) * (hv_ResCol2 - hv_ResCol1);
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow1.TupleLength())) * (new HTuple(hv_ResRow1.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow1.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_Height.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Height = (((hv_GtRow2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResRow2)) - (((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResRow1));
                            }
                            hv_Width.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Width = (((hv_GtCol2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResCol2)) - (((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResCol1));
                            }
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
                                    0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                hv_Intersection.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection = (hv_Height.TupleSelect(
                                        hv_ValidIdxs)) * (hv_Width.TupleSelect(hv_ValidIdxs));
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow1.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row", out hv_GtRow);
                    hv_GtCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col", out hv_GtCol);
                    hv_GtLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length1", out hv_GtLength1);
                    hv_GtLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length2", out hv_GtLength2);
                    hv_GtPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_phi", out hv_GtPhi);
                    hv_ResRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row", out hv_ResRow);
                    hv_ResCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col", out hv_ResCol);
                    hv_ResLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length1", out hv_ResLength1);
                    hv_ResLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length2", out hv_ResLength2);
                    hv_ResPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_phi", out hv_ResPhi);
                    //
                    //Sort results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow = hv_ResRow.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow.Dispose();
                            hv_ResRow = ExpTmpLocalVar_ResRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol = hv_ResCol.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol.Dispose();
                            hv_ResCol = ExpTmpLocalVar_ResCol;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength1.Dispose();
                            hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength2.Dispose();
                            hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResPhi.Dispose();
                            hv_ResPhi = ExpTmpLocalVar_ResPhi;
                        }
                    }
                    //
                    //Compute Areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (4.0 * hv_GtLength1) * hv_GtLength2;
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (4.0 * hv_ResLength1) * hv_ResLength2;
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow.TupleLength())) * (new HTuple(hv_ResRow.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                    hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                    0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection.Dispose();
                                    HOperatorSet.AreaIntersectionRectangle2(hv_GtRow.TupleSelect(hv_GtIdx),
                                        hv_GtCol.TupleSelect(hv_GtIdx), hv_GtPhi.TupleSelect(hv_GtIdx),
                                        hv_GtLength1.TupleSelect(hv_GtIdx), hv_GtLength2.TupleSelect(hv_GtIdx),
                                        hv_ResRow.TupleSelect(hv_ValidIdxs), hv_ResCol.TupleSelect(hv_ValidIdxs),
                                        hv_ResPhi.TupleSelect(hv_ValidIdxs), hv_ResLength1.TupleSelect(
                                        hv_ValidIdxs), hv_ResLength2.TupleSelect(hv_ValidIdxs), out hv_Intersection);
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_InstanceType.TupleEqual("mask"))) != 0)
                {
                    //Get the ground truth mask.
                    ho_GtMask.Dispose();
                    HOperatorSet.GetDictObject(out ho_GtMask, hv_Sample, "mask");
                    //
                    //Get the result mask.
                    ho_ResMask.Dispose();
                    HOperatorSet.GetDictObject(out ho_ResMask, hv_Result, "mask");
                    //
                    //Sort the results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.SelectObj(ho_ResMask, out ExpTmpOutVar_0, hv_ResultSortIndices + 1);
                        ho_ResMask.Dispose();
                        ho_ResMask = ExpTmpOutVar_0;
                    }
                    //
                    //Compute Areas.
                    hv_SampleArea.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.AreaCenter(ho_GtMask, out hv_SampleArea, out hv__, out hv__);
                    hv_ResultArea.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.AreaCenter(ho_ResMask, out hv_ResultArea, out hv__, out hv__);
                    //
                    //Compute IoUs.
                    hv_NumGt.Dispose();
                    HOperatorSet.CountObj(ho_GtMask, out hv_NumGt);
                    hv_NumRes.Dispose();
                    HOperatorSet.CountObj(ho_ResMask, out hv_NumRes);
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            hv_NumGt * hv_NumRes, 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        HTuple end_val96 = hv_NumGt - 1;
                        HTuple step_val96 = 1;
                        for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val96, step_val96); hv_GtIdx = hv_GtIdx.TupleAdd(step_val96))
                        {
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                    hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                    0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_CurrentGtMask.Dispose();
                                    HOperatorSet.SelectObj(ho_GtMask, out ho_CurrentGtMask, hv_GtIdx + 1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ValidResMask.Dispose();
                                    HOperatorSet.SelectObj(ho_ResMask, out ho_ValidResMask, hv_ValidIdxs + 1);
                                }
                                ho_RegionIntersection.Dispose();
                                HOperatorSet.Intersection(ho_ValidResMask, ho_CurrentGtMask, out ho_RegionIntersection
                                    );
                                hv_Intersection.Dispose(); hv__.Dispose(); hv__.Dispose();
                                HOperatorSet.AreaCenter(ho_RegionIntersection, out hv_Intersection,
                                    out hv__, out hv__);
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * hv_NumRes) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else
                {
                    throw new HalconException(("Instance type '" + hv_InstanceType) + "' is not supported");
                }
                ho_GtMask.Dispose();
                ho_ResMask.Dispose();
                ho_CurrentGtMask.Dispose();
                ho_ValidResMask.Dispose();
                ho_RegionIntersection.Dispose();

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv__.Dispose();
                hv_NumGt.Dispose();
                hv_NumRes.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GtMask.Dispose();
                ho_ResMask.Dispose();
                ho_CurrentGtMask.Dispose();
                ho_ValidResMask.Dispose();
                ho_RegionIntersection.Dispose();

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv__.Dispose();
                hv_NumGt.Dispose();
                hv_NumRes.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_brightness_variation(HTuple hv_DLSample, HTuple hv_BrightnessVariation)
        {



            // Local iconic variables 

            HObject ho_Image = null, ho_ImageScaled;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_BrightnessShift = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //For OCR Recognition samples, only a certain range is allowed for BrightnessVariation.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)((new HTuple(hv_OCRType.TupleEqual("ocr_recognition"))).TupleAnd(new HTuple(hv_BrightnessVariation.TupleGreater(
                    1)))) != 0)
                {
                    throw new HalconException("Value of augmentation method 'brightness_variation' cannot be greater than 1 for ocr_recognition models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //
                //Add random brightness variation.
                hv_BrightnessShift.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BrightnessShift = ((HTuple.TupleRand(
                        1) * 2) - 1) * hv_BrightnessVariation;
                }
                ho_ImageScaled.Dispose();
                HOperatorSet.ScaleImage(ho_Image, out ho_ImageScaled, 1.0, hv_BrightnessShift);
                //
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_ImageScaled, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_ImageScaled.Dispose();

                hv_OCRType.Dispose();
                hv_BrightnessShift.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_ImageScaled.Dispose();

                hv_OCRType.Dispose();
                hv_BrightnessShift.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_brightness_variation_spot(HTuple hv_DLSample, HTuple hv_BrightnessVariation)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_Filter, ho_GaussImage;
            HObject ho_GaussFilter, ho_Gauss, ho_GaussTargetType, ho_AddImage;
            HObject ho_ImageSpot = null;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_BrightnessShift = new HTuple();
            HTuple hv_SpotSize = new HTuple(), hv_SpotRow = new HTuple();
            HTuple hv_SpotColumn = new HTuple(), hv_Direction = new HTuple();
            HTuple hv_ShiftRow = new HTuple(), hv_ShiftCol = new HTuple();
            HTuple hv_Type = new HTuple(), hv_NChannels = new HTuple();
            HTuple hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Filter);
            HOperatorSet.GenEmptyObj(out ho_GaussImage);
            HOperatorSet.GenEmptyObj(out ho_GaussFilter);
            HOperatorSet.GenEmptyObj(out ho_Gauss);
            HOperatorSet.GenEmptyObj(out ho_GaussTargetType);
            HOperatorSet.GenEmptyObj(out ho_AddImage);
            HOperatorSet.GenEmptyObj(out ho_ImageSpot);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method should not be applied to OCR Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)(new HTuple(hv_OCRType.TupleEqual("ocr_recognition"))) != 0)
                {
                    throw new HalconException("The augmentation method 'brightness_variation_spot' is not supported by ocr_recognition models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //Determine random brightness variation.
                hv_BrightnessShift.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BrightnessShift = ((HTuple.TupleRand(
                        1) * 2) - 1) * hv_BrightnessVariation;
                }
                //Determine random spot size between [0.5*ImageHeight, ImageWidth]
                hv_SpotSize.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SpotSize = hv_ImageWidth * ((HTuple.TupleRand(
                        1) / 2) + 0.5);
                }
                //Determine random spot position.
                hv_SpotRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SpotRow = HTuple.TupleRand(
                        1) * hv_ImageHeight;
                }
                hv_SpotColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SpotColumn = HTuple.TupleRand(
                        1) * hv_ImageWidth;
                }
                //
                if ((int)(new HTuple(hv_BrightnessShift.TupleLess(0))) != 0)
                {
                    hv_Direction.Dispose();
                    hv_Direction = 0;
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BrightnessShift = -hv_BrightnessShift;
                            hv_BrightnessShift.Dispose();
                            hv_BrightnessShift = ExpTmpLocalVar_BrightnessShift;
                        }
                    }
                }
                else
                {
                    hv_Direction.Dispose();
                    hv_Direction = 1;
                }
                //Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.
                ho_Filter.Dispose();
                HOperatorSet.GenGaussFilter(out ho_Filter, 1, 1, 0, "none", "dc_center", hv_SpotSize,
                    hv_SpotSize);
                //Shift the filter image to the given position.
                hv_ShiftRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ShiftRow = -((hv_SpotSize / 2) - hv_SpotRow);
                }
                hv_ShiftCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ShiftCol = -((hv_SpotSize / 2) - hv_SpotColumn);
                }
                ho_GaussImage.Dispose();
                HOperatorSet.TileImagesOffset(ho_Filter, out ho_GaussImage, hv_ShiftRow, hv_ShiftCol,
                    -1, -1, -1, -1, hv_ImageWidth, hv_ImageHeight);
                ho_GaussFilter.Dispose();
                HOperatorSet.FullDomain(ho_GaussImage, out ho_GaussFilter);
                //Convert Gauss filter to target image type and apply brightness variation.
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_Image, out hv_Type);
                ho_Gauss.Dispose();
                HOperatorSet.ScaleImage(ho_GaussFilter, out ho_Gauss, hv_BrightnessShift, 0);
                ho_GaussTargetType.Dispose();
                HOperatorSet.ConvertImageType(ho_Gauss, out ho_GaussTargetType, hv_Type);
                //Add channels to fit input image.
                hv_NChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NChannels);
                ho_AddImage.Dispose();
                HOperatorSet.CopyObj(ho_GaussTargetType, out ho_AddImage, 1, 1);
                HTuple end_val43 = hv_NChannels - 1;
                HTuple step_val43 = 1;
                for (hv__ = 1; hv__.Continue(end_val43, step_val43); hv__ = hv__.TupleAdd(step_val43))
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AppendChannel(ho_AddImage, ho_GaussTargetType, out ExpTmpOutVar_0
                            );
                        ho_AddImage.Dispose();
                        ho_AddImage = ExpTmpOutVar_0;
                    }
                }
                //Apply on image.
                if ((int)(hv_Direction) != 0)
                {
                    ho_ImageSpot.Dispose();
                    HOperatorSet.AddImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
                }
                else
                {
                    ho_ImageSpot.Dispose();
                    HOperatorSet.SubImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
                }
                //
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_ImageSpot, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_Filter.Dispose();
                ho_GaussImage.Dispose();
                ho_GaussFilter.Dispose();
                ho_Gauss.Dispose();
                ho_GaussTargetType.Dispose();
                ho_AddImage.Dispose();
                ho_ImageSpot.Dispose();

                hv_OCRType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_BrightnessShift.Dispose();
                hv_SpotSize.Dispose();
                hv_SpotRow.Dispose();
                hv_SpotColumn.Dispose();
                hv_Direction.Dispose();
                hv_ShiftRow.Dispose();
                hv_ShiftCol.Dispose();
                hv_Type.Dispose();
                hv_NChannels.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_Filter.Dispose();
                ho_GaussImage.Dispose();
                ho_GaussFilter.Dispose();
                ho_Gauss.Dispose();
                ho_GaussTargetType.Dispose();
                ho_AddImage.Dispose();
                ho_ImageSpot.Dispose();

                hv_OCRType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_BrightnessShift.Dispose();
                hv_SpotSize.Dispose();
                hv_SpotRow.Dispose();
                hv_SpotColumn.Dispose();
                hv_Direction.Dispose();
                hv_ShiftRow.Dispose();
                hv_ShiftCol.Dispose();
                hv_Type.Dispose();
                hv_NChannels.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_contrast_variation(HTuple hv_DLSample, HTuple hv_ContrastVariation)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_GrayImage = null, ho_MeanImage;
            HObject ho_MeanImageScaled, ho_ImageScaled, ho_ImageOut;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_Borders = new HTuple();
            HTuple hv_Factor = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_MeanGray = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_MeanImage);
            HOperatorSet.GenEmptyObj(out ho_MeanImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageOut);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method should not be applied to OCR Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)(new HTuple(hv_OCRType.TupleEqual("ocr_recognition"))) != 0)
                {
                    throw new HalconException(("The augmentation method 'contrast_variation' is not supported by " + hv_OCRType) + " models.");
                }
                //
                //*** Augmentation ***
                //
                //Adjust contrast of the input image by blending it with its mean image.
                //
                //Minimum and maximum blend factors.
                hv_Borders.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Borders = new HTuple();
                    hv_Borders = hv_Borders.TupleConcat((new HTuple(0.0)).TupleMax2(
                        1 - hv_ContrastVariation));
                    hv_Borders = hv_Borders.TupleConcat(1 + hv_ContrastVariation);
                }
                //Random blend factor.
                hv_Factor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Factor = (hv_Borders.TupleSelect(
                        0)) + (((hv_Borders.TupleSelect(1)) - (hv_Borders.TupleSelect(0))) * HTuple.TupleRand(
                        1));
                }
                //
                if ((int)(new HTuple(hv_Factor.TupleEqual(1.0))) != 0)
                {
                    ho_Image.Dispose();
                    ho_GrayImage.Dispose();
                    ho_MeanImage.Dispose();
                    ho_MeanImageScaled.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_ImageOut.Dispose();

                    hv_OCRType.Dispose();
                    hv_Borders.Dispose();
                    hv_Factor.Dispose();
                    hv_NumChannels.Dispose();
                    hv_MeanGray.Dispose();
                    hv__.Dispose();

                    return;
                }
                //
                //Convert Image to a gray value image.
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleEqual(1))) != 0)
                {
                    ho_GrayImage.Dispose();
                    ho_GrayImage = new HObject(ho_Image);
                }
                else if ((int)(new HTuple(hv_NumChannels.TupleEqual(3))) != 0)
                {
                    ho_GrayImage.Dispose();
                    HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
                }
                else
                {
                    throw new HalconException("The augmentation method 'contrast_variation' can only be applied to gray scale and RGB images.");
                }
                //
                //Compute the mean of the gray value image.
                hv_MeanGray.Dispose(); hv__.Dispose();
                HOperatorSet.Intensity(ho_GrayImage, ho_GrayImage, out hv_MeanGray, out hv__);
                //Create a constant image with the gray value mean.
                ho_MeanImage.Dispose();
                HOperatorSet.GenImageProto(ho_GrayImage, out ho_MeanImage, hv_MeanGray);
                if ((int)(new HTuple(hv_NumChannels.TupleEqual(3))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Compose3(ho_MeanImage, ho_MeanImage, ho_MeanImage, out ExpTmpOutVar_0
                            );
                        ho_MeanImage.Dispose();
                        ho_MeanImage = ExpTmpOutVar_0;
                    }
                }
                //
                //Blend Image and MeanImage.
                //The resulting ImageOut will have the same domain as Image.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_MeanImageScaled.Dispose();
                    HOperatorSet.ScaleImage(ho_MeanImage, out ho_MeanImageScaled, 1.0 - hv_Factor,
                        0.0);
                }
                ho_ImageScaled.Dispose();
                HOperatorSet.ScaleImage(ho_Image, out ho_ImageScaled, hv_Factor, 0.0);
                ho_ImageOut.Dispose();
                HOperatorSet.AddImage(ho_MeanImageScaled, ho_ImageScaled, out ho_ImageOut,
                    1.0, 0.0);
                //
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_ImageOut, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_GrayImage.Dispose();
                ho_MeanImage.Dispose();
                ho_MeanImageScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageOut.Dispose();

                hv_OCRType.Dispose();
                hv_Borders.Dispose();
                hv_Factor.Dispose();
                hv_NumChannels.Dispose();
                hv_MeanGray.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_GrayImage.Dispose();
                ho_MeanImage.Dispose();
                ho_MeanImageScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageOut.Dispose();

                hv_OCRType.Dispose();
                hv_Borders.Dispose();
                hv_Factor.Dispose();
                hv_NumChannels.Dispose();
                hv_MeanGray.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_crop_percentage(HTuple hv_DLSample, HTuple hv_CropPercentage)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_ImagePart;

            // Local control variables 

            HTuple hv_ClassificationLabelExists = new HTuple();
            HTuple hv_XKeyExists = new HTuple(), hv_SegmenationImageKeyExists = new HTuple();
            HTuple hv_GrippingPointKeysExists = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_CropRate = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Key = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImagePart);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation can only be applied to samples from a classification or
                //3D Gripping Point Detection datasets.
                hv_ClassificationLabelExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_label_id", out hv_ClassificationLabelExists);
                hv_XKeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "x", out hv_XKeyExists);
                hv_SegmenationImageKeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_image",
                    out hv_SegmenationImageKeyExists);
                hv_GrippingPointKeysExists.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GrippingPointKeysExists = hv_XKeyExists.TupleAnd(
                        hv_SegmenationImageKeyExists);
                }
                if ((int)((new HTuple(hv_ClassificationLabelExists.TupleOr(hv_GrippingPointKeysExists))).TupleNot()
                    ) != 0)
                {
                    throw new HalconException("The augmentation method 'crop_percentage' is only supported by classification or 3D gripping point detection models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //
                //Define cropping rectangle.
                hv_CropRate.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CropRate = hv_CropPercentage * 0.01;
                }
                hv_Row1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row1 = ((((1 - hv_CropRate) * hv_ImageHeight) * HTuple.TupleRand(
                        1))).TupleFloor();
                }
                hv_Row2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row2 = hv_Row1 + (hv_CropRate * hv_ImageHeight);
                }
                hv_Column1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Column1 = ((((1 - hv_CropRate) * hv_ImageWidth) * HTuple.TupleRand(
                        1))).TupleFloor();
                }
                hv_Column2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Column2 = hv_Column1 + (hv_CropRate * hv_ImageWidth);
                }
                //
                //Crop the image.
                ho_ImagePart.Dispose();
                HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                    hv_Row2, hv_Column2);
                //
                //Scale image to the input size and set the augmented image to DLSample.
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                        hv_ImageHeight, "constant");
                    ho_ImagePart.Dispose();
                    ho_ImagePart = ExpTmpOutVar_0;
                }
                HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                //
                //3D sensor data should not be interpolated to avoid introducing unwanted
                //interpolation effects. Therfore we use 'nearest_neighbor' interpolation.
                if ((int)(hv_GrippingPointKeysExists) != 0)
                {
                    hv_Keys.Dispose();
                    hv_Keys = new HTuple();
                    hv_Keys[0] = "x";
                    hv_Keys[1] = "y";
                    hv_Keys[2] = "z";
                    hv_Keys[3] = "normals";
                    hv_Keys[4] = "segmentation_image";
                    hv_Keys[5] = "weight_image";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_Keys.TupleSelect(
                                hv_Index);
                        }
                        ho_Image.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image = hv_DLSample.TupleGetDictObject(
                                hv_Key);
                        }
                        //
                        //Crop the image.
                        ho_ImagePart.Dispose();
                        HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                            hv_Row2, hv_Column2);
                        //
                        //Scale image to the input size and set the augmented image to DLSample.
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                                hv_ImageHeight, "nearest_neighbor");
                            ho_ImagePart.Dispose();
                            ho_ImagePart = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, hv_Key);
                    }
                }
                ho_Image.Dispose();
                ho_ImagePart.Dispose();

                hv_ClassificationLabelExists.Dispose();
                hv_XKeyExists.Dispose();
                hv_SegmenationImageKeyExists.Dispose();
                hv_GrippingPointKeysExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_CropRate.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_ImagePart.Dispose();

                hv_ClassificationLabelExists.Dispose();
                hv_XKeyExists.Dispose();
                hv_SegmenationImageKeyExists.Dispose();
                hv_GrippingPointKeysExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_CropRate.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_crop_pixel(HTuple hv_DLSample, HTuple hv_CropPixel)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_ImagePart;

            // Local control variables 

            HTuple hv_ClassificationLabelExists = new HTuple();
            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_Length = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Column2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImagePart);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation can only be applied to samples from a classification dataset.
                hv_ClassificationLabelExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_label_id", out hv_ClassificationLabelExists);
                if ((int)(hv_ClassificationLabelExists.TupleNot()) != 0)
                {
                    throw new HalconException("The augmentation method 'crop_pixel' is only supported by classification models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //
                //Define cropping rectangle.
                hv_Length.Dispose();
                hv_Length = new HTuple(hv_CropPixel);
                hv_Row1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row1 = HTuple.TupleRand(
                        1) * (hv_ImageHeight - hv_Length);
                }
                hv_Row2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row2 = (hv_Row1 + hv_Length) - 1;
                }
                hv_Column1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Column1 = HTuple.TupleRand(
                        1) * (hv_ImageWidth - hv_Length);
                }
                hv_Column2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Column2 = (hv_Column1 + hv_Length) - 1;
                }
                //
                //Crop the image.
                ho_ImagePart.Dispose();
                HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                    hv_Row2, hv_Column2);
                //
                //Scale the image to the input size and set the augmented image to DLSample.
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                        hv_ImageHeight, "constant");
                    ho_ImagePart.Dispose();
                    ho_ImagePart = ExpTmpOutVar_0;
                }
                HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_ImagePart.Dispose();

                hv_ClassificationLabelExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_ImagePart.Dispose();

                hv_ClassificationLabelExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_mirror(HTuple hv_DLSample, HTuple hv_MirrorMethods,
            HTuple hv_ClassIDsNoOrientation, HTuple hv_IgnoreDirection)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_Mask = null, ho_SegmentationImage = null;
            HObject ho_WeightImage = null;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
            HTuple hv_Rectangle2ParamExist = new HTuple(), hv_InstanceMaskExists = new HTuple();
            HTuple hv_SegmentationImageExists = new HTuple(), hv_WeightImageExists = new HTuple();
            HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxCol1 = new HTuple();
            HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxCol2 = new HTuple();
            HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
            HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabelID = new HTuple();
            HTuple hv_NumMirrorMethods = new HTuple(), hv_ProbabilityMethods = new HTuple();
            HTuple hv_StrMirror = new HTuple(), hv_StrIdx = new HTuple();
            HTuple hv_SelectedChar = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_BBoxCol1Mirror = new HTuple();
            HTuple hv_BBoxCol2Mirror = new HTuple(), hv_ObjIdx = new HTuple();
            HTuple hv_BBoxRow1Mirror = new HTuple(), hv_BBoxRow2Mirror = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Mask);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
            HOperatorSet.GenEmptyObj(out ho_WeightImage);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method should not be applied to OCR Detection/Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)((new HTuple(hv_OCRType.TupleEqual("ocr_detection"))).TupleOr(new HTuple(hv_OCRType.TupleEqual(
                    "ocr_recognition")))) != 0)
                {
                    throw new HalconException(("The augmentation method 'mirror' is not supported by " + hv_OCRType) + " models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //Get the annotations from the sample that need to be
                //augmented together with the image.
                hv_Rectangle1ParamExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_row1", out hv_Rectangle1ParamExist);
                hv_Rectangle2ParamExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_phi", out hv_Rectangle2ParamExist);
                hv_InstanceMaskExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "mask", out hv_InstanceMaskExists);
                hv_SegmentationImageExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_image",
                    out hv_SegmentationImageExists);
                hv_WeightImageExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
                if ((int)(hv_Rectangle1ParamExist) != 0)
                {
                    hv_BBoxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
                    hv_BBoxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
                    hv_BBoxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
                    hv_BBoxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
                }
                else if ((int)(hv_Rectangle2ParamExist) != 0)
                {
                    hv_BBoxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
                    hv_BBoxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
                    hv_BBoxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
                    if ((int)(new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_BBoxLabelID.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabelID);
                    }
                }
                if ((int)(hv_InstanceMaskExists) != 0)
                {
                    ho_Mask.Dispose();
                    HOperatorSet.GetDictObject(out ho_Mask, hv_DLSample, "mask");
                }
                if ((int)(hv_SegmentationImageExists) != 0)
                {
                    ho_SegmentationImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
                }
                if ((int)(hv_WeightImageExists) != 0)
                {
                    ho_WeightImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_WeightImage, hv_DLSample, "weight_image");
                }
                //
                //Mirroring
                //
                //If more than one axis is allowed,
                //choose mirror axis/axes to be applied.
                hv_NumMirrorMethods.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumMirrorMethods = hv_MirrorMethods.TupleStrlen()
                        ;
                }
                hv_ProbabilityMethods.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProbabilityMethods = 1.0 / hv_NumMirrorMethods;
                }
                hv_StrMirror.Dispose();
                hv_StrMirror = "";
                while ((int)(new HTuple(hv_StrMirror.TupleEqual(""))) != 0)
                {
                    HTuple end_val52 = hv_NumMirrorMethods - 1;
                    HTuple step_val52 = 1;
                    for (hv_StrIdx = 0; hv_StrIdx.Continue(end_val52, step_val52); hv_StrIdx = hv_StrIdx.TupleAdd(step_val52))
                    {
                        hv_SelectedChar.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SelectedChar = hv_MirrorMethods.TupleStrBitSelect(
                                hv_StrIdx);
                        }
                        if ((int)(new HTuple((HTuple.TupleRand(1)).TupleLess(hv_ProbabilityMethods))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_StrMirror = hv_StrMirror + hv_SelectedChar;
                                    hv_StrMirror.Dispose();
                                    hv_StrMirror = ExpTmpLocalVar_StrMirror;
                                }
                            }
                        }
                    }
                }
                //Apply the chosen mirror axis/axes to the given sample data.
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                if ((int)(hv_StrMirror.TupleRegexpTest("c")) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "column");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    if ((int)(hv_Rectangle1ParamExist) != 0)
                    {
                        hv_BBoxCol1Mirror.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol1Mirror = (hv_ImageWidth - hv_BBoxCol2) - 1;
                        }
                        hv_BBoxCol2Mirror.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol2Mirror = (hv_ImageWidth - hv_BBoxCol1) - 1;
                        }
                        hv_BBoxCol1.Dispose();
                        hv_BBoxCol1 = new HTuple(hv_BBoxCol1Mirror);
                        hv_BBoxCol2.Dispose();
                        hv_BBoxCol2 = new HTuple(hv_BBoxCol2Mirror);
                    }
                    else if ((int)(hv_Rectangle2ParamExist) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxCol = (hv_ImageWidth - hv_BBoxCol) - 1;
                                hv_BBoxCol.Dispose();
                                hv_BBoxCol = ExpTmpLocalVar_BBoxCol;
                            }
                        }
                        //Check that BBoxPhi is only mirrored for classes with orientation.
                        if ((int)(new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))) != 0)
                        {
                            for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                            {
                                if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                    hv_ObjIdx)))).TupleEqual(-1))) != 0)
                                {
                                    if ((int)(hv_IgnoreDirection) != 0)
                                    {
                                        if (hv_BBoxPhi == null)
                                            hv_BBoxPhi = new HTuple();
                                        hv_BBoxPhi[hv_ObjIdx] = -(hv_BBoxPhi.TupleSelect(hv_ObjIdx));
                                    }
                                    else
                                    {
                                        if (hv_BBoxPhi == null)
                                            hv_BBoxPhi = new HTuple();
                                        hv_BBoxPhi[hv_ObjIdx] = (((-(((hv_BBoxPhi.TupleSelect(hv_ObjIdx))).TupleLessElem(
                                            0.0))) + (((hv_BBoxPhi.TupleSelect(hv_ObjIdx))).TupleGreaterEqualElem(
                                            0.0))) * ((new HTuple(180)).TupleRad())) - (hv_BBoxPhi.TupleSelect(
                                            hv_ObjIdx));
                                    }
                                }
                            }
                        }
                        else
                        {
                            if ((int)(hv_IgnoreDirection) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BBoxPhi = -hv_BBoxPhi;
                                        hv_BBoxPhi.Dispose();
                                        hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BBoxPhi = (((-(hv_BBoxPhi.TupleLessElem(
                                            0.0))) + (hv_BBoxPhi.TupleGreaterEqualElem(0.0))) * ((new HTuple(180)).TupleRad()
                                            )) - hv_BBoxPhi;
                                        hv_BBoxPhi.Dispose();
                                        hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                    }
                                }
                            }
                        }
                    }
                    if ((int)(hv_InstanceMaskExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorRegion(ho_Mask, out ExpTmpOutVar_0, "column", hv_ImageWidth);
                            ho_Mask.Dispose();
                            ho_Mask = ExpTmpOutVar_0;
                        }
                    }
                    if ((int)(hv_SegmentationImageExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0, "column");
                            ho_SegmentationImage.Dispose();
                            ho_SegmentationImage = ExpTmpOutVar_0;
                        }
                    }
                    if ((int)(hv_WeightImageExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "column");
                            ho_WeightImage.Dispose();
                            ho_WeightImage = ExpTmpOutVar_0;
                        }
                    }
                }
                //
                if ((int)(hv_StrMirror.TupleRegexpTest("r")) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "row");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    if ((int)(hv_Rectangle1ParamExist) != 0)
                    {
                        hv_BBoxRow1Mirror.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow1Mirror = (hv_ImageHeight - hv_BBoxRow2) - 1;
                        }
                        hv_BBoxRow2Mirror.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow2Mirror = (hv_ImageHeight - hv_BBoxRow1) - 1;
                        }
                        hv_BBoxRow1.Dispose();
                        hv_BBoxRow1 = new HTuple(hv_BBoxRow1Mirror);
                        hv_BBoxRow2.Dispose();
                        hv_BBoxRow2 = new HTuple(hv_BBoxRow2Mirror);
                    }
                    else if ((int)(hv_Rectangle2ParamExist) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxRow = (hv_ImageHeight - hv_BBoxRow) - 1;
                                hv_BBoxRow.Dispose();
                                hv_BBoxRow = ExpTmpLocalVar_BBoxRow;
                            }
                        }
                        if ((int)(new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))) != 0)
                        {
                            for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                            {
                                if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                    hv_ObjIdx)))).TupleEqual(-1))) != 0)
                                {
                                    if (hv_BBoxPhi == null)
                                        hv_BBoxPhi = new HTuple();
                                    hv_BBoxPhi[hv_ObjIdx] = -(hv_BBoxPhi.TupleSelect(hv_ObjIdx));
                                }
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_BBoxPhi = -hv_BBoxPhi;
                                    hv_BBoxPhi.Dispose();
                                    hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                }
                            }
                        }
                    }
                    if ((int)(hv_InstanceMaskExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorRegion(ho_Mask, out ExpTmpOutVar_0, "row", hv_ImageHeight);
                            ho_Mask.Dispose();
                            ho_Mask = ExpTmpOutVar_0;
                        }
                    }
                    if ((int)(hv_SegmentationImageExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0, "row");
                            ho_SegmentationImage.Dispose();
                            ho_SegmentationImage = ExpTmpOutVar_0;
                        }
                    }
                    if ((int)(hv_WeightImageExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "row");
                            ho_WeightImage.Dispose();
                            ho_WeightImage = ExpTmpOutVar_0;
                        }
                    }
                }
                //
                //Set the mirrored data to DLSample.
                HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                if ((int)(hv_Rectangle1ParamExist) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
                }
                else if ((int)(hv_Rectangle2ParamExist) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_BBoxRow);
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_BBoxCol);
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhi);
                }
                if ((int)(hv_InstanceMaskExists) != 0)
                {
                    HOperatorSet.SetDictObject(ho_Mask, hv_DLSample, "mask");
                }
                if ((int)(hv_SegmentationImageExists) != 0)
                {
                    HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
                }
                if ((int)(hv_WeightImageExists) != 0)
                {
                    HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
                }
                ho_Image.Dispose();
                ho_Mask.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();

                hv_OCRType.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_NumMirrorMethods.Dispose();
                hv_ProbabilityMethods.Dispose();
                hv_StrMirror.Dispose();
                hv_StrIdx.Dispose();
                hv_SelectedChar.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_BBoxCol1Mirror.Dispose();
                hv_BBoxCol2Mirror.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxRow1Mirror.Dispose();
                hv_BBoxRow2Mirror.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_Mask.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();

                hv_OCRType.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_NumMirrorMethods.Dispose();
                hv_ProbabilityMethods.Dispose();
                hv_StrMirror.Dispose();
                hv_StrIdx.Dispose();
                hv_SelectedChar.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_BBoxCol1Mirror.Dispose();
                hv_BBoxCol2Mirror.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxRow1Mirror.Dispose();
                hv_BBoxRow2Mirror.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_remove_pixel(HTuple hv_DLSample, HTuple hv_NumPixelsToRemoveX,
            HTuple hv_NumPixelsToRemoveY)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_ImageHighRes = null;
            HObject ho_Domain, ho_DomainHighRes = null, ho_ImagePart;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_IsOCRRecognition = new HTuple();
            HTuple hv_AugmentationDataExists = new HTuple(), hv_AugmentationData = new HTuple();
            HTuple hv_ImageHighResExists = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_ImageHighResWidth = new HTuple();
            HTuple hv_ImageHighResHeight = new HTuple();
            HTuple hv_NumPixelsToRemoveX_COPY_INP_TMP = new HTuple(hv_NumPixelsToRemoveX);
            HTuple hv_NumPixelsToRemoveY_COPY_INP_TMP = new HTuple(hv_NumPixelsToRemoveY);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageHighRes);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_DomainHighRes);
            HOperatorSet.GenEmptyObj(out ho_ImagePart);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method applies only to OCR Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                hv_IsOCRRecognition.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsOCRRecognition = new HTuple(hv_OCRType.TupleEqual(
                        "ocr_recognition"));
                }
                if ((int)(hv_IsOCRRecognition.TupleNot()) != 0)
                {
                    throw new HalconException("The augmentation method 'remove_pixel' is only supported by ocr_recognition models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //
                //Select the augmentation image with high resolution if available for ocr_recognition models.
                //Note the difference between Image and ImageHighRes.
                hv_AugmentationDataExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "augmentation_data", out hv_AugmentationDataExists);
                if ((int)(hv_IsOCRRecognition.TupleAnd(hv_AugmentationDataExists)) != 0)
                {
                    hv_AugmentationData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AugmentationData = hv_DLSample.TupleGetDictTuple(
                            "augmentation_data");
                    }
                    hv_ImageHighResExists.Dispose();
                    HOperatorSet.GetDictParam(hv_AugmentationData, "key_exists", "image_high_res",
                        out hv_ImageHighResExists);
                    if ((int)(hv_ImageHighResExists) != 0)
                    {
                        ho_ImageHighRes.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ImageHighRes = hv_AugmentationData.TupleGetDictObject(
                                "image_high_res");
                        }
                    }
                }
                //
                //Get dimensions of the domain of the preprocessed image,
                //The domain is assumed to be a rectangle1 domain.
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_Image, out ho_Domain);
                hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                HOperatorSet.SmallestRectangle1(ho_Domain, out hv_Row1, out hv_Column1, out hv_Row2,
                    out hv_Column2);
                hv_Width.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Width = (hv_Column2 - hv_Column1) + 1;
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = (hv_Row2 - hv_Row1) + 1;
                }
                //Do nothing if no pixel would remain available.
                if ((int)((new HTuple(hv_Width.TupleLessEqual(2 * hv_NumPixelsToRemoveX_COPY_INP_TMP))).TupleOr(
                    new HTuple(hv_Height.TupleLessEqual(2 * hv_NumPixelsToRemoveY_COPY_INP_TMP)))) != 0)
                {
                    ho_Image.Dispose();
                    ho_ImageHighRes.Dispose();
                    ho_Domain.Dispose();
                    ho_DomainHighRes.Dispose();
                    ho_ImagePart.Dispose();

                    hv_NumPixelsToRemoveX_COPY_INP_TMP.Dispose();
                    hv_NumPixelsToRemoveY_COPY_INP_TMP.Dispose();
                    hv_OCRType.Dispose();
                    hv_IsOCRRecognition.Dispose();
                    hv_AugmentationDataExists.Dispose();
                    hv_AugmentationData.Dispose();
                    hv_ImageHighResExists.Dispose();
                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column2.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_ImageHighResWidth.Dispose();
                    hv_ImageHighResHeight.Dispose();

                    return;
                }
                //In case of ocr_recognition use the high-resolution image if available.
                if ((int)(hv_IsOCRRecognition.TupleAnd(hv_AugmentationDataExists)) != 0)
                {
                    hv_ImageHighResWidth.Dispose(); hv_ImageHighResHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_ImageHighRes, out hv_ImageHighResWidth, out hv_ImageHighResHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NumPixelsToRemoveX = (((hv_NumPixelsToRemoveX_COPY_INP_TMP * hv_ImageHighResWidth) / (hv_Width.TupleReal()
                                ))).TupleInt();
                            hv_NumPixelsToRemoveX_COPY_INP_TMP.Dispose();
                            hv_NumPixelsToRemoveX_COPY_INP_TMP = ExpTmpLocalVar_NumPixelsToRemoveX;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NumPixelsToRemoveY = (((hv_NumPixelsToRemoveY_COPY_INP_TMP * hv_ImageHighResHeight) / (hv_Height.TupleReal()
                                ))).TupleInt();
                            hv_NumPixelsToRemoveY_COPY_INP_TMP.Dispose();
                            hv_NumPixelsToRemoveY_COPY_INP_TMP = ExpTmpLocalVar_NumPixelsToRemoveY;
                        }
                    }
                    ho_Image.Dispose();
                    ho_Image = new HObject(ho_ImageHighRes);
                    //The high-resolution image is expected to have full domain.
                    ho_DomainHighRes.Dispose();
                    HOperatorSet.GetDomain(ho_ImageHighRes, out ho_DomainHighRes);
                    hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                    HOperatorSet.SmallestRectangle1(ho_DomainHighRes, out hv_Row1, out hv_Column1,
                        out hv_Row2, out hv_Column2);
                }
                //Define cropping rectangle.
                if ((int)(new HTuple(hv_NumPixelsToRemoveY_COPY_INP_TMP.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Row1 = hv_Row1 + ((((HTuple.TupleRand(
                                1) * hv_NumPixelsToRemoveY_COPY_INP_TMP)).TupleInt()) + 1);
                            hv_Row1.Dispose();
                            hv_Row1 = ExpTmpLocalVar_Row1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Row2 = hv_Row2 - ((((HTuple.TupleRand(
                                1) * hv_NumPixelsToRemoveY_COPY_INP_TMP)).TupleInt()) + 1);
                            hv_Row2.Dispose();
                            hv_Row2 = ExpTmpLocalVar_Row2;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumPixelsToRemoveX_COPY_INP_TMP.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Column1 = hv_Column1 + ((((HTuple.TupleRand(
                                1) * hv_NumPixelsToRemoveX_COPY_INP_TMP)).TupleInt()) + 1);
                            hv_Column1.Dispose();
                            hv_Column1 = ExpTmpLocalVar_Column1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Column2 = hv_Column2 - ((((HTuple.TupleRand(
                                1) * hv_NumPixelsToRemoveX_COPY_INP_TMP)).TupleInt()) + 1);
                            hv_Column2.Dispose();
                            hv_Column2 = ExpTmpLocalVar_Column2;
                        }
                    }
                }
                //Crop the image.
                ho_ImagePart.Dispose();
                HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                    hv_Row2, hv_Column2);
                //Scale the image to the input size and set the augmented image to DLSample.
                if ((int)(hv_IsOCRRecognition.TupleAnd(hv_AugmentationDataExists)) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        preprocess_dl_model_images_ocr_recognition(ho_ImagePart, out ExpTmpOutVar_0,
                            hv_AugmentationData.TupleGetDictTuple("preprocess_params"));
                        ho_ImagePart.Dispose();
                        ho_ImagePart = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                            hv_ImageHeight, "constant");
                        ho_ImagePart.Dispose();
                        ho_ImagePart = ExpTmpOutVar_0;
                    }
                }
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_ImageHighRes.Dispose();
                ho_Domain.Dispose();
                ho_DomainHighRes.Dispose();
                ho_ImagePart.Dispose();

                hv_NumPixelsToRemoveX_COPY_INP_TMP.Dispose();
                hv_NumPixelsToRemoveY_COPY_INP_TMP.Dispose();
                hv_OCRType.Dispose();
                hv_IsOCRRecognition.Dispose();
                hv_AugmentationDataExists.Dispose();
                hv_AugmentationData.Dispose();
                hv_ImageHighResExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ImageHighResWidth.Dispose();
                hv_ImageHighResHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_ImageHighRes.Dispose();
                ho_Domain.Dispose();
                ho_DomainHighRes.Dispose();
                ho_ImagePart.Dispose();

                hv_NumPixelsToRemoveX_COPY_INP_TMP.Dispose();
                hv_NumPixelsToRemoveY_COPY_INP_TMP.Dispose();
                hv_OCRType.Dispose();
                hv_IsOCRRecognition.Dispose();
                hv_AugmentationDataExists.Dispose();
                hv_AugmentationData.Dispose();
                hv_ImageHighResExists.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ImageHighResWidth.Dispose();
                hv_ImageHighResHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_rotate(HTuple hv_DLSample, HTuple hv_RotationStep,
            HTuple hv_ClassIDsNoOrientation, HTuple hv_IgnoreDirection)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_Mask = null, ho_SegmentationImage = null;
            HObject ho_WeightImage = null, ho_ImageRotate = null;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
            HTuple hv_Rectangle2ParamExist = new HTuple(), hv_InstanceMaskExists = new HTuple();
            HTuple hv_SegmentationImageExists = new HTuple(), hv_WeightImageExists = new HTuple();
            HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxCol1 = new HTuple();
            HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxCol2 = new HTuple();
            HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
            HTuple hv_BBoxLength1 = new HTuple(), hv_BBoxLength2 = new HTuple();
            HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabelID = new HTuple();
            HTuple hv_NumPossibleRotations = new HTuple(), hv_CurrentRotation = new HTuple();
            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DTmp = new HTuple();
            HTuple hv_HomMat2DAdapted = new HTuple(), hv_Offset = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_RowTrans1 = new HTuple();
            HTuple hv_ColTrans1 = new HTuple(), hv_RowTrans2 = new HTuple();
            HTuple hv_ColTrans2 = new HTuple(), hv_RowTrans = new HTuple();
            HTuple hv_ColTrans = new HTuple(), hv_MaxAngle = new HTuple();
            HTuple hv_DiffAngle = new HTuple(), hv_IndicesLarge = new HTuple();
            HTuple hv_ObjIdx = new HTuple(), hv_BBoxLengthTmp = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Mask);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
            HOperatorSet.GenEmptyObj(out ho_WeightImage);
            HOperatorSet.GenEmptyObj(out ho_ImageRotate);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method should not be applied to OCR Detection/Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)((new HTuple(hv_OCRType.TupleEqual("ocr_detection"))).TupleOr(new HTuple(hv_OCRType.TupleEqual(
                    "ocr_recognition")))) != 0)
                {
                    throw new HalconException(("The augmentation method 'rotate' is not supported by " + hv_OCRType) + " models.");
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //Get the annotations from the sample that need to be
                //augmented together with the image.
                hv_Rectangle1ParamExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_row1", out hv_Rectangle1ParamExist);
                hv_Rectangle2ParamExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_phi", out hv_Rectangle2ParamExist);
                hv_InstanceMaskExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "mask", out hv_InstanceMaskExists);
                hv_SegmentationImageExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_image",
                    out hv_SegmentationImageExists);
                hv_WeightImageExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
                if ((int)(hv_Rectangle1ParamExist) != 0)
                {
                    hv_BBoxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
                    hv_BBoxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
                    hv_BBoxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
                    hv_BBoxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
                }
                else if ((int)(hv_Rectangle2ParamExist) != 0)
                {
                    hv_BBoxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
                    hv_BBoxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
                    hv_BBoxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BBoxLength1);
                    hv_BBoxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BBoxLength2);
                    hv_BBoxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
                    if ((int)(new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_BBoxLabelID.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabelID);
                    }
                }
                if ((int)(hv_InstanceMaskExists) != 0)
                {
                    ho_Mask.Dispose();
                    HOperatorSet.GetDictObject(out ho_Mask, hv_DLSample, "mask");
                }
                if ((int)(hv_SegmentationImageExists) != 0)
                {
                    ho_SegmentationImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
                }
                if ((int)(hv_WeightImageExists) != 0)
                {
                    ho_WeightImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_WeightImage, hv_DLSample, "weight_image");
                }
                //
                //Rotation
                //
                //Determine rotation angle for distortion type 'rotate' (angle in range (0:RotationStep:360)).
                hv_NumPossibleRotations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumPossibleRotations = (360.0 / hv_RotationStep) - 1;
                }
                hv_CurrentRotation.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentRotation = hv_RotationStep * ((((hv_NumPossibleRotations * HTuple.TupleRand(
                        1))).TupleInt()) + 1);
                }
                //
                if ((int)(new HTuple(hv_CurrentRotation.TupleNotEqual(0))) != 0)
                {
                    hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                    if ((int)((new HTuple(hv_ImageWidth.TupleNotEqual(hv_ImageHeight))).TupleAnd(
                        new HTuple(hv_CurrentRotation.TupleNotEqual(180.0)))) != 0)
                    {
                        //If an image is not quadratic, a rotation by 90 or 270 degrees is ignored.
                        ho_Image.Dispose();
                        ho_Mask.Dispose();
                        ho_SegmentationImage.Dispose();
                        ho_WeightImage.Dispose();
                        ho_ImageRotate.Dispose();

                        hv_OCRType.Dispose();
                        hv_Rectangle1ParamExist.Dispose();
                        hv_Rectangle2ParamExist.Dispose();
                        hv_InstanceMaskExists.Dispose();
                        hv_SegmentationImageExists.Dispose();
                        hv_WeightImageExists.Dispose();
                        hv_BBoxRow1.Dispose();
                        hv_BBoxCol1.Dispose();
                        hv_BBoxRow2.Dispose();
                        hv_BBoxCol2.Dispose();
                        hv_BBoxRow.Dispose();
                        hv_BBoxCol.Dispose();
                        hv_BBoxLength1.Dispose();
                        hv_BBoxLength2.Dispose();
                        hv_BBoxPhi.Dispose();
                        hv_BBoxLabelID.Dispose();
                        hv_NumPossibleRotations.Dispose();
                        hv_CurrentRotation.Dispose();
                        hv_ImageWidth.Dispose();
                        hv_ImageHeight.Dispose();
                        hv_HomMat2DIdentity.Dispose();
                        hv_HomMat2DTmp.Dispose();
                        hv_HomMat2DAdapted.Dispose();
                        hv_Offset.Dispose();
                        hv_HomMat2DRotate.Dispose();
                        hv_RowTrans1.Dispose();
                        hv_ColTrans1.Dispose();
                        hv_RowTrans2.Dispose();
                        hv_ColTrans2.Dispose();
                        hv_RowTrans.Dispose();
                        hv_ColTrans.Dispose();
                        hv_MaxAngle.Dispose();
                        hv_DiffAngle.Dispose();
                        hv_IndicesLarge.Dispose();
                        hv_ObjIdx.Dispose();
                        hv_BBoxLengthTmp.Dispose();

                        return;
                    }
                    //
                    ho_ImageRotate.Dispose();
                    HOperatorSet.RotateImage(ho_Image, out ho_ImageRotate, hv_CurrentRotation,
                        "constant");
                    HOperatorSet.SetDictObject(ho_ImageRotate, hv_DLSample, "image");
                    //
                    if ((int)(hv_Rectangle1ParamExist.TupleOr(hv_Rectangle2ParamExist)) != 0)
                    {
                        //Create a transformation matrix for the rotation of the bounding boxes.
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        hv_HomMat2DIdentity.Dispose();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        hv_HomMat2DTmp.Dispose();
                        HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, 0.5, 0.5, out hv_HomMat2DTmp);
                        hv_HomMat2DAdapted.Dispose();
                        HOperatorSet.HomMat2dTranslateLocal(hv_HomMat2DTmp, -0.5, -0.5, out hv_HomMat2DAdapted);
                        hv_Offset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Offset = ((hv_ImageHeight - hv_ImageWidth) * 0.5) * (((hv_CurrentRotation.TupleRad()
                                )).TupleSin());
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.HomMat2dTranslate(hv_HomMat2DAdapted, hv_Offset, hv_Offset,
                                out ExpTmpOutVar_0);
                            hv_HomMat2DAdapted.Dispose();
                            hv_HomMat2DAdapted = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HomMat2DRotate.Dispose();
                            HOperatorSet.HomMat2dRotate(hv_HomMat2DAdapted, hv_CurrentRotation.TupleRad()
                                , hv_ImageHeight * 0.5, hv_ImageWidth * 0.5, out hv_HomMat2DRotate);
                        }
                    }
                    if ((int)(hv_Rectangle1ParamExist) != 0)
                    {
                        hv_RowTrans1.Dispose(); hv_ColTrans1.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow1, hv_BBoxCol1,
                            out hv_RowTrans1, out hv_ColTrans1);
                        hv_RowTrans2.Dispose(); hv_ColTrans2.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow2, hv_BBoxCol2,
                            out hv_RowTrans2, out hv_ColTrans2);
                        if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(90))) != 0)
                        {
                            hv_BBoxRow1.Dispose();
                            hv_BBoxRow1 = new HTuple(hv_RowTrans2);
                            hv_BBoxCol1.Dispose();
                            hv_BBoxCol1 = new HTuple(hv_ColTrans1);
                            hv_BBoxRow2.Dispose();
                            hv_BBoxRow2 = new HTuple(hv_RowTrans1);
                            hv_BBoxCol2.Dispose();
                            hv_BBoxCol2 = new HTuple(hv_ColTrans2);
                        }
                        else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(180))) != 0)
                        {
                            hv_BBoxRow1.Dispose();
                            hv_BBoxRow1 = new HTuple(hv_RowTrans2);
                            hv_BBoxCol1.Dispose();
                            hv_BBoxCol1 = new HTuple(hv_ColTrans2);
                            hv_BBoxRow2.Dispose();
                            hv_BBoxRow2 = new HTuple(hv_RowTrans1);
                            hv_BBoxCol2.Dispose();
                            hv_BBoxCol2 = new HTuple(hv_ColTrans1);
                        }
                        else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(270))) != 0)
                        {
                            hv_BBoxRow1.Dispose();
                            hv_BBoxRow1 = new HTuple(hv_RowTrans1);
                            hv_BBoxCol1.Dispose();
                            hv_BBoxCol1 = new HTuple(hv_ColTrans2);
                            hv_BBoxRow2.Dispose();
                            hv_BBoxRow2 = new HTuple(hv_RowTrans2);
                            hv_BBoxCol2.Dispose();
                            hv_BBoxCol2 = new HTuple(hv_ColTrans1);
                        }
                        //
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
                    }
                    else if ((int)(hv_Rectangle2ParamExist) != 0)
                    {
                        hv_RowTrans.Dispose(); hv_ColTrans.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow, hv_BBoxCol,
                            out hv_RowTrans, out hv_ColTrans);
                        //Write the bounding box angles phi in the expected interval:
                        //-180° < phi <= 180° or if IgnoreDirection set to true -90° < phi <= 90°.
                        if ((int)(hv_IgnoreDirection.TupleNot()) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_BBoxPhi = hv_BBoxPhi + (hv_CurrentRotation.TupleRad()
                                        );
                                    hv_BBoxPhi.Dispose();
                                    hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                }
                            }
                            hv_MaxAngle.Dispose();
                            hv_MaxAngle = 180;
                            hv_DiffAngle.Dispose();
                            hv_DiffAngle = 360;
                        }
                        else
                        {
                            if ((int)((new HTuple(hv_CurrentRotation.TupleEqual(90))).TupleOr(new HTuple(hv_CurrentRotation.TupleEqual(
                                270)))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BBoxPhi = hv_BBoxPhi + ((new HTuple(90)).TupleRad()
                                            );
                                        hv_BBoxPhi.Dispose();
                                        hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                    }
                                }
                            }
                            hv_MaxAngle.Dispose();
                            hv_MaxAngle = 90;
                            hv_DiffAngle.Dispose();
                            hv_DiffAngle = 180;
                        }
                        hv_IndicesLarge.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndicesLarge = ((hv_BBoxPhi.TupleGreaterElem(
                                hv_MaxAngle.TupleRad()))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_IndicesLarge.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_BBoxPhi == null)
                                hv_BBoxPhi = new HTuple();
                            hv_BBoxPhi[hv_IndicesLarge] = (hv_BBoxPhi.TupleSelect(hv_IndicesLarge)) - (hv_DiffAngle.TupleRad()
                                );
                        }
                        //Check that the angle BBoxPhi for objects without orientation is always set to 0.0.
                        if ((int)(new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))) != 0)
                        {
                            for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                            {
                                if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                    hv_ObjIdx)))).TupleNotEqual(-1))) != 0)
                                {
                                    if (hv_BBoxPhi == null)
                                        hv_BBoxPhi = new HTuple();
                                    hv_BBoxPhi[hv_ObjIdx] = 0.0;
                                    //These classes require Length1 <= Length2: exchange them for 90° or 270° rotations.
                                    if ((int)((new HTuple(hv_CurrentRotation.TupleEqual(90))).TupleOr(
                                        new HTuple(hv_CurrentRotation.TupleEqual(270)))) != 0)
                                    {
                                        hv_BBoxLengthTmp.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_BBoxLengthTmp = hv_BBoxLength1.TupleSelect(
                                                hv_ObjIdx);
                                        }
                                        if (hv_BBoxLength1 == null)
                                            hv_BBoxLength1 = new HTuple();
                                        hv_BBoxLength1[hv_ObjIdx] = hv_BBoxLength2.TupleSelect(hv_ObjIdx);
                                        if (hv_BBoxLength2 == null)
                                            hv_BBoxLength2 = new HTuple();
                                        hv_BBoxLength2[hv_ObjIdx] = hv_BBoxLengthTmp;
                                    }
                                }
                            }
                        }
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_RowTrans);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_ColTrans);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhi);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv_BBoxLength1);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv_BBoxLength2);
                    }
                    if ((int)(hv_InstanceMaskExists) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AffineTransRegion(ho_Mask, out ExpTmpOutVar_0, hv_HomMat2DRotate,
                                "nearest_neighbor");
                            ho_Mask.Dispose();
                            ho_Mask = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_Mask, hv_DLSample, "mask");
                    }
                    if ((int)(hv_SegmentationImageExists) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.RotateImage(ho_SegmentationImage, out ExpTmpOutVar_0, hv_CurrentRotation.TupleInt()
                                , "constant");
                            ho_SegmentationImage.Dispose();
                            ho_SegmentationImage = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
                    }
                    if ((int)(hv_WeightImageExists) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.RotateImage(ho_WeightImage, out ExpTmpOutVar_0, hv_CurrentRotation.TupleInt()
                                , "constant");
                            ho_WeightImage.Dispose();
                            ho_WeightImage = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
                    }
                }
                ho_Image.Dispose();
                ho_Mask.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();
                ho_ImageRotate.Dispose();

                hv_OCRType.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_NumPossibleRotations.Dispose();
                hv_CurrentRotation.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DTmp.Dispose();
                hv_HomMat2DAdapted.Dispose();
                hv_Offset.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_RowTrans1.Dispose();
                hv_ColTrans1.Dispose();
                hv_RowTrans2.Dispose();
                hv_ColTrans2.Dispose();
                hv_RowTrans.Dispose();
                hv_ColTrans.Dispose();
                hv_MaxAngle.Dispose();
                hv_DiffAngle.Dispose();
                hv_IndicesLarge.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxLengthTmp.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_Mask.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();
                ho_ImageRotate.Dispose();

                hv_OCRType.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_NumPossibleRotations.Dispose();
                hv_CurrentRotation.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DTmp.Dispose();
                hv_HomMat2DAdapted.Dispose();
                hv_Offset.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_RowTrans1.Dispose();
                hv_ColTrans1.Dispose();
                hv_RowTrans2.Dispose();
                hv_ColTrans2.Dispose();
                hv_RowTrans.Dispose();
                hv_ColTrans.Dispose();
                hv_MaxAngle.Dispose();
                hv_DiffAngle.Dispose();
                hv_IndicesLarge.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxLengthTmp.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_rotate_range(HTuple hv_DLSample, HTuple hv_RotateRange)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_DomainRotated = null;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_IsOCRDetection = new HTuple();
            HTuple hv_IsOCRRecognition = new HTuple(), hv_IsOCR = new HTuple();
            HTuple hv_RotateRangeMax = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
            HTuple hv_Rectangle2ParamExist = new HTuple(), hv_InstanceMaskExists = new HTuple();
            HTuple hv_SegmentationImageExists = new HTuple(), hv_WeightImageExists = new HTuple();
            HTuple hv_ImageHighResExists = new HTuple(), hv_AugmentationDataExists = new HTuple();
            HTuple hv_AugmentationData = new HTuple(), hv_SampleHighResExists = new HTuple();
            HTuple hv_SampleHighRes = new HTuple(), hv_PreprocessParams = new HTuple();
            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_RotationAngle = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_PreprocessWidth = new HTuple();
            HTuple hv_PreprocessHeight = new HTuple(), hv_FactorWidth = new HTuple();
            HTuple hv_FactorHeight = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_HomMat2DTranslate = new HTuple();
            HTuple hv_HomMat2DTransform = new HTuple(), hv_BBoxRow1 = new HTuple();
            HTuple hv_BBoxCol1 = new HTuple(), hv_BBoxRow2 = new HTuple();
            HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow3 = new HTuple();
            HTuple hv_BBoxCol3 = new HTuple(), hv_BBoxRow4 = new HTuple();
            HTuple hv_BBoxCol4 = new HTuple(), hv_Row1Trans = new HTuple();
            HTuple hv_Col1Trans = new HTuple(), hv_Row2Trans = new HTuple();
            HTuple hv_Col2Trans = new HTuple(), hv_Row3Trans = new HTuple();
            HTuple hv_Col3Trans = new HTuple(), hv_Row4Trans = new HTuple();
            HTuple hv_Col4Trans = new HTuple(), hv___Tmp_Ctrl_0 = new HTuple();
            HTuple hv___Tmp_Ctrl_1 = new HTuple(), hv___Tmp_Ctrl_2 = new HTuple();
            HTuple hv___Tmp_Ctrl_3 = new HTuple(), hv___Tmp_Ctrl_4 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_DomainRotated);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                hv_IsOCRDetection.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsOCRDetection = new HTuple(hv_OCRType.TupleEqual(
                        "ocr_detection"));
                }
                hv_IsOCRRecognition.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsOCRRecognition = new HTuple(hv_OCRType.TupleEqual(
                        "ocr_recognition"));
                }
                hv_IsOCR.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsOCR = hv_IsOCRDetection.TupleOr(
                        hv_IsOCRRecognition);
                }
                if ((int)(hv_IsOCR) != 0)
                {
                    //For OCR Recognition samples only a certain RotateRange is allowed.
                    if ((int)(hv_IsOCRRecognition) != 0)
                    {
                        hv_RotateRangeMax.Dispose();
                        hv_RotateRangeMax = 5;
                        if ((int)(new HTuple(hv_RotateRange.TupleGreater(hv_RotateRangeMax))) != 0)
                        {
                            throw new HalconException(((("Value of augmentation method 'rotate_range' cannot be greater than " + hv_RotateRangeMax) + " for ") + hv_OCRType) + " models.");
                        }
                    }
                }
                else
                {
                    //This augmentation method cannot be applied to samples with
                    //object detection annotations or semantic segmentation annotations.
                    hv_Rectangle1ParamExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_row1", out hv_Rectangle1ParamExist);
                    hv_Rectangle2ParamExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_phi", out hv_Rectangle2ParamExist);
                    hv_InstanceMaskExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "mask", out hv_InstanceMaskExists);
                    hv_SegmentationImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_image",
                        out hv_SegmentationImageExists);
                    hv_WeightImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_Rectangle1ParamExist.TupleOr(
                        hv_Rectangle2ParamExist))).TupleOr(hv_InstanceMaskExists))).TupleOr(hv_SegmentationImageExists))).TupleOr(
                        hv_WeightImageExists)) != 0)
                    {
                        throw new HalconException(new HTuple("The augmentation method 'rotate_range' is not supported for object detection, instance segmentation or semantic segmentation samples."));
                    }
                }
                //
                //*** Augmentation ***
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //
                //Select the augmentation image with high resolution if available for OCR Detection/Recognition models.
                hv_ImageHighResExists.Dispose();
                hv_ImageHighResExists = 0;
                hv_AugmentationDataExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "augmentation_data", out hv_AugmentationDataExists);
                if ((int)(hv_IsOCR.TupleAnd(hv_AugmentationDataExists)) != 0)
                {
                    hv_AugmentationData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AugmentationData = hv_DLSample.TupleGetDictTuple(
                            "augmentation_data");
                    }
                    if ((int)(hv_IsOCRDetection) != 0)
                    {
                        hv_SampleHighResExists.Dispose();
                        HOperatorSet.GetDictParam(hv_AugmentationData, "key_exists", "sample_high_res",
                            out hv_SampleHighResExists);
                        if ((int)(hv_SampleHighResExists) != 0)
                        {
                            hv_SampleHighRes.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SampleHighRes = hv_AugmentationData.TupleGetDictTuple(
                                    "sample_high_res");
                            }
                            hv_ImageHighResExists.Dispose();
                            HOperatorSet.GetDictParam(hv_SampleHighRes, "key_exists", "image", out hv_ImageHighResExists);
                            if ((int)(hv_ImageHighResExists) != 0)
                            {
                                ho_Image.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Image = hv_SampleHighRes.TupleGetDictObject(
                                        "image");
                                }
                            }
                            hv_PreprocessParams.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PreprocessParams = hv_AugmentationData.TupleGetDictTuple(
                                    "preprocess_params");
                            }
                        }
                    }
                    else
                    {
                        hv_ImageHighResExists.Dispose();
                        HOperatorSet.GetDictParam(hv_AugmentationData, "key_exists", "image_high_res",
                            out hv_ImageHighResExists);
                        if ((int)(hv_ImageHighResExists) != 0)
                        {
                            ho_Image.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_Image = hv_AugmentationData.TupleGetDictObject(
                                    "image_high_res");
                            }
                        }
                    }
                }
                if ((int)(hv_IsOCRDetection.TupleAnd(hv_ImageHighResExists.TupleNot())) != 0)
                {
                    throw new HalconException("The augmentation method 'rotate_range' requires sample images with high resolution for ocr_detection models.");
                }
                //
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //Determine rotation angle for method 'rotate_range': angle in range [1:RotateRange].
                hv_RotationAngle.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RotationAngle = (((hv_RotateRange * HTuple.TupleRand(
                        1))).TupleInt()) + 1;
                }
                //Select direction of rotation randomly.
                if ((int)(new HTuple((HTuple.TupleRand(1)).TupleLess(0.5))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RotationAngle = 360 - hv_RotationAngle;
                            hv_RotationAngle.Dispose();
                            hv_RotationAngle = ExpTmpLocalVar_RotationAngle;
                        }
                    }
                }
                //For ocr_detection the transformation matrix is always needed so
                //the else-case is also used for angles multiple of 90 degrees.
                if ((int)((new HTuple(((hv_RotationAngle % 90)).TupleEqual(0))).TupleAnd(hv_IsOCRDetection.TupleNot()
                    )) != 0)
                {
                    //Rotations around 90 degrees are faster with rotate_image.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.RotateImage(ho_Image, out ExpTmpOutVar_0, hv_RotationAngle,
                            "constant");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    hv_HomMat2DIdentity.Dispose();
                    HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                    if ((int)(hv_IsOCRDetection.TupleNot()) != 0)
                    {
                        //Create rotation matrix and apply the rotation.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HomMat2DRotate.Dispose();
                            HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_RotationAngle.TupleRad()
                                , hv_ImageHeight / 2.0, hv_ImageWidth / 2.0, out hv_HomMat2DRotate);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AffineTransImage(ho_Image, out ExpTmpOutVar_0, hv_HomMat2DRotate,
                                "constant", "false");
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        //Remove potential undefined domain.
                        ho_DomainRotated.Dispose();
                        HOperatorSet.GetDomain(ho_Image, out ho_DomainRotated);
                        hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                        HOperatorSet.InnerRectangle1(ho_DomainRotated, out hv_Row1, out hv_Column1,
                            out hv_Row2, out hv_Column2);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.CropRectangle1(ho_Image, out ExpTmpOutVar_0, hv_Row1, hv_Column1,
                                hv_Row2, hv_Column2);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //Calculate temporary image dimensions with the same aspect ratio
                        //as the preprocessed image to enlarge the input image, such that
                        //the rotation output fits most part of it without zooming the content.
                        hv_PreprocessWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PreprocessWidth = hv_PreprocessParams.TupleGetDictTuple(
                                "image_width");
                        }
                        hv_PreprocessHeight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PreprocessHeight = hv_PreprocessParams.TupleGetDictTuple(
                                "image_height");
                        }
                        hv_FactorWidth.Dispose(); hv_FactorHeight.Dispose();
                        calculate_dl_image_zoom_factors(hv_ImageWidth, hv_ImageHeight, hv_PreprocessWidth,
                            hv_PreprocessHeight, hv_PreprocessParams, out hv_FactorWidth, out hv_FactorHeight);
                        hv_TempWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TempWidth = hv_PreprocessWidth / (hv_FactorWidth.TupleReal()
                                );
                        }
                        hv_TempHeight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TempHeight = hv_PreprocessHeight / (hv_FactorHeight.TupleReal()
                                );
                        }
                        //Rotate image.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HomMat2DTranslate.Dispose();
                            HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, (-hv_ImageHeight) / 2.0,
                                (-hv_ImageWidth) / 2.0, out hv_HomMat2DTranslate);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HomMat2DRotate.Dispose();
                            HOperatorSet.HomMat2dRotate(hv_HomMat2DTranslate, hv_RotationAngle.TupleRad()
                                , 0, 0, out hv_HomMat2DRotate);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HomMat2DTransform.Dispose();
                            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_ImageHeight / 2.0, hv_ImageWidth / 2.0,
                                out hv_HomMat2DTransform);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AffineTransImageSize(ho_Image, out ExpTmpOutVar_0, hv_HomMat2DTransform,
                                "constant", hv_TempWidth, hv_TempHeight);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        //Rotate bounding boxes.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow1.Dispose(); hv_BBoxCol1.Dispose(); hv_BBoxRow2.Dispose(); hv_BBoxCol2.Dispose(); hv_BBoxRow3.Dispose(); hv_BBoxCol3.Dispose(); hv_BBoxRow4.Dispose(); hv_BBoxCol4.Dispose();
                            convert_rect2_5to8param(hv_SampleHighRes.TupleGetDictTuple("bbox_row"),
                                hv_SampleHighRes.TupleGetDictTuple("bbox_col"), hv_SampleHighRes.TupleGetDictTuple(
                                "bbox_length1"), hv_SampleHighRes.TupleGetDictTuple("bbox_length2"),
                                hv_SampleHighRes.TupleGetDictTuple("bbox_phi"), out hv_BBoxRow1, out hv_BBoxCol1,
                                out hv_BBoxRow2, out hv_BBoxCol2, out hv_BBoxRow3, out hv_BBoxCol3,
                                out hv_BBoxRow4, out hv_BBoxCol4);
                        }
                        hv_Row1Trans.Dispose(); hv_Col1Trans.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DTransform, hv_BBoxRow1, hv_BBoxCol1,
                            out hv_Row1Trans, out hv_Col1Trans);
                        hv_Row2Trans.Dispose(); hv_Col2Trans.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DTransform, hv_BBoxRow2, hv_BBoxCol2,
                            out hv_Row2Trans, out hv_Col2Trans);
                        hv_Row3Trans.Dispose(); hv_Col3Trans.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DTransform, hv_BBoxRow3, hv_BBoxCol3,
                            out hv_Row3Trans, out hv_Col3Trans);
                        hv_Row4Trans.Dispose(); hv_Col4Trans.Dispose();
                        HOperatorSet.AffineTransPixel(hv_HomMat2DTransform, hv_BBoxRow4, hv_BBoxCol4,
                            out hv_Row4Trans, out hv_Col4Trans);
                        hv___Tmp_Ctrl_0.Dispose(); hv___Tmp_Ctrl_1.Dispose(); hv___Tmp_Ctrl_2.Dispose(); hv___Tmp_Ctrl_3.Dispose(); hv___Tmp_Ctrl_4.Dispose();
                        convert_rect2_8to5param(hv_Row1Trans, hv_Col1Trans, hv_Row2Trans, hv_Col2Trans,
                            hv_Row3Trans, hv_Col3Trans, hv_Row4Trans, hv_Col4Trans, 0, out hv___Tmp_Ctrl_0,
                            out hv___Tmp_Ctrl_1, out hv___Tmp_Ctrl_2, out hv___Tmp_Ctrl_3, out hv___Tmp_Ctrl_4);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv___Tmp_Ctrl_4);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv___Tmp_Ctrl_3);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv___Tmp_Ctrl_2);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv___Tmp_Ctrl_1);
                        HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv___Tmp_Ctrl_0);
                    }
                }
                //Do model specific operations before scaling.
                if ((int)(hv_IsOCRDetection) != 0)
                {
                }
                //Scale image to the input size.
                if ((int)(hv_IsOCR.TupleAnd(hv_ImageHighResExists)) != 0)
                {
                    if ((int)(hv_IsOCRDetection) != 0)
                    {
                        //Scale bounding boxes to the input size.
                        preprocess_dl_model_bbox_rect2(ho_Image, hv_DLSample, hv_PreprocessParams);
                        //Scale rotated image to the input size.
                        {
                            HObject ExpTmpOutVar_0;
                            preprocess_dl_model_images_ocr_detection(ho_Image, out ExpTmpOutVar_0,
                                hv_PreprocessParams);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        //Generate targets from the scaled rotated image.
                        HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                        gen_dl_ocr_detection_targets(hv_DLSample, hv_PreprocessParams);
                    }
                    else
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            preprocess_dl_model_images_ocr_recognition(ho_Image, out ExpTmpOutVar_0,
                                hv_PreprocessParams);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                }
                else
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ImageWidth, hv_ImageHeight,
                            "constant");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                }
                //
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_DomainRotated.Dispose();

                hv_OCRType.Dispose();
                hv_IsOCRDetection.Dispose();
                hv_IsOCRRecognition.Dispose();
                hv_IsOCR.Dispose();
                hv_RotateRangeMax.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_ImageHighResExists.Dispose();
                hv_AugmentationDataExists.Dispose();
                hv_AugmentationData.Dispose();
                hv_SampleHighResExists.Dispose();
                hv_SampleHighRes.Dispose();
                hv_PreprocessParams.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_RotationAngle.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_PreprocessWidth.Dispose();
                hv_PreprocessHeight.Dispose();
                hv_FactorWidth.Dispose();
                hv_FactorHeight.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_HomMat2DTranslate.Dispose();
                hv_HomMat2DTransform.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow3.Dispose();
                hv_BBoxCol3.Dispose();
                hv_BBoxRow4.Dispose();
                hv_BBoxCol4.Dispose();
                hv_Row1Trans.Dispose();
                hv_Col1Trans.Dispose();
                hv_Row2Trans.Dispose();
                hv_Col2Trans.Dispose();
                hv_Row3Trans.Dispose();
                hv_Col3Trans.Dispose();
                hv_Row4Trans.Dispose();
                hv_Col4Trans.Dispose();
                hv___Tmp_Ctrl_0.Dispose();
                hv___Tmp_Ctrl_1.Dispose();
                hv___Tmp_Ctrl_2.Dispose();
                hv___Tmp_Ctrl_3.Dispose();
                hv___Tmp_Ctrl_4.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_DomainRotated.Dispose();

                hv_OCRType.Dispose();
                hv_IsOCRDetection.Dispose();
                hv_IsOCRRecognition.Dispose();
                hv_IsOCR.Dispose();
                hv_RotateRangeMax.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskExists.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_ImageHighResExists.Dispose();
                hv_AugmentationDataExists.Dispose();
                hv_AugmentationData.Dispose();
                hv_SampleHighResExists.Dispose();
                hv_SampleHighRes.Dispose();
                hv_PreprocessParams.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_RotationAngle.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_PreprocessWidth.Dispose();
                hv_PreprocessHeight.Dispose();
                hv_FactorWidth.Dispose();
                hv_FactorHeight.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_HomMat2DTranslate.Dispose();
                hv_HomMat2DTransform.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow3.Dispose();
                hv_BBoxCol3.Dispose();
                hv_BBoxRow4.Dispose();
                hv_BBoxCol4.Dispose();
                hv_Row1Trans.Dispose();
                hv_Col1Trans.Dispose();
                hv_Row2Trans.Dispose();
                hv_Col2Trans.Dispose();
                hv_Row3Trans.Dispose();
                hv_Col3Trans.Dispose();
                hv_Row4Trans.Dispose();
                hv_Col4Trans.Dispose();
                hv___Tmp_Ctrl_0.Dispose();
                hv___Tmp_Ctrl_1.Dispose();
                hv___Tmp_Ctrl_2.Dispose();
                hv___Tmp_Ctrl_3.Dispose();
                hv___Tmp_Ctrl_4.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void augment_dl_sample_saturation_variation(HTuple hv_DLSample, HTuple hv_SaturationVariation)
        {



            // Local iconic variables 

            HObject ho_Image = null, ho_GrayImage, ho_GrayRGBChannelImage;
            HObject ho_GrayRGBChannelImageScaled, ho_ImageScaled, ho_ImageOut;

            // Local control variables 

            HTuple hv_OCRType = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_Borders = new HTuple(), hv_Factor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_GrayRGBChannelImage);
            HOperatorSet.GenEmptyObj(out ho_GrayRGBChannelImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageOut);
            try
            {
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //*** Input validation ***
                //
                //This augmentation method should not be applied to OCR Recognition samples.
                hv_OCRType.Dispose();
                get_dl_sample_ocr_type(hv_DLSample, out hv_OCRType);
                if ((int)(new HTuple(hv_OCRType.TupleEqual("ocr_recognition"))) != 0)
                {
                    throw new HalconException("The augmentation method 'saturation_variation' is not supported by ocr_recognition models.");
                }
                //
                ho_Image.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Image = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                //
                //If the image has only one channel, this augmentation has no effect.
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleEqual(1))) != 0)
                {
                    ho_Image.Dispose();
                    ho_GrayImage.Dispose();
                    ho_GrayRGBChannelImage.Dispose();
                    ho_GrayRGBChannelImageScaled.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_ImageOut.Dispose();

                    hv_OCRType.Dispose();
                    hv_NumChannels.Dispose();
                    hv_Borders.Dispose();
                    hv_Factor.Dispose();

                    return;
                }
                else if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                {
                    //Otherwise, only RGB images are allowed.
                    throw new HalconException("The augmentation method 'saturation_variation' can only be applied to gray scale and RGB images.");
                }
                //
                //*** Augmentation ***
                //
                //Adjust the saturation of the input image by blending it with its gray value version.
                //
                //Minimum and maximum blend factors.
                hv_Borders.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Borders = new HTuple();
                    hv_Borders = hv_Borders.TupleConcat((new HTuple(0.0)).TupleMax2(
                        1 - hv_SaturationVariation));
                    hv_Borders = hv_Borders.TupleConcat(1 + hv_SaturationVariation);
                }
                hv_Factor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Factor = (hv_Borders.TupleSelect(
                        0)) + (((hv_Borders.TupleSelect(1)) - (hv_Borders.TupleSelect(0))) * HTuple.TupleRand(
                        1));
                }
                //
                if ((int)(new HTuple(hv_Factor.TupleEqual(1.0))) != 0)
                {
                    ho_Image.Dispose();
                    ho_GrayImage.Dispose();
                    ho_GrayRGBChannelImage.Dispose();
                    ho_GrayRGBChannelImageScaled.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_ImageOut.Dispose();

                    hv_OCRType.Dispose();
                    hv_NumChannels.Dispose();
                    hv_Borders.Dispose();
                    hv_Factor.Dispose();

                    return;
                }
                //
                //Get the gray value image as an RGB image.
                ho_GrayImage.Dispose();
                HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
                ho_GrayRGBChannelImage.Dispose();
                HOperatorSet.Compose3(ho_GrayImage, ho_GrayImage, ho_GrayImage, out ho_GrayRGBChannelImage
                    );
                //
                //Blend Image and GrayRGBChannelImage.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_GrayRGBChannelImageScaled.Dispose();
                    HOperatorSet.ScaleImage(ho_GrayRGBChannelImage, out ho_GrayRGBChannelImageScaled,
                        1.0 - hv_Factor, 0.0);
                }
                ho_ImageScaled.Dispose();
                HOperatorSet.ScaleImage(ho_Image, out ho_ImageScaled, hv_Factor, 0.0);
                ho_ImageOut.Dispose();
                HOperatorSet.AddImage(ho_GrayRGBChannelImageScaled, ho_ImageScaled, out ho_ImageOut,
                    1.0, 0.0);
                //
                //Set the augmented image to DLSample.
                HOperatorSet.SetDictObject(ho_ImageOut, hv_DLSample, "image");
                ho_Image.Dispose();
                ho_GrayImage.Dispose();
                ho_GrayRGBChannelImage.Dispose();
                ho_GrayRGBChannelImageScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageOut.Dispose();

                hv_OCRType.Dispose();
                hv_NumChannels.Dispose();
                hv_Borders.Dispose();
                hv_Factor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_GrayImage.Dispose();
                ho_GrayRGBChannelImage.Dispose();
                ho_GrayRGBChannelImageScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageOut.Dispose();

                hv_OCRType.Dispose();
                hv_NumChannels.Dispose();
                hv_Borders.Dispose();
                hv_Factor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Perform data augmentation on the given samples. 
        public void augment_dl_samples(HTuple hv_DLSampleBatch, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumSamples = new HTuple(), hv_AugParams = new HTuple();
            HTuple hv_GenKeys = new HTuple(), hv_KeyIndex = new HTuple();
            HTuple hv_GenKey = new HTuple(), hv_AugMethodsToApply = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_ChosenIndex = new HTuple(), hv_AugMethod = new HTuple();
            HTuple hv_AugMethodValue = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
            HTuple hv___Tmp_Ctrl_Type = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure augments samples in the DLSampleBatch randomly.
                //The augmentation methods have to be specified using the dictionary GenParam.
                //
                //
                //*** Input validation ***
                //
                //If no augmentation parameter is given we return directly and the samples stay unchanged.
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleEqual(0))) != 0)
                {

                    hv_NumSamples.Dispose();
                    hv_AugParams.Dispose();
                    hv_GenKeys.Dispose();
                    hv_KeyIndex.Dispose();
                    hv_GenKey.Dispose();
                    hv_AugMethodsToApply.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_DLSample.Dispose();
                    hv_ChosenIndex.Dispose();
                    hv_AugMethod.Dispose();
                    hv_AugMethodValue.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    hv___Tmp_Ctrl_Type.Dispose();

                    return;
                }
                //
                //Check number of samples to be augmented.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSampleBatch.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException("There are no DLSamples to be processed.");
                }
                //
                //Validate and sanitize the input.
                //Note that this is just a shallow check of the given GenParam dict.
                //The compatibility of the resulting augmentation parameters dict with the
                //DLSampleBatch at hand needs to be checked below.
                check_augment_dl_samples_gen_param(hv_GenParam);
                //
                //
                //*** Default augmentation values ***
                //
                hv_AugParams.Dispose();
                HOperatorSet.CreateDict(out hv_AugParams);
                //
                //Augmentation methods:
                //
                //The absolute brightness change can vary in the range [-value, +value].
                HOperatorSet.SetDictTuple(hv_AugParams, "brightness_variation", 0);
                //The absolute brightness peak of a randomly positioned spot can vary in the range [-value, +value].
                HOperatorSet.SetDictTuple(hv_AugParams, "brightness_variation_spot", 0);
                //Contrast variation can be enabled by setting a value larger than zero, for example 0.2.
                HOperatorSet.SetDictTuple(hv_AugParams, "contrast_variation", 0);
                //Fraction of image length and width that remains after cropping (in %).
                HOperatorSet.SetDictTuple(hv_AugParams, "crop_percentage", "off");
                //Image length and width that remains after cropping (in pixel).
                HOperatorSet.SetDictTuple(hv_AugParams, "crop_pixel", "off");
                //Allowed mirroring types are coded by 'r' (row), 'c' (column).
                HOperatorSet.SetDictTuple(hv_AugParams, "mirror", "off");
                //In case of a ocr_recognition model:
                //Maximum amount of pixels that can be removed from the image borders: [x,y] => x:left,right and y:top,bottom.
                HOperatorSet.SetDictTuple(hv_AugParams, "remove_pixel", (new HTuple(0)).TupleConcat(
                    0));
                //Step size for possible rotations.
                //This parameter and augmentation method is independent from the 'rotate_range' parameter.
                HOperatorSet.SetDictTuple(hv_AugParams, "rotate", 0);
                //Step range for rotations with step size 1.
                //This parameter and augmentation method is independent from the 'rotate' parameter.
                HOperatorSet.SetDictTuple(hv_AugParams, "rotate_range", 0);
                //Saturation variation can be enabled by setting a value larger than zero, for example 0.2.
                HOperatorSet.SetDictTuple(hv_AugParams, "saturation_variation", 0);
                //
                //Other settings:
                //
                //The percentage of the images that are to be augmented.
                HOperatorSet.SetDictTuple(hv_AugParams, "augmentation_percentage", 50);
                //In case of a detection model of instance_type 'rectangle2': Use directions of instances within bounding boxes.
                HOperatorSet.SetDictTuple(hv_AugParams, "ignore_direction", 0);
                //In case of a detection model of instance_type 'rectangle2': Class IDs without orientation.
                //These are the IDs of the classes, for whose instances the orientation is not to be considered.
                HOperatorSet.SetDictTuple(hv_AugParams, "class_ids_no_orientation", new HTuple());
                //
                //
                //*** Get the augmentation that should be applied ***
                //
                //Set user-defined parameters:
                hv_GenKeys.Dispose();
                HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenKeys);
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_GenKeys.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    hv_GenKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GenKey = hv_GenKeys.TupleSelect(
                            hv_KeyIndex);
                    }
                    hv___Tmp_Ctrl_Type.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_data_type", hv_GenKey, out hv___Tmp_Ctrl_Type);
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(hv_GenParam.TupleGetDictObject(hv_GenKey), hv_AugParams,
                                hv_GenKey);
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_AugParams, hv_GenKey, hv_GenParam.TupleGetDictTuple(
                                hv_GenKey));
                        }
                    }
                }
                //
                //Get all methods that would actually have an effect when applied with the
                //augmentation value stored in AugParams.
                hv_AugMethodsToApply.Dispose();
                hv_AugMethodsToApply = new HTuple();
                //Brightness variation.
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("brightness_variation"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "brightness_variation");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Brightness variation spot.
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("brightness_variation_spot"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "brightness_variation_spot");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Contrast variation.
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("contrast_variation"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "contrast_variation");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Cropping percentage.
                if ((int)(((hv_AugParams.TupleGetDictTuple("crop_percentage"))).TupleIsNumber()
                    ) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "crop_percentage");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Cropping pixels.
                if ((int)(((hv_AugParams.TupleGetDictTuple("crop_pixel"))).TupleIsNumber()) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "crop_pixel");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Mirroring is allowed in row and column direction.
                if ((int)((new HTuple(((hv_AugParams.TupleGetDictTuple("mirror"))).TupleRegexpTest(
                    "r"))).TupleOr(((hv_AugParams.TupleGetDictTuple("mirror"))).TupleRegexpTest(
                    "c"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "mirror");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Removing pixels.
                if ((int)((new HTuple(((((hv_AugParams.TupleGetDictTuple("remove_pixel"))).TupleSelect(
                    0))).TupleGreater(0))).TupleOr(new HTuple(((((hv_AugParams.TupleGetDictTuple(
                    "remove_pixel"))).TupleSelect(1))).TupleGreater(0)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "remove_pixel");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Rotation with a given angular step size.
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("rotate"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "rotate");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Rotation within a given range (step size 1).
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("rotate_range"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "rotate_range");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //Saturation variation.
                if ((int)(new HTuple(((hv_AugParams.TupleGetDictTuple("saturation_variation"))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AugMethodsToApply = hv_AugMethodsToApply.TupleConcat(
                                "saturation_variation");
                            hv_AugMethodsToApply.Dispose();
                            hv_AugMethodsToApply = ExpTmpLocalVar_AugMethodsToApply;
                        }
                    }
                }
                //
                //Exit early if there is nothing to be applied
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", 0);
                if ((int)((new HTuple((new HTuple(hv_AugMethodsToApply.TupleLength())).TupleEqual(
                    0))).TupleOr(((hv_AugParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem(
                    "augmentation_percentage", "comp"))) != 0)
                {

                    hv_NumSamples.Dispose();
                    hv_AugParams.Dispose();
                    hv_GenKeys.Dispose();
                    hv_KeyIndex.Dispose();
                    hv_GenKey.Dispose();
                    hv_AugMethodsToApply.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_DLSample.Dispose();
                    hv_ChosenIndex.Dispose();
                    hv_AugMethod.Dispose();
                    hv_AugMethodValue.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    hv___Tmp_Ctrl_Type.Dispose();

                    return;
                }
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                        "HNULL");
                }
                //
                //
                //*** Augment the samples ***
                //
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_DLSampleBatch.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSampleBatch.TupleSelect(
                            hv_SampleIndex);
                    }
                    //Only augment the given percentage of samples.
                    if ((int)(new HTuple((new HTuple(HTuple.TupleRand(1) * 100)).TupleGreater(hv_AugParams.TupleGetDictTuple(
                        "augmentation_percentage")))) != 0)
                    {
                        continue;
                    }
                    //Select the augmentation method.
                    hv_ChosenIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChosenIndex = (new HTuple(HTuple.TupleRand(
                            1) * (new HTuple(hv_AugMethodsToApply.TupleLength())))).TupleInt();
                    }
                    hv_AugMethod.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AugMethod = hv_AugMethodsToApply.TupleSelect(
                            hv_ChosenIndex);
                    }
                    hv_AugMethodValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AugMethodValue = hv_AugParams.TupleGetDictTuple(
                            hv_AugMethod);
                    }
                    //
                    if ((int)(new HTuple(hv_AugMethod.TupleEqual("brightness_variation"))) != 0)
                    {
                        augment_dl_sample_brightness_variation(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("brightness_variation_spot"))) != 0)
                    {
                        augment_dl_sample_brightness_variation_spot(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("contrast_variation"))) != 0)
                    {
                        augment_dl_sample_contrast_variation(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("crop_percentage"))) != 0)
                    {
                        augment_dl_sample_crop_percentage(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("crop_pixel"))) != 0)
                    {
                        augment_dl_sample_crop_pixel(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("mirror"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            augment_dl_sample_mirror(hv_DLSample, hv_AugMethodValue, hv_AugParams.TupleGetDictTuple(
                                "class_ids_no_orientation"), hv_AugParams.TupleGetDictTuple("ignore_direction"));
                        }
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("remove_pixel"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            augment_dl_sample_remove_pixel(hv_DLSample, hv_AugMethodValue.TupleSelect(
                                0), hv_AugMethodValue.TupleSelect(1));
                        }
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("rotate"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            augment_dl_sample_rotate(hv_DLSample, hv_AugMethodValue, hv_AugParams.TupleGetDictTuple(
                                "class_ids_no_orientation"), hv_AugParams.TupleGetDictTuple("ignore_direction"));
                        }
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("rotate_range"))) != 0)
                    {
                        augment_dl_sample_rotate_range(hv_DLSample, hv_AugMethodValue);
                    }
                    else if ((int)(new HTuple(hv_AugMethod.TupleEqual("saturation_variation"))) != 0)
                    {
                        augment_dl_sample_saturation_variation(hv_DLSample, hv_AugMethodValue);
                    }
                }

                hv_NumSamples.Dispose();
                hv_AugParams.Dispose();
                hv_GenKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_GenKey.Dispose();
                hv_AugMethodsToApply.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ChosenIndex.Dispose();
                hv_AugMethod.Dispose();
                hv_AugMethodValue.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumSamples.Dispose();
                hv_AugParams.Dispose();
                hv_GenKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_GenKey.Dispose();
                hv_AugMethodsToApply.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ChosenIndex.Dispose();
                hv_AugMethod.Dispose();
                hv_AugMethodValue.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Calculate quantiles of pixel anomaly scores. 
        private void calculate_dl_anomaly_quantiles(HTuple hv_DLModelHandle, HTuple hv_LayerName,
            HTuple hv_DLSamples, HTuple hv_Ps, out HTuple hv_Quantiles)
        {



            // Local iconic variables 

            HObject ho_LayerOutput = null;

            // Local control variables 

            HTuple hv_Shape = new HTuple(), hv_N = new HTuple();
            HTuple hv_C = new HTuple(), hv_H = new HTuple(), hv_W = new HTuple();
            HTuple hv_PixelScores = new HTuple(), hv_NumIterations = new HTuple();
            HTuple hv_Index = new HTuple(), hv_FirstSampleIdx = new HTuple();
            HTuple hv_LastSampleIdx = new HTuple(), hv_DLSamplesBatch = new HTuple();
            HTuple hv_DLResultBatch = new HTuple(), hv_IndexSamples = new HTuple();
            HTuple hv_Iteration = new HTuple(), hv_SampleDict = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_LayerOutputValues = new HTuple(), hv_SliceStart = new HTuple();
            HTuple hv_SliceEnd = new HTuple(), hv_IndexP = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_LayerOutput);
            hv_Quantiles = new HTuple();
            try
            {
                //This procedure calculates quantiles of unnormalized pixel anomaly
                //scores returned by a given GC-AD model.
                //
                //The layer output has the shape N x C x H x W, where
                //- N is the batch size,
                //- C is number of channels, and
                //- H and W are the height and width, respectively.
                //
                hv_Shape.Dispose();
                HOperatorSet.GetDlModelLayerParam(hv_DLModelHandle, hv_LayerName, "shape",
                    out hv_Shape);
                hv_N.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_N = hv_Shape.TupleSelect(
                        3);
                }
                hv_C.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_C = hv_Shape.TupleSelect(
                        2);
                }
                if ((int)(new HTuple(hv_C.TupleNotEqual(1))) != 0)
                {
                    throw new HalconException("Only layers with a single output channel are supported.");
                }
                hv_H.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_H = hv_Shape.TupleSelect(
                        1);
                }
                hv_W.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_W = hv_Shape.TupleSelect(
                        0);
                }
                hv_PixelScores.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PixelScores = HTuple.TupleGenConst(
                        ((new HTuple(hv_DLSamples.TupleLength())) * hv_H) * hv_W, 0.0);
                }
                hv_NumIterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumIterations = (((new HTuple(hv_DLSamples.TupleLength()
                        )) / (hv_N.TupleReal()))).TupleCeil();
                }
                HTuple end_val18 = hv_NumIterations - 1;
                HTuple step_val18 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val18, step_val18); hv_Index = hv_Index.TupleAdd(step_val18))
                {
                    hv_FirstSampleIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FirstSampleIdx = hv_Index * hv_N;
                    }
                    hv_LastSampleIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LastSampleIdx = ((((hv_Index + 1) * hv_N) - 1)).TupleMin2(
                            (new HTuple(hv_DLSamples.TupleLength())) - 1);
                    }
                    hv_DLSamplesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesBatch = hv_DLSamples.TupleSelectRange(
                            hv_FirstSampleIdx, hv_LastSampleIdx);
                    }
                    hv_DLResultBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_LayerName,
                        out hv_DLResultBatch);
                    //
                    for (hv_IndexSamples = 0; (int)hv_IndexSamples <= (int)((new HTuple(hv_DLResultBatch.TupleLength()
                        )) - 1); hv_IndexSamples = (int)hv_IndexSamples + 1)
                    {
                        hv_Iteration.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Iteration = (hv_Index * hv_N) + hv_IndexSamples;
                        }
                        //
                        hv_SampleDict.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SampleDict = hv_DLResultBatch.TupleSelect(
                                hv_IndexSamples);
                        }
                        ho_LayerOutput.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LayerOutput = hv_SampleDict.TupleGetDictObject(
                                hv_LayerName);
                        }
                        //
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetRegionPoints(ho_LayerOutput, out hv_Rows, out hv_Columns);
                        hv_LayerOutputValues.Dispose();
                        HOperatorSet.GetGrayval(ho_LayerOutput, hv_Rows, hv_Columns, out hv_LayerOutputValues);
                        hv_SliceStart.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SliceStart = (hv_Iteration * hv_H) * hv_W;
                        }
                        hv_SliceEnd.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SliceEnd = (hv_SliceStart + (hv_H * hv_W)) - 1;
                        }
                        if (hv_PixelScores == null)
                            hv_PixelScores = new HTuple();
                        hv_PixelScores[HTuple.TupleGenSequence(hv_SliceStart, hv_SliceEnd, 1)] = hv_LayerOutputValues;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_PixelScores = hv_PixelScores.TupleSort()
                            ;
                        hv_PixelScores.Dispose();
                        hv_PixelScores = ExpTmpLocalVar_PixelScores;
                    }
                }
                //
                hv_Quantiles.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Quantiles = HTuple.TupleGenConst(
                        new HTuple(hv_Ps.TupleLength()), 0.0);
                }
                for (hv_IndexP = 0; (int)hv_IndexP <= (int)((new HTuple(hv_Ps.TupleLength())) - 1); hv_IndexP = (int)hv_IndexP + 1)
                {
                    if (hv_Quantiles == null)
                        hv_Quantiles = new HTuple();
                    hv_Quantiles[hv_IndexP] = hv_PixelScores.TupleSelect((((hv_Ps.TupleSelect(
                        hv_IndexP)) * ((new HTuple(hv_PixelScores.TupleLength())) - 1))).TupleRound()
                        );
                }
                //
                ho_LayerOutput.Dispose();

                hv_Shape.Dispose();
                hv_N.Dispose();
                hv_C.Dispose();
                hv_H.Dispose();
                hv_W.Dispose();
                hv_PixelScores.Dispose();
                hv_NumIterations.Dispose();
                hv_Index.Dispose();
                hv_FirstSampleIdx.Dispose();
                hv_LastSampleIdx.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultBatch.Dispose();
                hv_IndexSamples.Dispose();
                hv_Iteration.Dispose();
                hv_SampleDict.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_LayerOutputValues.Dispose();
                hv_SliceStart.Dispose();
                hv_SliceEnd.Dispose();
                hv_IndexP.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_LayerOutput.Dispose();

                hv_Shape.Dispose();
                hv_N.Dispose();
                hv_C.Dispose();
                hv_H.Dispose();
                hv_W.Dispose();
                hv_PixelScores.Dispose();
                hv_NumIterations.Dispose();
                hv_Index.Dispose();
                hv_FirstSampleIdx.Dispose();
                hv_LastSampleIdx.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultBatch.Dispose();
                hv_IndexSamples.Dispose();
                hv_Iteration.Dispose();
                hv_SampleDict.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_LayerOutputValues.Dispose();
                hv_SliceStart.Dispose();
                hv_SliceEnd.Dispose();
                hv_IndexP.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / OCR
        // Short Description: Compute zoom factors to fit an image to a target size. 
        private void calculate_dl_image_zoom_factors(HTuple hv_ImageWidth, HTuple hv_ImageHeight,
            HTuple hv_TargetWidth, HTuple hv_TargetHeight, HTuple hv_DLPreprocessParam,
            out HTuple hv_ZoomFactorWidth, out HTuple hv_ZoomFactorHeight)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ScaleWidthUnit = new HTuple(), hv_ScaleHeightUnit = new HTuple();
            HTuple hv_PreserveAspectRatio = new HTuple(), hv_Scale = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
            // Initialize local and output iconic variables 
            hv_ZoomFactorWidth = new HTuple();
            hv_ZoomFactorHeight = new HTuple();
            try
            {
                //Calculate the unit zoom factors, which zoom the input image to 1px.
                hv_ScaleWidthUnit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScaleWidthUnit = 1.0 / (hv_ImageWidth.TupleReal()
                        );
                }
                hv_ScaleHeightUnit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScaleHeightUnit = 1.0 / (hv_ImageHeight.TupleReal()
                        );
                }
                //
                //Calculate the required zoom factors for the available target size.
                hv_ZoomFactorWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZoomFactorWidth = hv_TargetWidth * hv_ScaleWidthUnit;
                }
                hv_ZoomFactorHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZoomFactorHeight = hv_TargetHeight * hv_ScaleHeightUnit;
                }
                //
                //Aspect-ratio preserving zoom is supported for model type 'ocr_detection' only.
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "ocr_detection");
                hv_PreserveAspectRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PreserveAspectRatio = ((hv_DLPreprocessParam.TupleConcat(
                        hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem("model_type", "comp");
                }
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                        "HNULL");
                }
                //
                if ((int)(hv_PreserveAspectRatio) != 0)
                {
                    //
                    //Use smaller scaling factor, which results in unfilled domain
                    //on the respective other axis.
                    hv_Scale.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Scale = hv_ZoomFactorWidth.TupleMin2(
                            hv_ZoomFactorHeight);
                    }
                    //Ensure that the zoom factors result in lengths of at least 1px.
                    hv_ZoomFactorWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomFactorWidth = hv_Scale.TupleMax2(
                            hv_ScaleWidthUnit);
                    }
                    hv_ZoomFactorHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomFactorHeight = hv_Scale.TupleMax2(
                            hv_ScaleHeightUnit);
                    }
                }

                hv_ScaleWidthUnit.Dispose();
                hv_ScaleHeightUnit.Dispose();
                hv_PreserveAspectRatio.Dispose();
                hv_Scale.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ScaleWidthUnit.Dispose();
                hv_ScaleHeightUnit.Dispose();
                hv_PreserveAspectRatio.Dispose();
                hv_Scale.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Calculate the channel-wise mean and standard deviation of a DL model layer. 
        private void calculate_dl_model_layer_mean_stddev(HTuple hv_DLModelHandle, HTuple hv_LayerName,
            HTuple hv_DLSamples, out HTuple hv_Mean, out HTuple hv_StdDev)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_LayerOutput = null, ho_SquaredLayerOutput = null;
            HObject ho_MeanOfFeatureMaps = null, ho_MeanOfSquaredFeatureMaps = null;
            HObject ho_UpdateScaled = null, ho_MeanOfFeatureMap = null;
            HObject ho_MeanOfSquaredFeatureMap = null;

            // Local control variables 

            HTuple hv_Shape = new HTuple(), hv_N = new HTuple();
            HTuple hv_C = new HTuple(), hv_NumIterations = new HTuple();
            HTuple hv_Index = new HTuple(), hv_FirstSampleIdx = new HTuple();
            HTuple hv_LastSampleIdx = new HTuple(), hv_DLSamplesBatch = new HTuple();
            HTuple hv_DLResultBatch = new HTuple(), hv_IndexSamples = new HTuple();
            HTuple hv_Iteration = new HTuple(), hv_SampleDict = new HTuple();
            HTuple hv_Var = new HTuple(), hv_IndexC = new HTuple();
            HTuple hv_FeatureMapMean = new HTuple(), hv__ = new HTuple();
            HTuple hv_FeatureMapSquaredMean = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_LayerOutput);
            HOperatorSet.GenEmptyObj(out ho_SquaredLayerOutput);
            HOperatorSet.GenEmptyObj(out ho_MeanOfFeatureMaps);
            HOperatorSet.GenEmptyObj(out ho_MeanOfSquaredFeatureMaps);
            HOperatorSet.GenEmptyObj(out ho_UpdateScaled);
            HOperatorSet.GenEmptyObj(out ho_MeanOfFeatureMap);
            HOperatorSet.GenEmptyObj(out ho_MeanOfSquaredFeatureMap);
            hv_Mean = new HTuple();
            hv_StdDev = new HTuple();
            try
            {
                //Calculate the running mean and standard deviation of a
                //DL model layer. The layer output has the shape
                //N x C x H x W, where
                //- N is the batch size,
                //- C is number of channels, and
                //- H and W are the height and width, respectively.
                //
                hv_Shape.Dispose();
                HOperatorSet.GetDlModelLayerParam(hv_DLModelHandle, hv_LayerName, "shape",
                    out hv_Shape);
                hv_N.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_N = hv_Shape.TupleSelect(
                        3);
                }
                hv_C.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_C = hv_Shape.TupleSelect(
                        2);
                }
                //Compute the average of the layer output and its square
                //over all samples.
                hv_NumIterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumIterations = (((new HTuple(hv_DLSamples.TupleLength()
                        )) / (hv_N.TupleReal()))).TupleCeil();
                }
                HTuple end_val13 = hv_NumIterations - 1;
                HTuple step_val13 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val13, step_val13); hv_Index = hv_Index.TupleAdd(step_val13))
                {
                    hv_FirstSampleIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FirstSampleIdx = hv_Index * hv_N;
                    }
                    hv_LastSampleIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LastSampleIdx = ((((hv_Index + 1) * hv_N) - 1)).TupleMin2(
                            (new HTuple(hv_DLSamples.TupleLength())) - 1);
                    }
                    hv_DLSamplesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesBatch = hv_DLSamples.TupleSelectRange(
                            hv_FirstSampleIdx, hv_LastSampleIdx);
                    }
                    hv_DLResultBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_LayerName,
                        out hv_DLResultBatch);
                    //
                    for (hv_IndexSamples = 0; (int)hv_IndexSamples <= (int)((new HTuple(hv_DLResultBatch.TupleLength()
                        )) - 1); hv_IndexSamples = (int)hv_IndexSamples + 1)
                    {
                        hv_Iteration.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Iteration = (hv_Index * hv_N) + hv_IndexSamples;
                        }
                        //
                        hv_SampleDict.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SampleDict = hv_DLResultBatch.TupleSelect(
                                hv_IndexSamples);
                        }
                        ho_LayerOutput.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LayerOutput = hv_SampleDict.TupleGetDictObject(
                                hv_LayerName);
                        }
                        ho_SquaredLayerOutput.Dispose();
                        HOperatorSet.MultImage(ho_LayerOutput, ho_LayerOutput, out ho_SquaredLayerOutput,
                            1, 0);
                        //
                        if ((int)(new HTuple(hv_Iteration.TupleEqual(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_MeanOfFeatureMaps.Dispose();
                                HOperatorSet.ScaleImage(ho_LayerOutput, out ho_MeanOfFeatureMaps, 1.0 / (new HTuple(hv_DLSamples.TupleLength()
                                    )), 0);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_MeanOfSquaredFeatureMaps.Dispose();
                                HOperatorSet.ScaleImage(ho_SquaredLayerOutput, out ho_MeanOfSquaredFeatureMaps,
                                    1.0 / (new HTuple(hv_DLSamples.TupleLength())), 0);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_UpdateScaled.Dispose();
                                HOperatorSet.ScaleImage(ho_LayerOutput, out ho_UpdateScaled, 1.0 / (new HTuple(hv_DLSamples.TupleLength()
                                    )), 0);
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho_MeanOfFeatureMaps, ho_UpdateScaled, out ExpTmpOutVar_0,
                                    1, 0);
                                ho_MeanOfFeatureMaps.Dispose();
                                ho_MeanOfFeatureMaps = ExpTmpOutVar_0;
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_UpdateScaled.Dispose();
                                HOperatorSet.ScaleImage(ho_SquaredLayerOutput, out ho_UpdateScaled, 1.0 / (new HTuple(hv_DLSamples.TupleLength()
                                    )), 0);
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho_MeanOfSquaredFeatureMaps, ho_UpdateScaled, out ExpTmpOutVar_0,
                                    1, 0);
                                ho_MeanOfSquaredFeatureMaps.Dispose();
                                ho_MeanOfSquaredFeatureMaps = ExpTmpOutVar_0;
                            }
                        }
                    }
                }
                //
                hv_Mean.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Mean = HTuple.TupleGenConst(
                        hv_C, 0.0);
                }
                hv_Var.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Var = HTuple.TupleGenConst(
                        hv_C, 0.0);
                }
                //
                HTuple end_val42 = hv_C - 1;
                HTuple step_val42 = 1;
                for (hv_IndexC = 0; hv_IndexC.Continue(end_val42, step_val42); hv_IndexC = hv_IndexC.TupleAdd(step_val42))
                {
                    //Compute Var[X] as E[X^2] - (E[X])^2.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_MeanOfFeatureMap.Dispose();
                        HOperatorSet.AccessChannel(ho_MeanOfFeatureMaps, out ho_MeanOfFeatureMap,
                            hv_IndexC + 1);
                    }
                    hv_FeatureMapMean.Dispose(); hv__.Dispose();
                    HOperatorSet.Intensity(ho_MeanOfFeatureMap, ho_MeanOfFeatureMap, out hv_FeatureMapMean,
                        out hv__);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_MeanOfSquaredFeatureMap.Dispose();
                        HOperatorSet.AccessChannel(ho_MeanOfSquaredFeatureMaps, out ho_MeanOfSquaredFeatureMap,
                            hv_IndexC + 1);
                    }
                    hv_FeatureMapSquaredMean.Dispose(); hv__.Dispose();
                    HOperatorSet.Intensity(ho_MeanOfSquaredFeatureMap, ho_MeanOfSquaredFeatureMap,
                        out hv_FeatureMapSquaredMean, out hv__);
                    if (hv_Mean == null)
                        hv_Mean = new HTuple();
                    hv_Mean[hv_IndexC] = hv_FeatureMapMean;
                    if (hv_Var == null)
                        hv_Var = new HTuple();
                    hv_Var[hv_IndexC] = hv_FeatureMapSquaredMean - (hv_FeatureMapMean * hv_FeatureMapMean);
                }
                hv_StdDev.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StdDev = hv_Var.TupleSqrt()
                        ;
                }
                ho_LayerOutput.Dispose();
                ho_SquaredLayerOutput.Dispose();
                ho_MeanOfFeatureMaps.Dispose();
                ho_MeanOfSquaredFeatureMaps.Dispose();
                ho_UpdateScaled.Dispose();
                ho_MeanOfFeatureMap.Dispose();
                ho_MeanOfSquaredFeatureMap.Dispose();

                hv_Shape.Dispose();
                hv_N.Dispose();
                hv_C.Dispose();
                hv_NumIterations.Dispose();
                hv_Index.Dispose();
                hv_FirstSampleIdx.Dispose();
                hv_LastSampleIdx.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultBatch.Dispose();
                hv_IndexSamples.Dispose();
                hv_Iteration.Dispose();
                hv_SampleDict.Dispose();
                hv_Var.Dispose();
                hv_IndexC.Dispose();
                hv_FeatureMapMean.Dispose();
                hv__.Dispose();
                hv_FeatureMapSquaredMean.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_LayerOutput.Dispose();
                ho_SquaredLayerOutput.Dispose();
                ho_MeanOfFeatureMaps.Dispose();
                ho_MeanOfSquaredFeatureMaps.Dispose();
                ho_UpdateScaled.Dispose();
                ho_MeanOfFeatureMap.Dispose();
                ho_MeanOfSquaredFeatureMap.Dispose();

                hv_Shape.Dispose();
                hv_N.Dispose();
                hv_C.Dispose();
                hv_NumIterations.Dispose();
                hv_Index.Dispose();
                hv_FirstSampleIdx.Dispose();
                hv_LastSampleIdx.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultBatch.Dispose();
                hv_IndexSamples.Dispose();
                hv_Iteration.Dispose();
                hv_SampleDict.Dispose();
                hv_Var.Dispose();
                hv_IndexC.Dispose();
                hv_FeatureMapMean.Dispose();
                hv__.Dispose();
                hv_FeatureMapSquaredMean.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
        public void calculate_evaluation_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_EvaluationType = new HTuple(), hv_EvaluationResultTmp = new HTuple();
            HTuple hv_PixelMeasures = new HTuple(), hv_PixelMeasureValues = new HTuple();
            HTuple hv_ResultKeys = new HTuple(), hv_KeyIndex = new HTuple();
            HTuple hv___Tmp_Ctrl_Type = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final measures depending on the evaluation type.
                //
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams,
                        out hv_EvaluationResult);
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                    {
                        {
                            HTuple ExpTmpOutVar_0;
                            calculate_ocr_detection_measures(hv_EvaluationResult, out ExpTmpOutVar_0);
                            hv_EvaluationResult.Dispose();
                            hv_EvaluationResult = ExpTmpOutVar_0;
                        }
                    }
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("segmentation"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection")))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                    {
                        hv_EvaluationResultTmp.Dispose();
                        calculate_region_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResultTmp);
                        //Only report requested pixel and region measures.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PixelMeasures.Dispose();
                            get_requested_pixel_measures(hv_EvalParams.TupleGetDictTuple("measures"),
                                hv_EvaluationType, out hv_PixelMeasures);
                        }
                        hv_PixelMeasureValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_PixelMeasures, out hv_PixelMeasureValues);
                        HOperatorSet.SetDictTuple(hv_EvaluationResultTmp, hv_PixelMeasures, hv_PixelMeasureValues);
                        hv_EvaluationResult.Dispose();
                        hv_EvaluationResult = new HTuple(hv_EvaluationResultTmp);
                        hv_EvaluationResultTmp.Dispose();
                        calculate_running_gripping_point_measures(hv_RunningMeasures, hv_EvalParams,
                            out hv_EvaluationResultTmp);
                        hv_ResultKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_EvaluationResultTmp, "keys", new HTuple(),
                            out hv_ResultKeys);
                        for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_ResultKeys.TupleLength()
                            )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_Type.Dispose();
                                HOperatorSet.GetDictParam(hv_EvaluationResultTmp, "key_data_type", hv_ResultKeys.TupleSelect(
                                    hv_KeyIndex), out hv___Tmp_Ctrl_Type);
                            }
                            if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictObject(hv_EvaluationResultTmp.TupleGetDictObject(
                                        hv_ResultKeys.TupleSelect(hv_KeyIndex)), hv_EvaluationResult, hv_ResultKeys.TupleSelect(
                                        hv_KeyIndex));
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_ResultKeys.TupleSelect(
                                        hv_KeyIndex), hv_EvaluationResultTmp.TupleGetDictTuple(hv_ResultKeys.TupleSelect(
                                        hv_KeyIndex)));
                                }
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_ocr_recognition_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                //

                hv_EvaluationType.Dispose();
                hv_EvaluationResultTmp.Dispose();
                hv_PixelMeasures.Dispose();
                hv_PixelMeasureValues.Dispose();
                hv_ResultKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();
                hv_EvaluationResultTmp.Dispose();
                hv_PixelMeasures.Dispose();
                hv_PixelMeasureValues.Dispose();
                hv_ResultKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Calculate anomaly measures based on RunningMeasures. 
        private void calculate_image_anomaly_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcAnomalyHistogram = new HTuple();
            HTuple hv_CalcPrecision = new HTuple(), hv_CalcRecall = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_M = new HTuple(), hv_AnomalyClassificationThresholdExists = new HTuple();
            HTuple hv_AnomalyClassificationThreshold = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_OKIndices = new HTuple();
            HTuple hv_NOKIndices = new HTuple(), hv_HistoOKXValues = new HTuple();
            HTuple hv_HistoOKYValues = new HTuple(), hv_NumOKEvalData = new HTuple();
            HTuple hv_ImageLevelScoresOK = new HTuple(), hv_HistoNOKXValues = new HTuple();
            HTuple hv_HistoNOKYValues = new HTuple(), hv_NumNOKEvalData = new HTuple();
            HTuple hv_ImageLevelScoresNOK = new HTuple(), hv_ScoreHistogram = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_AllPredictions = new HTuple(), hv_IndThreshold = new HTuple();
            HTuple hv_CurrentThresholdValue = new HTuple(), hv_CurrentThresholdKey = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_AbsoluteConfustionMatrices = new HTuple();
            HTuple hv_AbsoluteConfusionMatrix = new HTuple(), hv_Rows = new HTuple();
            HTuple hv_Columns = new HTuple(), hv_Value = new HTuple();
            HTuple hv_AbsoluteConfusionMatrixDictionary = new HTuple();
            HTuple hv_RelativeConfustionMatrices = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_RelativeConfusionMatrixDictionary = new HTuple();
            HTuple hv_GlobalEvaluation = new HTuple(), hv_AllClassPrecisions = new HTuple();
            HTuple hv_AllMeanPrecisions = new HTuple(), hv_AbsoluteConfusionMatrices = new HTuple();
            HTuple hv_ClassPrecisions = new HTuple(), hv_MatrixRowSumID = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_Index = new HTuple();
            HTuple hv_TruePositive = new HTuple(), hv_SumPredictedClass = new HTuple();
            HTuple hv_SumLabel = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_ValidClassPrecisions = new HTuple(), hv_MeanPrecision = new HTuple();
            HTuple hv_AllClassRecalls = new HTuple(), hv_AllMeanRecalls = new HTuple();
            HTuple hv_ClassRecalls = new HTuple(), hv_ClassRecall = new HTuple();
            HTuple hv_ValidClassRecalls = new HTuple(), hv_MeanRecall = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image anomaly measures based on the running measures.
                //
                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcAnomalyHistogram = 1;
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists) != 0)
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                    {
                        if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("anomaly_score_histogram"))) != 0)
                        {
                            //The default, just here for consistency.
                            hv_CalcAnomalyHistogram.Dispose();
                            hv_CalcAnomalyHistogram = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "precision"))) != 0)
                        {
                            hv_CalcPrecision.Dispose();
                            hv_CalcPrecision = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "recall"))) != 0)
                        {
                            hv_CalcRecall.Dispose();
                            hv_CalcRecall = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "absolute_confusion_matrix"))) != 0)
                        {
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "relative_confusion_matrix"))) != 0)
                        {
                            hv_CalcRelativeConfusionMatrix.Dispose();
                            hv_CalcRelativeConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "all"))) != 0)
                        {
                            hv_CalcPrecision.Dispose();
                            hv_CalcPrecision = 1;
                            hv_CalcRecall.Dispose();
                            hv_CalcRecall = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                            hv_CalcRelativeConfusionMatrix.Dispose();
                            hv_CalcRelativeConfusionMatrix = 1;
                        }
                        else
                        {
                            throw new HalconException(("Unknown Measure: " + (hv_Measures.TupleSelect(
                                hv_M))) + ".");
                        }
                    }
                }
                //
                hv_AnomalyClassificationThresholdExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "anomaly_classification_thresholds",
                    out hv_AnomalyClassificationThresholdExists);
                if ((int)(hv_AnomalyClassificationThresholdExists) != 0)
                {
                    hv_AnomalyClassificationThreshold.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                        out hv_AnomalyClassificationThreshold);
                }
                else if ((int)(hv_CalcRelativeConfusionMatrix.TupleOr(hv_CalcAbsoluteConfusionMatrix)) != 0)
                {
                    throw new HalconException("A threshold value is needed to calculate a confusion matrix.");
                }
                //
                //Get and check values in RunningMeasures.
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get image scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //
                //Calculate histograms.
                //
                //Find scores of 'ok' and 'nok' images.
                hv_OKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(
                        0);
                }
                hv_NOKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(
                        1);
                }
                if ((int)((new HTuple(hv_OKIndices.TupleEqual(-1))).TupleAnd(new HTuple(hv_NOKIndices.TupleEqual(
                    -1)))) != 0)
                {
                    throw new HalconException("No data available for evaluation");
                }
                //
                //Calculate histogram for 'ok' images.
                hv_HistoOKXValues.Dispose();
                hv_HistoOKXValues = new HTuple();
                hv_HistoOKYValues.Dispose();
                hv_HistoOKYValues = new HTuple();
                hv_NumOKEvalData.Dispose();
                hv_NumOKEvalData = 0;
                if ((int)(new HTuple(hv_OKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_NumOKEvalData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumOKEvalData = new HTuple(hv_OKIndices.TupleLength()
                            );
                    }
                    hv_ImageLevelScoresOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresOK = hv_AnomalyScores.TupleSelect(
                            hv_OKIndices);
                    }
                    hv_HistoOKXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOKXValues = hv_ImageLevelScoresOK.TupleSort()
                            ;
                    }
                    hv_HistoOKYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOKYValues = ((HTuple.TupleGenSequence(
                            new HTuple(hv_ImageLevelScoresOK.TupleLength()), 1, -1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresOK.TupleLength()
                            ));
                    }
                }
                //
                //Calculate histogram for 'nok' images.
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKXValues = new HTuple();
                hv_HistoNOKYValues.Dispose();
                hv_HistoNOKYValues = new HTuple();
                hv_NumNOKEvalData.Dispose();
                hv_NumNOKEvalData = 0;
                if ((int)(new HTuple(hv_NOKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_NumNOKEvalData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumNOKEvalData = new HTuple(hv_NOKIndices.TupleLength()
                            );
                    }
                    hv_ImageLevelScoresNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresNOK = hv_AnomalyScores.TupleSelect(
                            hv_NOKIndices);
                    }
                    hv_HistoNOKXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoNOKXValues = hv_ImageLevelScoresNOK.TupleSort()
                            ;
                    }
                    hv_HistoNOKYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoNOKYValues = ((HTuple.TupleGenSequence(
                            1, new HTuple(hv_ImageLevelScoresNOK.TupleLength()), 1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresNOK.TupleLength()
                            ));
                    }
                }
                //
                //Create dictionary for the score histogram.
                hv_ScoreHistogram.Dispose();
                HOperatorSet.CreateDict(out hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_x", hv_HistoOKXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_y", hv_HistoOKYValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_x", hv_HistoNOKXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_y", hv_HistoNOKYValues);
                //
                //Set the score histogram in the results dictionary.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", hv_ScoreHistogram);
                //
                //Get Predictions according to given Threshold value(s).
                //Remember, precision and recall base on the absolute confusion matrix.
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    hv_AllPredictions.Dispose();
                    HOperatorSet.CreateDict(out hv_AllPredictions);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Predictions = hv_AnomalyScores.TupleGreaterEqualElem(
                                hv_CurrentThresholdValue);
                        }
                        HOperatorSet.SetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, hv_Predictions);
                    }
                }
                //
                //Calculate absolute confusion matrix.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_AbsoluteConfustionMatrices.Dispose();
                    hv_AbsoluteConfustionMatrices = new HTuple();
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                        hv_AbsoluteConfusionMatrix.Dispose();
                        gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                            "return_matrix"), (new HTuple("none")).TupleConcat("absolute"), new HTuple(),
                            out hv_AbsoluteConfusionMatrix);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_AbsoluteConfusionMatrix, out hv_Rows, out hv_Columns);
                        if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                            new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                            2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                        {
                            //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                            //data is used for evaluation.
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, out hv_Value);
                            hv_AbsoluteConfusionMatrix.Dispose();
                            HOperatorSet.CreateMatrix(2, 2, 0, out hv_AbsoluteConfusionMatrix);
                            if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 1, (new HTuple(hv_Predictions.TupleLength()
                                        )) - hv_Value);
                                }
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 1, hv_Value);
                            }
                            if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, hv_Value);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 0, (new HTuple(hv_Predictions.TupleLength()
                                        )) - hv_Value);
                                }
                            }
                        }
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        HOperatorSet.CreateDict(out hv_AbsoluteConfusionMatrixDictionary);
                        HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            hv_AbsoluteConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "threshold",
                            hv_CurrentThresholdValue);
                        if (hv_AbsoluteConfustionMatrices == null)
                            hv_AbsoluteConfustionMatrices = new HTuple();
                        hv_AbsoluteConfustionMatrices[hv_IndThreshold] = hv_AbsoluteConfusionMatrixDictionary;
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_AbsoluteConfustionMatrices);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfustionMatrices.Dispose();
                    hv_RelativeConfustionMatrices = new HTuple();
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                        hv_RelativeConfusionMatrix.Dispose();
                        gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                            "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                            out hv_RelativeConfusionMatrix);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_RelativeConfusionMatrix, out hv_Rows, out hv_Columns);
                        if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                            new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                            2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                        {
                            //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                            //data is used for evaluation.
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, out hv_Value);
                            hv_RelativeConfusionMatrix.Dispose();
                            HOperatorSet.CreateMatrix(2, 2, 0, out hv_RelativeConfusionMatrix);
                            if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 1, 1.0 - hv_Value);
                                }
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 1, hv_Value);
                            }
                            if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, hv_Value);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 0, 1.0 - hv_Value);
                                }
                            }
                        }
                        hv_RelativeConfusionMatrixDictionary.Dispose();
                        HOperatorSet.CreateDict(out hv_RelativeConfusionMatrixDictionary);
                        HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "confusion_matrix",
                            hv_RelativeConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "threshold",
                            hv_CurrentThresholdValue);
                        if (hv_RelativeConfustionMatrices == null)
                            hv_RelativeConfustionMatrices = new HTuple();
                        hv_RelativeConfustionMatrices[hv_IndThreshold] = hv_RelativeConfusionMatrixDictionary;
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfustionMatrices);
                }
                //
                if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
                {
                    hv_GlobalEvaluation.Dispose();
                    HOperatorSet.CreateDict(out hv_GlobalEvaluation);
                }
                //Calculate precision.
                if ((int)(hv_CalcPrecision) != 0)
                {
                    hv_AllClassPrecisions.Dispose();
                    hv_AllClassPrecisions = new HTuple();
                    hv_AllMeanPrecisions.Dispose();
                    hv_AllMeanPrecisions = new HTuple();
                    hv_AbsoluteConfusionMatrices.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        out hv_AbsoluteConfusionMatrices);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfusionMatrices.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfusionMatrices.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_AbsoluteConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            out hv_AbsoluteConfusionMatrix);
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val184 = hv_NumClasses - 1;
                        HTuple step_val184 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val184, step_val184); hv_Index = hv_Index.TupleAdd(step_val184))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                    hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_ClassIDs.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            if ((int)(new HTuple(hv_SumLabel.TupleLessEqual(0))) != 0)
                            {
                                //Invalid per-class precision.
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = -1.0;
                            }
                            else if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(
                                0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0.0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidClassPrecisions.Dispose();
                            HOperatorSet.TupleSelectMask(hv_ClassPrecisions, hv_ClassPrecisions.TupleGreaterEqualElem(
                                0.0), out hv_ValidClassPrecisions);
                        }
                        hv_MeanPrecision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanPrecision = hv_ValidClassPrecisions.TupleMean()
                                ;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllClassPrecisions = hv_AllClassPrecisions.TupleConcat(
                                    hv_ClassPrecisions);
                                hv_AllClassPrecisions.Dispose();
                                hv_AllClassPrecisions = ExpTmpLocalVar_AllClassPrecisions;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllMeanPrecisions = hv_AllMeanPrecisions.TupleConcat(
                                    hv_MeanPrecision);
                                hv_AllMeanPrecisions.Dispose();
                                hv_AllMeanPrecisions = ExpTmpLocalVar_AllMeanPrecisions;
                            }
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                    }
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "precision_per_class", hv_AllClassPrecisions);
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_precision", hv_AllMeanPrecisions);
                }
                //
                //Calculate recall.
                if ((int)(hv_CalcRecall) != 0)
                {
                    hv_AllClassRecalls.Dispose();
                    hv_AllClassRecalls = new HTuple();
                    hv_AllMeanRecalls.Dispose();
                    hv_AllMeanRecalls = new HTuple();
                    hv_AbsoluteConfustionMatrices.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        out hv_AbsoluteConfustionMatrices);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfustionMatrices.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfustionMatrices.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_AbsoluteConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            out hv_AbsoluteConfusionMatrix);
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val219 = hv_NumClasses - 1;
                        HTuple step_val219 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val219, step_val219); hv_Index = hv_Index.TupleAdd(step_val219))
                        {
                            //Compute the recall for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                    hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            if ((int)(new HTuple(hv_SumLabel.TupleEqual(0))) != 0)
                            {
                                //Invalid per-class recall.
                                hv_ClassRecall.Dispose();
                                hv_ClassRecall = -1.0;
                            }
                            else
                            {
                                hv_ClassRecall.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidClassRecalls.Dispose();
                            HOperatorSet.TupleSelectMask(hv_ClassRecalls, hv_ClassRecalls.TupleGreaterEqualElem(
                                0.0), out hv_ValidClassRecalls);
                        }
                        hv_MeanRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanRecall = hv_ValidClassRecalls.TupleMean()
                                ;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllClassRecalls = hv_AllClassRecalls.TupleConcat(
                                    hv_ClassRecalls);
                                hv_AllClassRecalls.Dispose();
                                hv_AllClassRecalls = ExpTmpLocalVar_AllClassRecalls;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllMeanRecalls = hv_AllMeanRecalls.TupleConcat(
                                    hv_MeanRecall);
                                hv_AllMeanRecalls.Dispose();
                                hv_AllMeanRecalls = ExpTmpLocalVar_AllMeanRecalls;
                            }
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        //
                    }
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "recall_per_class", hv_AllClassRecalls);
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_recall", hv_AllMeanRecalls);
                }
                //
                if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "global_evaluation", hv_GlobalEvaluation);
                }
                //

                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_AnomalyClassificationThresholdExists.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_OKIndices.Dispose();
                hv_NOKIndices.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_NumOKEvalData.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_NumNOKEvalData.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_ScoreHistogram.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassIDs.Dispose();
                hv_AllPredictions.Dispose();
                hv_IndThreshold.Dispose();
                hv_CurrentThresholdValue.Dispose();
                hv_CurrentThresholdKey.Dispose();
                hv_Predictions.Dispose();
                hv_AbsoluteConfustionMatrices.Dispose();
                hv_AbsoluteConfusionMatrix.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Value.Dispose();
                hv_AbsoluteConfusionMatrixDictionary.Dispose();
                hv_RelativeConfustionMatrices.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrixDictionary.Dispose();
                hv_GlobalEvaluation.Dispose();
                hv_AllClassPrecisions.Dispose();
                hv_AllMeanPrecisions.Dispose();
                hv_AbsoluteConfusionMatrices.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_Index.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassPrecision.Dispose();
                hv_ValidClassPrecisions.Dispose();
                hv_MeanPrecision.Dispose();
                hv_AllClassRecalls.Dispose();
                hv_AllMeanRecalls.Dispose();
                hv_ClassRecalls.Dispose();
                hv_ClassRecall.Dispose();
                hv_ValidClassRecalls.Dispose();
                hv_MeanRecall.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_AnomalyClassificationThresholdExists.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_OKIndices.Dispose();
                hv_NOKIndices.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_NumOKEvalData.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_NumNOKEvalData.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_ScoreHistogram.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassIDs.Dispose();
                hv_AllPredictions.Dispose();
                hv_IndThreshold.Dispose();
                hv_CurrentThresholdValue.Dispose();
                hv_CurrentThresholdKey.Dispose();
                hv_Predictions.Dispose();
                hv_AbsoluteConfustionMatrices.Dispose();
                hv_AbsoluteConfusionMatrix.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Value.Dispose();
                hv_AbsoluteConfusionMatrixDictionary.Dispose();
                hv_RelativeConfustionMatrices.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrixDictionary.Dispose();
                hv_GlobalEvaluation.Dispose();
                hv_AllClassPrecisions.Dispose();
                hv_AllMeanPrecisions.Dispose();
                hv_AbsoluteConfusionMatrices.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_Index.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassPrecision.Dispose();
                hv_ValidClassPrecisions.Dispose();
                hv_MeanPrecision.Dispose();
                hv_AllClassRecalls.Dispose();
                hv_AllMeanRecalls.Dispose();
                hv_ClassRecalls.Dispose();
                hv_ClassRecall.Dispose();
                hv_ValidClassRecalls.Dispose();
                hv_MeanRecall.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Calculate image classification measures based on RunningMeasures. 
        private void calculate_image_classification_measures(HTuple hv_RunningMeasures,
            HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TopKErrorKs = new HTuple(), hv_CalcPrecision = new HTuple();
            HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_RegExpTopKError = new HTuple();
            HTuple hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_K = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassesToEvaluate = new HTuple();
            HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Position = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_TopKPredictions = new HTuple();
            HTuple hv_EvalIndex = new HTuple(), hv_CurrentEvalClass = new HTuple();
            HTuple hv_IndexClass = new HTuple(), hv_EvaluatedSamples = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_EvalClassID = new HTuple(), hv_KIndex = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TopKError = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassPrecisions = new HTuple();
            HTuple hv_MatrixRowSumID = new HTuple(), hv_TruePositive = new HTuple();
            HTuple hv_SumPredictedClass = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_Precision = new HTuple(), hv_ClassRecalls = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_SumLabel = new HTuple();
            HTuple hv_ClassRecall = new HTuple(), hv_Recall = new HTuple();
            HTuple hv_ClassFScores = new HTuple(), hv_SumPrecisionRecall = new HTuple();
            HTuple hv_PositiveIndices = new HTuple(), hv_FScore = new HTuple();
            HTuple hv_KeyName = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image classification measures based on the running measures.
                //
                //Set default values.
                hv_TopKErrorKs.Dispose();
                hv_TopKErrorKs = new HTuple();
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcFScore.Dispose();
                hv_CalcFScore = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest("top([0-9]+)_error");
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = ((((hv_Measures.TupleSelect(
                                hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber();
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    hv_K))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))) != 0)
                    {
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "f_score"))) != 0)
                    {
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "absolute_confusion_matrix"))) != 0)
                    {
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "relative_confusion_matrix"))) != 0)
                    {
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    1))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown image classification measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate = new HTuple();
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassesToEvaluate.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Position.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Position = (((((new HTuple("global")).TupleConcat(
                                hv_ClassNames))).TupleEqualElem(hv_ClassesToEvaluate.TupleSelect(hv_Index)))).TupleFind(
                                1);
                        }
                        if ((int)((new HTuple(hv_Position.TupleEqual(-1))).TupleOr(new HTuple(hv_Position.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            throw new HalconException("Invalid entry in  'class_names_to_evaluate': " + ((((new HTuple("global")).TupleConcat(
                                hv_ClassesToEvaluate))).TupleSelect(hv_Index)));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(
                                    (((new HTuple("global")).TupleConcat(hv_ClassIDs))).TupleSelect(hv_Position));
                                hv_ClassIDsToEvaluate.Dispose();
                                hv_ClassIDsToEvaluate = ExpTmpLocalVar_ClassIDsToEvaluate;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                }
                hv_ClassIDsToEvaluate.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                //
                //Get and check values in RunningMeasures.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Predictions);
                hv_TopKPredictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictions);
                //
                //Check if needed classes appear in image label IDs.
                //For the confusion matrices, all classes need to be represented.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcAbsoluteConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcAbsoluteConfusionMatrix);
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = ExpTmpLocalVar_CalcAbsoluteConfusionMatrix;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcRelativeConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcRelativeConfusionMatrix);
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = ExpTmpLocalVar_CalcRelativeConfusionMatrix;
                    }
                }
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                        hv_ClassIDs.TupleSort()))) != 0)
                    {
                        throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                    }
                }
                //For top-K errors, the evaluated classes need to be represented.
                if ((int)(new HTuple(hv_TopKErrorKs.TupleNotEqual(new HTuple()))) != 0)
                {
                    for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                        )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                    {
                        hv_CurrentEvalClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                                hv_EvalIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleNotEqual("global"))) != 0)
                        {
                            hv_IndexClass.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IndexClass = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                            if ((int)((new HTuple(hv_IndexClass.TupleEqual(-1))).TupleOr(new HTuple(hv_IndexClass.TupleEqual(
                                new HTuple())))) != 0)
                            {
                                throw new HalconException(("The evaluated class ID " + hv_CurrentEvalClass) + " is not represented in the ground truth labels.");
                            }
                        }
                    }
                }
                //
                //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluatedSamples);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_samples", hv_EvaluatedSamples);
                //
                //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix",
                        "none", new HTuple(), out hv_ConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_ConfusionMatrix);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                        out hv_RelativeConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfusionMatrix);
                }
                //
                // Calculate measures for every class to be evaluated.
                for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                    )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                {
                    hv_CurrentEvalClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    hv_EvalClassID.Dispose();
                    HOperatorSet.CreateDict(out hv_EvalClassID);
                    //
                    //Calculate top-K errors.
                    for (hv_KIndex = 0; (int)hv_KIndex <= (int)((new HTuple(hv_TopKErrorKs.TupleLength()
                        )) - 1); hv_KIndex = (int)hv_KIndex + 1)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = hv_TopKErrorKs.TupleSelect(
                                hv_KIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = HTuple.TupleGenSequence(
                                    0, (new HTuple(hv_ImageLabelIDs.TupleLength())) - 1, 1);
                            }
                        }
                        else
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TopKError.Dispose();
                            compute_top_k_error(hv_ImageLabelIDs.TupleSelect(hv_Indices), hv_TopKPredictions.TupleSelect(
                                hv_Indices), hv_K, out hv_TopKError);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, ("top" + hv_K) + "_error", hv_TopKError);
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                    {
                        //Compute the mean of the measures for all classes.
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
                                );
                        }
                        hv_IndexClass.Dispose();
                        hv_IndexClass = new HTuple(hv_ClassIDs);
                    }
                    else
                    {
                        //Compute the measures for a certain class.
                        hv_NumClasses.Dispose();
                        hv_NumClasses = 1;
                        hv_IndexClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexClass = hv_ClassIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                    }
                    //
                    //Calculate prediction.
                    if ((int)(hv_CalcPrecision.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        HTuple end_val138 = hv_NumClasses - 1;
                        HTuple step_val138 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val138, step_val138); hv_Index = hv_Index.TupleAdd(step_val138))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = hv_ClassPrecisions.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
                        }
                    }
                    //
                    //Calculate recall.
                    if ((int)(hv_CalcRecall.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val163 = hv_NumClasses - 1;
                        HTuple step_val163 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val163, step_val163); hv_Index = hv_Index.TupleAdd(step_val163))
                        {
                            //Compute the recall for every class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            hv_ClassRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = hv_ClassRecalls.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
                        }
                    }
                    //
                    //Calculate F-score.
                    if ((int)(hv_CalcFScore) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassFScores.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_ClassPrecisions.TupleLength()),
                                0.0, out hv_ClassFScores);
                        }
                        hv_SumPrecisionRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPrecisionRecall = hv_ClassPrecisions + hv_ClassRecalls;
                        }
                        hv_PositiveIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PositiveIndices = ((hv_SumPrecisionRecall.TupleNotEqualElem(
                                0.0))).TupleFind(1);
                        }
                        if ((int)((new HTuple(hv_PositiveIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PositiveIndices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            if (hv_ClassFScores == null)
                                hv_ClassFScores = new HTuple();
                            hv_ClassFScores[hv_PositiveIndices] = ((2 * (hv_ClassPrecisions.TupleSelect(
                                hv_PositiveIndices))) * (hv_ClassRecalls.TupleSelect(hv_PositiveIndices))) / (hv_SumPrecisionRecall.TupleSelect(
                                hv_PositiveIndices));
                        }
                        hv_FScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FScore = hv_ClassFScores.TupleMean()
                                ;
                        }
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
                        }
                    }
                    //
                    //Set evaluation results for current class ID.
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleSelect(hv_EvalIndex))).TupleNotEqual(
                        "global"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyName = "class_id_" + hv_KeyName;
                                hv_KeyName.Dispose();
                                hv_KeyName = ExpTmpLocalVar_KeyName;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_KeyName, hv_EvalClassID);
                }
                //

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Calculate instance measures based on RunningMeasures. 
        private void calculate_instance_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
            HTuple hv_CalcSoAP = new HTuple(), hv_EvalType = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_M = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_InterpolatePRCurves = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_RecThreshs = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_PerMaxNumEvaluationResult = new HTuple();
            HTuple hv_AreaIdx = new HTuple(), hv_MinArea = new HTuple();
            HTuple hv_MaxArea = new HTuple(), hv_AreaName = new HTuple();
            HTuple hv_AreaRunningMeasures = new HTuple(), hv_PerClassNumGt = new HTuple();
            HTuple hv_PerClassNumPred = new HTuple(), hv_PerClassConfidence = new HTuple();
            HTuple hv_PerClassNumGtIgnore = new HTuple(), hv_CurrentEvaluationResult = new HTuple();
            HTuple hv_ITIdx = new HTuple(), hv_PerIoUAP = new HTuple();
            HTuple hv_PerIoUSoAP = new HTuple(), hv_PerIoUDetailedEvaluation = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_PerClassDetailedEvaluation = new HTuple();
            HTuple hv_DetectionConfusionMatrix = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_NumImgIDsWithFN = new HTuple(), hv_NumImgIDsWithFP = new HTuple();
            HTuple hv_ImgIDsWithFN = new HTuple(), hv_ImgIDsWithFP = new HTuple();
            HTuple hv_ClassMAPDict = new HTuple(), hv_ClassMSoAPDict = new HTuple();
            HTuple hv_ClassesWithGt = new HTuple(), hv_PerClassMAP = new HTuple();
            HTuple hv_PerIoUMAP = new HTuple(), hv_PerClassMSoAP = new HTuple();
            HTuple hv_PerIoUMSoAP = new HTuple(), hv_PerIoUNumClassesWithTP = new HTuple();
            HTuple hv_PerIoUTP = new HTuple(), hv_PerIoUFN = new HTuple();
            HTuple hv_PerIoUFP = new HTuple(), hv_PerIoUFPClass = new HTuple();
            HTuple hv_PerIoUFPBackground = new HTuple(), hv_PerIoUFPLocalization = new HTuple();
            HTuple hv_PerIoUFPDuplicate = new HTuple(), hv_PerIoUFPMultiple = new HTuple();
            HTuple hv_PerIoUSoAPClass = new HTuple(), hv_PerIoUSoAPLocalization = new HTuple();
            HTuple hv_PerIoUSoAPDuplicate = new HTuple(), hv_PerIoUSoAPMultiple = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPClass = new HTuple(), hv_PerIoUNumClassesWithFPLocalization = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPMultiple = new HTuple();
            HTuple hv_ClassAPPerIoU = new HTuple(), hv_ClassSoAPPerIoU = new HTuple();
            HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
            HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
            HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
            HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
            HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
            HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
            HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
            HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
            HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
            HTuple hv_RecQuantile = new HTuple(), hv_AOD = new HTuple();
            HTuple hv_IdxsTP = new HTuple(), hv_IsFPClass = new HTuple();
            HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
            HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
            HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
            HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
            HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
            HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
            HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
            HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_NumConfusedThisIdx = new HTuple(), hv_AODClass = new HTuple();
            HTuple hv_IdxsClass = new HTuple(), hv_ResSoAPClass = new HTuple();
            HTuple hv_AODLocalization = new HTuple(), hv_IdxsLocalization = new HTuple();
            HTuple hv_ResSoAPLocalization = new HTuple(), hv_AODDuplicate = new HTuple();
            HTuple hv_IdxsDuplicate = new HTuple(), hv_ResSoAPDuplicate = new HTuple();
            HTuple hv_AODMultiple = new HTuple(), hv_IdxsMultiple = new HTuple();
            HTuple hv_ResSoAPMultiple = new HTuple(), hv_SoAPIoUIdxsPositive = new HTuple();
            HTuple hv_MeanClassAP = new HTuple(), hv_MeanClassSoAP = new HTuple();
            HTuple hv_MAP = new HTuple(), hv_MSoAP = new HTuple();
            HTuple hv_IoUsWithTP = new HTuple(), hv_MSoAPAll = new HTuple();
            HTuple hv_NumSoAPAll = new HTuple(), hv_IoUsWithFPClass = new HTuple();
            HTuple hv_IoUsWithFPLocalization = new HTuple(), hv_IoUsWithFPDuplicate = new HTuple();
            HTuple hv_IoUsWithFPMultiple = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing instance measures based on the running measures.
                //
                //Set default values.
                hv_CalcClassAP.Dispose();
                hv_CalcClassAP = 0;
                hv_CalcMeanAP.Dispose();
                hv_CalcMeanAP = 0;
                hv_CalcSoAP.Dispose();
                hv_CalcSoAP = 0;
                //Check which measures are to be calculated.
                hv_EvalType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvalType);
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
                    {
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        //As we need to calculate the class APs anyway, we also write them out.
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                    }
                    else if ((int)((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "soap"))).TupleAnd(new HTuple(hv_InstanceType.TupleEqual("rectangle2")))) != 0)
                    {
                        hv_CalcSoAP.Dispose();
                        hv_CalcSoAP = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                        {
                            hv_CalcSoAP.Dispose();
                            hv_CalcSoAP = 1;
                        }
                    }
                    else
                    {
                        if ((int)((new HTuple(hv_EvalType.TupleEqual("ocr_detection"))).TupleAnd(
                            (new HTuple((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "recall"))).TupleOr(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "precision"))))).TupleOr(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "f_score"))))) != 0)
                        {
                            hv_CalcMeanAP.Dispose();
                            hv_CalcMeanAP = 1;
                            hv_CalcClassAP.Dispose();
                            hv_CalcClassAP = 1;
                            continue;
                        }
                        else
                        {
                            throw new HalconException("Unknown Instance Measure: " + (hv_Measures.TupleSelect(
                                hv_M)));
                        }
                    }
                }
                //*
                //Dependencies of measures:
                //
                //Recall (per-class)       *                   --> AP per class --> mAP
                //Precision (per-class)  /
                //
                //*
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                //Check if a detailed evaluation should be done and if PR-curves should be interpolated.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_InterpolatePRCurves.Dispose();
                hv_InterpolatePRCurves = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("detailed_evaluation")).TupleConcat(
                    "interpolate_pr_curves"), out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                {
                    hv_InterpolatePRCurves.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                }
                //
                //Get information about area ranges.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                //
                //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
                hv_RecThreshs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RecThreshs = HTuple.TupleGenSequence(
                        0.0, 1.0, 0.01);
                }
                //Start with calculation.
                if ((int)((new HTuple(hv_CalcClassAP.TupleOr(hv_CalcMeanAP))).TupleOr(hv_CalcSoAP)) != 0)
                {
                    //Loop over maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        //
                        //Get corresponding running measures.
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Initialize output dictionary.
                        hv_PerMaxNumEvaluationResult.Dispose();
                        HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
                        //
                        //Loop over area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //Get area thresholds.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidence.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            //Initialize output dictionary.
                            hv_CurrentEvaluationResult.Dispose();
                            HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                hv_PerIoUAP.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUAP);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUAP);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAP.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUSoAP);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUSoAP);
                                    }
                                }
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Initialize detailed measures.
                                    hv_PerIoUDetailedEvaluation.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
                                    HTuple end_val108 = hv_NumClasses - 1;
                                    HTuple step_val108 = 1;
                                    for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val108, step_val108); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val108))
                                    {
                                        hv_PerClassDetailedEvaluation.Dispose();
                                        HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                                        //Initialize with zeros in case there is no ground truth for this class.
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                            0);
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple",
                                                -1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_DetectionConfusionMatrix.Dispose();
                                        HOperatorSet.CreateMatrix(hv_NumClasses + 1, hv_NumClasses + 4, 0, out hv_DetectionConfusionMatrix);
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                        hv_DetectionConfusionMatrix);
                                    //
                                    //Get and set image IDs with false negatives and false positives.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Get image IDs with false negatives and false positives, respectively.
                                    hv_NumImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                        out hv_NumImgIDsWithFN);
                                    hv_NumImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                        out hv_NumImgIDsWithFP);
                                    hv_ImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        out hv_ImgIDsWithFN);
                                    hv_ImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        out hv_ImgIDsWithFP);
                                    //Set in current output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives",
                                            hv_ImgIDsWithFN.TupleSelectRange(0, hv_NumImgIDsWithFN - 1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives",
                                            hv_ImgIDsWithFP.TupleSelectRange(0, hv_NumImgIDsWithFP - 1));
                                    }
                                    //
                                    //Set output for this IoU.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUDetailedEvaluation);
                                    }
                                }
                            }
                            hv_ClassMAPDict.Dispose();
                            HOperatorSet.CreateDict(out hv_ClassMAPDict);
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                hv_ClassMAPDict);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_ClassMSoAPDict.Dispose();
                                HOperatorSet.CreateDict(out hv_ClassMSoAPDict);
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                    hv_ClassMSoAPDict);
                            }
                            //
                            //Check which classes have ground truth annotations.
                            hv_ClassesWithGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassesWithGt = ((((hv_PerClassNumGt - hv_PerClassNumGtIgnore)).TupleGreaterElem(
                                    0))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
                            {
                                hv_ClassesWithGt.Dispose();
                                hv_ClassesWithGt = new HTuple();
                            }
                            //
                            //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
                            hv_PerClassMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerClassMAP = HTuple.TupleGenConst(
                                    hv_NumClasses, -1.0);
                            }
                            //
                            //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
                            hv_PerIoUMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUMAP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                            }
                            //
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
                                hv_PerClassMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerClassMSoAP = HTuple.TupleGenConst(
                                        hv_NumClasses, -1.0);
                                }
                                //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
                                hv_PerIoUMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMSoAP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                                }
                                //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occurred.
                                hv_PerIoUNumClassesWithTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Initialize overall num_fn, num_tp, ...
                                hv_PerIoUTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPBackground.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPBackground = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUNumClassesWithFPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                }
                            }
                            //Loop over all classes.
                            HTuple end_val195 = hv_NumClasses - 1;
                            HTuple step_val195 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val195, step_val195); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val195))
                            {
                                //
                                //Initialize per-class AP per IoU-threshold (only for one class).
                                hv_ClassAPPerIoU.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassAPPerIoU = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                }
                                //
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_ClassSoAPPerIoU.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ClassSoAPPerIoU = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                    }
                                }
                                //Get results for this class.
                                hv_NumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGt = hv_PerClassNumGt.TupleSelect(
                                        hv_ClsIdx);
                                }
                                hv_NumGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                {
                                    hv_NumPred.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_NumPred = hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Confidences.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_Confidences);
                                    }
                                    //
                                    //Sort the confidences in descending order and
                                    //only take the first NumPred ones due to block allocation.
                                    hv_SortIdxs.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                                            0, hv_NumPred - 1)))).TupleSortIndex();
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                                hv_SortIdxs);
                                            hv_Confidences.Dispose();
                                            hv_Confidences = ExpTmpLocalVar_Confidences;
                                        }
                                    }
                                }
                                //
                                //Loop over IoU thresholds.
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    //
                                    //Check if there are ground truth labels for this class.
                                    if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                    {
                                        //
                                        //Get results for this class and IoU-threshold.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_CurrentClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_CurrentClassMeasures);
                                        }
                                        hv_IsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                                        hv_Ignore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                                        //
                                        //Sort the arrays IsTP and Ignore according to the confidence values.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_IsTP.Dispose();
                                                hv_IsTP = ExpTmpLocalVar_IsTP;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_Ignore.Dispose();
                                                hv_Ignore = ExpTmpLocalVar_Ignore;
                                            }
                                        }
                                        //
                                        //Sort out the ignored results.
                                        if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                                            0))) != 0)
                                        {
                                            hv_NoIgnoreIdxs.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                                                    0);
                                            }
                                            if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                            hv_NoIgnoreIdxs);
                                                        hv_IsTP.Dispose();
                                                        hv_IsTP = ExpTmpLocalVar_IsTP;
                                                    }
                                                }
                                                hv_IsFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFP = hv_IsTP.TupleNot()
                                                        ;
                                                }
                                            }
                                            else
                                            {
                                                hv_IsTP.Dispose();
                                                hv_IsTP = new HTuple();
                                                hv_IsFP.Dispose();
                                                hv_IsFP = new HTuple();
                                            }
                                        }
                                        else
                                        {
                                            hv_IsFP.Dispose();
                                            hv_IsFP = new HTuple();
                                        }
                                        //
                                        //Accumulate IsTP and IsFP.
                                        hv_AccumulatedIsTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                                                ;
                                        }
                                        hv_AccumulatedIsFP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                                                ;
                                        }
                                        //
                                        //Compute recall.
                                        //The recall is computed with respect to all ground truth instances,
                                        //independent of MaxNum.
                                        hv_Recall.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_NumGt - hv_NumGtIgnore);
                                        }
                                        //
                                        //Compute precision.
                                        hv_Precision.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_AccumulatedIsTP + hv_AccumulatedIsFP);
                                        }
                                        //
                                        //(Optionally) smooth precision-recall curve.
                                        hv_InterpolatedPrecision.Dispose();
                                        hv_InterpolatedPrecision = new HTuple(hv_Precision);
                                        if ((int)(hv_InterpolatePRCurves) != 0)
                                        {
                                            HTuple end_val261 = 0;
                                            HTuple step_val261 = -1;
                                            for (hv_PIdx = hv_NumPred - 2; hv_PIdx.Continue(end_val261, step_val261); hv_PIdx = hv_PIdx.TupleAdd(step_val261))
                                            {
                                                if (hv_InterpolatedPrecision == null)
                                                    hv_InterpolatedPrecision = new HTuple();
                                                hv_InterpolatedPrecision[hv_PIdx] = ((hv_InterpolatedPrecision.TupleSelect(
                                                    hv_PIdx))).TupleMax2(hv_InterpolatedPrecision.TupleSelect(
                                                    hv_PIdx + 1));
                                            }
                                        }
                                        //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                                        hv_PrecisionAtRecThreshs.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                                                new HTuple(hv_RecThreshs.TupleLength()), 0.0);
                                        }
                                        for (hv_RTIdx = 0; (int)hv_RTIdx <= (int)((new HTuple(hv_RecThreshs.TupleLength()
                                            )) - 1); hv_RTIdx = (int)hv_RTIdx + 1)
                                        {
                                            hv_RecQuantile.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                                                    hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                                            }
                                            if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                                            {
                                                if (hv_PrecisionAtRecThreshs == null)
                                                    hv_PrecisionAtRecThreshs = new HTuple();
                                                hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                                                    hv_RecQuantile);
                                            }
                                        }
                                        //
                                        //Calculate AP as mean of precision at equidistant recall values.
                                        if (hv_ClassAPPerIoU == null)
                                            hv_ClassAPPerIoU = new HTuple();
                                        hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                                            ;
                                        //
                                        //Accumulate AP over classes.
                                        if (hv_PerIoUMAP == null)
                                            hv_PerIoUMAP = new HTuple();
                                        hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx)) + (hv_ClassAPPerIoU.TupleSelect(
                                            hv_ITIdx));
                                        //
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            //Calculate SoAP out of the mean over absolute orientation differences.
                                            hv_AOD.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff",
                                                out hv_AOD);
                                            hv_IdxsTP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsTP = hv_IsTP.TupleFind(
                                                    1);
                                            }
                                            if ((int)((new HTuple((new HTuple(hv_IdxsTP.TupleLength())).TupleGreater(
                                                0))).TupleAnd(new HTuple(hv_IdxsTP.TupleNotEqual(-1)))) != 0)
                                            {
                                                if (hv_ClassSoAPPerIoU == null)
                                                    hv_ClassSoAPPerIoU = new HTuple();
                                                hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0 - ((((hv_AOD.TupleSelect(hv_SortIdxs.TupleSelect(
                                                    hv_NoIgnoreIdxs.TupleSelect(hv_IdxsTP))))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                    ));
                                                //Accumulate SoAP over classes.
                                                if (hv_PerIoUMSoAP == null)
                                                    hv_PerIoUMSoAP = new HTuple();
                                                hv_PerIoUMSoAP[hv_ITIdx] = (hv_PerIoUMSoAP.TupleSelect(hv_ITIdx)) + (hv_ClassSoAPPerIoU.TupleSelect(
                                                    hv_ITIdx));
                                            }
                                            //Update PerIoUNumClassesWithTP.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                if (hv_PerIoUNumClassesWithTP == null)
                                                    hv_PerIoUNumClassesWithTP = new HTuple();
                                                hv_PerIoUNumClassesWithTP[hv_ITIdx] = (hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_ITIdx)) + (((hv_AccumulatedIsTP.TupleSelect((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                    )) - 1))).TupleGreaterElem(0));
                                            }
                                        }
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                                            //
                                            //Get the necessary running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            //
                                            //We use the values with maximal recall,
                                            //in case a higher precision is desired, increase 'min_confidence'.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumTP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsTP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumTP.Dispose();
                                                hv_NumTP = 0;
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsFP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumFP.Dispose();
                                                hv_NumFP = 0;
                                            }
                                            hv_NumFN.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFN = (hv_NumGt - hv_NumGtIgnore) - hv_NumTP;
                                            }
                                            hv_NumFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                                            }
                                            hv_NumFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                                                0))) != 0)
                                            {
                                                hv_NumFPClass.Dispose();
                                                hv_NumFPClass = 0;
                                                hv_NumFPBackground.Dispose();
                                                hv_NumFPBackground = 0;
                                                hv_NumFPLocalization.Dispose();
                                                hv_NumFPLocalization = 0;
                                                hv_NumFPDuplicate.Dispose();
                                                hv_NumFPDuplicate = 0;
                                                hv_NumFPMultiple.Dispose();
                                                hv_NumFPMultiple = 0;
                                            }
                                            //Consistency checks.
                                            if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                                                hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                                                hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                                                hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass + hv_NumFPBackground) + hv_NumFPLocalization) + hv_NumFPDuplicate) + hv_NumFPMultiple))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            //
                                            //Set per-class measures.
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerIoUDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerClassDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                    hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                                hv_NumTP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                                hv_NumFN);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                                hv_NumFP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                                hv_NumFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                                hv_NumFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                                hv_NumFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                                hv_NumFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                                hv_NumFPMultiple);
                                            //
                                            //Set detection confusion matrix values.
                                            hv_DetectionConfusionMatrix.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                                out hv_DetectionConfusionMatrix);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_ClsIdx, hv_NumTP);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses,
                                                hv_ClsIdx, hv_NumFN);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses, hv_NumFPBackground);
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 1, hv_NumFPLocalization);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 2, hv_NumFPDuplicate);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 3, hv_NumFPMultiple);
                                            }
                                            //
                                            //Go over IsFPClass and set confusions in matrix.
                                            hv_IndicesWithClassConfusion.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                                            }
                                            hv_IsFPClassIdxs.Dispose();
                                            hv_IsFPClassIdxs = new HTuple();
                                            if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                                                -1))) != 0)
                                            {
                                                hv_IsFPClassIdxs.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                                                        hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                                                }
                                            }
                                            hv_ClassIdxsConfused.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                                                    )).TupleUniq();
                                            }
                                            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                                                )) - 1); hv_Idx = (int)hv_Idx + 1)
                                            {
                                                hv_NumConfusedThisIdx.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                                                        -1))).TupleSum();
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                                                }
                                            }
                                            //
                                            //Update overall measures.
                                            if (hv_PerIoUFN == null)
                                                hv_PerIoUFN = new HTuple();
                                            hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx)) + hv_NumFN;
                                            if (hv_PerIoUTP == null)
                                                hv_PerIoUTP = new HTuple();
                                            hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx)) + hv_NumTP;
                                            if (hv_PerIoUFP == null)
                                                hv_PerIoUFP = new HTuple();
                                            hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx)) + hv_NumFP;
                                            if (hv_PerIoUFPClass == null)
                                                hv_PerIoUFPClass = new HTuple();
                                            hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx)) + hv_NumFPClass;
                                            if (hv_PerIoUFPBackground == null)
                                                hv_PerIoUFPBackground = new HTuple();
                                            hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPBackground;
                                            if (hv_PerIoUFPLocalization == null)
                                                hv_PerIoUFPLocalization = new HTuple();
                                            hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPLocalization;
                                            if (hv_PerIoUFPDuplicate == null)
                                                hv_PerIoUFPDuplicate = new HTuple();
                                            hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPDuplicate;
                                            if (hv_PerIoUFPMultiple == null)
                                                hv_PerIoUFPMultiple = new HTuple();
                                            hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPMultiple;
                                            if ((int)(hv_CalcSoAP) != 0)
                                            {
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AODClass);
                                                hv_IdxsClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsClass = ((hv_AODClass.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsClass.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPClass.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPClass = 1.0 - ((((hv_AODClass.TupleSelect(
                                                            hv_IdxsClass))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_class", hv_ResSoAPClass);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPClass == null)
                                                        hv_PerIoUNumClassesWithFPClass = new HTuple();
                                                    hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = (hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx))).TupleEqual(
                                                        -1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPClass;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for localization false positives.
                                                hv_AODLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AODLocalization);
                                                hv_IdxsLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsLocalization = ((hv_AODLocalization.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsLocalization.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPLocalization.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPLocalization = 1.0 - ((((hv_AODLocalization.TupleSelect(
                                                            hv_IdxsLocalization))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_localization", hv_ResSoAPLocalization);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPLocalization == null)
                                                        hv_PerIoUNumClassesWithFPLocalization = new HTuple();
                                                    hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPLocalization.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPLocalization;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AODDuplicate);
                                                hv_IdxsDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsDuplicate = ((hv_AODDuplicate.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsDuplicate.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPDuplicate.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPDuplicate = 1.0 - ((((hv_AODDuplicate.TupleSelect(
                                                            hv_IdxsDuplicate))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_duplicate", hv_ResSoAPDuplicate);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPDuplicate == null)
                                                        hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
                                                    hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPDuplicate;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for multiple false positives.
                                                hv_AODMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AODMultiple);
                                                hv_IdxsMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsMultiple = ((hv_AODMultiple.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsMultiple.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPMultiple.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPMultiple = 1.0 - ((((hv_AODMultiple.TupleSelect(
                                                            hv_IdxsMultiple))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_multiple", hv_ResSoAPMultiple);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPMultiple == null)
                                                        hv_PerIoUNumClassesWithFPMultiple = new HTuple();
                                                    hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPMultiple.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPMultiple;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //
                                    //Write to output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUSoAP.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_ClassSoAPPerIoU.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                                //
                                //Class mAP is the mean over IoU-thresholds.
                                if (hv_PerClassMAP == null)
                                    hv_PerClassMAP = new HTuple();
                                hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
                                hv_ClassMAPDict.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                    out hv_ClassMAPDict);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    //ClassMSoAP is the mean over IoU-thresholds.
                                    hv_SoAPIoUIdxsPositive.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SoAPIoUIdxsPositive = ((hv_ClassSoAPPerIoU.TupleGreaterEqualElem(
                                            0.0))).TupleFind(1);
                                    }
                                    if ((int)(new HTuple(hv_SoAPIoUIdxsPositive.TupleNotEqual(-1))) != 0)
                                    {
                                        if (hv_PerClassMSoAP == null)
                                            hv_PerClassMSoAP = new HTuple();
                                        hv_PerClassMSoAP[hv_ClsIdx] = ((hv_ClassSoAPPerIoU.TupleSelect(
                                            hv_SoAPIoUIdxsPositive))).TupleMean();
                                    }
                                    else
                                    {
                                        if (hv_PerClassMSoAP == null)
                                            hv_PerClassMSoAP = new HTuple();
                                        hv_PerClassMSoAP[hv_ClsIdx] = -1.0;
                                    }
                                    hv_ClassMSoAPDict.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                        out hv_ClassMSoAPDict);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassMSoAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_PerClassMSoAP.TupleSelect(hv_ClsIdx));
                                    }
                                }
                            }
                            //
                            //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                }
                                //
                                //Consider only present classes.
                                hv_MeanClassAP.Dispose();
                                hv_MeanClassAP = -1.0;
                                if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_MeanClassAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                                            hv_ITIdx)) / (new HTuple(hv_ClassesWithGt.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                    }
                                    //
                                    //Consider only present classes.
                                    hv_MeanClassSoAP.Dispose();
                                    hv_MeanClassSoAP = -1.0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx))).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_MeanClassSoAP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MeanClassSoAP = (hv_PerIoUMSoAP.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
                                }
                                //
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Add overall measures for TP, FN, FP, ...
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUDetailedEvaluation.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp",
                                            hv_PerIoUTP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn",
                                            hv_PerIoUFN.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp",
                                            hv_PerIoUFP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class",
                                            hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background",
                                            hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate",
                                            hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization",
                                            hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple",
                                            hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPClass == null)
                                                hv_PerIoUSoAPClass = new HTuple();
                                            hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPLocalization == null)
                                                hv_PerIoUSoAPLocalization = new HTuple();
                                            hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPDuplicate == null)
                                                hv_PerIoUSoAPDuplicate = new HTuple();
                                            hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPMultiple == null)
                                                hv_PerIoUSoAPMultiple = new HTuple();
                                            hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class",
                                                hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization",
                                                hv_PerIoUSoAPLocalization.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate",
                                                hv_PerIoUSoAPDuplicate.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple",
                                                hv_PerIoUSoAPMultiple.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                            }
                            //
                            //Calculate overall mean AP (over classes and IoU-thresholds).
                            //Also here only classes with ground truth annotations are taken into account.
                            hv_MAP.Dispose();
                            hv_MAP = -1.0;
                            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_MAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MAP = (((hv_PerClassMAP.TupleSelect(
                                        hv_ClassesWithGt))).TupleSum()) / (new HTuple(hv_ClassesWithGt.TupleLength()
                                        ));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_MSoAP.Dispose();
                                hv_MSoAP = -1.0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    hv_MSoAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MSoAP = ((((hv_PerIoUMSoAP.TupleSelect(
                                            hv_IoUsWithTP)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_IoUsWithTP)))).TupleSum()
                                            ) / (new HTuple(hv_IoUsWithTP.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp",
                                    hv_MSoAP);
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    hv_MSoAPAll.Dispose();
                                    hv_MSoAPAll = 0.0;
                                    hv_NumSoAPAll.Dispose();
                                    hv_NumSoAPAll = 0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        hv_MSoAPAll.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MSoAPAll = hv_MSoAP * (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_IoUsWithTP))).TupleSum());
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_IoUsWithTP))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPClass = ((hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum()) / (new HTuple(hv_IoUsWithFPClass.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_IoUsWithFPClass))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPLocalization = ((hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum()) / (new HTuple(hv_IoUsWithFPLocalization.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(hv_IoUsWithFPLocalization))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPDuplicate = ((hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum()) / (new HTuple(hv_IoUsWithFPDuplicate.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(hv_IoUsWithFPDuplicate))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPMultiple = ((hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum()) / (new HTuple(hv_IoUsWithFPMultiple.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(hv_IoUsWithFPMultiple))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(hv_NumSoAPAll.TupleGreater(0))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                                (hv_MSoAPAll.TupleReal()) / hv_NumSoAPAll);
                                        }
                                    }
                                    else
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                            -1);
                                    }
                                    //
                                }
                            }
                            //
                            //Add CurrentEvaluationResult to output.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_" + hv_AreaName,
                                    hv_CurrentEvaluationResult);
                            }
                        }
                        //Add PerMaxNumEvaluationResult to output.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumStr,
                                hv_PerMaxNumEvaluationResult);
                        }
                    }
                }
                //

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_EvalType.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_SoAPIoUIdxsPositive.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_EvalType.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_SoAPIoUIdxsPositive.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Computes the ocr_detection relevant evaluation measures. 
        private void calculate_ocr_detection_measures(HTuple hv_DetectionEvaluationResult,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Keys = new HTuple(), hv_Matches = new HTuple();
            HTuple hv_Key = new HTuple(), hv_WordEval = new HTuple();
            HTuple hv_NumAll = new HTuple(), hv_NumTPFP = new HTuple();
            HTuple hv_Divisor = new HTuple(), hv___Tmp_Ctrl_Type = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(((hv_DetectionEvaluationResult.TupleGetDictTuple(
                        "max_num_detections_all"))).TupleGetDictTuple("area_all"), "keys", new HTuple(),
                        out hv_Keys);
                }
                //Use the first matching key in order to compute the measures.
                hv_Matches.Dispose();
                HOperatorSet.TupleRegexpSelect(hv_Keys, "detailed_evaluation_iou_.*", out hv_Matches);
                hv_Key.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Key = hv_Matches.TupleSelect(
                        0);
                }
                hv_WordEval.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WordEval = ((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                        "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                        hv_Key))).TupleGetDictTuple("class_0");
                }
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                //Recall
                hv_NumAll.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAll = (hv_WordEval.TupleGetDictTuple(
                        "num_tp")) + (hv_WordEval.TupleGetDictTuple("num_fn"));
                }
                if ((int)(new HTuple(hv_NumAll.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "recall", (hv_WordEval.TupleGetDictTuple(
                            "num_tp")) / (hv_NumAll.TupleReal()));
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "recall", 0.0);
                }
                //Precision
                hv_NumTPFP.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumTPFP = (hv_WordEval.TupleGetDictTuple(
                        "num_tp")) + (hv_WordEval.TupleGetDictTuple("num_fp"));
                }
                if ((int)(new HTuple(hv_NumTPFP.TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "precision", (hv_WordEval.TupleGetDictTuple(
                            "num_tp")) / (hv_NumTPFP.TupleReal()));
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "precision", 0.0);
                }
                //F-Score
                hv_Divisor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Divisor = (hv_EvaluationResult.TupleGetDictTuple(
                        "precision")) + (hv_EvaluationResult.TupleGetDictTuple("recall"));
                }
                if ((int)(new HTuple(hv_Divisor.TupleNotEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "f_score", ((2 * (hv_EvaluationResult.TupleGetDictTuple(
                            "precision"))) * (hv_EvaluationResult.TupleGetDictTuple("recall"))) / hv_Divisor);
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "f_score", 0.0);
                }
                //SoAP
                hv_Matches.Dispose();
                HOperatorSet.TupleRegexpSelect(hv_Keys, "soap_tp_iou_.*", out hv_Matches);
                if ((int)(new HTuple((new HTuple(hv_Matches.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_Key.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Key = hv_Matches.TupleSelect(
                            0);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                            "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                            hv_Key), "key_data_type", "class_0", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                                "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                                hv_Key))).TupleGetDictObject("class_0"), hv_EvaluationResult, "soap");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "soap", ((((((hv_DetectionEvaluationResult.TupleGetDictTuple(
                                "max_num_detections_all"))).TupleGetDictTuple("area_all"))).TupleGetDictTuple(
                                hv_Key))).TupleGetDictTuple("class_0"));
                        }
                    }
                }

                hv_Keys.Dispose();
                hv_Matches.Dispose();
                hv_Key.Dispose();
                hv_WordEval.Dispose();
                hv_NumAll.Dispose();
                hv_NumTPFP.Dispose();
                hv_Divisor.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Keys.Dispose();
                hv_Matches.Dispose();
                hv_Key.Dispose();
                hv_WordEval.Dispose();
                hv_NumAll.Dispose();
                hv_NumTPFP.Dispose();
                hv_Divisor.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Calculate OCR recognition measures based on RunningMeasures. 
        private void calculate_ocr_recognition_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Equal = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing OCR recognition measures based on the running measures.
                //
                //
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                //
                //Compute Accuracy
                hv_Equal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Equal = ((hv_RunningMeasures.TupleGetDictTuple(
                        "words_ground_truth"))).TupleEqualElem(hv_RunningMeasures.TupleGetDictTuple(
                        "words_prediction"));
                }
                if ((int)(new HTuple((new HTuple(hv_Equal.TupleLength())).TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", ((hv_Equal.TupleSum()
                            ) / ((new HTuple(hv_Equal.TupleLength())).TupleReal())) * 100);
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "accuracy", 0);
                }

                hv_Equal.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Equal.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Calculate pixel measures based on RunningMeasures. 
        private void calculate_pixel_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassPixelAccuracy = new HTuple();
            HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
            HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanPrecision = new HTuple();
            HTuple hv_CalcMeanIou = new HTuple(), hv_CalcClassIou = new HTuple();
            HTuple hv_CalcFWIou = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_EvaluationType = new HTuple(), hv_PixelMeasures = new HTuple();
            HTuple hv_M = new HTuple(), hv_ConfMatrix = new HTuple();
            HTuple hv_TPMat = new HTuple(), hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
            HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
            HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
            HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
            HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
            HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
            HTuple hv_PD = new HTuple(), hv_PDIdxValid = new HTuple();
            HTuple hv_ClassPixelPrecision = new HTuple(), hv_MeanPrecision = new HTuple();
            HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
            HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the pixel-wise measures based on the values in running measures.
                //
                //Set default values.
                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcClassPixelAccuracy = 0;
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy = 0;
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcPixelConfusionMatrix = 0;
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanAccuracy = 0;
                hv_CalcMeanPrecision.Dispose();
                hv_CalcMeanPrecision = 0;
                hv_CalcMeanIou.Dispose();
                hv_CalcMeanIou = 0;
                hv_CalcClassIou.Dispose();
                hv_CalcClassIou = 0;
                hv_CalcFWIou.Dispose();
                hv_CalcFWIou = 0;
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_PixelMeasures.Dispose();
                get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
                if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleEqual(
                    0))) != 0)
                {

                    hv_CalcClassPixelAccuracy.Dispose();
                    hv_CalcPixelAccuracy.Dispose();
                    hv_CalcPixelConfusionMatrix.Dispose();
                    hv_CalcMeanAccuracy.Dispose();
                    hv_CalcMeanPrecision.Dispose();
                    hv_CalcMeanIou.Dispose();
                    hv_CalcClassIou.Dispose();
                    hv_CalcFWIou.Dispose();
                    hv_Measures.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_PixelMeasures.Dispose();
                    hv_M.Dispose();
                    hv_ConfMatrix.Dispose();
                    hv_TPMat.Dispose();
                    hv_TP.Dispose();
                    hv_SumRowMat.Dispose();
                    hv_RowSum.Dispose();
                    hv_FP.Dispose();
                    hv_SumColMat.Dispose();
                    hv_ColSum.Dispose();
                    hv_FN.Dispose();
                    hv_IgnoreClassIDs.Dispose();
                    hv_Rows.Dispose();
                    hv_Columns.Dispose();
                    hv_FPIgnore.Dispose();
                    hv_GT.Dispose();
                    hv_ClsIdxValid.Dispose();
                    hv_ClassPixelAccuracy.Dispose();
                    hv_MeanAccuracy.Dispose();
                    hv_PixelAccuracy.Dispose();
                    hv_PD.Dispose();
                    hv_PDIdxValid.Dispose();
                    hv_ClassPixelPrecision.Dispose();
                    hv_MeanPrecision.Dispose();
                    hv_ClassIoU.Dispose();
                    hv_MeanIoU.Dispose();
                    hv_FWIoU.Dispose();
                    hv_FwWeights.Dispose();

                    return;
                }
                //
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_PixelMeasures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "class_pixel_accuracy"))) != 0)
                    {
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "pixel_confusion_matrix"))) != 0)
                    {
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "mean_accuracy"))) != 0)
                    {
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "mean_precision"))) != 0)
                    {
                        hv_CalcMeanPrecision.Dispose();
                        hv_CalcMeanPrecision = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "mean_iou"))) != 0)
                    {
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "class_iou"))) != 0)
                    {
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_PixelMeasures.TupleSelect(hv_M))).TupleEqual(
                        "frequency_weighted_iou"))) != 0)
                    {
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown pixel measure: " + (hv_PixelMeasures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
                //we first calculate TP/FP/FN from the ConfusionMatrix.
                if ((int)(hv_CalcPixelConfusionMatrix) != 0)
                {
                    //Get the running measures.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Get the per-class true positives as the diagonal of the matrix.
                    hv_TPMat.Dispose();
                    HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
                    hv_TP.Dispose();
                    HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
                    //For the confusion matrix, the row determines the predicted class-IDs,
                    //the column determines the ground truth class-IDs.
                    //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
                    hv_SumRowMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
                    hv_RowSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
                    hv_FP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FP = hv_RowSum - hv_TP;
                    }
                    //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
                    hv_SumColMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
                    hv_ColSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
                    hv_FN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FN = hv_ColSum - hv_TP;
                    }
                    //We do not want to count the false positives (FP) in the ignore region.
                    //The false negatives (FN) are not affected, since the model does not predict the ignore class.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //The ignore class corresponds to the last row/column in the confusion matrix.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPIgnore.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0, hv_Rows - 1, 1),
                                HTuple.TupleGenConst(hv_Rows, hv_Columns - 1), out hv_FPIgnore);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP - hv_FPIgnore;
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        //Remove last entries of TP, FP, FN (those related to the ignore class).
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
                                    0, (new HTuple(hv_TP.TupleLength())) - 2);
                                hv_TP.Dispose();
                                hv_TP = ExpTmpLocalVar_TP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
                                    0, (new HTuple(hv_FP.TupleLength())) - 2);
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
                                    0, (new HTuple(hv_FN.TupleLength())) - 2);
                                hv_FN.Dispose();
                                hv_FN = ExpTmpLocalVar_FN;
                            }
                        }
                        //Remove last row/column from confusion matrix.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows - 1, hv_Columns - 1,
                                out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    //Paste the confusion matrix to the output.
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix",
                        hv_ConfMatrix);
                }
                else
                {
                    //Get the running measure values.
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //It might be the case, that some of the classes are not present in the set of validation images.
                //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
                hv_GT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GT = hv_TP + hv_FN;
                }
                hv_ClsIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
                        0))).TupleFind(1);
                }
                //
                //Mean Accuracy, Class Pixel Accuracy.
                //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
                //   as they have to be calculated anyway (to the most part).
                if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
                {
                    //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
                    hv_ClassPixelAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPixelAccuracy = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanAccuracy.Dispose();
                    hv_MeanAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPixelAccuracy == null)
                            hv_ClassPixelAccuracy = new HTuple();
                        hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / (hv_GT.TupleSelect(hv_ClsIdxValid));
                        hv_MeanAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
                }
                //Pixel Accuracy.
                if ((int)(hv_CalcPixelAccuracy) != 0)
                {
                    //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
                    hv_PixelAccuracy.Dispose();
                    hv_PixelAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        hv_PixelAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PixelAccuracy = (((((hv_TP.TupleSelect(
                                hv_ClsIdxValid))).TupleSum())).TupleReal()) / (((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
                                );
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
                }
                //Mean Precision.
                //-> Also includes precisions for each of the classes which are
                //   used to calculate the mean precision.
                if ((int)(hv_CalcMeanPrecision) != 0)
                {
                    //Compute pixel-level precision averaged over all classes.
                    hv_PD.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PD = hv_TP + hv_FP;
                    }
                    hv_PDIdxValid.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PDIdxValid = ((hv_PD.TupleGreaterElem(
                            0.0))).TupleFind(1);
                    }
                    hv_ClassPixelPrecision.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPixelPrecision = HTuple.TupleGenConst(
                            new HTuple(hv_PD.TupleLength()), -1);
                    }
                    hv_MeanPrecision.Dispose();
                    hv_MeanPrecision = -1;
                    if ((int)(new HTuple(((hv_PDIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPixelPrecision == null)
                            hv_ClassPixelPrecision = new HTuple();
                        hv_ClassPixelPrecision[hv_PDIdxValid] = (((hv_TP.TupleSelect(hv_PDIdxValid))).TupleReal()
                            ) / (hv_PD.TupleSelect(hv_PDIdxValid));
                        hv_MeanPrecision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanPrecision = ((hv_ClassPixelPrecision.TupleSelect(
                                hv_PDIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_precision", hv_MeanPrecision);
                }
                //Mean IoU, class IoU, frequency weighted IoU:
                //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
                //   we return all three of them as they have to be calculated anyway (to the most part).
                if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
                {
                    hv_ClassIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIoU = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanIoU.Dispose();
                    hv_MeanIoU = -1;
                    hv_FWIoU.Dispose();
                    hv_FWIoU = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassIoU == null)
                            hv_ClassIoU = new HTuple();
                        hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / ((hv_GT.TupleSelect(hv_ClsIdxValid)) + (hv_FP.TupleSelect(hv_ClsIdxValid)));
                        hv_MeanIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                        hv_FwWeights.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FwWeights = (hv_GT.TupleReal()
                                ) / (hv_GT.TupleSum());
                        }
                        hv_FWIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FWIoU = (((hv_FwWeights.TupleSelect(
                                hv_ClsIdxValid)) * (hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
                                ;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou",
                        hv_FWIoU);
                }
                //

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanPrecision.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_EvaluationType.Dispose();
                hv_PixelMeasures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_PD.Dispose();
                hv_PDIdxValid.Dispose();
                hv_ClassPixelPrecision.Dispose();
                hv_MeanPrecision.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanPrecision.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_EvaluationType.Dispose();
                hv_PixelMeasures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_PD.Dispose();
                hv_PDIdxValid.Dispose();
                hv_ClassPixelPrecision.Dispose();
                hv_MeanPrecision.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Calculate region measures based on running measure values. 
        private void calculate_region_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcMeanPRO = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_M = new HTuple(), hv_ClsIdxValid = new HTuple();
            HTuple hv_ClassPRO = new HTuple(), hv_MeanPRO = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the region measures based on the
                //values in running measures.
                //
                //Set default values.
                hv_CalcMeanPRO.Dispose();
                hv_CalcMeanPRO = 0;
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_pro"))) != 0)
                    {
                        hv_CalcMeanPRO.Dispose();
                        hv_CalcMeanPRO = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcMeanPRO.Dispose();
                        hv_CalcMeanPRO = 1;
                    }
                }
                //
                if ((int)(hv_CalcMeanPRO) != 0)
                {
                    //It might be the case, that some of the classes are not present
                    //in the set of evaluation images and are excluded.
                    hv_ClsIdxValid.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClsIdxValid = ((((hv_RunningMeasures.TupleGetDictTuple(
                            "num_gt_regions"))).TupleGreaterElem(0))).TupleFind(1);
                    }
                    //
                    //Compute per-region-overlap averaged over the valid classes.
                    hv_ClassPRO.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPRO = HTuple.TupleGenConst(
                            new HTuple(((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleLength()
                            ), -1);
                    }
                    hv_MeanPRO.Dispose();
                    hv_MeanPRO = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPRO == null)
                            hv_ClassPRO = new HTuple();
                        hv_ClassPRO[hv_ClsIdxValid] = (((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))).TupleSelect(
                            hv_ClsIdxValid)) / (((((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleSelect(
                            hv_ClsIdxValid))).TupleReal());
                        hv_MeanPRO.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanPRO = ((hv_ClassPRO.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_pro", hv_MeanPRO);
                }
                //

                hv_CalcMeanPRO.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPRO.Dispose();
                hv_MeanPRO.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcMeanPRO.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPRO.Dispose();
                hv_MeanPRO.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Calculate 3D gripping point measures based on RunningMeasures. 
        private void calculate_running_gripping_point_measures(HTuple hv_RunningMeasures,
            HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Positives = new HTuple(), hv_GT = new HTuple();
            HTuple hv_Precision = new HTuple(), hv_Recall = new HTuple();
            HTuple hv_SumPrecisionRecall = new HTuple(), hv_FScore = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                    "measures"))).TupleRegexpSelect("gripping_point_.*|all"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    hv_Positives.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Positives = (hv_RunningMeasures.TupleGetDictTuple(
                            "gp_tp")) + (hv_RunningMeasures.TupleGetDictTuple("gp_fp"));
                    }
                    hv_GT.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GT = (hv_RunningMeasures.TupleGetDictTuple(
                            "gp_tp")) + (hv_RunningMeasures.TupleGetDictTuple("gp_fn"));
                    }
                    if ((int)(new HTuple(hv_Positives.TupleGreater(0.0))) != 0)
                    {
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = (hv_RunningMeasures.TupleGetDictTuple(
                                "gp_tp")) / hv_Positives;
                        }
                    }
                    else
                    {
                        hv_Precision.Dispose();
                        hv_Precision = 0.0;
                    }
                    if ((int)(new HTuple(hv_GT.TupleGreater(0.0))) != 0)
                    {
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = (hv_RunningMeasures.TupleGetDictTuple(
                                "gp_tp")) / hv_GT;
                        }
                    }
                    else
                    {
                        hv_Recall.Dispose();
                        hv_Recall = 0.0;
                    }
                    hv_SumPrecisionRecall.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SumPrecisionRecall = hv_Precision + hv_Recall;
                    }
                    if ((int)(new HTuple(hv_SumPrecisionRecall.TupleGreater(0.0))) != 0)
                    {
                        hv_FScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FScore = ((2 * hv_Precision) * hv_Recall) / hv_SumPrecisionRecall;
                        }
                    }
                    else
                    {
                        hv_FScore.Dispose();
                        hv_FScore = 0.0;
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                        "measures"))).TupleRegexpSelect("gripping_point_precision|all"))).TupleLength()
                        )).TupleGreater(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_precision",
                            hv_Precision);
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                        "measures"))).TupleRegexpSelect("gripping_point_recall|all"))).TupleLength()
                        )).TupleGreater(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_recall",
                            hv_Recall);
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                        "measures"))).TupleRegexpSelect("gripping_point_f_score|all"))).TupleLength()
                        )).TupleGreater(0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvaluationResult, "gripping_point_f_score",
                            hv_FScore);
                    }
                }

                hv_Positives.Dispose();
                hv_GT.Dispose();
                hv_Precision.Dispose();
                hv_Recall.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_FScore.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Positives.Dispose();
                hv_GT.Dispose();
                hv_Precision.Dispose();
                hv_Recall.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_FScore.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Check and sanitize the parameters of augment_dl_samples. 
        private void check_augment_dl_samples_gen_param(HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GenKeys = new HTuple(), hv_ValidAugMethods = new HTuple();
            HTuple hv_ValidOtherKeys = new HTuple(), hv_ValidKeys = new HTuple();
            HTuple hv_InvalidKeys = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_GenKey = new HTuple();
            HTuple hv_GenValue = new HTuple(), hv_NumValues = new HTuple();
            HTuple hv_V = new HTuple(), hv_Value = new HTuple(), hv_SanitizedValue = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure validates and sanitizes the GenParam parameter of the
                //augment_dl_samples procedure.
                //
                //This procedure should not be used outside of the augment_dl_samples procedure!
                //The name, parameters, and functionality of this procedure are subject to change.
                //
                //Check that there are no unknown parameters.
                hv_GenKeys.Dispose();
                HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenKeys);
                hv_ValidAugMethods.Dispose();
                hv_ValidAugMethods = new HTuple();
                hv_ValidAugMethods[0] = "brightness_variation";
                hv_ValidAugMethods[1] = "brightness_variation_spot";
                hv_ValidAugMethods[2] = "contrast_variation";
                hv_ValidAugMethods[3] = "crop_percentage";
                hv_ValidAugMethods[4] = "crop_pixel";
                hv_ValidAugMethods[5] = "mirror";
                hv_ValidAugMethods[6] = "remove_pixel";
                hv_ValidAugMethods[7] = "rotate";
                hv_ValidAugMethods[8] = "rotate_range";
                hv_ValidAugMethods[9] = "saturation_variation";
                hv_ValidOtherKeys.Dispose();
                hv_ValidOtherKeys = new HTuple();
                hv_ValidOtherKeys[0] = "augmentation_percentage";
                hv_ValidOtherKeys[1] = "class_ids_no_orientation";
                hv_ValidOtherKeys[2] = "ignore_direction";
                hv_ValidKeys.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidKeys = new HTuple();
                    hv_ValidKeys = hv_ValidKeys.TupleConcat(hv_ValidAugMethods, hv_ValidOtherKeys);
                }
                hv_InvalidKeys.Dispose();
                HOperatorSet.TupleDifference(hv_GenKeys, hv_ValidKeys, out hv_InvalidKeys);
                if ((int)(new HTuple((new HTuple(hv_InvalidKeys.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "These keys in GenParam are not supported by augment_dl_samples: '" + (hv_InvalidKeys.TupleJoin(
                            new HTuple("', '") + "'"));
                    }
                    throw new HalconException(hv_Exception);
                }
                //
                //Check each parameter.
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_GenKeys.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    //Get the key and value, for example 'rotate_range' and 3.
                    hv_GenKey.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GenKey = hv_GenKeys.TupleSelect(
                            hv_KeyIndex);
                    }
                    hv_GenValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GenValue = hv_GenParam.TupleGetDictTuple(
                            hv_GenKey);
                    }
                    //Perform validation
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("augmentation_percentage"))) != 0)
                    {
                        //Check if input value is in range of 0-100 %.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'augmentation_percentage' has to be in the range 0-100.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)((new HTuple(hv_GenValue.TupleLess(0))).TupleOr(new HTuple(hv_GenValue.TupleGreater(
                                100)))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("brightness_variation"))) != 0)
                    {
                        //Check if the input value is in range of 0-255.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'brightness_variation' has to be in the range 0-255.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)((new HTuple(hv_GenValue.TupleLess(0))).TupleOr(new HTuple(hv_GenValue.TupleGreater(
                                255)))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("brightness_variation_spot"))) != 0)
                    {
                        //Check if the input value is in range of 0-255.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'brightness_variation_spot' has to be in the range 0-255.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)((new HTuple(hv_GenValue.TupleLess(0))).TupleOr(new HTuple(hv_GenValue.TupleGreater(
                                255)))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("contrast_variation"))) != 0)
                    {
                        //Check if the input value is not negative.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'contrast_variation' has to be greater than or equal to zero.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)(new HTuple(hv_GenValue.TupleLess(0))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("crop_percentage"))) != 0)
                    {
                        //Check if the input value is in range of 1-100%.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'crop_percentage' has to be in the range 1-100.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)((new HTuple(hv_GenValue.TupleLess(1))).TupleOr(new HTuple(hv_GenValue.TupleGreater(
                                100)))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("crop_pixel"))) != 0)
                    {
                        //Check if the input value is greater 0.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'crop_pixel' has to be greater or equal to 1.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)(new HTuple(hv_GenValue.TupleLess(1))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("ignore_direction"))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = new HTuple("The value given for 'ignore_direction' has to be either 'true','false', true or false.");
                        if ((int)(new HTuple((new HTuple(((((new HTuple("true")).TupleConcat("false")).TupleConcat(
                            1)).TupleConcat(0)).TupleFind(hv_GenValue))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                        //Sanitize string values to Booleans.
                        if ((int)(new HTuple(hv_GenValue.TupleEqual("false"))) != 0)
                        {
                            hv_GenValue.Dispose();
                            hv_GenValue = 0;
                        }
                        else if ((int)(new HTuple(hv_GenValue.TupleEqual("true"))) != 0)
                        {
                            hv_GenValue.Dispose();
                            hv_GenValue = 1;
                        }
                        //Overwrite the value in GenParam.
                        HOperatorSet.SetDictTuple(hv_GenParam, hv_GenKey, hv_GenValue);
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("mirror"))) != 0)
                    {
                        //Check if the input is a string and contains either 'off' or the mirroring code.
                        if ((int)(((hv_GenValue.TupleIsNumber())).TupleOr((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_GenValue.TupleEqual(
                            "off"))).TupleOr(new HTuple(hv_GenValue.TupleEqual("c"))))).TupleOr(
                            new HTuple(hv_GenValue.TupleEqual("r"))))).TupleOr(new HTuple(hv_GenValue.TupleEqual(
                            "cr"))))).TupleOr(new HTuple(hv_GenValue.TupleEqual("rc"))))).TupleNot()
                            )) != 0)
                        {
                            throw new HalconException("Unknown type for mirroring.");
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("remove_pixel"))) != 0)
                    {
                        //Set pixels to remove.
                        //Check if the input values are valid. Valid are either 1d-tuples with
                        //the pixels to remove for both dimensions, or 2d-tuples with the pixels
                        //to remove for each dimension [x,y].
                        hv_NumValues.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumValues = new HTuple(hv_GenValue.TupleLength()
                                );
                        }
                        if ((int)((new HTuple(hv_NumValues.TupleNotEqual(1))).TupleAnd(new HTuple(hv_NumValues.TupleNotEqual(
                            2)))) != 0)
                        {
                            throw new HalconException("The number of values for 'remove_pixel' has to be 1 or 2.");
                        }
                        HTuple end_val118 = hv_NumValues - 1;
                        HTuple step_val118 = 1;
                        for (hv_V = 0; hv_V.Continue(end_val118, step_val118); hv_V = hv_V.TupleAdd(step_val118))
                        {
                            hv_Value.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Value = hv_GenValue.TupleSelect(
                                    hv_V);
                            }
                            if ((int)(((hv_Value.TupleIsInt())).TupleNot()) != 0)
                            {
                                throw new HalconException("The given value for 'remove_pixel' has to be an integer value.");
                            }
                            if ((int)(new HTuple(hv_Value.TupleLess(0))) != 0)
                            {
                                throw new HalconException("The given value for 'remove_pixel' has to be equal or greater than 0.");
                            }
                        }
                        //Store the input values for each dimension [x,y].
                        hv_SanitizedValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SanitizedValue = hv_GenValue.TupleSelect(
                                0);
                        }
                        if ((int)(new HTuple(hv_NumValues.TupleEqual(1))) != 0)
                        {
                            if (hv_SanitizedValue == null)
                                hv_SanitizedValue = new HTuple();
                            hv_SanitizedValue[1] = hv_GenValue.TupleSelect(0);
                        }
                        else
                        {
                            if (hv_SanitizedValue == null)
                                hv_SanitizedValue = new HTuple();
                            hv_SanitizedValue[1] = hv_GenValue.TupleSelect(1);
                        }
                        //Overwrite the value in GenParam.
                        HOperatorSet.SetDictTuple(hv_GenParam, hv_GenKey, hv_SanitizedValue);
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("rotate"))) != 0)
                    {
                        //Check if the input value is either 0, 90, or 180.
                        hv_Exception.Dispose();
                        hv_Exception = new HTuple("The value given for 'rotate' has to be either 0, 90, or 180.");
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)(new HTuple((new HTuple((((new HTuple(0)).TupleConcat(90)).TupleConcat(
                                180)).TupleFind(hv_GenValue))).TupleEqual(-1))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("rotate_range"))) != 0)
                    {
                        //Check if the input value is in range of 0-180.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'rotate_range' has to be in the range 0-180.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)((new HTuple(hv_GenValue.TupleLess(0))).TupleOr(new HTuple(hv_GenValue.TupleGreater(
                                180)))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    if ((int)(new HTuple(hv_GenKey.TupleEqual("saturation_variation"))) != 0)
                    {
                        //Check if the input value is not negative.
                        hv_Exception.Dispose();
                        hv_Exception = "The given value for 'saturation_variation' has to be greater than or equal to zero.";
                        if ((int)(hv_GenValue.TupleIsNumber()) != 0)
                        {
                            if ((int)(new HTuple(hv_GenValue.TupleLess(0))) != 0)
                            {
                                throw new HalconException(hv_Exception);
                            }
                        }
                        else
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                }

                hv_GenKeys.Dispose();
                hv_ValidAugMethods.Dispose();
                hv_ValidOtherKeys.Dispose();
                hv_ValidKeys.Dispose();
                hv_InvalidKeys.Dispose();
                hv_Exception.Dispose();
                hv_KeyIndex.Dispose();
                hv_GenKey.Dispose();
                hv_GenValue.Dispose();
                hv_NumValues.Dispose();
                hv_V.Dispose();
                hv_Value.Dispose();
                hv_SanitizedValue.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenKeys.Dispose();
                hv_ValidAugMethods.Dispose();
                hv_ValidOtherKeys.Dispose();
                hv_ValidKeys.Dispose();
                hv_InvalidKeys.Dispose();
                hv_Exception.Dispose();
                hv_KeyIndex.Dispose();
                hv_GenKey.Dispose();
                hv_GenValue.Dispose();
                hv_NumValues.Dispose();
                hv_V.Dispose();
                hv_Value.Dispose();
                hv_SanitizedValue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Initialize and check parameter for the generation of 3D gripping points and poses. 
        public void check_dl_3d_gripping_points_and_poses_params(HTuple hv_DLGrippingPointParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_HasMinAreaSize = new HTuple(), hv_HasSortingDir = new HTuple();
            HTuple hv_SortingDirectionRaw = new HTuple(), hv_LenSortingDirectionRaw = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                hv_HasMinAreaSize.Dispose();
                HOperatorSet.GetDictParam(hv_DLGrippingPointParams, "key_exists", "min_area_size",
                    out hv_HasMinAreaSize);
                if ((int)(hv_HasMinAreaSize) != 0)
                {
                    if ((int)(new HTuple(((hv_DLGrippingPointParams.TupleGetDictTuple("min_area_size"))).TupleLessEqual(
                        0))) != 0)
                    {
                        throw new HalconException("DLGrippingPointParams.min_area_size has to be at least 1.");
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "min_area_size", 1);
                }
                //
                hv_HasSortingDir.Dispose();
                HOperatorSet.GetDictParam(hv_DLGrippingPointParams, "key_exists", "sorting_direction",
                    out hv_HasSortingDir);
                if ((int)(hv_HasSortingDir) != 0)
                {
                    if ((int)(new HTuple((new HTuple(((hv_DLGrippingPointParams.TupleGetDictTuple(
                        "sorting_direction"))).TupleLength())).TupleNotEqual(3))) != 0)
                    {
                        throw new HalconException("DLGrippingPointParams.sorting_direction has to be a 3D-vector.");
                    }
                    hv_SortingDirectionRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SortingDirectionRaw = hv_DLGrippingPointParams.TupleGetDictTuple(
                            "sorting_direction");
                    }
                    hv_LenSortingDirectionRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LenSortingDirectionRaw = ((((hv_SortingDirectionRaw * hv_SortingDirectionRaw)).TupleSum()
                            )).TupleSqrt();
                    }
                    if ((int)(new HTuple(hv_LenSortingDirectionRaw.TupleLess(1.0e-06))) != 0)
                    {
                        throw new HalconException("DLGrippingPointParams.sorting_direction must not be the zero-vector.");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "sorting_direction",
                            hv_SortingDirectionRaw / hv_LenSortingDirectionRaw);
                    }
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_DLGrippingPointParams, "sorting_direction",
                        ((new HTuple(0.0)).TupleConcat(0.0)).TupleConcat(0.1));
                }

                hv_HasMinAreaSize.Dispose();
                hv_HasSortingDir.Dispose();
                hv_SortingDirectionRaw.Dispose();
                hv_LenSortingDirectionRaw.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_HasMinAreaSize.Dispose();
                hv_HasSortingDir.Dispose();
                hv_SortingDirectionRaw.Dispose();
                hv_LenSortingDirectionRaw.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Check if scores of a Global Context Anomaly Detection model have been normalized 
        public void check_dl_gc_anomaly_scores_normalization(HTuple hv_DLModelHandle,
            HTuple hv_GenParam)
        {



            // Local iconic variables 

            HObject ho_Weights = null, ho_Bias = null;

            // Local control variables 

            HTuple hv_DLModelIsConverted = new HTuple();
            HTuple hv_Networks = new HTuple(), hv_HasLocalNetwork = new HTuple();
            HTuple hv_HasGlobalNetwork = new HTuple(), hv_NormalizationLayers = new HTuple();
            HTuple hv_Index = new HTuple(), hv_LayerName = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_WeightsValues = new HTuple(), hv_HasDefaultWeights = new HTuple();
            HTuple hv_BiasValues = new HTuple(), hv_HasDefaultBias = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Weights);
            HOperatorSet.GenEmptyObj(out ho_Bias);
            try
            {
                //This procedure checks if all gc anomaly scores have been normalized.
                //
                //Make sure GenParam is an empty tuple.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    throw new HalconException("The parameter GenParam must be an empty tuple.");
                }
                //
                //For models using an AI accelerator interface for inference, the
                //weights of internal layers are no longer available. They are
                //removed to reduce the memory footprint of the model. Therefore
                //we have no means to check if the gc anomaly scores have been
                //normalized, and thus we assume that this is already the case.
                hv_DLModelIsConverted.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "precision_is_converted", out hv_DLModelIsConverted);
                if ((int)(new HTuple(hv_DLModelIsConverted.TupleEqual("true"))) != 0)
                {
                    ho_Weights.Dispose();
                    ho_Bias.Dispose();

                    hv_DLModelIsConverted.Dispose();
                    hv_Networks.Dispose();
                    hv_HasLocalNetwork.Dispose();
                    hv_HasGlobalNetwork.Dispose();
                    hv_NormalizationLayers.Dispose();
                    hv_Index.Dispose();
                    hv_LayerName.Dispose();
                    hv_Rows.Dispose();
                    hv_Columns.Dispose();
                    hv_WeightsValues.Dispose();
                    hv_HasDefaultWeights.Dispose();
                    hv_BiasValues.Dispose();
                    hv_HasDefaultBias.Dispose();

                    return;
                }
                //
                //Find networks to be normalized.
                hv_Networks.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", out hv_Networks);
                hv_HasLocalNetwork.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasLocalNetwork = new HTuple(((hv_Networks.TupleFind(
                        "local"))).TupleNotEqual(-1));
                }
                hv_HasGlobalNetwork.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasGlobalNetwork = new HTuple(((hv_Networks.TupleFind(
                        "global"))).TupleNotEqual(-1));
                }
                hv_NormalizationLayers.Dispose();
                hv_NormalizationLayers = new HTuple();
                if ((int)(hv_HasLocalNetwork) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                                "local_normalization");
                            hv_NormalizationLayers.Dispose();
                            hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                        }
                    }
                }
                if ((int)(hv_HasGlobalNetwork) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                                "global_normalization");
                            hv_NormalizationLayers.Dispose();
                            hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                        }
                    }
                }
                //
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NormalizationLayers.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_LayerName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LayerName = hv_NormalizationLayers.TupleSelect(
                            hv_Index);
                    }
                    ho_Weights.Dispose();
                    HOperatorSet.GetDlModelLayerWeights(out ho_Weights, hv_DLModelHandle, hv_LayerName,
                        "weights");
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetRegionPoints(ho_Weights, out hv_Rows, out hv_Columns);
                    hv_WeightsValues.Dispose();
                    HOperatorSet.GetGrayval(ho_Weights, hv_Rows, hv_Columns, out hv_WeightsValues);
                    //Calculate if weights are equal since some floating point arithmetic
                    //is involved in their creation.
                    hv_HasDefaultWeights.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HasDefaultWeights = new HTuple(((((((new HTuple(hv_WeightsValues.TupleLength()
                            )) * hv_WeightsValues) - HTuple.TupleGenConst(new HTuple(hv_WeightsValues.TupleLength()
                            ), 1.0))).TupleAbs())).TupleLess((new HTuple(hv_WeightsValues.TupleLength()
                            )) * 1e-6));
                    }
                    //
                    ho_Bias.Dispose();
                    HOperatorSet.GetDlModelLayerWeights(out ho_Bias, hv_DLModelHandle, hv_LayerName,
                        "bias");
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetRegionPoints(ho_Bias, out hv_Rows, out hv_Columns);
                    hv_BiasValues.Dispose();
                    HOperatorSet.GetGrayval(ho_Bias, hv_Rows, hv_Columns, out hv_BiasValues);
                    //The bias is set directly, hence an equality check is sufficient.
                    hv_HasDefaultBias.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HasDefaultBias = new HTuple(hv_BiasValues.TupleEqual(
                            HTuple.TupleGenConst(new HTuple(hv_BiasValues.TupleLength()), 0.0)));
                    }
                    //
                    if ((int)(hv_HasDefaultWeights.TupleAnd(hv_HasDefaultBias)) != 0)
                    {
                        throw new HalconException(new HTuple("For a model of type gc_anomaly_detection, the anomaly scores must be normalized first."));
                    }
                }
                //
                ho_Weights.Dispose();
                ho_Bias.Dispose();

                hv_DLModelIsConverted.Dispose();
                hv_Networks.Dispose();
                hv_HasLocalNetwork.Dispose();
                hv_HasGlobalNetwork.Dispose();
                hv_NormalizationLayers.Dispose();
                hv_Index.Dispose();
                hv_LayerName.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_WeightsValues.Dispose();
                hv_HasDefaultWeights.Dispose();
                hv_BiasValues.Dispose();
                hv_HasDefaultBias.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Weights.Dispose();
                ho_Bias.Dispose();

                hv_DLModelIsConverted.Dispose();
                hv_Networks.Dispose();
                hv_HasLocalNetwork.Dispose();
                hv_HasGlobalNetwork.Dispose();
                hv_NormalizationLayers.Dispose();
                hv_Index.Dispose();
                hv_LayerName.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_WeightsValues.Dispose();
                hv_HasDefaultWeights.Dispose();
                hv_BiasValues.Dispose();
                hv_HasDefaultBias.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Check the content of the parameter dictionary DLPreprocessParam. 
        private void check_dl_preprocess_param(HTuple hv_DLPreprocessParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CheckParams = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_DLModelType = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_SupportedModelTypes = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ParamNamesGeneral = new HTuple(), hv_ParamNamesSegmentation = new HTuple();
            HTuple hv_ParamNamesDetectionOptional = new HTuple(), hv_ParamNamesPreprocessingOptional = new HTuple();
            HTuple hv_ParamNames3DGrippingPointsOptional = new HTuple();
            HTuple hv_ParamNamesAll = new HTuple(), hv_ParamNames = new HTuple();
            HTuple hv_KeysExists = new HTuple(), hv_I = new HTuple();
            HTuple hv_Exists = new HTuple(), hv_InputKeys = new HTuple();
            HTuple hv_Key = new HTuple(), hv_Value = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_ValidValues = new HTuple();
            HTuple hv_ValidTypes = new HTuple(), hv_V = new HTuple();
            HTuple hv_T = new HTuple(), hv_IsInt = new HTuple(), hv_ValidTypesListing = new HTuple();
            HTuple hv_ValidValueListing = new HTuple(), hv_EmptyStrings = new HTuple();
            HTuple hv_ImageRangeMinExists = new HTuple(), hv_ImageRangeMaxExists = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_IndexParam = new HTuple(), hv_SetBackgroundID = new HTuple();
            HTuple hv_ClassIDsBackground = new HTuple(), hv_Intersection = new HTuple();
            HTuple hv_IgnoreClassIDs = new HTuple(), hv_KnownClasses = new HTuple();
            HTuple hv_IgnoreClassID = new HTuple(), hv_OptionalKeysExist = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_IsInstanceSegmentation = new HTuple();
            HTuple hv_IgnoreDirection = new HTuple(), hv_ClassIDsNoOrientation = new HTuple();
            HTuple hv_SemTypes = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure checks a dictionary with parameters for DL preprocessing.
                //
                hv_CheckParams.Dispose();
                hv_CheckParams = 1;
                //If check_params is set to false, do not check anything.
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "check_params",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_CheckParams.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "check_params", out hv_CheckParams);
                    if ((int)(hv_CheckParams.TupleNot()) != 0)
                    {

                        hv_CheckParams.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLModelType.Dispose();
                        hv_Exception.Dispose();
                        hv_SupportedModelTypes.Dispose();
                        hv_Index.Dispose();
                        hv_ParamNamesGeneral.Dispose();
                        hv_ParamNamesSegmentation.Dispose();
                        hv_ParamNamesDetectionOptional.Dispose();
                        hv_ParamNamesPreprocessingOptional.Dispose();
                        hv_ParamNames3DGrippingPointsOptional.Dispose();
                        hv_ParamNamesAll.Dispose();
                        hv_ParamNames.Dispose();
                        hv_KeysExists.Dispose();
                        hv_I.Dispose();
                        hv_Exists.Dispose();
                        hv_InputKeys.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_Indices.Dispose();
                        hv_ValidValues.Dispose();
                        hv_ValidTypes.Dispose();
                        hv_V.Dispose();
                        hv_T.Dispose();
                        hv_IsInt.Dispose();
                        hv_ValidTypesListing.Dispose();
                        hv_ValidValueListing.Dispose();
                        hv_EmptyStrings.Dispose();
                        hv_ImageRangeMinExists.Dispose();
                        hv_ImageRangeMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_IndexParam.Dispose();
                        hv_SetBackgroundID.Dispose();
                        hv_ClassIDsBackground.Dispose();
                        hv_Intersection.Dispose();
                        hv_IgnoreClassIDs.Dispose();
                        hv_KnownClasses.Dispose();
                        hv_IgnoreClassID.Dispose();
                        hv_OptionalKeysExist.Dispose();
                        hv_InstanceType.Dispose();
                        hv_IsInstanceSegmentation.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_ClassIDsNoOrientation.Dispose();
                        hv_SemTypes.Dispose();

                        return;
                    }
                }
                //
                try
                {
                    hv_DLModelType.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    throw new HalconException(new HTuple(new HTuple("DLPreprocessParam needs the parameter: '") + "model_type") + "'");
                }
                //
                //Check for correct model type.
                hv_SupportedModelTypes.Dispose();
                hv_SupportedModelTypes = new HTuple();
                hv_SupportedModelTypes[0] = "3d_gripping_point_detection";
                hv_SupportedModelTypes[1] = "anomaly_detection";
                hv_SupportedModelTypes[2] = "classification";
                hv_SupportedModelTypes[3] = "detection";
                hv_SupportedModelTypes[4] = "gc_anomaly_detection";
                hv_SupportedModelTypes[5] = "ocr_recognition";
                hv_SupportedModelTypes[6] = "ocr_detection";
                hv_SupportedModelTypes[7] = "segmentation";
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_SupportedModelTypes, hv_DLModelType, out hv_Index);
                if ((int)((new HTuple(hv_Index.TupleEqual(-1))).TupleOr(new HTuple(hv_Index.TupleEqual(
                    new HTuple())))) != 0)
                {
                    throw new HalconException(new HTuple("Only models of type '3d_gripping_point_detection', 'anomaly_detection', 'classification', 'detection', 'gc_anomaly_detection', 'ocr_recognition', 'ocr_detection' or 'segmentation' are supported"));

                    hv_CheckParams.Dispose();
                    hv_KeyExists.Dispose();
                    hv_DLModelType.Dispose();
                    hv_Exception.Dispose();
                    hv_SupportedModelTypes.Dispose();
                    hv_Index.Dispose();
                    hv_ParamNamesGeneral.Dispose();
                    hv_ParamNamesSegmentation.Dispose();
                    hv_ParamNamesDetectionOptional.Dispose();
                    hv_ParamNamesPreprocessingOptional.Dispose();
                    hv_ParamNames3DGrippingPointsOptional.Dispose();
                    hv_ParamNamesAll.Dispose();
                    hv_ParamNames.Dispose();
                    hv_KeysExists.Dispose();
                    hv_I.Dispose();
                    hv_Exists.Dispose();
                    hv_InputKeys.Dispose();
                    hv_Key.Dispose();
                    hv_Value.Dispose();
                    hv_Indices.Dispose();
                    hv_ValidValues.Dispose();
                    hv_ValidTypes.Dispose();
                    hv_V.Dispose();
                    hv_T.Dispose();
                    hv_IsInt.Dispose();
                    hv_ValidTypesListing.Dispose();
                    hv_ValidValueListing.Dispose();
                    hv_EmptyStrings.Dispose();
                    hv_ImageRangeMinExists.Dispose();
                    hv_ImageRangeMaxExists.Dispose();
                    hv_ImageRangeMin.Dispose();
                    hv_ImageRangeMax.Dispose();
                    hv_IndexParam.Dispose();
                    hv_SetBackgroundID.Dispose();
                    hv_ClassIDsBackground.Dispose();
                    hv_Intersection.Dispose();
                    hv_IgnoreClassIDs.Dispose();
                    hv_KnownClasses.Dispose();
                    hv_IgnoreClassID.Dispose();
                    hv_OptionalKeysExist.Dispose();
                    hv_InstanceType.Dispose();
                    hv_IsInstanceSegmentation.Dispose();
                    hv_IgnoreDirection.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_SemTypes.Dispose();

                    return;
                }
                //
                //Parameter names that are required.
                //General parameters.
                hv_ParamNamesGeneral.Dispose();
                hv_ParamNamesGeneral = new HTuple();
                hv_ParamNamesGeneral[0] = "model_type";
                hv_ParamNamesGeneral[1] = "image_width";
                hv_ParamNamesGeneral[2] = "image_height";
                hv_ParamNamesGeneral[3] = "image_num_channels";
                hv_ParamNamesGeneral[4] = "image_range_min";
                hv_ParamNamesGeneral[5] = "image_range_max";
                hv_ParamNamesGeneral[6] = "normalization_type";
                hv_ParamNamesGeneral[7] = "domain_handling";
                //Segmentation specific parameters.
                hv_ParamNamesSegmentation.Dispose();
                hv_ParamNamesSegmentation = new HTuple();
                hv_ParamNamesSegmentation[0] = "ignore_class_ids";
                hv_ParamNamesSegmentation[1] = "set_background_id";
                hv_ParamNamesSegmentation[2] = "class_ids_background";
                //Detection specific parameters.
                hv_ParamNamesDetectionOptional.Dispose();
                hv_ParamNamesDetectionOptional = new HTuple();
                hv_ParamNamesDetectionOptional[0] = "instance_type";
                hv_ParamNamesDetectionOptional[1] = "ignore_direction";
                hv_ParamNamesDetectionOptional[2] = "class_ids_no_orientation";
                hv_ParamNamesDetectionOptional[3] = "instance_segmentation";
                //Optional preprocessing parameters.
                hv_ParamNamesPreprocessingOptional.Dispose();
                hv_ParamNamesPreprocessingOptional = new HTuple();
                hv_ParamNamesPreprocessingOptional[0] = "mean_values_normalization";
                hv_ParamNamesPreprocessingOptional[1] = "deviation_values_normalization";
                hv_ParamNamesPreprocessingOptional[2] = "check_params";
                hv_ParamNamesPreprocessingOptional[3] = "augmentation";
                //3D Gripping Point Detection specific parameters.
                hv_ParamNames3DGrippingPointsOptional.Dispose();
                hv_ParamNames3DGrippingPointsOptional = new HTuple();
                hv_ParamNames3DGrippingPointsOptional[0] = "min_z";
                hv_ParamNames3DGrippingPointsOptional[1] = "max_z";
                hv_ParamNames3DGrippingPointsOptional[2] = "normal_image_width";
                hv_ParamNames3DGrippingPointsOptional[3] = "normal_image_height";
                //All parameters
                hv_ParamNamesAll.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ParamNamesAll = new HTuple();
                    hv_ParamNamesAll = hv_ParamNamesAll.TupleConcat(hv_ParamNamesGeneral, hv_ParamNamesSegmentation, hv_ParamNamesDetectionOptional, hv_ParamNames3DGrippingPointsOptional, hv_ParamNamesPreprocessingOptional);
                }
                hv_ParamNames.Dispose();
                hv_ParamNames = new HTuple(hv_ParamNamesGeneral);
                if ((int)((new HTuple(hv_DLModelType.TupleEqual("segmentation"))).TupleOr(new HTuple(hv_DLModelType.TupleEqual(
                    "3d_gripping_point_detection")))) != 0)
                {
                    //Extend ParamNames for models of type segmentation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ParamNames = hv_ParamNames.TupleConcat(
                                hv_ParamNamesSegmentation);
                            hv_ParamNames.Dispose();
                            hv_ParamNames = ExpTmpLocalVar_ParamNames;
                        }
                    }
                }
                //
                //Check if legacy parameter exist.
                //Otherwise map it to the legal parameter.
                replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);
                //
                //Check that all necessary parameters are included.
                //
                hv_KeysExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNames,
                    out hv_KeysExists);
                if ((int)(new HTuple(((((hv_KeysExists.TupleEqualElem(0))).TupleSum())).TupleGreater(
                    0))) != 0)
                {
                    for (hv_I = 0; (int)hv_I <= (int)(new HTuple(hv_KeysExists.TupleLength())); hv_I = (int)hv_I + 1)
                    {
                        hv_Exists.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exists = hv_KeysExists.TupleSelect(
                                hv_I);
                        }
                        if ((int)(hv_Exists.TupleNot()) != 0)
                        {
                            throw new HalconException(("DLPreprocessParam needs the parameter: '" + (hv_ParamNames.TupleSelect(
                                hv_I))) + "'");
                        }
                    }
                }
                //
                //Check the keys provided.
                hv_InputKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "keys", new HTuple(), out hv_InputKeys);
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_InputKeys.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    hv_Key.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Key = hv_InputKeys.TupleSelect(
                            hv_I);
                    }
                    hv_Value.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_Key, out hv_Value);
                    //Check that the key is known.
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_ParamNamesAll, hv_Key, out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
                    {
                        throw new HalconException(("Unknown key for DLPreprocessParam: '" + (hv_InputKeys.TupleSelect(
                            hv_I))) + "'");

                        hv_CheckParams.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLModelType.Dispose();
                        hv_Exception.Dispose();
                        hv_SupportedModelTypes.Dispose();
                        hv_Index.Dispose();
                        hv_ParamNamesGeneral.Dispose();
                        hv_ParamNamesSegmentation.Dispose();
                        hv_ParamNamesDetectionOptional.Dispose();
                        hv_ParamNamesPreprocessingOptional.Dispose();
                        hv_ParamNames3DGrippingPointsOptional.Dispose();
                        hv_ParamNamesAll.Dispose();
                        hv_ParamNames.Dispose();
                        hv_KeysExists.Dispose();
                        hv_I.Dispose();
                        hv_Exists.Dispose();
                        hv_InputKeys.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_Indices.Dispose();
                        hv_ValidValues.Dispose();
                        hv_ValidTypes.Dispose();
                        hv_V.Dispose();
                        hv_T.Dispose();
                        hv_IsInt.Dispose();
                        hv_ValidTypesListing.Dispose();
                        hv_ValidValueListing.Dispose();
                        hv_EmptyStrings.Dispose();
                        hv_ImageRangeMinExists.Dispose();
                        hv_ImageRangeMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_IndexParam.Dispose();
                        hv_SetBackgroundID.Dispose();
                        hv_ClassIDsBackground.Dispose();
                        hv_Intersection.Dispose();
                        hv_IgnoreClassIDs.Dispose();
                        hv_KnownClasses.Dispose();
                        hv_IgnoreClassID.Dispose();
                        hv_OptionalKeysExist.Dispose();
                        hv_InstanceType.Dispose();
                        hv_IsInstanceSegmentation.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_ClassIDsNoOrientation.Dispose();
                        hv_SemTypes.Dispose();

                        return;
                    }
                    //Set expected values and types.
                    hv_ValidValues.Dispose();
                    hv_ValidValues = new HTuple();
                    hv_ValidTypes.Dispose();
                    hv_ValidTypes = new HTuple();
                    if ((int)(new HTuple(hv_Key.TupleEqual("normalization_type"))) != 0)
                    {
                        hv_ValidValues.Dispose();
                        hv_ValidValues = new HTuple();
                        hv_ValidValues[0] = "all_channels";
                        hv_ValidValues[1] = "first_channel";
                        hv_ValidValues[2] = "constant_values";
                        hv_ValidValues[3] = "none";
                    }
                    else if ((int)(new HTuple(hv_Key.TupleEqual("domain_handling"))) != 0)
                    {
                        if ((int)(new HTuple(hv_DLModelType.TupleEqual("anomaly_detection"))) != 0)
                        {
                            hv_ValidValues.Dispose();
                            hv_ValidValues = new HTuple();
                            hv_ValidValues[0] = "full_domain";
                            hv_ValidValues[1] = "crop_domain";
                            hv_ValidValues[2] = "keep_domain";
                        }
                        else if ((int)(new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                        {
                            hv_ValidValues.Dispose();
                            hv_ValidValues = new HTuple();
                            hv_ValidValues[0] = "full_domain";
                            hv_ValidValues[1] = "crop_domain";
                            hv_ValidValues[2] = "keep_domain";
                        }
                        else
                        {
                            hv_ValidValues.Dispose();
                            hv_ValidValues = new HTuple();
                            hv_ValidValues[0] = "full_domain";
                            hv_ValidValues[1] = "crop_domain";
                        }
                    }
                    else if ((int)(new HTuple(hv_Key.TupleEqual("model_type"))) != 0)
                    {
                        hv_ValidValues.Dispose();
                        hv_ValidValues = new HTuple();
                        hv_ValidValues[0] = "3d_gripping_point_detection";
                        hv_ValidValues[1] = "anomaly_detection";
                        hv_ValidValues[2] = "classification";
                        hv_ValidValues[3] = "detection";
                        hv_ValidValues[4] = "gc_anomaly_detection";
                        hv_ValidValues[5] = "ocr_recognition";
                        hv_ValidValues[6] = "ocr_detection";
                        hv_ValidValues[7] = "segmentation";
                    }
                    else if ((int)(new HTuple(hv_Key.TupleEqual("augmentation"))) != 0)
                    {
                        hv_ValidValues.Dispose();
                        hv_ValidValues = new HTuple();
                        hv_ValidValues[0] = "true";
                        hv_ValidValues[1] = "false";
                    }
                    else if ((int)(new HTuple(hv_Key.TupleEqual("set_background_id"))) != 0)
                    {
                        hv_ValidTypes.Dispose();
                        hv_ValidTypes = "int";
                    }
                    else if ((int)(new HTuple(hv_Key.TupleEqual("class_ids_background"))) != 0)
                    {
                        hv_ValidTypes.Dispose();
                        hv_ValidTypes = "int";
                    }
                    //Check that type is valid.
                    if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        for (hv_V = 0; (int)hv_V <= (int)((new HTuple(hv_ValidTypes.TupleLength())) - 1); hv_V = (int)hv_V + 1)
                        {
                            hv_T.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_T = hv_ValidTypes.TupleSelect(
                                    hv_V);
                            }
                            if ((int)(new HTuple(hv_T.TupleEqual("int"))) != 0)
                            {
                                hv_IsInt.Dispose();
                                HOperatorSet.TupleIsInt(hv_Value, out hv_IsInt);
                                if ((int)(hv_IsInt.TupleNot()) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ValidTypes = ("'" + hv_ValidTypes) + "'";
                                            hv_ValidTypes.Dispose();
                                            hv_ValidTypes = ExpTmpLocalVar_ValidTypes;
                                        }
                                    }
                                    if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleLess(
                                        2))) != 0)
                                    {
                                        hv_ValidTypesListing.Dispose();
                                        hv_ValidTypesListing = new HTuple(hv_ValidTypes);
                                    }
                                    else
                                    {
                                        hv_ValidTypesListing.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ValidTypesListing = ((((hv_ValidTypes.TupleSelectRange(
                                                0, (new HTuple(0)).TupleMax2((new HTuple(hv_ValidTypes.TupleLength()
                                                )) - 2))) + new HTuple(", ")) + (hv_ValidTypes.TupleSelect((new HTuple(hv_ValidTypes.TupleLength()
                                                )) - 1)))).TupleSum();
                                        }
                                    }
                                    throw new HalconException(((((("The value given in the key '" + hv_Key) + "' of DLPreprocessParam is invalid. Valid types are: ") + hv_ValidTypesListing) + ". The given value was '") + hv_Value) + "'.");

                                    hv_CheckParams.Dispose();
                                    hv_KeyExists.Dispose();
                                    hv_DLModelType.Dispose();
                                    hv_Exception.Dispose();
                                    hv_SupportedModelTypes.Dispose();
                                    hv_Index.Dispose();
                                    hv_ParamNamesGeneral.Dispose();
                                    hv_ParamNamesSegmentation.Dispose();
                                    hv_ParamNamesDetectionOptional.Dispose();
                                    hv_ParamNamesPreprocessingOptional.Dispose();
                                    hv_ParamNames3DGrippingPointsOptional.Dispose();
                                    hv_ParamNamesAll.Dispose();
                                    hv_ParamNames.Dispose();
                                    hv_KeysExists.Dispose();
                                    hv_I.Dispose();
                                    hv_Exists.Dispose();
                                    hv_InputKeys.Dispose();
                                    hv_Key.Dispose();
                                    hv_Value.Dispose();
                                    hv_Indices.Dispose();
                                    hv_ValidValues.Dispose();
                                    hv_ValidTypes.Dispose();
                                    hv_V.Dispose();
                                    hv_T.Dispose();
                                    hv_IsInt.Dispose();
                                    hv_ValidTypesListing.Dispose();
                                    hv_ValidValueListing.Dispose();
                                    hv_EmptyStrings.Dispose();
                                    hv_ImageRangeMinExists.Dispose();
                                    hv_ImageRangeMaxExists.Dispose();
                                    hv_ImageRangeMin.Dispose();
                                    hv_ImageRangeMax.Dispose();
                                    hv_IndexParam.Dispose();
                                    hv_SetBackgroundID.Dispose();
                                    hv_ClassIDsBackground.Dispose();
                                    hv_Intersection.Dispose();
                                    hv_IgnoreClassIDs.Dispose();
                                    hv_KnownClasses.Dispose();
                                    hv_IgnoreClassID.Dispose();
                                    hv_OptionalKeysExist.Dispose();
                                    hv_InstanceType.Dispose();
                                    hv_IsInstanceSegmentation.Dispose();
                                    hv_IgnoreDirection.Dispose();
                                    hv_ClassIDsNoOrientation.Dispose();
                                    hv_SemTypes.Dispose();

                                    return;
                                }
                            }
                            else
                            {
                                throw new HalconException("Internal error. Unknown valid type.");
                            }
                        }
                    }
                    //Check that value is valid.
                    if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_Index.Dispose();
                        HOperatorSet.TupleFindFirst(hv_ValidValues, hv_Value, out hv_Index);
                        if ((int)(new HTuple(hv_Index.TupleEqual(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ValidValues = ("'" + hv_ValidValues) + "'";
                                    hv_ValidValues.Dispose();
                                    hv_ValidValues = ExpTmpLocalVar_ValidValues;
                                }
                            }
                            if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleLess(
                                2))) != 0)
                            {
                                hv_ValidValueListing.Dispose();
                                hv_ValidValueListing = new HTuple(hv_ValidValues);
                            }
                            else
                            {
                                hv_EmptyStrings.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_EmptyStrings = HTuple.TupleGenConst(
                                        (new HTuple(hv_ValidValues.TupleLength())) - 2, "");
                                }
                                hv_ValidValueListing.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ValidValueListing = ((((hv_ValidValues.TupleSelectRange(
                                        0, (new HTuple(0)).TupleMax2((new HTuple(hv_ValidValues.TupleLength()
                                        )) - 2))) + new HTuple(", ")) + (hv_EmptyStrings.TupleConcat(hv_ValidValues.TupleSelect(
                                        (new HTuple(hv_ValidValues.TupleLength())) - 1))))).TupleSum();
                                }
                            }
                            throw new HalconException(((((("The value given in the key '" + hv_Key) + "' of DLPreprocessParam is invalid. Valid values are: ") + hv_ValidValueListing) + ". The given value was '") + hv_Value) + "'.");
                        }
                    }
                }
                //
                //Check the correct setting of ImageRangeMin and ImageRangeMax.
                if ((int)((new HTuple(hv_DLModelType.TupleEqual("classification"))).TupleOr(
                    new HTuple(hv_DLModelType.TupleEqual("detection")))) != 0)
                {
                    //Check ImageRangeMin and ImageRangeMax.
                    hv_ImageRangeMinExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_min",
                        out hv_ImageRangeMinExists);
                    hv_ImageRangeMaxExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_max",
                        out hv_ImageRangeMaxExists);
                    //If they are present, check that they are set correctly.
                    if ((int)(hv_ImageRangeMinExists) != 0)
                    {
                        hv_ImageRangeMin.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                        if ((int)(new HTuple(hv_ImageRangeMin.TupleNotEqual(-127))) != 0)
                        {
                            throw new HalconException(("For model type " + hv_DLModelType) + " ImageRangeMin has to be -127.");
                        }
                    }
                    if ((int)(hv_ImageRangeMaxExists) != 0)
                    {
                        hv_ImageRangeMax.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                        if ((int)(new HTuple(hv_ImageRangeMax.TupleNotEqual(128))) != 0)
                        {
                            throw new HalconException(("For model type " + hv_DLModelType) + " ImageRangeMax has to be 128.");
                        }
                    }
                }
                //
                //Check segmentation specific parameters.
                if ((int)((new HTuple(hv_DLModelType.TupleEqual("segmentation"))).TupleOr(new HTuple(hv_DLModelType.TupleEqual(
                    "3d_gripping_point_detection")))) != 0)
                {
                    //Check if detection specific parameters are set.
                    hv_KeysExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional,
                        out hv_KeysExists);
                    //If they are present, check that they are [].
                    for (hv_IndexParam = 0; (int)hv_IndexParam <= (int)((new HTuple(hv_ParamNamesDetectionOptional.TupleLength()
                        )) - 1); hv_IndexParam = (int)hv_IndexParam + 1)
                    {
                        if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Value.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                                    hv_IndexParam), out hv_Value);
                            }
                            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
                            {
                                throw new HalconException(((("The preprocessing parameter '" + (hv_ParamNamesDetectionOptional.TupleSelect(
                                    hv_IndexParam))) + "' was set to ") + hv_Value) + new HTuple(" but for segmentation it should be set to [], as it is not used for this method."));
                            }
                        }
                    }
                    //Check 'set_background_id'.
                    hv_SetBackgroundID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
                    if ((int)((new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                    {
                        throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '") + "set_background_id") + new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
                    }
                    if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        throw new HalconException("Only one class_id as 'set_background_id' allowed.");
                    }
                    //Check 'class_ids_background'.
                    hv_ClassIDsBackground.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassIDsBackground);
                    if ((int)((new HTuple(hv_ClassIDsBackground.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                    {
                        throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '") + "class_ids_background") + new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
                    }
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
                        )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
                        )).TupleGreater(0))).TupleNot()))).TupleOr((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
                        )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
                        )).TupleGreater(0))).TupleNot()))) != 0)
                    {
                        throw new HalconException("Both keys 'set_background_id' and 'class_ids_background' are required.");
                    }
                    //Check that 'class_ids_background' and 'set_background_id' are disjoint.
                    if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_Intersection.Dispose();
                        HOperatorSet.TupleIntersection(hv_SetBackgroundID, hv_ClassIDsBackground,
                            out hv_Intersection);
                        if ((int)(new HTuple(hv_Intersection.TupleLength())) != 0)
                        {
                            throw new HalconException("Class IDs in 'set_background_id' and 'class_ids_background' need to be disjoint.");
                        }
                    }
                    //Check 'ignore_class_ids'.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                    if ((int)((new HTuple(hv_IgnoreClassIDs.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_DLModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                    {
                        throw new HalconException(new HTuple(new HTuple("The preprocessing parameter '") + "ignore_class_ids") + new HTuple("' should be set to [] for 3d_gripping_point_detection, as it is not used for this method."));
                    }
                    hv_KnownClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KnownClasses = new HTuple();
                        hv_KnownClasses = hv_KnownClasses.TupleConcat(hv_SetBackgroundID, hv_ClassIDsBackground);
                    }
                    for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                        )) - 1); hv_I = (int)hv_I + 1)
                    {
                        hv_IgnoreClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
                                hv_I);
                        }
                        hv_Index.Dispose();
                        HOperatorSet.TupleFindFirst(hv_KnownClasses, hv_IgnoreClassID, out hv_Index);
                        if ((int)((new HTuple((new HTuple(hv_Index.TupleLength())).TupleGreater(
                            0))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                        {
                            throw new HalconException("The given 'ignore_class_ids' must not be included in the 'class_ids_background' or 'set_background_id'.");
                        }
                    }
                }
                else if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
                {
                    //Check if segmentation specific parameters are set.
                    hv_KeysExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesSegmentation,
                        out hv_KeysExists);
                    //If they are present, check that they are [].
                    for (hv_IndexParam = 0; (int)hv_IndexParam <= (int)((new HTuple(hv_ParamNamesSegmentation.TupleLength()
                        )) - 1); hv_IndexParam = (int)hv_IndexParam + 1)
                    {
                        if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Value.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesSegmentation.TupleSelect(
                                    hv_IndexParam), out hv_Value);
                            }
                            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
                            {
                                throw new HalconException(((("The preprocessing parameter '" + (hv_ParamNamesSegmentation.TupleSelect(
                                    hv_IndexParam))) + "' was set to ") + hv_Value) + new HTuple(" but for detection it should be set to [], as it is not used for this method."));
                            }
                        }
                    }
                    //Check optional parameters.
                    hv_OptionalKeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional,
                        out hv_OptionalKeysExist);
                    if ((int)(hv_OptionalKeysExist.TupleSelect(0)) != 0)
                    {
                        //Check 'instance_type'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InstanceType.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                                0), out hv_InstanceType);
                        }
                        if ((int)(new HTuple((new HTuple((((new HTuple("rectangle1")).TupleConcat(
                            "rectangle2")).TupleConcat("mask")).TupleFind(hv_InstanceType))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid generic parameter for 'instance_type': " + hv_InstanceType) + new HTuple(", only 'rectangle1' and 'rectangle2' are allowed"));
                        }
                    }
                    //If instance_segmentation is set we might overwrite the instance_type for the preprocessing.
                    if ((int)(hv_OptionalKeysExist.TupleSelect(3)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IsInstanceSegmentation.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                                3), out hv_IsInstanceSegmentation);
                        }
                        if ((int)(new HTuple((new HTuple(((((new HTuple(1)).TupleConcat(0)).TupleConcat(
                            "true")).TupleConcat("false")).TupleFind(hv_IsInstanceSegmentation))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid generic parameter for 'instance_segmentation': " + hv_IsInstanceSegmentation) + new HTuple(", only true, false, 'true' and 'false' are allowed"));
                        }
                    }
                    if ((int)(hv_OptionalKeysExist.TupleSelect(1)) != 0)
                    {
                        //Check 'ignore_direction'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IgnoreDirection.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                                1), out hv_IgnoreDirection);
                        }
                        if ((int)(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_IgnoreDirection))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(("Invalid generic parameter for 'ignore_direction': " + hv_IgnoreDirection) + new HTuple(", only true and false are allowed"));
                        }
                    }
                    if ((int)(hv_OptionalKeysExist.TupleSelect(2)) != 0)
                    {
                        //Check 'class_ids_no_orientation'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassIDsNoOrientation.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                                2), out hv_ClassIDsNoOrientation);
                        }
                        hv_SemTypes.Dispose();
                        HOperatorSet.TupleSemTypeElem(hv_ClassIDsNoOrientation, out hv_SemTypes);
                        if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
                            new HTuple(((((hv_SemTypes.TupleEqualElem("integer"))).TupleSum())).TupleNotEqual(
                            new HTuple(hv_ClassIDsNoOrientation.TupleLength()))))) != 0)
                        {
                            throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': " + hv_ClassIDsNoOrientation) + new HTuple(", only integers are allowed"));
                        }
                        else
                        {
                            if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
                                new HTuple(((((hv_ClassIDsNoOrientation.TupleGreaterEqualElem(0))).TupleSum()
                                )).TupleNotEqual(new HTuple(hv_ClassIDsNoOrientation.TupleLength()
                                ))))) != 0)
                            {
                                throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': " + hv_ClassIDsNoOrientation) + new HTuple(", only non-negative integers are allowed"));
                            }
                        }
                    }
                }
                //

                hv_CheckParams.Dispose();
                hv_KeyExists.Dispose();
                hv_DLModelType.Dispose();
                hv_Exception.Dispose();
                hv_SupportedModelTypes.Dispose();
                hv_Index.Dispose();
                hv_ParamNamesGeneral.Dispose();
                hv_ParamNamesSegmentation.Dispose();
                hv_ParamNamesDetectionOptional.Dispose();
                hv_ParamNamesPreprocessingOptional.Dispose();
                hv_ParamNames3DGrippingPointsOptional.Dispose();
                hv_ParamNamesAll.Dispose();
                hv_ParamNames.Dispose();
                hv_KeysExists.Dispose();
                hv_I.Dispose();
                hv_Exists.Dispose();
                hv_InputKeys.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_Indices.Dispose();
                hv_ValidValues.Dispose();
                hv_ValidTypes.Dispose();
                hv_V.Dispose();
                hv_T.Dispose();
                hv_IsInt.Dispose();
                hv_ValidTypesListing.Dispose();
                hv_ValidValueListing.Dispose();
                hv_EmptyStrings.Dispose();
                hv_ImageRangeMinExists.Dispose();
                hv_ImageRangeMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IndexParam.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassIDsBackground.Dispose();
                hv_Intersection.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_KnownClasses.Dispose();
                hv_IgnoreClassID.Dispose();
                hv_OptionalKeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_SemTypes.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CheckParams.Dispose();
                hv_KeyExists.Dispose();
                hv_DLModelType.Dispose();
                hv_Exception.Dispose();
                hv_SupportedModelTypes.Dispose();
                hv_Index.Dispose();
                hv_ParamNamesGeneral.Dispose();
                hv_ParamNamesSegmentation.Dispose();
                hv_ParamNamesDetectionOptional.Dispose();
                hv_ParamNamesPreprocessingOptional.Dispose();
                hv_ParamNames3DGrippingPointsOptional.Dispose();
                hv_ParamNamesAll.Dispose();
                hv_ParamNames.Dispose();
                hv_KeysExists.Dispose();
                hv_I.Dispose();
                hv_Exists.Dispose();
                hv_InputKeys.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_Indices.Dispose();
                hv_ValidValues.Dispose();
                hv_ValidTypes.Dispose();
                hv_V.Dispose();
                hv_T.Dispose();
                hv_IsInt.Dispose();
                hv_ValidTypesListing.Dispose();
                hv_ValidValueListing.Dispose();
                hv_EmptyStrings.Dispose();
                hv_ImageRangeMinExists.Dispose();
                hv_ImageRangeMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IndexParam.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassIDsBackground.Dispose();
                hv_Intersection.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_KnownClasses.Dispose();
                hv_IgnoreClassID.Dispose();
                hv_OptionalKeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_SemTypes.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void check_train_dl_model_params(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_NumTrainSamples, HTuple hv_StartEpoch, HTuple hv_TrainParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_PreprocessedDataset = new HTuple();
            HTuple hv_PreprocessParam = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_DLPreprocessParams = new HTuple(), hv_DLPreprocessImageRange = new HTuple();
            HTuple hv_DLPreprocessNormalizationType = new HTuple();
            HTuple hv_TrainParamAnomaly = new HTuple(), hv_DomainRatio = new HTuple();
            HTuple hv_ErrorThreshold = new HTuple(), hv_RegularizationNoise = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_BatchSizeDevice = new HTuple();
            HTuple hv_BatchSizeMultiplier = new HTuple(), hv_BatchSize = new HTuple();
            HTuple hv_ClassIdsExist = new HTuple(), hv_ClassIDsModel = new HTuple();
            HTuple hv_ClassIDsDataset = new HTuple(), hv_Index = new HTuple();
            HTuple hv_IndexFind = new HTuple(), hv_ClassIDsModelStr = new HTuple();
            HTuple hv_ClassIDsDatasetStr = new HTuple(), hv_DisplayParam = new HTuple();
            HTuple hv_DisplayKeys = new HTuple(), hv_KeyName = new HTuple();
            HTuple hv_KeyValue = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_OptimizationMethod = new HTuple();
            HTuple hv_EvaluationComparisonKeysString = new HTuple();
            HTuple hv_TrainParamCopy = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure checks the parameters used in the procedure train_dl_model for consistency.
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                //
                //Check the NumEpochs parameter.
                if ((int)(hv_StartEpoch.TupleIsNumber()) != 0)
                {
                    if ((int)(new HTuple(hv_StartEpoch.TupleLess(0.0))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch < 0 is not allowed.");
                    }
                }
                //
                //Check if the dataset is already preprocessed.
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessedDataset = 0;
                try
                {
                    hv_PreprocessParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "preprocess_param", out hv_PreprocessParam);
                    hv_PreprocessedDataset.Dispose();
                    hv_PreprocessedDataset = 1;
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                if ((int)(hv_PreprocessedDataset.TupleNot()) != 0)
                {
                    throw new HalconException("Error: The supplied dataset needs to be preprocessed already. Use the standard procedure preprocess_dl_dataset.");
                }
                //
                //Check if the dataset preprocessing parameters fit
                //to the parameters required by the model.
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_max", out hv_ImageRangeMax);
                hv_DLPreprocessParams.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLPreprocessParams = hv_DLDataset.TupleGetDictTuple(
                        "preprocess_param");
                }
                hv_DLPreprocessImageRange.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLPreprocessImageRange = new HTuple();
                    hv_DLPreprocessImageRange = hv_DLPreprocessImageRange.TupleConcat(((hv_DLDataset.TupleGetDictTuple(
                        "preprocess_param"))).TupleGetDictTuple("image_range_min"));
                    hv_DLPreprocessImageRange = hv_DLPreprocessImageRange.TupleConcat(((hv_DLDataset.TupleGetDictTuple(
                        "preprocess_param"))).TupleGetDictTuple("image_range_max"));
                }
                hv_DLPreprocessNormalizationType.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLPreprocessNormalizationType = ((hv_DLDataset.TupleGetDictTuple(
                        "preprocess_param"))).TupleGetDictTuple("normalization_type");
                }
                if ((int)((new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))).TupleAnd(
                    (new HTuple(hv_DLPreprocessImageRange.TupleNotEqual(hv_ImageRangeMin.TupleConcat(
                    hv_ImageRangeMax)))).TupleOr(new HTuple(hv_DLPreprocessNormalizationType.TupleNotEqual(
                    "none"))))) != 0)
                {
                    throw new HalconException(new HTuple("Error: For models of type 'gc_anomaly_detection' the dataset must be preprocessed with 'normalization_type' set to 'none' and default image range [-127, 128]."));
                }
                //
                //Check parameters for anomaly detection
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_TrainParamAnomaly.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                    hv_DomainRatio.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "domain_ratio", out hv_DomainRatio);
                    if ((int)((new HTuple(hv_DomainRatio.TupleLessEqual(0))).TupleOr(new HTuple(hv_DomainRatio.TupleGreater(
                        1.0)))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'domain_ratio' must be between 0 and 1.");
                    }
                    hv_ErrorThreshold.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "error_threshold", out hv_ErrorThreshold);
                    if ((int)((new HTuple(hv_ErrorThreshold.TupleLess(0))).TupleOr(new HTuple(hv_ErrorThreshold.TupleGreater(
                        1)))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'error_threshold' must be between 0 and 1.");
                    }
                    hv_RegularizationNoise.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "regularization_noise", out hv_RegularizationNoise);
                    if ((int)(new HTuple(hv_RegularizationNoise.TupleLess(0))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'regularization_noise' must be greater than or equal to 0.");
                    }

                    hv_ModelType.Dispose();
                    hv_PreprocessedDataset.Dispose();
                    hv_PreprocessParam.Dispose();
                    hv_Exception.Dispose();
                    hv_ImageRangeMin.Dispose();
                    hv_ImageRangeMax.Dispose();
                    hv_DLPreprocessParams.Dispose();
                    hv_DLPreprocessImageRange.Dispose();
                    hv_DLPreprocessNormalizationType.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatio.Dispose();
                    hv_ErrorThreshold.Dispose();
                    hv_RegularizationNoise.Dispose();
                    hv_NumEpochs.Dispose();
                    hv_BatchSizeDevice.Dispose();
                    hv_BatchSizeMultiplier.Dispose();
                    hv_BatchSize.Dispose();
                    hv_ClassIdsExist.Dispose();
                    hv_ClassIDsModel.Dispose();
                    hv_ClassIDsDataset.Dispose();
                    hv_Index.Dispose();
                    hv_IndexFind.Dispose();
                    hv_ClassIDsModelStr.Dispose();
                    hv_ClassIDsDatasetStr.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_DisplayKeys.Dispose();
                    hv_KeyName.Dispose();
                    hv_KeyValue.Dispose();
                    hv_KeyExists.Dispose();
                    hv_EvaluationComparisonKeys.Dispose();
                    hv_OptimizationMethod.Dispose();
                    hv_EvaluationComparisonKeysString.Dispose();
                    hv_TrainParamCopy.Dispose();
                    hv__.Dispose();

                    return;
                }
                //
                //Check parameters for other models.
                //
                //Check the NumEpochs parameter.
                if ((int)(hv_StartEpoch.TupleIsNumber()) != 0)
                {
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    if ((int)(new HTuple(hv_StartEpoch.TupleGreater(hv_NumEpochs))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch > NumEpochs is not allowed.");
                    }
                }
                else
                {
                    if ((int)(new HTuple(hv_StartEpoch.TupleNotEqual("resume"))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch has to be a number or equal to 'resume'.");
                    }
                }
                //
                //Check that the number of training samples is at least as big as the total batch size.
                hv_BatchSizeDevice.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                hv_BatchSizeMultiplier.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier", out hv_BatchSizeMultiplier);
                hv_BatchSize.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BatchSize = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                }
                if ((int)(new HTuple(hv_NumTrainSamples.TupleLess(hv_BatchSize))) != 0)
                {
                    throw new HalconException("Error: Number of training samples is smaller than the batch size.");
                }
                //
                //Check that all model class IDs are a part of the DLDataset class IDs.
                hv_ClassIdsExist.Dispose();
                HOperatorSet.GetHandleParam(hv_PreprocessParam, "key_exists", "class_ids",
                    out hv_ClassIdsExist);
                if ((int)(hv_ClassIdsExist) != 0)
                {
                    hv_ClassIDsModel.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDsModel);
                    hv_ClassIDsDataset.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDsDataset);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassIDsModel.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexFind.Dispose();
                            HOperatorSet.TupleFindFirst(hv_ClassIDsDataset, hv_ClassIDsModel.TupleSelect(
                                hv_Index), out hv_IndexFind);
                        }
                        if ((int)(new HTuple(hv_IndexFind.TupleLess(0))) != 0)
                        {
                            hv_ClassIDsModelStr.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassIDsModelStr = ((" " + hv_ClassIDsModel)).TupleSum()
                                    ;
                            }
                            hv_ClassIDsDatasetStr.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassIDsDatasetStr = ((" " + hv_ClassIDsDataset)).TupleSum()
                                    ;
                            }
                            throw new HalconException((((("Error: A model class ID is not part of the DLDataset class IDs. DLModelHandle class ID: " + hv_ClassIDsModelStr) + ". ") + "DLDataset class IDs: ") + hv_ClassIDsDatasetStr) + ".");
                        }
                    }
                }
                //
                //Check display parameters.
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                hv_DisplayKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayParam, "keys", new HTuple(), out hv_DisplayKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DisplayKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_DisplayKeys.TupleSelect(
                            hv_Index);
                    }
                    if ((int)(new HTuple(hv_KeyName.TupleEqual("enabled"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(hv_KeyValue.TupleNotEqual(1))).TupleAnd(new HTuple(hv_KeyValue.TupleNotEqual(
                            0)))) != 0)
                        {
                            throw new HalconException("The value for 'enabled' is not supported.");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("change_plot_interval_seconds"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'change_plot_interval_seconds' has to be of type integer or real");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("num_images"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleNot())).TupleOr(
                            new HTuple(hv_KeyValue.TupleLess(1)))) != 0)
                        {
                            throw new HalconException("The value of 'num_images' has to be of type integer and larger or equal to one");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("selected_percentage_train_samples"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'selected_percentage_train_samples' has to be of type integer or real");
                        }
                        if ((int)((new HTuple(hv_KeyValue.TupleLess(0))).TupleOr(new HTuple(hv_KeyValue.TupleGreater(
                            100)))) != 0)
                        {
                            throw new HalconException(new HTuple("The value of 'selected_percentage_train_samples' has to be in [0,100]"));
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("update_images_interval_epochs"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'update_images_interval_epochs' has to be of type integer or real");
                        }
                        if ((int)(new HTuple(hv_KeyValue.TupleLessEqual(0))) != 0)
                        {
                            throw new HalconException("The value of 'update_images_interval_epochs' has to be larger than zero");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("x_axis_label"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(hv_KeyValue.TupleNotEqual("epochs"))).TupleAnd(new HTuple(hv_KeyValue.TupleNotEqual(
                            "iterations")))) != 0)
                        {
                            throw new HalconException("The value for 'x_axis_label' is not supported.");
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(hv_KeyName.TupleEqual("status_model_params"))).TupleOr(
                        new HTuple(hv_KeyName.TupleEqual("tiled_param"))))).TupleOr(new HTuple(hv_KeyName.TupleEqual(
                        "randomize_images")))) != 0)
                    {
                        //No check for these advanced settings.
                        //No check for randomize_images for backward compatibility.
                        continue;
                    }
                    else
                    {
                        throw new HalconException(("The provided key " + hv_KeyName) + " for 'display' is invalid.");
                    }
                }
                //
                //Check evaluation related train parameters.
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_TrainParam, "key_exists", "evaluation_comparison_keys",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_EvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
                    //Check optimization method based on provided evaluation comparison keys.
                    hv_OptimizationMethod.Dispose();
                    get_dl_evaluation_optimization_method(hv_EvaluationComparisonKeys, out hv_OptimizationMethod);
                    if ((int)(new HTuple(hv_OptimizationMethod.TupleEqual("mixed"))) != 0)
                    {
                        hv_EvaluationComparisonKeysString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationComparisonKeysString = ((hv_EvaluationComparisonKeys + " ")).TupleSum()
                                ;
                        }
                        throw new HalconException(new HTuple("Comparison keys invalid. No useful combination of values possible that are compared differently (\"<\", \">\"). EvaluationComparisonKeys: ") + hv_EvaluationComparisonKeysString);
                    }
                }
                //
                //Initialize change and serialization strategies in order to test for valid values.
                hv_TrainParamCopy.Dispose();
                HOperatorSet.CopyDict(hv_TrainParam, new HTuple(), new HTuple(), out hv_TrainParamCopy);
                hv__.Dispose();
                init_train_dl_model_change_strategies(hv_TrainParamCopy, out hv__);
                hv__.Dispose();
                init_train_dl_model_serialization_strategies(hv_TrainParamCopy, out hv__);
                //

                hv_ModelType.Dispose();
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessParam.Dispose();
                hv_Exception.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DLPreprocessParams.Dispose();
                hv_DLPreprocessImageRange.Dispose();
                hv_DLPreprocessNormalizationType.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_NumEpochs.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_ClassIdsExist.Dispose();
                hv_ClassIDsModel.Dispose();
                hv_ClassIDsDataset.Dispose();
                hv_Index.Dispose();
                hv_IndexFind.Dispose();
                hv_ClassIDsModelStr.Dispose();
                hv_ClassIDsDatasetStr.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayKeys.Dispose();
                hv_KeyName.Dispose();
                hv_KeyValue.Dispose();
                hv_KeyExists.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_OptimizationMethod.Dispose();
                hv_EvaluationComparisonKeysString.Dispose();
                hv_TrainParamCopy.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessParam.Dispose();
                hv_Exception.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DLPreprocessParams.Dispose();
                hv_DLPreprocessImageRange.Dispose();
                hv_DLPreprocessNormalizationType.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_NumEpochs.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_ClassIdsExist.Dispose();
                hv_ClassIDsModel.Dispose();
                hv_ClassIDsDataset.Dispose();
                hv_Index.Dispose();
                hv_IndexFind.Dispose();
                hv_ClassIDsModelStr.Dispose();
                hv_ClassIDsDatasetStr.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayKeys.Dispose();
                hv_KeyName.Dispose();
                hv_KeyValue.Dispose();
                hv_KeyExists.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_OptimizationMethod.Dispose();
                hv_EvaluationComparisonKeysString.Dispose();
                hv_TrainParamCopy.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Collect the information required for displaying the training progress update. 
        private void collect_train_dl_model_info(HTuple hv_DLModelHandle, HTuple hv_TrainResults,
            HTuple hv_EvaluationInfos, HTuple hv_EvaluationComparisonKeys, HTuple hv_EvaluationOptimizationMethod,
            HTuple hv_Iteration, HTuple hv_NumIterations, HTuple hv_NumIterationsPerEpoch,
            HTuple hv_NumSamplesMeanLoss, out HTuple hv_TrainInfo)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_EpochReal = new HTuple(), hv_NumEpochs = new HTuple();
            HTuple hv_TrainResultsStored = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_PossibleParamNames = new HTuple(), hv_ModelParams = new HTuple();
            HTuple hv_Index = new HTuple(), hv_ParamName = new HTuple();
            HTuple hv_DeviceHandles = new HTuple(), hv_DeviceLength = new HTuple();
            HTuple hv_DeviceTypes = new HTuple(), hv_DeviceNames = new HTuple();
            HTuple hv_DeviceIndex = new HTuple(), hv_DeviceType = new HTuple();
            HTuple hv_DeviceName = new HTuple(), hv_GenParamValue = new HTuple();
            HTuple hv_LossSamplesTrainResults = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_TrainResultsUsed = new HTuple(), hv_BatchSizeDevice = new HTuple();
            HTuple hv_BatchSizeMultiplier = new HTuple(), hv_BatchSize = new HTuple();
            HTuple hv_NumIterationsMean = new HTuple(), hv_LossParam = new HTuple();
            HTuple hv_LossValues = new HTuple(), hv_TrainResult = new HTuple();
            HTuple hv_LossValue = new HTuple(), hv_LossMean = new HTuple();
            HTuple hv_BestEvaluationInfo = new HTuple(), hv_BestEvaluationInfoTrain = new HTuple();
            HTuple hv_BestEvaluationValue = new HTuple(), hv_BestEvaluationValueTrain = new HTuple();
            HTuple hv_BestEvaluationKeys = new HTuple(), hv_BestEvaluationKeysTrain = new HTuple();
            HTuple hv_EvaluationInfo = new HTuple(), hv_ValidationEvaluationResult = new HTuple();
            HTuple hv_TrainEvaluationResult = new HTuple(), hv_Value = new HTuple();
            HTuple hv_ValidEvaluationKeys = new HTuple(), hv_ValueTrain = new HTuple();
            HTuple hv_ValidEvaluationKeysTrain = new HTuple(), hv_BestEvaluationData = new HTuple();
            // Initialize local and output iconic variables 
            hv_TrainInfo = new HTuple();
            try
            {
                //
                //This procedure computes training information for the given iteration.
                //
                hv_TrainInfo.Dispose();
                HOperatorSet.CreateDict(out hv_TrainInfo);
                //
                //General iteration and epoch status.
                hv_EpochReal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EpochReal = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                        );
                }
                //Important note:
                //Inside of this procedure, we compute iterations like that:
                //*  IterationTmp := int(round(EpochReal * (NumIterationsPerEpoch))-1)
                //If a caller of this procedure supplies a value we should use:
                //*  IterationTmp := int(floor(EpochReal * NumIterationsPerEpoch))
                //
                hv_NumEpochs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumEpochs = hv_NumIterations / (hv_NumIterationsPerEpoch.TupleReal()
                        );
                }
                //
                //Note, iterations depend on a specific batch size,
                //hence only epochs are expressive.
                HOperatorSet.SetDictTuple(hv_TrainInfo, "epoch", hv_EpochReal);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "num_epochs", hv_NumEpochs);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "num_iterations_per_epoch", hv_NumIterationsPerEpoch);
                //
                try
                {
                    hv_TrainResultsStored.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TrainResultsStored = hv_TrainResults.TupleSelect(
                            ((hv_TrainResults.TupleNotEqualElem(-1))).TupleFind(1));
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_TrainResultsStored.Dispose();
                    hv_TrainResultsStored = new HTuple();
                }
                //
                //Collect all model parameters.
                hv_PossibleParamNames.Dispose();
                HOperatorSet.GetParamInfo("get_dl_model_param", "GenParamName", "value_list",
                    out hv_PossibleParamNames);
                hv_ModelParams.Dispose();
                HOperatorSet.CreateDict(out hv_ModelParams);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "model_params", hv_ModelParams);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_PossibleParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ParamName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParamName = hv_PossibleParamNames.TupleSelect(
                            hv_Index);
                    }
                    //Do not collect summary as it cannot change during training and consumes much space.
                    if ((int)(new HTuple(hv_ParamName.TupleEqual("summary"))) != 0)
                    {
                        continue;
                    }
                    //
                    try
                    {
                        if ((int)(new HTuple(hv_ParamName.TupleEqual("device"))) != 0)
                        {
                            //The device handle cannot be serialized. Therefore we get the
                            //information via keys and serialize them.
                            hv_DeviceHandles.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ParamName, out hv_DeviceHandles);
                            hv_DeviceLength.Dispose();
                            HOperatorSet.TupleLength(hv_DeviceHandles, out hv_DeviceLength);
                            hv_DeviceTypes.Dispose();
                            hv_DeviceTypes = new HTuple();
                            hv_DeviceNames.Dispose();
                            hv_DeviceNames = new HTuple();
                            hv_DeviceTypes.Dispose();
                            HOperatorSet.TupleGenConst(hv_DeviceLength, "", out hv_DeviceTypes);
                            hv_DeviceNames.Dispose();
                            HOperatorSet.TupleGenConst(hv_DeviceLength, "", out hv_DeviceNames);
                            for (hv_DeviceIndex = 0; (int)hv_DeviceIndex <= (int)((new HTuple(hv_DeviceLength.TupleLength()
                                )) - 1); hv_DeviceIndex = (int)hv_DeviceIndex + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DeviceType.Dispose();
                                    HOperatorSet.GetHandleTuple(hv_DeviceHandles.TupleSelect(hv_DeviceIndex),
                                        "type", out hv_DeviceType);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DeviceName.Dispose();
                                    HOperatorSet.GetHandleTuple(hv_DeviceHandles.TupleSelect(hv_DeviceIndex),
                                        "name", out hv_DeviceName);
                                }
                                if (hv_DeviceTypes == null)
                                    hv_DeviceTypes = new HTuple();
                                hv_DeviceTypes[hv_DeviceIndex] = hv_DeviceType;
                                if (hv_DeviceNames == null)
                                    hv_DeviceNames = new HTuple();
                                hv_DeviceNames[hv_DeviceIndex] = hv_DeviceName;
                            }
                        }
                        else
                        {
                            hv_GenParamValue.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ParamName, out hv_GenParamValue);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    //
                    if ((int)(new HTuple(hv_ParamName.TupleEqual("device"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_ModelParams, "device_type", hv_DeviceTypes);
                        HOperatorSet.SetDictTuple(hv_ModelParams, "device_name", hv_DeviceNames);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_ModelParams, hv_ParamName, hv_GenParamValue);
                    }
                }
                //
                //Calculate a mean loss value.
                HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", new HTuple());
                HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", 0);
                //
                hv_LossSamplesTrainResults.Dispose();
                hv_LossSamplesTrainResults = new HTuple();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_TrainResults.TupleNotEqualElem(-1), 1, out hv_Indices);
                }
                if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                {
                    hv_TrainResultsUsed.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TrainResultsUsed = hv_TrainResults.TupleSelect(
                            hv_Indices);
                    }
                }
                else
                {
                    hv_TrainResultsUsed.Dispose();
                    hv_TrainResultsUsed = new HTuple();
                }
                if ((int)(new HTuple((new HTuple(hv_TrainResultsUsed.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BatchSizeDevice.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                    hv_BatchSizeMultiplier.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier", out hv_BatchSizeMultiplier);
                    hv_BatchSize.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchSize = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                    }
                    hv_NumIterationsMean.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumIterationsMean = ((((hv_NumSamplesMeanLoss / (hv_BatchSize.TupleReal()
                            ))).TupleCeil())).TupleInt();
                    }
                    //
                    if ((int)(new HTuple(hv_NumIterationsMean.TupleEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelect(
                                    (new HTuple(hv_TrainResultsUsed.TupleLength())) - 1);
                                hv_TrainResultsUsed.Dispose();
                                hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
                            }
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelectRange(
                                    (((new HTuple(hv_TrainResultsUsed.TupleLength())) - hv_NumIterationsMean)).TupleMax2(
                                    0), (new HTuple(hv_TrainResultsUsed.TupleLength())) - 1);
                                hv_TrainResultsUsed.Dispose();
                                hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
                            }
                        }
                    }
                    //
                    hv_LossParam.Dispose();
                    hv_LossParam = "total_loss";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValues.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_TrainResultsUsed.TupleLength()),
                            -1, out hv_LossValues);
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TrainResultsUsed.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_TrainResult.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TrainResult = hv_TrainResultsUsed.TupleSelect(
                                hv_Index);
                        }
                        hv_LossValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainResult, hv_LossParam, out hv_LossValue);
                        if (hv_LossValues == null)
                            hv_LossValues = new HTuple();
                        hv_LossValues[hv_Index] = hv_LossValue;
                    }
                    hv_LossMean.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossMean = hv_LossValues.TupleMean()
                            ;
                    }
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", hv_LossMean);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", new HTuple(hv_LossValues.TupleLength()
                            ));
                    }
                }
                //
                //Collect the best evaluation information.
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfo = new HTuple();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationInfoTrain = new HTuple();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValue = new HTuple();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationValueTrain = new HTuple();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeys = new HTuple();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_BestEvaluationKeysTrain = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_EvaluationInfos.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_EvaluationInfo.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluationInfo = hv_EvaluationInfos.TupleSelect(
                            hv_Index);
                    }
                    //Ignore missing information
                    if ((int)(new HTuple(hv_EvaluationInfo.TupleEqual(-1))) != 0)
                    {
                        continue;
                    }
                    //
                    hv_ValidationEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationInfo, "result", out hv_ValidationEvaluationResult);
                    hv_TrainEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationInfo, "result_train", out hv_TrainEvaluationResult);
                    //
                    //Reduce the result to a single (mean) value.
                    hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                    reduce_dl_evaluation_result(hv_ValidationEvaluationResult, hv_EvaluationComparisonKeys,
                        out hv_Value, out hv_ValidEvaluationKeys);
                    hv_ValueTrain.Dispose(); hv_ValidEvaluationKeysTrain.Dispose();
                    reduce_dl_evaluation_result(hv_TrainEvaluationResult, hv_EvaluationComparisonKeys,
                        out hv_ValueTrain, out hv_ValidEvaluationKeysTrain);
                    //
                    //Compare current evaluation result with the best one.
                    if ((int)(new HTuple(hv_EvaluationOptimizationMethod.TupleEqual("min"))) != 0)
                    {
                        //Validation.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleEqual(
                            0))).TupleOr(new HTuple(hv_Value.TupleLessEqual(hv_BestEvaluationValue)))) != 0)
                        {
                            hv_BestEvaluationInfo.Dispose();
                            hv_BestEvaluationInfo = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValue.Dispose();
                            hv_BestEvaluationValue = new HTuple(hv_Value);
                            hv_BestEvaluationKeys.Dispose();
                            hv_BestEvaluationKeys = new HTuple(hv_ValidEvaluationKeys);
                        }
                        //Training.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfoTrain.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_ValueTrain.TupleLessEqual(
                            hv_BestEvaluationValueTrain)))) != 0)
                        {
                            hv_BestEvaluationInfoTrain.Dispose();
                            hv_BestEvaluationInfoTrain = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValueTrain.Dispose();
                            hv_BestEvaluationValueTrain = new HTuple(hv_ValueTrain);
                            hv_BestEvaluationKeysTrain.Dispose();
                            hv_BestEvaluationKeysTrain = new HTuple(hv_ValidEvaluationKeysTrain);
                        }
                    }
                    else if ((int)(new HTuple(hv_EvaluationOptimizationMethod.TupleEqual(
                        "max"))) != 0)
                    {
                        //Validation.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleEqual(
                            0))).TupleOr(new HTuple(hv_Value.TupleGreaterEqual(hv_BestEvaluationValue)))) != 0)
                        {
                            hv_BestEvaluationInfo.Dispose();
                            hv_BestEvaluationInfo = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValue.Dispose();
                            hv_BestEvaluationValue = new HTuple(hv_Value);
                            hv_BestEvaluationKeys.Dispose();
                            hv_BestEvaluationKeys = new HTuple(hv_ValidEvaluationKeys);
                        }
                        //Training.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfoTrain.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_ValueTrain.TupleGreaterEqual(
                            hv_BestEvaluationValueTrain)))) != 0)
                        {
                            hv_BestEvaluationInfoTrain.Dispose();
                            hv_BestEvaluationInfoTrain = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValueTrain.Dispose();
                            hv_BestEvaluationValueTrain = new HTuple(hv_ValueTrain);
                            hv_BestEvaluationKeysTrain.Dispose();
                            hv_BestEvaluationKeysTrain = new HTuple(hv_ValidEvaluationKeysTrain);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Invalid optimization method " + hv_EvaluationOptimizationMethod) + ". Choose either \"min\" or \"max\".");
                    }
                }
                //
                //Store best evaluation information.
                if ((int)(new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BestEvaluationData.Dispose();
                    HOperatorSet.CreateDict(out hv_BestEvaluationData);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "comparison_keys", hv_BestEvaluationKeys);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_info", hv_BestEvaluationInfo);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_value", hv_BestEvaluationValue);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "comparison_keys_train",
                        hv_BestEvaluationKeysTrain);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_info_train", hv_BestEvaluationInfoTrain);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_value_train", hv_BestEvaluationValueTrain);
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", hv_BestEvaluationData);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", new HTuple());
                }
                //

                hv_EpochReal.Dispose();
                hv_NumEpochs.Dispose();
                hv_TrainResultsStored.Dispose();
                hv_Exception.Dispose();
                hv_PossibleParamNames.Dispose();
                hv_ModelParams.Dispose();
                hv_Index.Dispose();
                hv_ParamName.Dispose();
                hv_DeviceHandles.Dispose();
                hv_DeviceLength.Dispose();
                hv_DeviceTypes.Dispose();
                hv_DeviceNames.Dispose();
                hv_DeviceIndex.Dispose();
                hv_DeviceType.Dispose();
                hv_DeviceName.Dispose();
                hv_GenParamValue.Dispose();
                hv_LossSamplesTrainResults.Dispose();
                hv_Indices.Dispose();
                hv_TrainResultsUsed.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_NumIterationsMean.Dispose();
                hv_LossParam.Dispose();
                hv_LossValues.Dispose();
                hv_TrainResult.Dispose();
                hv_LossValue.Dispose();
                hv_LossMean.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_ValueTrain.Dispose();
                hv_ValidEvaluationKeysTrain.Dispose();
                hv_BestEvaluationData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EpochReal.Dispose();
                hv_NumEpochs.Dispose();
                hv_TrainResultsStored.Dispose();
                hv_Exception.Dispose();
                hv_PossibleParamNames.Dispose();
                hv_ModelParams.Dispose();
                hv_Index.Dispose();
                hv_ParamName.Dispose();
                hv_DeviceHandles.Dispose();
                hv_DeviceLength.Dispose();
                hv_DeviceTypes.Dispose();
                hv_DeviceNames.Dispose();
                hv_DeviceIndex.Dispose();
                hv_DeviceType.Dispose();
                hv_DeviceName.Dispose();
                hv_GenParamValue.Dispose();
                hv_LossSamplesTrainResults.Dispose();
                hv_Indices.Dispose();
                hv_TrainResultsUsed.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_NumIterationsMean.Dispose();
                hv_LossParam.Dispose();
                hv_LossValues.Dispose();
                hv_TrainResult.Dispose();
                hv_LossValue.Dispose();
                hv_LossMean.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_ValueTrain.Dispose();
                hv_ValidEvaluationKeysTrain.Dispose();
                hv_BestEvaluationData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Compute thresholds for anomaly detection or Global Context Anomaly Detection. 
        public void compute_dl_anomaly_thresholds(HTuple hv_DLModelHandle, HTuple hv_DLDataset,
            HTuple hv_GenParam, out HTuple hv_AnomalySegmentationThreshold, out HTuple hv_AnomalyClassificationThresholds)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_Domain = null;

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_SplitExists = new HTuple(), hv_SupportedKeys = new HTuple();
            HTuple hv_UseOkSamplesOnly = new HTuple(), hv_EnableDisplay = new HTuple();
            HTuple hv_SupportedSegmentationCriteria = new HTuple();
            HTuple hv_SegmentationCriterion = new HTuple(), hv_SegmentationTolerance = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_UnsupportedKeys = new HTuple();
            HTuple hv_UnsupportedKeysString = new HTuple(), hv_UseOkSamplesOnlyExists = new HTuple();
            HTuple hv_EnableDisplayExists = new HTuple(), hv_SegmentationCriterionKeyExists = new HTuple();
            HTuple hv_ToleranceKeyExists = new HTuple(), hv_ValidationIndices = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleInfo = new HTuple();
            HTuple hv_ValidationSamples = new HTuple(), hv_ThresholdInformation = new HTuple();
            HTuple hv_ValidationResults = new HTuple(), hv_Values = new HTuple();
            HTuple hv_NumValues = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Grayval = new HTuple(), hv_TestIndices = new HTuple();
            HTuple hv_TestIndicesNOK = new HTuple(), hv_TestIndicesOK = new HTuple();
            HTuple hv_TestSamplesOK = new HTuple(), hv_TestResultsOK = new HTuple();
            HTuple hv_AnomalyScoresOK = new HTuple(), hv_AnomalyScore = new HTuple();
            HTuple hv_Eps = new HTuple(), hv_TestSamplesNOK = new HTuple();
            HTuple hv_TestResultsNOK = new HTuple(), hv_AnomalyScoresNOK = new HTuple();
            HTuple hv_MaxScoreOK = new HTuple(), hv_MinScoreNOK = new HTuple();
            HTuple hv_IntermediateThreshold = new HTuple(), hv_AnomalyScores = new HTuple();
            HTuple hv_AnomalyScoresSortIndices = new HTuple(), hv_AnomalyScoresSorted = new HTuple();
            HTuple hv_TmpOK = new HTuple(), hv_TrueNegativesPerScore = new HTuple();
            HTuple hv_FPRate = new HTuple(), hv_TmpNOK = new HTuple();
            HTuple hv_FalseNegativesPerScore = new HTuple(), hv_FNRate = new HTuple();
            HTuple hv_FprFnrSum = new HTuple(), hv_MinFprFnRSum = new HTuple();
            HTuple hv_ThresholdIndex = new HTuple(), hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_1 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_2 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_3 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            hv_AnomalySegmentationThreshold = new HTuple();
            hv_AnomalyClassificationThresholds = new HTuple();
            try
            {
                //This procedure estimates two different thresholds used in deep-learning-based
                //anomaly detection and Global Context Anomaly Detection
                //(For models of type 'anomaly_detection' and 'gc_anomaly_detection').
                //These thresholds are used for:
                //1) Region segmentation: AnomalySegmentationThreshold can be used as threshold
                //   whether a pixel within the anomaly image belongs to a region of an anomaly.
                //   The threshold is estimated based on the samples in the validation split of DLDataset.
                //2) Image classification: AnomalyClassificationThresholds can be used as threshold
                //   whether the image is counted as containing an anomaly.
                //   It consists of a tuple with the following values:
                // - the maximal anomaly score obtained for the ok test samples
                // - the minimal anomaly score obtained for the nok test samples
                // - an intermediate threshold for the anomaly scores that minimizes
                //   the sum of the false negative rate and the false positive rate.
                //   Note, the latter two values are only calculated if nok test samples are available.
                //
                //Check model type.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("gc_anomaly_detection")))) != 0)
                {
                    throw new HalconException("This procedure can only be used for models of type 'anomaly_detection' and 'gc_anomaly_detection'.");
                }
                //
                //Get sample entries in DLDataset.
                hv_DLSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSamples = hv_DLDataset.TupleGetDictTuple(
                        "samples");
                }
                //
                //Check whether the dataset is split.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SplitExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "split",
                        out hv_SplitExists);
                }
                if ((int)(hv_SplitExists.TupleNot()) != 0)
                {
                    throw new HalconException("This procedure can only be used if DLDataset has already been split.");
                }
                //
                //For Global Context Anomaly Detection, check if model has been normalized.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                {
                    check_dl_gc_anomaly_scores_normalization(hv_DLModelHandle, new HTuple());
                }
                //
                //Read in generic parameters.
                hv_SupportedKeys.Dispose();
                hv_SupportedKeys = new HTuple();
                hv_SupportedKeys[0] = "enable_display";
                hv_SupportedKeys[1] = "use_ok_samples_only";
                hv_SupportedKeys[2] = "segmentation_criterion";
                hv_SupportedKeys[3] = "segmentation_tolerance";
                hv_UseOkSamplesOnly.Dispose();
                hv_UseOkSamplesOnly = 0;
                hv_EnableDisplay.Dispose();
                hv_EnableDisplay = 0;
                hv_SupportedSegmentationCriteria.Dispose();
                hv_SupportedSegmentationCriteria = new HTuple();
                hv_SupportedSegmentationCriteria[0] = "deviation";
                hv_SupportedSegmentationCriteria[1] = "tolerance";
                hv_SegmentationCriterion.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationCriterion = hv_SupportedSegmentationCriteria.TupleSelect(
                        0);
                }
                hv_SegmentationTolerance.Dispose();
                hv_SegmentationTolerance = 0.0;
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_Keys);
                    hv_UnsupportedKeys.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UnsupportedKeys = hv_Keys.TupleDifference(
                            hv_SupportedKeys);
                    }
                    if ((int)(new HTuple(hv_UnsupportedKeys.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_UnsupportedKeysString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UnsupportedKeysString = ((hv_UnsupportedKeys + new HTuple(", "))).TupleSum()
                                ;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_UnsupportedKeysString = hv_UnsupportedKeysString.TupleStrFirstN(
                                    (hv_UnsupportedKeysString.TupleStrlen()) - 3);
                                hv_UnsupportedKeysString.Dispose();
                                hv_UnsupportedKeysString = ExpTmpLocalVar_UnsupportedKeysString;
                            }
                        }
                        throw new HalconException("Unsupported keys: " + hv_UnsupportedKeysString);
                    }
                    hv_UseOkSamplesOnlyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "use_ok_samples_only",
                        out hv_UseOkSamplesOnlyExists);
                    if ((int)(hv_UseOkSamplesOnlyExists) != 0)
                    {
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", 1);
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "true");
                        hv_UseOkSamplesOnly.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UseOkSamplesOnly = ((((hv_GenParam.TupleConcat(
                                hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem("use_ok_samples_only",
                                "comp"))).TupleOr(((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                                "use_ok_samples_only", "comp"));
                        }
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                                "HNULL");
                        }
                    }
                    hv_EnableDisplayExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "enable_display", out hv_EnableDisplayExists);
                    if ((int)(hv_EnableDisplayExists) != 0)
                    {
                        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_2);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", 1);
                        hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_3);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", "true");
                        hv_EnableDisplay.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EnableDisplay = ((((hv_GenParam.TupleConcat(
                                hv___Tmp_Ctrl_Dict_Init_3))).TupleTestEqualDictItem("enable_display",
                                "comp"))).TupleOr(((hv_GenParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2))).TupleTestEqualDictItem(
                                "enable_display", "comp"));
                        }
                        hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_3 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_2 = HTuple.TupleConstant(
                                "HNULL");
                        }
                    }
                    hv_SegmentationCriterionKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "segmentation_criterion",
                        out hv_SegmentationCriterionKeyExists);
                    if ((int)(hv_SegmentationCriterionKeyExists) != 0)
                    {
                        hv_SegmentationCriterion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SegmentationCriterion = hv_GenParam.TupleGetDictTuple(
                                "segmentation_criterion");
                        }
                        if ((int)(new HTuple(((hv_SupportedSegmentationCriteria.TupleFindFirst(
                            hv_SegmentationCriterion))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException("Unsupported segmentation criterion " + hv_SegmentationCriterion);
                        }
                    }
                    hv_ToleranceKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "segmentation_tolerance",
                        out hv_ToleranceKeyExists);
                    if ((int)(hv_ToleranceKeyExists) != 0)
                    {
                        hv_SegmentationTolerance.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SegmentationTolerance = hv_GenParam.TupleGetDictTuple(
                                "segmentation_tolerance");
                        }
                        if ((int)(((hv_SegmentationTolerance.TupleIsNumber())).TupleNot()) != 0)
                        {
                            throw new HalconException(new HTuple("Value for 'segmentation_tolerance' must be a number, but is ") + hv_SegmentationTolerance);
                        }
                        if ((int)((new HTuple(hv_SegmentationTolerance.TupleLess(0.0))).TupleOr(
                            new HTuple(hv_SegmentationTolerance.TupleGreaterEqual(1.0)))) != 0)
                        {
                            throw new HalconException(new HTuple("Value for 'segmentation_tolerance' must be larger than or equal to 0 and smaller than 1, but is ") + hv_SegmentationTolerance);
                        }
                    }
                }
                //
                //Determine the threshold for region segmentation: AnomalySegmentationThreshold.
                //
                //Get the samples in the validation split.
                hv_ValidationIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "validation", "or", out hv_ValidationIndices);
                //If the validation split is empty, the segmentation threshold cannot be estimated.
                if ((int)(new HTuple((new HTuple(hv_ValidationIndices.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    throw new HalconException("This procedure can only be used with at least one validation image.");
                }
                //
                //Display progress message.
                if ((int)(hv_EnableDisplay) != 0)
                {
                    hv_WindowWidth.Dispose();
                    hv_WindowWidth = 500;
                    hv_WindowHeight.Dispose();
                    hv_WindowHeight = 200;
                    hv_WindowBGColor.Dispose();
                    hv_WindowBGColor = "light gray";
                    //
                    //Open and setup text window.
                    HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                    HOperatorSet.OpenWindow(0, 0, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleInfo);
                    HDevWindowStack.Push(hv_WindowHandleInfo);
                    set_display_font(hv_WindowHandleInfo, 16, "mono", "true", "false");
                }
                //
                hv_ValidationSamples.Dispose();
                read_dl_samples(hv_DLDataset, hv_ValidationIndices, out hv_ValidationSamples);
                //
                //Get the gray values of the anomaly images for the validation split.
                if ((int)(hv_EnableDisplay) != 0)
                {
                    hv_ThresholdInformation.Dispose();
                    hv_ThresholdInformation = new HTuple();
                    hv_ThresholdInformation[0] = "Computing thresholds.";
                    hv_ThresholdInformation[1] = "";
                    hv_ThresholdInformation[2] = "This may take some time...";
                    hv_ThresholdInformation[3] = "";
                    hv_ThresholdInformation[4] = "Get gray values of anomaly images";
                    hv_ThresholdInformation[5] = "for the validation split (1/3)";
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ThresholdInformation,
                            "window", "top", "left", "black", "box", "false");
                    }
                }
                hv_ValidationResults.Dispose();
                HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_ValidationSamples, new HTuple(),
                    out hv_ValidationResults);
                //
                hv_Values.Dispose();
                hv_Values = new HTuple();
                hv_NumValues.Dispose();
                hv_NumValues = 0;
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ValidationResults.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_AnomalyImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_ValidationResults.TupleSelect(
                            hv_Index), "anomaly_image");
                    }
                    if ((int)(new HTuple(hv_Values.TupleEqual(new HTuple()))) != 0)
                    {
                        //Allocate buffer for pixel values
                        hv_Width.Dispose(); hv_Height.Dispose();
                        HOperatorSet.GetImageSize(ho_AnomalyImage, out hv_Width, out hv_Height);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Values.Dispose();
                            HOperatorSet.TupleGenConst((hv_Width * hv_Height) * (new HTuple(hv_ValidationResults.TupleLength()
                                )), -1, out hv_Values);
                        }
                    }
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_AnomalyImage, out ho_Domain);
                    hv_Rows.Dispose(); hv_Columns.Dispose();
                    HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
                    hv_Grayval.Dispose();
                    HOperatorSet.GetGrayval(ho_AnomalyImage, hv_Rows, hv_Columns, out hv_Grayval);
                    if (hv_Values == null)
                        hv_Values = new HTuple();
                    hv_Values[HTuple.TupleGenSequence(hv_NumValues, (hv_NumValues + (new HTuple(hv_Grayval.TupleLength()
                        ))) - 1, 1)] = hv_Grayval;
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NumValues = hv_NumValues + (new HTuple(hv_Grayval.TupleLength()
                                ));
                            hv_NumValues.Dispose();
                            hv_NumValues = ExpTmpLocalVar_NumValues;
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Values = hv_Values.TupleSelectRange(
                            0, hv_NumValues - 1);
                        hv_Values.Dispose();
                        hv_Values = ExpTmpLocalVar_Values;
                    }
                }
                //
                //Compute the estimated threshold.
                if ((int)(new HTuple(hv_SegmentationCriterion.TupleEqual("deviation"))) != 0)
                {
                    //We take the mean of the anomaly images plus four times their standard deviation.
                    //This ensures that almost all gray values in the anomaly images
                    //of the validation samples are below threshold, while the estimate
                    //is still robust against unexpected outliers.
                    hv_AnomalySegmentationThreshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalySegmentationThreshold = (hv_Values.TupleMean()
                            ) + (4.0 * (hv_Values.TupleDeviation()));
                    }
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AnomalySegmentationThreshold = hv_AnomalySegmentationThreshold.TupleMin2(
                                    1.0);
                                hv_AnomalySegmentationThreshold.Dispose();
                                hv_AnomalySegmentationThreshold = ExpTmpLocalVar_AnomalySegmentationThreshold;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_SegmentationCriterion.TupleEqual("tolerance"))) != 0)
                {
                    //We tolerate a fraction of anomaly scores to be anomalous. This fraction is
                    //given by the value of SegmentationTolerance.
                    if ((int)(new HTuple(hv_SegmentationTolerance.TupleEqual(0.0))) != 0)
                    {
                        hv_AnomalySegmentationThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalySegmentationThreshold = hv_Values.TupleMax()
                                ;
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Values = hv_Values.TupleSort()
                                    ;
                                hv_Values.Dispose();
                                hv_Values = ExpTmpLocalVar_Values;
                            }
                        }
                        hv_AnomalySegmentationThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalySegmentationThreshold = hv_Values.TupleSelect(
                                (((1 - hv_SegmentationTolerance) * ((new HTuple(hv_Values.TupleLength()
                                )) - 1))).TupleRound());
                        }
                    }
                }
                //
                //Determine the thresholds for anomaly image classification: AnomalyClassificationThresholds.
                //
                //Get the indices of the ok and nok test samples.
                hv_TestIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "test", "or", out hv_TestIndices);
                hv_TestIndicesNOK.Dispose();
                find_dl_samples(hv_DLSamples, "anomaly_label", "nok", "or", out hv_TestIndicesNOK);
                hv_TestIndicesOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TestIndicesOK = hv_TestIndices.TupleDifference(
                        hv_TestIndicesNOK);
                }
                //
                if ((int)(new HTuple((new HTuple(hv_TestIndicesOK.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    //No thresholds are computed.
                    throw new HalconException("This procedure requires at least one test image labeled as 'ok'.");
                }
                //
                //Compute the anomaly scores of the ok test samples.
                if ((int)(hv_EnableDisplay) != 0)
                {
                    hv_ThresholdInformation.Dispose();
                    hv_ThresholdInformation = new HTuple();
                    hv_ThresholdInformation[0] = "Computing thresholds.";
                    hv_ThresholdInformation[1] = "";
                    hv_ThresholdInformation[2] = "This may take some time...";
                    hv_ThresholdInformation[3] = "";
                    hv_ThresholdInformation[4] = "Compute the anomaly scores";
                    hv_ThresholdInformation[5] = "of the ok test samples (2/3)";
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ThresholdInformation,
                            "window", "top", "left", "black", "box", "false");
                    }
                }
                hv_TestSamplesOK.Dispose();
                read_dl_samples(hv_DLDataset, hv_TestIndicesOK, out hv_TestSamplesOK);
                hv_TestResultsOK.Dispose();
                HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_TestSamplesOK, new HTuple(),
                    out hv_TestResultsOK);
                hv_AnomalyScoresOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyScoresOK = HTuple.TupleGenConst(
                        new HTuple(hv_TestResultsOK.TupleLength()), 0.0);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TestResultsOK.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyScore.Dispose();
                        HOperatorSet.GetDictTuple(hv_TestResultsOK.TupleSelect(hv_Index), "anomaly_score",
                            out hv_AnomalyScore);
                    }
                    if (hv_AnomalyScoresOK == null)
                        hv_AnomalyScoresOK = new HTuple();
                    hv_AnomalyScoresOK[hv_Index] = hv_AnomalyScore;
                }
                //
                //Set a small value which is used to slightly increase the calculated thresholds
                //to ensure correct classification of OK scores.
                hv_Eps.Dispose();
                hv_Eps = 1e-15;
                //
                //In case only test samples labeled as ok are used,
                //only one anomaly image classification threshold is returned.
                if ((int)((new HTuple((new HTuple(hv_TestIndicesNOK.TupleLength())).TupleEqual(
                    0))).TupleOr(hv_UseOkSamplesOnly)) != 0)
                {
                    hv_AnomalyClassificationThresholds.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyClassificationThresholds = (hv_AnomalyScoresOK.TupleMax()
                            ) * (1 + hv_Eps);
                    }
                }
                else
                {
                    if ((int)(hv_EnableDisplay) != 0)
                    {
                        hv_ThresholdInformation.Dispose();
                        hv_ThresholdInformation = new HTuple();
                        hv_ThresholdInformation[0] = "Computing thresholds.";
                        hv_ThresholdInformation[1] = "";
                        hv_ThresholdInformation[2] = "This may take some time...";
                        hv_ThresholdInformation[3] = "";
                        hv_ThresholdInformation[4] = "Compute the anomaly scores";
                        hv_ThresholdInformation[5] = "of the nok test samples (3/3)";
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ThresholdInformation,
                                "window", "top", "left", "black", "box", "false");
                        }
                    }
                    //Compute the anomaly scores of the nok test samples.
                    hv_TestSamplesNOK.Dispose();
                    read_dl_samples(hv_DLDataset, hv_TestIndicesNOK, out hv_TestSamplesNOK);
                    hv_TestResultsNOK.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_TestSamplesNOK, new HTuple(),
                        out hv_TestResultsNOK);
                    hv_AnomalyScoresNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyScoresNOK = HTuple.TupleGenConst(
                            new HTuple(hv_TestResultsNOK.TupleLength()), 0.0);
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TestResultsNOK.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScore.Dispose();
                            HOperatorSet.GetDictTuple(hv_TestResultsNOK.TupleSelect(hv_Index), "anomaly_score",
                                out hv_AnomalyScore);
                        }
                        if (hv_AnomalyScoresNOK == null)
                            hv_AnomalyScoresNOK = new HTuple();
                        hv_AnomalyScoresNOK[hv_Index] = hv_AnomalyScore;
                    }
                    //Get minimum and maximum values of the anomaly scores.
                    hv_MaxScoreOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScoreOK = hv_AnomalyScoresOK.TupleMax()
                            ;
                    }
                    hv_MinScoreNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScoreNOK = hv_AnomalyScoresNOK.TupleMin()
                            ;
                    }
                    if ((int)(new HTuple(hv_MaxScoreOK.TupleLessEqual(hv_MinScoreNOK))) != 0)
                    {
                        //In this case the ok and nok samples can be perfectly separated
                        //by a threshold.
                        hv_IntermediateThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IntermediateThreshold = (hv_MaxScoreOK + hv_MinScoreNOK) / 2;
                        }
                    }
                    else
                    {
                        //In this case there will be false positives or false negatives
                        //for any threshold.
                        //
                        //Compute the histograms of the ok and nok scores.
                        //
                        //Sort the anomaly scores.
                        hv_AnomalyScores.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScores = new HTuple();
                            hv_AnomalyScores = hv_AnomalyScores.TupleConcat(hv_AnomalyScoresOK, hv_AnomalyScoresNOK);
                        }
                        hv_AnomalyScoresSortIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScoresSortIndices = hv_AnomalyScores.TupleSortIndex()
                                ;
                        }
                        hv_AnomalyScoresSorted.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScoresSorted = hv_AnomalyScores.TupleSelect(
                                hv_AnomalyScoresSortIndices);
                        }
                        //
                        //Compute the false positive rates.
                        hv_TmpOK.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpOK = new HTuple();
                            hv_TmpOK = hv_TmpOK.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_AnomalyScoresOK.TupleLength()), 1.0));
                            hv_TmpOK = hv_TmpOK.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_AnomalyScoresNOK.TupleLength()), 0.0));
                        }
                        hv_TrueNegativesPerScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TrueNegativesPerScore = ((hv_TmpOK.TupleSelect(
                                hv_AnomalyScoresSortIndices))).TupleCumul();
                        }
                        hv_FPRate.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPRate = 1.0 - (hv_TrueNegativesPerScore / (new HTuple(hv_AnomalyScoresOK.TupleLength()
                                )));
                        }
                        //
                        //Compute the false negative rates.
                        hv_TmpNOK.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TmpNOK = new HTuple();
                            hv_TmpNOK = hv_TmpNOK.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_AnomalyScoresOK.TupleLength()), 0.0));
                            hv_TmpNOK = hv_TmpNOK.TupleConcat(HTuple.TupleGenConst(
                                new HTuple(hv_AnomalyScoresNOK.TupleLength()), 1.0));
                        }
                        hv_FalseNegativesPerScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FalseNegativesPerScore = ((hv_TmpNOK.TupleSelect(
                                hv_AnomalyScoresSortIndices))).TupleCumul();
                        }
                        hv_FNRate.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FNRate = hv_FalseNegativesPerScore / (new HTuple(hv_AnomalyScoresNOK.TupleLength()
                                ));
                        }
                        //
                        //Get the threshold for which the sum of the false positive
                        //and false negative rates is the lowest.
                        hv_FprFnrSum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FprFnrSum = hv_FPRate + hv_FNRate;
                        }
                        hv_MinFprFnRSum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MinFprFnRSum = hv_FprFnrSum.TupleMin()
                                ;
                        }
                        hv_ThresholdIndex.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThresholdIndex = hv_FprFnrSum.TupleFindFirst(
                                hv_MinFprFnRSum);
                        }
                        hv_IntermediateThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IntermediateThreshold = hv_AnomalyScoresSorted.TupleSelect(
                                hv_ThresholdIndex);
                        }
                        //
                        //In some cases IntermediateThreshold may be smaller than MinScoreNOK.
                        //We set it to at least that value.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_IntermediateThreshold = hv_IntermediateThreshold.TupleMax2(
                                    hv_MinScoreNOK);
                                hv_IntermediateThreshold.Dispose();
                                hv_IntermediateThreshold = ExpTmpLocalVar_IntermediateThreshold;
                            }
                        }
                        //
                    }
                    //Set the tuple of anomaly classification thresholds.
                    hv_AnomalyClassificationThresholds.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyClassificationThresholds = new HTuple();
                        hv_AnomalyClassificationThresholds = hv_AnomalyClassificationThresholds.TupleConcat(hv_MaxScoreOK * (1 + hv_Eps));
                        hv_AnomalyClassificationThresholds = hv_AnomalyClassificationThresholds.TupleConcat(hv_MinScoreNOK, hv_IntermediateThreshold);
                    }
                }
                //
                ho_AnomalyImage.Dispose();
                ho_Domain.Dispose();

                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_SplitExists.Dispose();
                hv_SupportedKeys.Dispose();
                hv_UseOkSamplesOnly.Dispose();
                hv_EnableDisplay.Dispose();
                hv_SupportedSegmentationCriteria.Dispose();
                hv_SegmentationCriterion.Dispose();
                hv_SegmentationTolerance.Dispose();
                hv_Keys.Dispose();
                hv_UnsupportedKeys.Dispose();
                hv_UnsupportedKeysString.Dispose();
                hv_UseOkSamplesOnlyExists.Dispose();
                hv_EnableDisplayExists.Dispose();
                hv_SegmentationCriterionKeyExists.Dispose();
                hv_ToleranceKeyExists.Dispose();
                hv_ValidationIndices.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleInfo.Dispose();
                hv_ValidationSamples.Dispose();
                hv_ThresholdInformation.Dispose();
                hv_ValidationResults.Dispose();
                hv_Values.Dispose();
                hv_NumValues.Dispose();
                hv_Index.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Grayval.Dispose();
                hv_TestIndices.Dispose();
                hv_TestIndicesNOK.Dispose();
                hv_TestIndicesOK.Dispose();
                hv_TestSamplesOK.Dispose();
                hv_TestResultsOK.Dispose();
                hv_AnomalyScoresOK.Dispose();
                hv_AnomalyScore.Dispose();
                hv_Eps.Dispose();
                hv_TestSamplesNOK.Dispose();
                hv_TestResultsNOK.Dispose();
                hv_AnomalyScoresNOK.Dispose();
                hv_MaxScoreOK.Dispose();
                hv_MinScoreNOK.Dispose();
                hv_IntermediateThreshold.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoresSortIndices.Dispose();
                hv_AnomalyScoresSorted.Dispose();
                hv_TmpOK.Dispose();
                hv_TrueNegativesPerScore.Dispose();
                hv_FPRate.Dispose();
                hv_TmpNOK.Dispose();
                hv_FalseNegativesPerScore.Dispose();
                hv_FNRate.Dispose();
                hv_FprFnrSum.Dispose();
                hv_MinFprFnRSum.Dispose();
                hv_ThresholdIndex.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_Domain.Dispose();

                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_SplitExists.Dispose();
                hv_SupportedKeys.Dispose();
                hv_UseOkSamplesOnly.Dispose();
                hv_EnableDisplay.Dispose();
                hv_SupportedSegmentationCriteria.Dispose();
                hv_SegmentationCriterion.Dispose();
                hv_SegmentationTolerance.Dispose();
                hv_Keys.Dispose();
                hv_UnsupportedKeys.Dispose();
                hv_UnsupportedKeysString.Dispose();
                hv_UseOkSamplesOnlyExists.Dispose();
                hv_EnableDisplayExists.Dispose();
                hv_SegmentationCriterionKeyExists.Dispose();
                hv_ToleranceKeyExists.Dispose();
                hv_ValidationIndices.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleInfo.Dispose();
                hv_ValidationSamples.Dispose();
                hv_ThresholdInformation.Dispose();
                hv_ValidationResults.Dispose();
                hv_Values.Dispose();
                hv_NumValues.Dispose();
                hv_Index.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Grayval.Dispose();
                hv_TestIndices.Dispose();
                hv_TestIndicesNOK.Dispose();
                hv_TestIndicesOK.Dispose();
                hv_TestSamplesOK.Dispose();
                hv_TestResultsOK.Dispose();
                hv_AnomalyScoresOK.Dispose();
                hv_AnomalyScore.Dispose();
                hv_Eps.Dispose();
                hv_TestSamplesNOK.Dispose();
                hv_TestResultsNOK.Dispose();
                hv_AnomalyScoresNOK.Dispose();
                hv_MaxScoreOK.Dispose();
                hv_MinScoreNOK.Dispose();
                hv_IntermediateThreshold.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoresSortIndices.Dispose();
                hv_AnomalyScoresSorted.Dispose();
                hv_TmpOK.Dispose();
                hv_TrueNegativesPerScore.Dispose();
                hv_FPRate.Dispose();
                hv_TmpNOK.Dispose();
                hv_FalseNegativesPerScore.Dispose();
                hv_FNRate.Dispose();
                hv_FprFnrSum.Dispose();
                hv_MinFprFnRSum.Dispose();
                hv_ThresholdIndex.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Compute 3D normals. 
        private void compute_normals_xyz(HObject ho_x, HObject ho_y, HObject ho_z, out HObject ho_NXImage,
            out HObject ho_NYImage, out HObject ho_NZImage, HTuple hv_Smoothing)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_xScaled, ho_yScaled, ho_zScaled;
            HObject ho_xDiffRow, ho_xDiffCol, ho_yDiffRow, ho_yDiffCol;
            HObject ho_zDiffRow, ho_zDiffCol, ho_ImageResult, ho_ImageResult2;
            HObject ho_NXRaw, ho_NYRaw, ho_NZRaw, ho_NXSquare, ho_NYSquare;
            HObject ho_NZSquare, ho_ImageResult1, ho_SqrtImage;

            // Local control variables 

            HTuple hv_Factor = new HTuple(), hv_MaskRow = new HTuple();
            HTuple hv_MaskCol = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_NXImage);
            HOperatorSet.GenEmptyObj(out ho_NYImage);
            HOperatorSet.GenEmptyObj(out ho_NZImage);
            HOperatorSet.GenEmptyObj(out ho_xScaled);
            HOperatorSet.GenEmptyObj(out ho_yScaled);
            HOperatorSet.GenEmptyObj(out ho_zScaled);
            HOperatorSet.GenEmptyObj(out ho_xDiffRow);
            HOperatorSet.GenEmptyObj(out ho_xDiffCol);
            HOperatorSet.GenEmptyObj(out ho_yDiffRow);
            HOperatorSet.GenEmptyObj(out ho_yDiffCol);
            HOperatorSet.GenEmptyObj(out ho_zDiffRow);
            HOperatorSet.GenEmptyObj(out ho_zDiffCol);
            HOperatorSet.GenEmptyObj(out ho_ImageResult);
            HOperatorSet.GenEmptyObj(out ho_ImageResult2);
            HOperatorSet.GenEmptyObj(out ho_NXRaw);
            HOperatorSet.GenEmptyObj(out ho_NYRaw);
            HOperatorSet.GenEmptyObj(out ho_NZRaw);
            HOperatorSet.GenEmptyObj(out ho_NXSquare);
            HOperatorSet.GenEmptyObj(out ho_NYSquare);
            HOperatorSet.GenEmptyObj(out ho_NZSquare);
            HOperatorSet.GenEmptyObj(out ho_ImageResult1);
            HOperatorSet.GenEmptyObj(out ho_SqrtImage);
            try
            {
                //For numerical reasons we scale the input data
                hv_Factor.Dispose();
                hv_Factor = 1e6;
                ho_xScaled.Dispose();
                HOperatorSet.ScaleImage(ho_x, out ho_xScaled, hv_Factor, 0);
                ho_yScaled.Dispose();
                HOperatorSet.ScaleImage(ho_y, out ho_yScaled, hv_Factor, 0);
                ho_zScaled.Dispose();
                HOperatorSet.ScaleImage(ho_z, out ho_zScaled, hv_Factor, 0);

                //Filter for diffs in row/col direction
                hv_MaskRow.Dispose();
                hv_MaskRow = new HTuple();
                hv_MaskRow[0] = 2;
                hv_MaskRow[1] = 1;
                hv_MaskRow[2] = 1.0;
                hv_MaskRow[3] = 1;
                hv_MaskRow[4] = -1;
                hv_MaskCol.Dispose();
                hv_MaskCol = new HTuple();
                hv_MaskCol[0] = 1;
                hv_MaskCol[1] = 2;
                hv_MaskCol[2] = 1.0;
                hv_MaskCol[3] = -1;
                hv_MaskCol[4] = 1;
                ho_xDiffRow.Dispose();
                HOperatorSet.ConvolImage(ho_xScaled, out ho_xDiffRow, hv_MaskRow, "continued");
                ho_xDiffCol.Dispose();
                HOperatorSet.ConvolImage(ho_xScaled, out ho_xDiffCol, hv_MaskCol, "continued");
                ho_yDiffRow.Dispose();
                HOperatorSet.ConvolImage(ho_yScaled, out ho_yDiffRow, hv_MaskRow, "continued");
                ho_yDiffCol.Dispose();
                HOperatorSet.ConvolImage(ho_yScaled, out ho_yDiffCol, hv_MaskCol, "continued");
                ho_zDiffRow.Dispose();
                HOperatorSet.ConvolImage(ho_zScaled, out ho_zDiffRow, hv_MaskRow, "continued");
                ho_zDiffCol.Dispose();
                HOperatorSet.ConvolImage(ho_zScaled, out ho_zDiffCol, hv_MaskCol, "continued");
                //
                //Calculate normal as cross product
                ho_ImageResult.Dispose();
                HOperatorSet.MultImage(ho_yDiffRow, ho_zDiffCol, out ho_ImageResult, 1.0, 0);
                ho_ImageResult2.Dispose();
                HOperatorSet.MultImage(ho_zDiffRow, ho_yDiffCol, out ho_ImageResult2, -1.0,
                    0);
                ho_NXRaw.Dispose();
                HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NXRaw, 1.0, 0);
                //
                ho_ImageResult.Dispose();
                HOperatorSet.MultImage(ho_xDiffRow, ho_zDiffCol, out ho_ImageResult, -1.0,
                    0);
                ho_ImageResult2.Dispose();
                HOperatorSet.MultImage(ho_zDiffRow, ho_xDiffCol, out ho_ImageResult2, 1.0,
                    0);
                ho_NYRaw.Dispose();
                HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NYRaw, 1.0, 0);
                //
                ho_ImageResult.Dispose();
                HOperatorSet.MultImage(ho_xDiffRow, ho_yDiffCol, out ho_ImageResult, 1.0, 0);
                ho_ImageResult2.Dispose();
                HOperatorSet.MultImage(ho_yDiffRow, ho_xDiffCol, out ho_ImageResult2, -1.0,
                    0);
                ho_NZRaw.Dispose();
                HOperatorSet.AddImage(ho_ImageResult, ho_ImageResult2, out ho_NZRaw, 1.0, 0);

                //Smooth
                //-> 5 is used as it is used in surface_normals_object_model_3d - 'xyz_mapping'
                if ((int)(hv_Smoothing) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MeanImage(ho_NXRaw, out ExpTmpOutVar_0, 5, 5);
                        ho_NXRaw.Dispose();
                        ho_NXRaw = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MeanImage(ho_NYRaw, out ExpTmpOutVar_0, 5, 5);
                        ho_NYRaw.Dispose();
                        ho_NYRaw = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MeanImage(ho_NZRaw, out ExpTmpOutVar_0, 5, 5);
                        ho_NZRaw.Dispose();
                        ho_NZRaw = ExpTmpOutVar_0;
                    }
                }

                //Normalize
                ho_NXSquare.Dispose();
                HOperatorSet.MultImage(ho_NXRaw, ho_NXRaw, out ho_NXSquare, 1.0, 0);
                ho_NYSquare.Dispose();
                HOperatorSet.MultImage(ho_NYRaw, ho_NYRaw, out ho_NYSquare, 1.0, 0);
                ho_NZSquare.Dispose();
                HOperatorSet.MultImage(ho_NZRaw, ho_NZRaw, out ho_NZSquare, 1.0, 0);
                ho_ImageResult1.Dispose();
                HOperatorSet.AddImage(ho_NXSquare, ho_NYSquare, out ho_ImageResult1, 1.0, 0);
                ho_ImageResult2.Dispose();
                HOperatorSet.AddImage(ho_ImageResult1, ho_NZSquare, out ho_ImageResult2, 1.0,
                    0);
                ho_SqrtImage.Dispose();
                HOperatorSet.SqrtImage(ho_ImageResult2, out ho_SqrtImage);
                //
                ho_NXImage.Dispose();
                HOperatorSet.DivImage(ho_NXRaw, ho_SqrtImage, out ho_NXImage, 1.0, 0);
                ho_NYImage.Dispose();
                HOperatorSet.DivImage(ho_NYRaw, ho_SqrtImage, out ho_NYImage, 1.0, 0);
                ho_NZImage.Dispose();
                HOperatorSet.DivImage(ho_NZRaw, ho_SqrtImage, out ho_NZImage, 1.0, 0);
                ho_xScaled.Dispose();
                ho_yScaled.Dispose();
                ho_zScaled.Dispose();
                ho_xDiffRow.Dispose();
                ho_xDiffCol.Dispose();
                ho_yDiffRow.Dispose();
                ho_yDiffCol.Dispose();
                ho_zDiffRow.Dispose();
                ho_zDiffCol.Dispose();
                ho_ImageResult.Dispose();
                ho_ImageResult2.Dispose();
                ho_NXRaw.Dispose();
                ho_NYRaw.Dispose();
                ho_NZRaw.Dispose();
                ho_NXSquare.Dispose();
                ho_NYSquare.Dispose();
                ho_NZSquare.Dispose();
                ho_ImageResult1.Dispose();
                ho_SqrtImage.Dispose();

                hv_Factor.Dispose();
                hv_MaskRow.Dispose();
                hv_MaskCol.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_xScaled.Dispose();
                ho_yScaled.Dispose();
                ho_zScaled.Dispose();
                ho_xDiffRow.Dispose();
                ho_xDiffCol.Dispose();
                ho_yDiffRow.Dispose();
                ho_yDiffCol.Dispose();
                ho_zDiffRow.Dispose();
                ho_zDiffCol.Dispose();
                ho_ImageResult.Dispose();
                ho_ImageResult2.Dispose();
                ho_NXRaw.Dispose();
                ho_NYRaw.Dispose();
                ho_NZRaw.Dispose();
                ho_NXSquare.Dispose();
                ho_NYSquare.Dispose();
                ho_NZSquare.Dispose();
                ho_ImageResult1.Dispose();
                ho_SqrtImage.Dispose();

                hv_Factor.Dispose();
                hv_MaskRow.Dispose();
                hv_MaskCol.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Calculate top-K error. 
        private void compute_top_k_error(HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions,
            HTuple hv_K, out HTuple hv_TopKError)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_PredictedClasses = new HTuple();
            // Initialize local and output iconic variables 
            hv_TopKError = new HTuple();
            try
            {
                //
                //This procedure calculates the top-K error out of the given predictions and labels.
                //
                hv_NumMatches.Dispose();
                hv_NumMatches = 0;
                //
                //Loop through all selected ground truth labels.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageLabelIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Get the K best results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_TopKPredictions.TupleSelect(hv_Index), "predictions",
                            out hv_Predictions);
                    }
                    hv_PredictedClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PredictedClasses = hv_Predictions.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    //Count how often the ground truth label
                    //and K predicted classes match.
                    if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_ImageLabelIDs.TupleSelect(
                        hv_Index)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumMatches = hv_NumMatches + 1;
                                hv_NumMatches.Dispose();
                                hv_NumMatches = ExpTmpLocalVar_NumMatches;
                            }
                        }
                    }
                }
                hv_TopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopKError = 1.0 - ((hv_NumMatches.TupleReal()
                        ) / (new HTuple(hv_ImageLabelIDs.TupleLength())));
                }
                //

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Compute a pose from a 3D point and orientation. 
        private void convert_dl_3d_gripping_point_to_pose(HTuple hv_X, HTuple hv_Y, HTuple hv_Z,
            HTuple hv_NX, HTuple hv_NY, HTuple hv_NZ, out HTuple hv_Pose)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Normal = new HTuple(), hv_Abs = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_ToolInCamY = new HTuple();
            HTuple hv_ToolInCamX = new HTuple(), hv_ToolInCamHRot = new HTuple();
            HTuple hv_ToolInCamPoseRot = new HTuple(), hv_HomMat3D = new HTuple();
            HTuple hv_Qx = new HTuple(), hv_Qy = new HTuple(), hv_Qz = new HTuple();
            // Initialize local and output iconic variables 
            hv_Pose = new HTuple();
            try
            {
                //Check for invalid points.
                if ((int)((new HTuple((new HTuple((new HTuple(hv_X.TupleEqual(0.0))).TupleAnd(
                    new HTuple(hv_Y.TupleEqual(0.0))))).TupleAnd(new HTuple(hv_Z.TupleEqual(
                    0.0))))).TupleOr((new HTuple((new HTuple(hv_NX.TupleEqual(0.0))).TupleAnd(
                    new HTuple(hv_NY.TupleEqual(0.0))))).TupleAnd(new HTuple(hv_NZ.TupleEqual(
                    0.0))))) != 0)
                {
                    hv_Pose.Dispose();
                    hv_Pose = new HTuple();

                    hv_Normal.Dispose();
                    hv_Abs.Dispose();
                    hv_Indices.Dispose();
                    hv_ToolInCamY.Dispose();
                    hv_ToolInCamX.Dispose();
                    hv_ToolInCamHRot.Dispose();
                    hv_ToolInCamPoseRot.Dispose();
                    hv_HomMat3D.Dispose();
                    hv_Qx.Dispose();
                    hv_Qy.Dispose();
                    hv_Qz.Dispose();

                    return;
                }
                //
                //Get rotation.
                hv_Normal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Normal = new HTuple();
                    hv_Normal = hv_Normal.TupleConcat(hv_NX, hv_NY, hv_NZ);
                }
                hv_Abs.Dispose();
                HOperatorSet.TupleFabs(hv_Normal, out hv_Abs);
                hv_Indices.Dispose();
                HOperatorSet.TupleSortIndex(hv_Abs, out hv_Indices);
                if (hv_ToolInCamY == null)
                    hv_ToolInCamY = new HTuple();
                hv_ToolInCamY[hv_Indices.TupleSelect(0)] = 0.0;
                if (hv_ToolInCamY == null)
                    hv_ToolInCamY = new HTuple();
                hv_ToolInCamY[hv_Indices.TupleSelect(1)] = -(hv_Normal.TupleSelect(hv_Indices.TupleSelect(
                    2)));
                if (hv_ToolInCamY == null)
                    hv_ToolInCamY = new HTuple();
                hv_ToolInCamY[hv_Indices.TupleSelect(2)] = hv_Normal.TupleSelect(hv_Indices.TupleSelect(
                    1));
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ToolInCamY = hv_ToolInCamY / (((((hv_ToolInCamY * hv_ToolInCamY)).TupleSum()
                            )).TupleSqrt());
                        hv_ToolInCamY.Dispose();
                        hv_ToolInCamY = ExpTmpLocalVar_ToolInCamY;
                    }
                }
                hv_ToolInCamX.Dispose();
                tuple_vector_cross_product(hv_ToolInCamY, hv_Normal, out hv_ToolInCamX);
                hv_ToolInCamHRot.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ToolInCamHRot = new HTuple();
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                        0));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                        0));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                        0));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                        1));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                        1));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                        1));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamX.TupleSelect(
                        2));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_ToolInCamY.TupleSelect(
                        2));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(hv_Normal.TupleSelect(
                        2));
                    hv_ToolInCamHRot = hv_ToolInCamHRot.TupleConcat(0.0);
                }
                hv_ToolInCamPoseRot.Dispose();
                HOperatorSet.HomMat3dToPose(hv_ToolInCamHRot, out hv_ToolInCamPoseRot);
                if (hv_ToolInCamPoseRot == null)
                    hv_ToolInCamPoseRot = new HTuple();
                hv_ToolInCamPoseRot[5] = 0.0;
                hv_HomMat3D.Dispose();
                HOperatorSet.PoseToHomMat3d(hv_ToolInCamPoseRot, out hv_HomMat3D);
                //
                //Get translation.
                hv_Qx.Dispose(); hv_Qy.Dispose(); hv_Qz.Dispose();
                HOperatorSet.AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, out hv_Qx, out hv_Qy,
                    out hv_Qz);
                hv_Pose.Dispose();
                hv_Pose = new HTuple(hv_ToolInCamPoseRot);
                if (hv_Pose == null)
                    hv_Pose = new HTuple();
                hv_Pose[0] = hv_X - hv_Qx;
                if (hv_Pose == null)
                    hv_Pose = new HTuple();
                hv_Pose[1] = hv_Y - hv_Qy;
                if (hv_Pose == null)
                    hv_Pose = new HTuple();
                hv_Pose[2] = hv_Z - hv_Qz;

                hv_Normal.Dispose();
                hv_Abs.Dispose();
                hv_Indices.Dispose();
                hv_ToolInCamY.Dispose();
                hv_ToolInCamX.Dispose();
                hv_ToolInCamHRot.Dispose();
                hv_ToolInCamPoseRot.Dispose();
                hv_HomMat3D.Dispose();
                hv_Qx.Dispose();
                hv_Qy.Dispose();
                hv_Qz.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Normal.Dispose();
                hv_Abs.Dispose();
                hv_Indices.Dispose();
                hv_ToolInCamY.Dispose();
                hv_ToolInCamX.Dispose();
                hv_ToolInCamHRot.Dispose();
                hv_ToolInCamPoseRot.Dispose();
                hv_HomMat3D.Dispose();
                hv_Qx.Dispose();
                hv_Qy.Dispose();
                hv_Qz.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: This procedure converts Deep OCR Detection results to an Object Detection results. 
        public void convert_ocr_detection_result_to_object_detection(HTuple hv_OcrResults,
            out HTuple hv_DetectionResults)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Index = new HTuple(), hv_OcrResult = new HTuple();
            HTuple hv_RequiredKeysExist = new HTuple(), hv_DetectionResult = new HTuple();
            HTuple hv___Tmp_Ctrl_Type = new HTuple();
            // Initialize local and output iconic variables 
            hv_DetectionResults = new HTuple();
            try
            {
                //
                //Convert Deep OCR Detection results
                //to Object Detection results.
                //
                //Create DetectionResults Dict
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DetectionResults.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_OcrResults.TupleLength()), HTuple.TupleConstant(
                        "HNULL"), out hv_DetectionResults);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_OcrResults.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_OcrResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OcrResult = hv_OcrResults.TupleSelect(
                            hv_Index);
                    }
                    //Check if input is valid
                    hv_RequiredKeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_OcrResult, "key_exists", "words", out hv_RequiredKeysExist);
                    if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
                        )))) != 0)
                    {
                        throw new HalconException(("The item at Index " + hv_Index) + " is not a valid Deep OCR Detection Result");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RequiredKeysExist.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_exists",
                            ((((new HTuple("row")).TupleConcat("col")).TupleConcat("phi")).TupleConcat(
                            "length1")).TupleConcat("length2"), out hv_RequiredKeysExist);
                    }
                    if ((int)(new HTuple(((hv_RequiredKeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_RequiredKeysExist.TupleLength()
                        )))) != 0)
                    {
                        throw new HalconException(("The item at Index " + hv_Index) + " is not a valid Deep OCR Detection Result");
                    }
                    //Convert ocr detection result to object detection
                    hv_DetectionResult.Dispose();
                    HOperatorSet.CreateDict(out hv_DetectionResult);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                            "row", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                                "row"), hv_DetectionResult, "bbox_row");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_row", ((hv_OcrResult.TupleGetDictTuple(
                                "words"))).TupleGetDictTuple("row"));
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                            "col", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                                "col"), hv_DetectionResult, "bbox_col");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_col", ((hv_OcrResult.TupleGetDictTuple(
                                "words"))).TupleGetDictTuple("col"));
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                            "phi", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                                "phi"), hv_DetectionResult, "bbox_phi");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_phi", ((hv_OcrResult.TupleGetDictTuple(
                                "words"))).TupleGetDictTuple("phi"));
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                            "length1", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                                "length1"), hv_DetectionResult, "bbox_length1");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length1", ((hv_OcrResult.TupleGetDictTuple(
                                "words"))).TupleGetDictTuple("length1"));
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_OcrResult.TupleGetDictTuple("words"), "key_data_type",
                            "length2", out hv___Tmp_Ctrl_Type);
                    }
                    if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(((hv_OcrResult.TupleGetDictTuple("words"))).TupleGetDictObject(
                                "length2"), hv_DetectionResult, "bbox_length2");
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_length2", ((hv_OcrResult.TupleGetDictTuple(
                                "words"))).TupleGetDictTuple("length2"));
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_confidence", HTuple.TupleGenConst(
                            new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
                            ), 1.0));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DetectionResult, "bbox_class_id", HTuple.TupleGenConst(
                            new HTuple(((hv_DetectionResult.TupleGetDictTuple("bbox_row"))).TupleLength()
                            ), 0));
                    }
                    if (hv_DetectionResults == null)
                        hv_DetectionResults = new HTuple();
                    hv_DetectionResults[hv_Index] = hv_DetectionResult;
                }



                hv_Index.Dispose();
                hv_OcrResult.Dispose();
                hv_RequiredKeysExist.Dispose();
                hv_DetectionResult.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Index.Dispose();
                hv_OcrResult.Dispose();
                hv_RequiredKeysExist.Dispose();
                hv_DetectionResult.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tools / Geometry
        // Short Description: Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points. 
        private void convert_rect2_5to8param(HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1,
            HTuple hv_Length2, HTuple hv_Phi, out HTuple hv_Row1, out HTuple hv_Col1, out HTuple hv_Row2,
            out HTuple hv_Col2, out HTuple hv_Row3, out HTuple hv_Col3, out HTuple hv_Row4,
            out HTuple hv_Col4)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Co1 = new HTuple(), hv_Co2 = new HTuple();
            HTuple hv_Si1 = new HTuple(), hv_Si2 = new HTuple();
            // Initialize local and output iconic variables 
            hv_Row1 = new HTuple();
            hv_Col1 = new HTuple();
            hv_Row2 = new HTuple();
            hv_Col2 = new HTuple();
            hv_Row3 = new HTuple();
            hv_Col3 = new HTuple();
            hv_Row4 = new HTuple();
            hv_Col4 = new HTuple();
            try
            {
                //This procedure takes the parameters for a rectangle of type 'rectangle2'
                //and returns the coordinates of the four corners.
                //
                hv_Co1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Co1 = (hv_Phi.TupleCos()
                        ) * hv_Length1;
                }
                hv_Co2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Co2 = (hv_Phi.TupleCos()
                        ) * hv_Length2;
                }
                hv_Si1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Si1 = (hv_Phi.TupleSin()
                        ) * hv_Length1;
                }
                hv_Si2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Si2 = (hv_Phi.TupleSin()
                        ) * hv_Length2;
                }

                hv_Col1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Col1 = (hv_Co1 - hv_Si2) + hv_Col;
                }
                hv_Row1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row1 = ((-hv_Si1) - hv_Co2) + hv_Row;
                }
                hv_Col2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Col2 = ((-hv_Co1) - hv_Si2) + hv_Col;
                }
                hv_Row2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row2 = (hv_Si1 - hv_Co2) + hv_Row;
                }
                hv_Col3.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Col3 = ((-hv_Co1) + hv_Si2) + hv_Col;
                }
                hv_Row3.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row3 = (hv_Si1 + hv_Co2) + hv_Row;
                }
                hv_Col4.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Col4 = (hv_Co1 + hv_Si2) + hv_Col;
                }
                hv_Row4.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row4 = ((-hv_Si1) + hv_Co2) + hv_Row;
                }


                hv_Co1.Dispose();
                hv_Co2.Dispose();
                hv_Si1.Dispose();
                hv_Si2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Co1.Dispose();
                hv_Co2.Dispose();
                hv_Si1.Dispose();
                hv_Si2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tools / Geometry
        // Short Description: Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2. 
        private void convert_rect2_8to5param(HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2,
            HTuple hv_Col2, HTuple hv_Row3, HTuple hv_Col3, HTuple hv_Row4, HTuple hv_Col4,
            HTuple hv_ForceL1LargerL2, out HTuple hv_Row, out HTuple hv_Col, out HTuple hv_Length1,
            out HTuple hv_Length2, out HTuple hv_Phi)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Hor = new HTuple(), hv_Vert = new HTuple();
            HTuple hv_IdxSwap = new HTuple(), hv_Tmp = new HTuple();
            // Initialize local and output iconic variables 
            hv_Row = new HTuple();
            hv_Col = new HTuple();
            hv_Length1 = new HTuple();
            hv_Length2 = new HTuple();
            hv_Phi = new HTuple();
            try
            {
                //This procedure takes the corners of four-sided figures
                //and returns the parameters of type 'rectangle2'.
                //
                //Calculate center row and column.
                hv_Row.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Row = (((hv_Row1 + hv_Row2) + hv_Row3) + hv_Row4) / 4.0;
                }
                hv_Col.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Col = (((hv_Col1 + hv_Col2) + hv_Col3) + hv_Col4) / 4.0;
                }
                //Length1 and Length2.
                hv_Length1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length1 = (((((hv_Row1 - hv_Row2) * (hv_Row1 - hv_Row2)) + ((hv_Col1 - hv_Col2) * (hv_Col1 - hv_Col2)))).TupleSqrt()
                        ) / 2.0;
                }
                hv_Length2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length2 = (((((hv_Row2 - hv_Row3) * (hv_Row2 - hv_Row3)) + ((hv_Col2 - hv_Col3) * (hv_Col2 - hv_Col3)))).TupleSqrt()
                        ) / 2.0;
                }
                //Calculate the angle phi.
                hv_Hor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Hor = hv_Col1 - hv_Col2;
                }
                hv_Vert.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Vert = hv_Row2 - hv_Row1;
                }
                if ((int)(hv_ForceL1LargerL2) != 0)
                {
                    //Swap length1 and length2 if necessary.
                    hv_IdxSwap.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IdxSwap = ((((hv_Length2 - hv_Length1)).TupleGreaterElem(
                            1e-9))).TupleFind(1);
                    }
                    if ((int)(new HTuple(hv_IdxSwap.TupleNotEqual(-1))) != 0)
                    {
                        hv_Tmp.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Tmp = hv_Length1.TupleSelect(
                                hv_IdxSwap);
                        }
                        if (hv_Length1 == null)
                            hv_Length1 = new HTuple();
                        hv_Length1[hv_IdxSwap] = hv_Length2.TupleSelect(hv_IdxSwap);
                        if (hv_Length2 == null)
                            hv_Length2 = new HTuple();
                        hv_Length2[hv_IdxSwap] = hv_Tmp;
                        if (hv_Hor == null)
                            hv_Hor = new HTuple();
                        hv_Hor[hv_IdxSwap] = (hv_Col2.TupleSelect(hv_IdxSwap)) - (hv_Col3.TupleSelect(
                            hv_IdxSwap));
                        if (hv_Vert == null)
                            hv_Vert = new HTuple();
                        hv_Vert[hv_IdxSwap] = (hv_Row3.TupleSelect(hv_IdxSwap)) - (hv_Row2.TupleSelect(
                            hv_IdxSwap));
                    }
                }
                hv_Phi.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Phi = hv_Vert.TupleAtan2(
                        hv_Hor);
                }
                //

                hv_Hor.Dispose();
                hv_Vert.Dispose();
                hv_IdxSwap.Dispose();
                hv_Tmp.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Hor.Dispose();
                hv_Vert.Dispose();
                hv_IdxSwap.Dispose();
                hv_Tmp.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Create a dictionary with preprocessing parameters. 
        public void create_dl_preprocess_param(HTuple hv_DLModelType, HTuple hv_ImageWidth,
            HTuple hv_ImageHeight, HTuple hv_ImageNumChannels, HTuple hv_ImageRangeMin,
            HTuple hv_ImageRangeMax, HTuple hv_NormalizationType, HTuple hv_DomainHandling,
            HTuple hv_IgnoreClassIDs, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground,
            HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
        {



            // Local control variables 

            HTuple hv_GenParamNames = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_KeysExist = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_IsInstanceSegmentation = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLPreprocessParam = new HTuple();
            try
            {
                //
                //This procedure creates a dictionary with all parameters needed for preprocessing.
                //
                hv_DLPreprocessParam.Dispose();
                HOperatorSet.CreateDict(out hv_DLPreprocessParam);
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "model_type", hv_DLModelType);
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_width", hv_ImageWidth);
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_height", hv_ImageHeight);
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_num_channels", hv_ImageNumChannels);
                if ((int)(new HTuple(hv_ImageRangeMin.TupleEqual(new HTuple()))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", -127);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", hv_ImageRangeMin);
                }
                if ((int)(new HTuple(hv_ImageRangeMax.TupleEqual(new HTuple()))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", 128);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", hv_ImageRangeMax);
                }
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", hv_NormalizationType);
                //Replace possible legacy parameters.
                replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "domain_handling", hv_DomainHandling);
                //
                //Set segmentation and '3d_gripping_point_detection' parameters.
                if ((int)((new HTuple(hv_DLModelType.TupleEqual("segmentation"))).TupleOr(new HTuple(hv_DLModelType.TupleEqual(
                    "3d_gripping_point_detection")))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", hv_IgnoreClassIDs);
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "set_background_id", hv_SetBackgroundID);
                    HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "class_ids_background", hv_ClassIDsBackground);
                }
                //
                //Set default values of generic parameters.
                HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "augmentation", "false");
                //
                //Set generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamNames.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GenParamValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamNames.TupleSelect(hv_GenParamIndex),
                                out hv_GenParamValue);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, hv_GenParamNames.TupleSelect(
                                hv_GenParamIndex), hv_GenParamValue);
                        }
                    }
                }
                //
                //Set necessary default values.
                if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
                {
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", ((new HTuple("instance_type")).TupleConcat(
                        "ignore_direction")).TupleConcat("instance_segmentation"), out hv_KeysExist);
                    if ((int)(((hv_KeysExist.TupleSelect(0))).TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "instance_type", "rectangle1");
                    }
                    //Set default for 'ignore_direction' only if instance_type is 'rectangle2'.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "instance_type", out hv_InstanceType);
                    if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                        ((hv_KeysExist.TupleSelect(1))).TupleNot())) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "ignore_direction", 0);
                    }
                    //In case of instance_segmentation we overwrite the instance_type to mask.
                    if ((int)(hv_KeysExist.TupleSelect(2)) != 0)
                    {
                        hv_IsInstanceSegmentation.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "instance_segmentation",
                            out hv_IsInstanceSegmentation);
                        if ((int)(new HTuple((new HTuple(((((new HTuple(1)).TupleConcat(0)).TupleConcat(
                            "true")).TupleConcat("false")).TupleFind(hv_IsInstanceSegmentation))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid generic parameter for 'instance_segmentation': " + hv_IsInstanceSegmentation) + new HTuple(", only true and false are allowed"));
                        }
                        if ((int)((new HTuple(hv_IsInstanceSegmentation.TupleEqual("true"))).TupleOr(
                            new HTuple(hv_IsInstanceSegmentation.TupleEqual(1)))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "instance_type", "mask");
                        }
                    }
                }
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //

                hv_GenParamNames.Dispose();
                hv_GenParamIndex.Dispose();
                hv_GenParamValue.Dispose();
                hv_KeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParamNames.Dispose();
                hv_GenParamIndex.Dispose();
                hv_GenParamValue.Dispose();
                hv_KeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Create a dictionary with the preprocessing parameters based on a given DL model. 
        public void create_dl_preprocess_param_from_model(HTuple hv_DLModelHandle, HTuple hv_NormalizationType,
            HTuple hv_DomainHandling, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground,
            HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_IgnoreClassIDs = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_IsInstanceSegmentation = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_ClassIDsNoOrientation = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

            // Initialize local and output iconic variables 
            hv_DLPreprocessParam = new HTuple();
            try
            {
                //
                //This procedure creates a dictionary with all parameters needed for preprocessing
                //according to a model provided through DLModelHandle.
                //
                //Get the relevant model parameters.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_ImageNumChannels);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_max", out hv_ImageRangeMax);
                hv_IgnoreClassIDs.Dispose();
                hv_IgnoreClassIDs = new HTuple();
                //
                //Get model specific parameters.
                if ((int)((new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    //No specific parameters for both anomaly detection
                    //and Global Context Anomaly Detection model types.
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    //No classification specific parameters.
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    //Get detection specific parameters.
                    //If GenParam has not been created yet, create it to add new generic parameters.
                    if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        hv_GenParam_COPY_INP_TMP.Dispose();
                        HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                    }
                    //Add instance_type.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    //If the model can do instance segmentation, the preprocessing instance_type
                    //needs to be 'mask'.
                    hv_IsInstanceSegmentation.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_segmentation", out hv_IsInstanceSegmentation);
                    if ((int)(new HTuple(hv_IsInstanceSegmentation.TupleEqual("true"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "instance_type", "mask");
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "instance_type", hv_InstanceType);
                    }
                    //For instance_type 'rectangle2', add the boolean ignore_direction and class IDs without orientation.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "ignore_direction",
                                1);
                        }
                        else if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "ignore_direction",
                                0);
                        }
                        hv_ClassIDsNoOrientation.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids_no_orientation",
                            out hv_ClassIDsNoOrientation);
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "class_ids_no_orientation",
                            hv_ClassIDsNoOrientation);
                    }
                }
                else if ((int)((new HTuple(hv_ModelType.TupleEqual("ocr_detection"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("ocr_recognition")))) != 0)
                {
                    //No ocr specific parameters.
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    //Get segmentation specific parameters.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_IgnoreClassIDs);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    //The input image is expected to be a single channel image.
                    hv_ImageNumChannels.Dispose();
                    hv_ImageNumChannels = 1;
                }
                else
                {
                    throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
                }
                //
                //Create the dictionary with the preprocessing parameters returned by this procedure.
                hv_DLPreprocessParam.Dispose();
                create_dl_preprocess_param(hv_ModelType, hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels,
                    hv_ImageRangeMin, hv_ImageRangeMax, hv_NormalizationType, hv_DomainHandling,
                    hv_IgnoreClassIDs, hv_SetBackgroundID, hv_ClassIDsBackground, hv_GenParam_COPY_INP_TMP,
                    out hv_DLPreprocessParam);
                //

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Create a training parameter dictionary which is used in train_dl_model. 
        public void create_dl_train_param(HTuple hv_DLModelHandle, HTuple hv_NumEpochs,
            HTuple hv_EvaluationIntervalEpochs, HTuple hv_EnableDisplay, HTuple hv_RandomSeed,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, out HTuple hv_TrainParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_AvailableGenParam = new HTuple();
            HTuple hv_IndexGenParam = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_TrainParamAnomaly = new HTuple();
            HTuple hv_DomainRatioKeyExists = new HTuple(), hv_ErrorThresholdKeyExists = new HTuple();
            HTuple hv_RegularizationNoiseKeyExists = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_EvaluateBeforeTrain = new HTuple();
            HTuple hv_EvaluationParam = new HTuple(), hv_AugmentationParam = new HTuple();
            HTuple hv_ClassIDsNoOrientation = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_ChangeStrategies = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_SerializationStrategy = new HTuple(), hv_SerializationStrategies = new HTuple();
            HTuple hv_Seconds = new HTuple(), hv_SetDisplayParam = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_ConvertToMean = new HTuple();
            HTuple hv_Index = new HTuple(), hv_FoundIndices = new HTuple();
            HTuple hv_EnableDisplay_COPY_INP_TMP = new HTuple(hv_EnableDisplay);
            HTuple hv_RandomSeed_COPY_INP_TMP = new HTuple(hv_RandomSeed);

            // Initialize local and output iconic variables 
            hv_TrainParam = new HTuple();
            try
            {
                //
                //This procedure creates a dictionary with all needed training parameters,
                //as required by train_dl_model as input.
                //
                //Check length of input GenParam tuple.
                if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
                    new HTuple(hv_GenParamValue.TupleLength())))) != 0)
                {
                    throw new HalconException("GenParamName and GenParamValue have to have the same length.");
                }
                //
                //Some default parameters depend on model type.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual(
                    "anomaly_detection"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("classification"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "gc_anomaly_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "ocr_recognition"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("segmentation"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "3d_gripping_point_detection")))) != 0)
                {
                    throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
                }
                //
                //Check if the given GenParamName strings are available.
                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))) != 0)
                {
                    hv_AvailableGenParam.Dispose();
                    hv_AvailableGenParam = new HTuple();
                    hv_AvailableGenParam[0] = "evaluate";
                    hv_AvailableGenParam[1] = "augment";
                    hv_AvailableGenParam[2] = "change";
                    hv_AvailableGenParam[3] = "serialize";
                    hv_AvailableGenParam[4] = "display";
                    hv_AvailableGenParam[5] = "evaluate_before_train";
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                    {
                        hv_AvailableGenParam.Dispose();
                        hv_AvailableGenParam = new HTuple();
                        hv_AvailableGenParam[0] = "augment";
                        hv_AvailableGenParam[1] = "change";
                        hv_AvailableGenParam[2] = "serialize";
                        hv_AvailableGenParam[3] = "display";
                    }
                }
                else
                {
                    hv_AvailableGenParam.Dispose();
                    hv_AvailableGenParam = "anomaly";
                }
                for (hv_IndexGenParam = 0; (int)hv_IndexGenParam <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
                {
                    hv_IndexFind.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndexFind = hv_AvailableGenParam.TupleFind(
                            hv_GenParamName.TupleSelect(hv_IndexGenParam));
                    }
                    if ((int)(new HTuple(hv_IndexFind.TupleEqual(-1))) != 0)
                    {
                        throw new HalconException(("The provided GenParamName " + (hv_GenParamName.TupleSelect(
                            hv_IndexGenParam))) + " is invalid.");
                    }
                }
                //
                //Check if display is enabled.
                hv_IsString.Dispose();
                HOperatorSet.TupleIsString(hv_EnableDisplay_COPY_INP_TMP, out hv_IsString);
                if ((int)(hv_IsString) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
                                "true"));
                            hv_EnableDisplay_COPY_INP_TMP.Dispose();
                            hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
                                1));
                            hv_EnableDisplay_COPY_INP_TMP.Dispose();
                            hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
                        }
                    }
                }
                //
                //Initialize the dictionary holding the training parameters.
                hv_TrainParam.Dispose();
                HOperatorSet.CreateDict(out hv_TrainParam);
                //
                //** User supplied parameters: ***
                //
                //Set training parameters for anomaly detection models.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_TrainParamAnomaly.Dispose();
                    get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "anomaly", out hv_TrainParamAnomaly);
                    //Set default values in case no values are provided.
                    if ((int)(new HTuple(hv_TrainParamAnomaly.TupleEqual(new HTuple()))) != 0)
                    {
                        hv_TrainParamAnomaly.Dispose();
                        HOperatorSet.CreateDict(out hv_TrainParamAnomaly);
                    }
                    hv_DomainRatioKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "domain_ratio",
                        out hv_DomainRatioKeyExists);
                    if ((int)(hv_DomainRatioKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "domain_ratio", 0.1);
                    }
                    hv_ErrorThresholdKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "error_threshold",
                        out hv_ErrorThresholdKeyExists);
                    if ((int)(hv_ErrorThresholdKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "error_threshold", 0.001);
                    }
                    hv_RegularizationNoiseKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "regularization_noise",
                        out hv_RegularizationNoiseKeyExists);
                    if ((int)(hv_RegularizationNoiseKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "regularization_noise",
                            0.0001);
                    }
                    //
                    HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "max_num_epochs", hv_NumEpochs);
                    HOperatorSet.SetDictTuple(hv_TrainParam, "anomaly_param", hv_TrainParamAnomaly);
                    hv_DisplayParam.Dispose();
                    HOperatorSet.CreateDict(out hv_DisplayParam);
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "enabled", hv_EnableDisplay_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_TrainParam, "display_param", hv_DisplayParam);

                    hv_EnableDisplay_COPY_INP_TMP.Dispose();
                    hv_RandomSeed_COPY_INP_TMP.Dispose();
                    hv_ModelType.Dispose();
                    hv_AvailableGenParam.Dispose();
                    hv_IndexGenParam.Dispose();
                    hv_IndexFind.Dispose();
                    hv_IsString.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatioKeyExists.Dispose();
                    hv_ErrorThresholdKeyExists.Dispose();
                    hv_RegularizationNoiseKeyExists.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_EvaluateBeforeTrain.Dispose();
                    hv_EvaluationParam.Dispose();
                    hv_AugmentationParam.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_Exception.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_Indices.Dispose();
                    hv_SerializationStrategy.Dispose();
                    hv_SerializationStrategies.Dispose();
                    hv_Seconds.Dispose();
                    hv_SetDisplayParam.Dispose();
                    hv_EvaluationComparisonKeys.Dispose();
                    hv_ConvertToMean.Dispose();
                    hv_Index.Dispose();
                    hv_FoundIndices.Dispose();

                    return;
                }
                //
                //Set training parameters for all model types except 'anomaly_detection'.
                //
                //Number of epochs to train the model on the train split of the dataset.
                HOperatorSet.SetDictTuple(hv_TrainParam, "num_epochs", hv_NumEpochs);
                //
                //Interval (in epochs) to evaluate the model on the validation split of the dataset.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                {
                    //For models of type 'gc_anomaly_detection' no evaluation can be done.
                    HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_interval_epochs", 0);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_interval_epochs", hv_EvaluationIntervalEpochs);
                }
                //
                //Transfer the parameter defining if an evaluation before training is to be done.
                hv_EvaluateBeforeTrain.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "evaluate_before_train",
                    out hv_EvaluateBeforeTrain);
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluate_before_train", hv_EvaluateBeforeTrain);
                //
                //Transfer evaluation parameters used in further steps.
                hv_EvaluationParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "evaluate", out hv_EvaluationParam);
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_param", hv_EvaluationParam);
                //
                //Transfer augmentation parameters used in further steps.
                hv_AugmentationParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "augment", out hv_AugmentationParam);
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    //In addition, add class IDs without orientation, since these classes require
                    //special treatment during the augmentation.
                    try
                    {
                        hv_ClassIDsNoOrientation.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids_no_orientation",
                            out hv_ClassIDsNoOrientation);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_ClassIDsNoOrientation.Dispose();
                        hv_ClassIDsNoOrientation = new HTuple();
                    }
                    if ((int)(new HTuple((new HTuple(hv_ClassIDsNoOrientation.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(hv_AugmentationParam.TupleEqual(new HTuple()))) != 0)
                        {
                            hv_AugmentationParam.Dispose();
                            HOperatorSet.CreateDict(out hv_AugmentationParam);
                        }
                        HOperatorSet.SetDictTuple(hv_AugmentationParam, "class_ids_no_orientation",
                            hv_ClassIDsNoOrientation);
                    }
                }
                HOperatorSet.SetDictTuple(hv_TrainParam, "augmentation_param", hv_AugmentationParam);
                //
                //Change strategies for any parameters that need to be changed during training.
                hv_ChangeStrategies.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "change", out hv_ChangeStrategies);
                HOperatorSet.SetDictTuple(hv_TrainParam, "change_strategies", hv_ChangeStrategies);
                //
                //Serialization strategies used during training.
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_GenParamName.TupleFind(
                        "serialize");
                }
                if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(0))).TupleOr(
                    new HTuple(hv_Indices.TupleEqual(-1)))) != 0)
                {
                    //Set a default in case no value is provided.
                    hv_SerializationStrategy.Dispose();
                    HOperatorSet.CreateDict(out hv_SerializationStrategy);
                    HOperatorSet.SetDictTuple(hv_SerializationStrategy, "type", "best");
                    HOperatorSet.SetDictTuple(hv_SerializationStrategy, "basename", "model_best");
                    hv_SerializationStrategies.Dispose();
                    hv_SerializationStrategies = new HTuple(hv_SerializationStrategy);
                }
                else
                {
                    //Set user provided values.
                    hv_SerializationStrategies.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SerializationStrategies = hv_GenParamValue.TupleSelect(
                            hv_Indices);
                    }
                }
                HOperatorSet.SetDictTuple(hv_TrainParam, "serialization_strategies", hv_SerializationStrategies);
                //
                //Get random seed or set a useful default value.
                if ((int)(new HTuple((new HTuple(hv_RandomSeed_COPY_INP_TMP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_RandomSeed_COPY_INP_TMP);
                }
                else
                {
                    //If no random seed is given we will use system time as a default.
                    hv_Seconds.Dispose();
                    HOperatorSet.CountSeconds(out hv_Seconds);
                    hv_RandomSeed_COPY_INP_TMP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RandomSeed_COPY_INP_TMP = hv_Seconds.TupleInt()
                            ;
                    }
                    HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_RandomSeed_COPY_INP_TMP);
                }
                //
                //** Display parameters: ***
                //
                //Create display parameter dictionary.
                hv_SetDisplayParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "display", out hv_SetDisplayParam);
                if ((int)(new HTuple(hv_SetDisplayParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_DisplayParam.Dispose();
                    hv_DisplayParam = new HTuple(hv_SetDisplayParam);
                }
                else
                {
                    hv_DisplayParam.Dispose();
                    HOperatorSet.CreateDict(out hv_DisplayParam);
                }
                //
                HOperatorSet.SetDictTuple(hv_DisplayParam, "enabled", hv_EnableDisplay_COPY_INP_TMP);
                HOperatorSet.SetDictTuple(hv_TrainParam, "display_param", hv_DisplayParam);
                //
                //** Generic internal defaults: ***
                //
                //Default update interval (in seconds) of TrainInfo calculation and text/plot updates
                //in case display is enabled.
                HOperatorSet.SetDictTuple(hv_TrainParam, "update_interval_seconds", 2);
                //
                //Evaluation comparison keys. Note, that internally only those keys apply which
                //are really available. No error is thrown as long as a valid key is given.
                //Hence, we use the major defaults here for classification ('top1_error'),
                //for detection ('mean_ap'), and for segmentation ('mean_iou') if no valid key
                //is given.
                hv_EvaluationComparisonKeys.Dispose();
                hv_EvaluationComparisonKeys = new HTuple();
                //
                try
                {
                    hv_EvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationParam, "measures", out hv_EvaluationComparisonKeys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                if ((int)(new HTuple(hv_EvaluationComparisonKeys.TupleEqual(new HTuple()))) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "top1_error";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "mean_ap";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "none";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "f_score";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "accuracy";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "mean_iou";
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "mean_iou";
                    }
                }

                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))) != 0)
                {
                    //If the evaluation metric is 'precision', 'recall', 'f_score', or
                    //'soap' we always take the mean value.
                    hv_ConvertToMean.Dispose();
                    hv_ConvertToMean = new HTuple();
                    hv_ConvertToMean[0] = "precision";
                    hv_ConvertToMean[1] = "recall";
                    hv_ConvertToMean[2] = "f_score";
                    hv_ConvertToMean[3] = "soap";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ConvertToMean.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_FoundIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FoundIndices = ((hv_EvaluationComparisonKeys.TupleEqualElem(
                                hv_ConvertToMean.TupleSelect(hv_Index)))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_FoundIndices.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_EvaluationComparisonKeys == null)
                                hv_EvaluationComparisonKeys = new HTuple();
                            hv_EvaluationComparisonKeys[hv_FoundIndices] = "mean_" + (hv_EvaluationComparisonKeys.TupleSelect(
                                hv_FoundIndices));
                            if ((int)(new HTuple(((hv_ConvertToMean.TupleSelect(hv_Index))).TupleEqual(
                                "soap"))) != 0)
                            {
                                if (hv_EvaluationComparisonKeys == null)
                                    hv_EvaluationComparisonKeys = new HTuple();
                                hv_EvaluationComparisonKeys[hv_FoundIndices] = (hv_EvaluationComparisonKeys.TupleSelect(
                                    hv_FoundIndices)) + "_tp";
                            }
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_comparison_keys", hv_EvaluationComparisonKeys);
                //
                //Number of samples used to average the loss during training. Note, this is used for display
                //and information calculation only and does not have an effect on training the model.
                HOperatorSet.SetDictTuple(hv_TrainParam, "num_samples_mean_loss", 1000);
                //

                hv_EnableDisplay_COPY_INP_TMP.Dispose();
                hv_RandomSeed_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_AvailableGenParam.Dispose();
                hv_IndexGenParam.Dispose();
                hv_IndexFind.Dispose();
                hv_IsString.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatioKeyExists.Dispose();
                hv_ErrorThresholdKeyExists.Dispose();
                hv_RegularizationNoiseKeyExists.Dispose();
                hv_DisplayParam.Dispose();
                hv_EvaluateBeforeTrain.Dispose();
                hv_EvaluationParam.Dispose();
                hv_AugmentationParam.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_Exception.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Indices.Dispose();
                hv_SerializationStrategy.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_Seconds.Dispose();
                hv_SetDisplayParam.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_ConvertToMean.Dispose();
                hv_Index.Dispose();
                hv_FoundIndices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EnableDisplay_COPY_INP_TMP.Dispose();
                hv_RandomSeed_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_AvailableGenParam.Dispose();
                hv_IndexGenParam.Dispose();
                hv_IndexFind.Dispose();
                hv_IsString.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatioKeyExists.Dispose();
                hv_ErrorThresholdKeyExists.Dispose();
                hv_RegularizationNoiseKeyExists.Dispose();
                hv_DisplayParam.Dispose();
                hv_EvaluateBeforeTrain.Dispose();
                hv_EvaluationParam.Dispose();
                hv_AugmentationParam.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_Exception.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Indices.Dispose();
                hv_SerializationStrategy.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_Seconds.Dispose();
                hv_SetDisplayParam.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_ConvertToMean.Dispose();
                hv_Index.Dispose();
                hv_FoundIndices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
        public void create_evaluation_default_param(HTuple hv_EvaluationType, HTuple hv_ClassIDsModel,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AvailableEvaluationTypes = new HTuple();
            HTuple hv_EvaluationTypesStr = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_EvaluateInstances = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_GrippingPointParams = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple();
            HTuple hv_ClassIDsModel_COPY_INP_TMP = new HTuple(hv_ClassIDsModel);

            // Initialize local and output iconic variables 
            hv_EvalParams = new HTuple();
            try
            {
                //
                //This procedure generates a dictionary EvalParams,
                //which contains default values for evaluation parameters.
                //Depending on the evaluation type, the corresponding default parameters and values are set.
                //The class IDs that the model can predict must be given via ClassIDsModel.
                //
                //Check inputs.
                hv_AvailableEvaluationTypes.Dispose();
                hv_AvailableEvaluationTypes = new HTuple();
                hv_AvailableEvaluationTypes[0] = "3d_gripping_point_detection";
                hv_AvailableEvaluationTypes[1] = "anomaly_detection";
                hv_AvailableEvaluationTypes[2] = "classification";
                hv_AvailableEvaluationTypes[3] = "detection";
                hv_AvailableEvaluationTypes[4] = "gc_anomaly_detection";
                hv_AvailableEvaluationTypes[5] = "ocr_detection";
                hv_AvailableEvaluationTypes[6] = "ocr_recognition";
                hv_AvailableEvaluationTypes[7] = "segmentation";
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EvaluationTypesStr.Dispose();
                    HOperatorSet.TupleGenConst((2 * (new HTuple(hv_AvailableEvaluationTypes.TupleLength()
                        ))) - 1, new HTuple("','"), out hv_EvaluationTypesStr);
                }
                if (hv_EvaluationTypesStr == null)
                    hv_EvaluationTypesStr = new HTuple();
                hv_EvaluationTypesStr[HTuple.TupleGenSequence(0, new HTuple(hv_EvaluationTypesStr.TupleLength()
                    ), 2)] = hv_AvailableEvaluationTypes;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
                            ;
                        hv_EvaluationTypesStr.Dispose();
                        hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
                    }
                }
                hv_Indices.Dispose();
                HOperatorSet.TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, out hv_Indices);
                if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                    new HTuple())))) != 0)
                {
                    throw new HalconException(((("Unknown evaluation_type: " + hv_EvaluationType) + ". Choose one of ['") + hv_EvaluationTypesStr) + "']");
                }
                //
                if ((int)(new HTuple((new HTuple(hv_ClassIDsModel_COPY_INP_TMP.TupleLength()
                    )).TupleLess(1))) != 0)
                {
                    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                    {
                        hv_ClassIDsModel_COPY_INP_TMP.Dispose();
                        hv_ClassIDsModel_COPY_INP_TMP = 0;
                    }
                    else
                    {
                        throw new HalconException("ClassIDsModel should have at least one entry");
                    }
                }
                //
                //Initialize EvalParams.
                hv_EvalParams.Dispose();
                HOperatorSet.CreateDict(out hv_EvalParams);
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                //
                //Set the class IDs.
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel_COPY_INP_TMP);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel_COPY_INP_TMP.TupleLength()
                        ));
                }
                //
                //Set specific parameters depending on the evaluation type.
                hv_EvaluateInstances.Dispose();
                hv_EvaluateInstances = 0;
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    //
                    //Set default 3D Gripping Point Detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = new HTuple();
                    hv_Measures[0] = "mean_pro";
                    hv_Measures[1] = "mean_precision";
                    hv_Measures[2] = "mean_iou";
                    //
                    //There are no ignored classes for this model type.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                    //
                    //Set default 3D gripping point generation parameters.
                    hv_GrippingPointParams.Dispose();
                    HOperatorSet.CreateDict(out hv_GrippingPointParams);
                    check_dl_3d_gripping_points_and_poses_params(hv_GrippingPointParams);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "gripping_point_params", hv_GrippingPointParams);
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    //
                    //Set default image level measures.
                    hv_Measures.Dispose();
                    hv_Measures = "anomaly_score_histogram";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //
                    //Set default classification measures.
                    hv_Measures.Dispose();
                    hv_Measures = "top1_error";
                    //
                    //Per default all classes are used for evaluation.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", "global");
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //
                    //Set default detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = "mean_ap";
                    //
                    //Set detection-specific default values.
                    hv_EvaluateInstances.Dispose();
                    hv_EvaluateInstances = 1;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
                    //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
                            0.5, 0.96, 0.05));
                    }
                    //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                    //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                    //Some tuples are changing their length during the evaluation. As this slows down the
                    //evaluation process they are allocated in blocks of AllocationBlockLength.
                    hv_AllocationBlockLength.Dispose();
                    hv_AllocationBlockLength = 200;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                    //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
                    //Interpolate the precision-recall curves per default.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", 1);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //
                    //Set default pixel measures.
                    hv_Measures.Dispose();
                    hv_Measures = new HTuple();
                    hv_Measures[0] = "pixel_accuracy";
                    hv_Measures[1] = "mean_accuracy";
                    hv_Measures[2] = "mean_iou";
                    //
                    //Per default there are no ignored classes.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
                {
                    //
                    //Set default OCR recognition measures
                    hv_Measures.Dispose();
                    hv_Measures = "accuracy";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                {
                    //
                    //Set default ocr_detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = "f_score";
                    HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 1);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", 0.5);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle2");
                    HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", 100);
                    //
                    //Configure area constraints.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_AreaRanges, "max", HTuple.TupleConstant("H_INT_MAX"));
                    }
                    HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                }
                //
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                //

                hv_ClassIDsModel_COPY_INP_TMP.Dispose();
                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_GrippingPointParams.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ClassIDsModel_COPY_INP_TMP.Dispose();
                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_GrippingPointParams.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Crops a given image object based on the given domain handling. 
        private void crop_dl_sample_image(HObject ho_Domain, HTuple hv_DLSample, HTuple hv_Key,
            HTuple hv_DLPreprocessParam)
        {




            // Local iconic variables 

            HObject ho___Tmp_Obj_0 = null;

            // Local control variables 

            HTuple hv_KeyExists = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_0 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
            try
            {
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", hv_Key, out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "crop_domain");
                    if ((int)(((hv_DLPreprocessParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                        "domain_handling", "comp")) != 0)
                    {
                        hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                        HOperatorSet.SmallestRectangle1(ho_Domain, out hv_Row1, out hv_Column1,
                            out hv_Row2, out hv_Column2);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho___Tmp_Obj_0.Dispose();
                            HOperatorSet.CropPart(hv_DLSample.TupleGetDictObject(hv_Key), out ho___Tmp_Obj_0,
                                hv_Row1, hv_Column1, (hv_Column2 - hv_Column1) + 1, (hv_Row2 - hv_Row1) + 1);
                        }
                        HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, hv_Key);
                    }
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                            "HNULL");
                    }
                }
                ho___Tmp_Obj_0.Dispose();

                hv_KeyExists.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho___Tmp_Obj_0.Dispose();

                hv_KeyExists.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Close all window handles contained in a dictionary. 
        public void dev_close_window_dict(HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandleDicts = new HTuple();
            HTuple hv_WindowDictIdx = new HTuple(), hv_WindowHandleKeys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_RemovedWindowIndices = new HTuple();
            HTuple hv_WindowHandleIndex = new HTuple();
            HTuple hv_WindowHandleDict_COPY_INP_TMP = new HTuple(hv_WindowHandleDict);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure closes all window handles
                //that are contained in the dictionary WindowHandleDict.
                //
                hv_WindowHandleDicts.Dispose();
                hv_WindowHandleDicts = new HTuple(hv_WindowHandleDict_COPY_INP_TMP);
                for (hv_WindowDictIdx = 0; (int)hv_WindowDictIdx <= (int)((new HTuple(hv_WindowHandleDicts.TupleLength()
                    )) - 1); hv_WindowDictIdx = (int)hv_WindowDictIdx + 1)
                {
                    hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowHandleDict_COPY_INP_TMP = hv_WindowHandleDicts.TupleSelect(
                            hv_WindowDictIdx);
                    }
                    hv_WindowHandleKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_WindowHandleKeys);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowHandles.Dispose();
                                HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                                    hv_Index), out hv_WindowHandles);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            continue;
                        }
                        hv_RemovedWindowIndices.Dispose();
                        hv_RemovedWindowIndices = new HTuple();
                        for (hv_WindowHandleIndex = 0; (int)hv_WindowHandleIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowHandleIndex = (int)hv_WindowHandleIndex + 1)
                        {
                            //Not every entry has to be a window handle, therefore use try-catch.
                            try
                            {
                                //Call set_window_param to check if the handle is a window handle.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowHandleIndex),
                                        "flush", "true");
                                }
                                HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                                    hv_WindowHandleIndex));
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_RemovedWindowIndices = hv_RemovedWindowIndices.TupleConcat(
                                            hv_WindowHandleIndex);
                                        hv_RemovedWindowIndices.Dispose();
                                        hv_RemovedWindowIndices = ExpTmpLocalVar_RemovedWindowIndices;
                                    }
                                }
                            }
                            // catch (Exception) 
                            catch (HalconException HDevExpDefaultException1)
                            {
                                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            }
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleRemove(hv_WindowHandles, hv_RemovedWindowIndices, out ExpTmpOutVar_0);
                            hv_WindowHandles.Dispose();
                            hv_WindowHandles = ExpTmpOutVar_0;
                        }
                        //If some entries remained, set reduced tuple. Otherwise, remove whole key entry.
                        if ((int)(new HTuple((new HTuple(hv_WindowHandles.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                                    hv_Index), hv_WindowHandles);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.RemoveDictKey(hv_WindowHandleDict_COPY_INP_TMP, hv_WindowHandleKeys.TupleSelect(
                                    hv_Index));
                            }
                        }
                    }
                }
                //

                hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                hv_WindowHandleDicts.Dispose();
                hv_WindowDictIdx.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                hv_WindowHandleDicts.Dispose();
                hv_WindowDictIdx.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Display evaluation results of an evaluated DL model of type 'anomaly_detection' or 'gc_anomaly_detection'. 
        public void dev_display_anomaly_detection_evaluation(HTuple hv_EvaluationResult,
            HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_BackgroundColor = new HTuple(), hv_OKColor = new HTuple();
            HTuple hv_OKColorPlot = new HTuple(), hv_NOKColor = new HTuple();
            HTuple hv_NOKColorPlot = new HTuple(), hv_IntermediateColor = new HTuple();
            HTuple hv_PredefinedColors = new HTuple(), hv_EvaluationThresholds = new HTuple();
            HTuple hv_AdditionalThresholds = new HTuple(), hv_EvaluationThresholdIndex = new HTuple();
            HTuple hv_RowColNameColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_DisplayMatrixColor = new HTuple(), hv_Font = new HTuple();
            HTuple hv_FontSize = new HTuple(), hv_HistogramLegendVerticalOffset = new HTuple();
            HTuple hv_NumXTicks = new HTuple(), hv_HistogramMin = new HTuple();
            HTuple hv_HistogramMax = new HTuple(), hv_DisplayThresholds = new HTuple();
            HTuple hv_DisplayScoreHistogram = new HTuple(), hv_DisplayScoreLegend = new HTuple();
            HTuple hv_DisplayConfusionAbsolute = new HTuple(), hv_DisplayConfusionRelative = new HTuple();
            HTuple hv_DisplayPieChartPrecision = new HTuple(), hv_DisplayPieChartRecall = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowMaxColumn = new HTuple(), hv_WindowColumnSeparator = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_ThresholdValues = new HTuple(), hv_DisplayMode = new HTuple();
            HTuple hv_DisplayAll = new HTuple(), hv_MinValue = new HTuple();
            HTuple hv_MaxValue = new HTuple(), hv_CalculateHistogramMin = new HTuple();
            HTuple hv_CalculateHistogramMax = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_EvalThresholdsExist = new HTuple(), hv_DiffEpsilon = new HTuple();
            HTuple hv_RemoveIndices = new HTuple(), hv_ThresholdIdx = new HTuple();
            HTuple hv_MinThresholdDiff = new HTuple(), hv_AllThresholds = new HTuple();
            HTuple hv_ThresholdColors = new HTuple(), hv_UseSpecificLegend = new HTuple();
            HTuple hv_RandomColors = new HTuple(), hv_AnomalyScoreHistogram = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_HistoOKXValues = new HTuple();
            HTuple hv_HistoOKYValues = new HTuple(), hv_HistoNOKXValues = new HTuple();
            HTuple hv_HistoNOKYValues = new HTuple(), hv_AnomalyScores = new HTuple();
            HTuple hv_HistogramWidthOK = new HTuple(), hv_HistogramRangeWidth = new HTuple();
            HTuple hv_HistogramWidthNOK = new HTuple(), hv_MaxScore = new HTuple();
            HTuple hv_MinScore = new HTuple(), hv_TicksX = new HTuple();
            HTuple hv_FormatX = new HTuple(), hv_OKMinY = new HTuple();
            HTuple hv_OKMinIndex = new HTuple(), hv_NOKMaxY = new HTuple();
            HTuple hv_NOKMaxIndex = new HTuple(), hv_MaxY = new HTuple();
            HTuple hv_PlotOKXValues = new HTuple(), hv_PlotOKYValues = new HTuple();
            HTuple hv_OKIndex = new HTuple(), hv_PlotNOKXValues = new HTuple();
            HTuple hv_PlotNOKYValues = new HTuple(), hv_NOKIndex = new HTuple();
            HTuple hv_WindowScoreHistogramExists = new HTuple(), hv_WindowHandleScoreHistogram = new HTuple();
            HTuple hv_FlushStateScoreHistogram = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Color = new HTuple(), hv_WindowHandle = new HTuple();
            HTuple hv__ = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WindowScoreLegendExists = new HTuple(), hv_WindowHandleScoreLegend = new HTuple();
            HTuple hv_FlushStateScoreLegend = new HTuple(), hv_Offset = new HTuple();
            HTuple hv_RunningIndex = new HTuple(), hv_ThresholdCaptions = new HTuple();
            HTuple hv_WindowExists = new HTuple(), hv_WindowHandlePrecision = new HTuple();
            HTuple hv_WindowHandleRecall = new HTuple(), hv_RowColumnNames = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_DiagonalColor = new HTuple();
            HTuple hv_DiagonalIndices = new HTuple(), hv_DisplayMatrices = new HTuple();
            HTuple hv_Strings = new HTuple(), hv_CapitalStrings = new HTuple();
            HTuple hv_TitelAdditions = new HTuple(), hv_IndexMatrixToDisplay = new HTuple();
            HTuple hv_ConfusionMatrixDictionaries = new HTuple(), hv_ConfusionMatrixDictionary = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_ThresholdValue = new HTuple();
            HTuple hv_ConfusionMatrixDisplay = new HTuple(), hv_ValuesRelative = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_WindowHandleConfusion = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure visualizes the evaluation results for models of
                //type 'anomaly_detection' or 'gc_anomaly_detection'.
                //
                //Set the default values.
                hv_BackgroundColor.Dispose();
                hv_BackgroundColor = "light gray";
                hv_OKColor.Dispose();
                hv_OKColor = "#1354ad";
                hv_OKColorPlot.Dispose();
                hv_OKColorPlot = "#3e94d8";
                hv_NOKColor.Dispose();
                hv_NOKColor = "#ff3410";
                hv_NOKColorPlot.Dispose();
                hv_NOKColorPlot = "#ff942e";
                hv_IntermediateColor.Dispose();
                hv_IntermediateColor = "#444444";
                hv_PredefinedColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PredefinedColors = new HTuple();
                    hv_PredefinedColors = hv_PredefinedColors.TupleConcat(hv_OKColor, hv_NOKColor, hv_IntermediateColor);
                }
                //
                hv_EvaluationThresholds.Dispose();
                hv_EvaluationThresholds = new HTuple();
                hv_AdditionalThresholds.Dispose();
                hv_AdditionalThresholds = new HTuple();
                hv_EvaluationThresholdIndex.Dispose();
                hv_EvaluationThresholdIndex = -1;
                //
                hv_RowColNameColor.Dispose();
                hv_RowColNameColor = "light gray";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayMatrixColor.Dispose();
                hv_DisplayMatrixColor = 1;
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                hv_HistogramLegendVerticalOffset.Dispose();
                hv_HistogramLegendVerticalOffset = 50;
                hv_NumXTicks.Dispose();
                hv_NumXTicks = 10;
                hv_HistogramMin.Dispose();
                hv_HistogramMin = -1;
                hv_HistogramMax.Dispose();
                hv_HistogramMax = -1;
                //
                hv_DisplayThresholds.Dispose();
                hv_DisplayThresholds = 0;
                hv_DisplayScoreHistogram.Dispose();
                hv_DisplayScoreHistogram = 1;
                hv_DisplayScoreLegend.Dispose();
                hv_DisplayScoreLegend = 1;
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionAbsolute = 0;
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayConfusionRelative = 0;
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartPrecision = 0;
                hv_DisplayPieChartRecall.Dispose();
                hv_DisplayPieChartRecall = 0;
                //
                //Parameters used for the window placements:
                hv_WindowRow.Dispose();
                hv_WindowRow = 0;
                hv_WindowColumn.Dispose();
                hv_WindowColumn = 0;
                hv_WindowMaxColumn.Dispose();
                hv_WindowMaxColumn = 0;
                hv_WindowColumnSeparator.Dispose();
                hv_WindowColumnSeparator = 8;
                //
                //Handle the generic parameters.
                if ((int)(new HTuple(hv_GenParam_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_GenParamKeys);
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "estimated_thresholds"))) != 0)
                        {
                            hv_ThresholdValues.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "estimated_thresholds",
                                out hv_ThresholdValues);
                            if ((int)(new HTuple((((((hv_ThresholdValues.TupleIsIntElem()) + (hv_ThresholdValues.TupleIsRealElem()
                                ))).TupleFind(0))).TupleNotEqual(-1))) != 0)
                            {
                                throw new HalconException("GenParam 'estimated_thresholds' must be numeric values");
                            }
                            if ((int)(new HTuple((new HTuple(hv_ThresholdValues.TupleLength())).TupleGreater(
                                3))) != 0)
                            {
                                throw new HalconException("GenParam 'estimated_thresholds' must be of length 3 or less");
                            }
                            //
                            hv_DisplayThresholds.Dispose();
                            hv_DisplayThresholds = 1;
                            hv_AdditionalThresholds.Dispose();
                            hv_AdditionalThresholds = new HTuple(hv_ThresholdValues);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "display_mode"))) != 0)
                        {
                            hv_DisplayScoreHistogram.Dispose();
                            hv_DisplayScoreHistogram = 0;
                            hv_DisplayScoreLegend.Dispose();
                            hv_DisplayScoreLegend = 0;
                            hv_DisplayMode.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_mode", out hv_DisplayMode);
                            hv_DisplayAll.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayAll = (new HTuple(((hv_DisplayMode.TupleFind(
                                    "all"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                    new HTuple())));
                            }
                            if ((int)(hv_DisplayAll) != 0)
                            {
                                hv_DisplayScoreHistogram.Dispose();
                                hv_DisplayScoreHistogram = 1;
                                hv_DisplayScoreLegend.Dispose();
                                hv_DisplayScoreLegend = 1;
                                hv_DisplayConfusionAbsolute.Dispose();
                                hv_DisplayConfusionAbsolute = 1;
                                hv_DisplayConfusionRelative.Dispose();
                                hv_DisplayConfusionRelative = 1;
                                hv_DisplayPieChartPrecision.Dispose();
                                hv_DisplayPieChartPrecision = 1;
                                hv_DisplayPieChartRecall.Dispose();
                                hv_DisplayPieChartRecall = 1;
                            }
                            else
                            {
                                hv_DisplayScoreHistogram.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayScoreHistogram = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "score_histogram"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                                hv_DisplayScoreLegend.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayScoreLegend = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "score_legend"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                                hv_DisplayConfusionAbsolute.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayConfusionAbsolute = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "absolute_confusion_matrix"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                                hv_DisplayConfusionRelative.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayConfusionRelative = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "relative_confusion_matrix"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                                hv_DisplayPieChartPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayPieChartPrecision = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "pie_charts_precision"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                                hv_DisplayPieChartRecall.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DisplayPieChartRecall = (new HTuple(((hv_DisplayMode.TupleFind(
                                        "pie_charts_recall"))).TupleNotEqual(-1))).TupleAnd(new HTuple(hv_DisplayMode.TupleNotEqual(
                                        new HTuple())));
                                }
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "classification_threshold_index"))) != 0)
                        {
                            hv_EvaluationThresholdIndex.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "classification_threshold_index",
                                out hv_EvaluationThresholdIndex);
                            if ((int)((new HTuple(((hv_EvaluationThresholdIndex.TupleIsInt())).TupleNot()
                                )).TupleOr(new HTuple((new HTuple(hv_EvaluationThresholdIndex.TupleLength()
                                )).TupleNotEqual(1)))) != 0)
                            {
                                throw new HalconException("GenParam 'classification_threshold_index' must be one integer value");
                            }
                            if ((int)(new HTuple(hv_EvaluationThresholdIndex.TupleLess(0))) != 0)
                            {
                                throw new HalconException("GenParam 'classification_threshold_index' must be greater or equal 0");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "histogram_min"))) != 0)
                        {
                            hv_MinValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "histogram_min",
                                out hv_MinValue);
                            if ((int)(new HTuple((new HTuple(hv_MinValue.TupleLength())).TupleNotEqual(
                                1))) != 0)
                            {
                                throw new HalconException("GenParam 'histogram_min' must be one value");
                            }
                            if ((int)((new HTuple(((hv_MinValue.TupleIsInt())).TupleOr(hv_MinValue.TupleIsReal()
                                ))).TupleNot()) != 0)
                            {
                                throw new HalconException("GenParam 'histogram_min' must be a numeric value");
                            }
                            hv_HistogramMin.Dispose();
                            hv_HistogramMin = new HTuple(hv_MinValue);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "histogram_max"))) != 0)
                        {
                            hv_MaxValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "histogram_max",
                                out hv_MaxValue);
                            if ((int)(new HTuple((new HTuple(hv_MaxValue.TupleLength())).TupleNotEqual(
                                1))) != 0)
                            {
                                throw new HalconException("GenParam 'histogram_max' must be one value");
                            }
                            if ((int)((new HTuple(((hv_MaxValue.TupleIsInt())).TupleOr(hv_MaxValue.TupleIsReal()
                                ))).TupleNot()) != 0)
                            {
                                throw new HalconException("GenParam 'histogram_max' must be a numeric value");
                            }
                            hv_HistogramMax.Dispose();
                            hv_HistogramMax = new HTuple(hv_MaxValue);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "row_col_names_color"))) != 0)
                        {
                            hv_RowColNameColor.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "row_col_names_color",
                                out hv_RowColNameColor);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "display_column_width"))) != 0)
                        {
                            hv_DisplayColumnWidth.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                                out hv_DisplayColumnWidth);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "display_matrix_color"))) != 0)
                        {
                            hv_DisplayMatrixColor.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_matrix_color",
                                out hv_DisplayMatrixColor);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "font"))) != 0)
                        {
                            hv_Font.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "font", out hv_Font);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "font_size"))) != 0)
                        {
                            hv_FontSize.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "font_size", out hv_FontSize);
                        }
                        else
                        {
                            throw new HalconException(("Invalid GenParam key '" + (hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex))) + "'");
                        }
                    }
                }
                //
                hv_CalculateHistogramMin.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalculateHistogramMin = new HTuple(hv_HistogramMin.TupleEqual(
                        -1));
                }
                hv_CalculateHistogramMax.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalculateHistogramMax = new HTuple(hv_HistogramMax.TupleEqual(
                        -1));
                }
                //
                //Check that evaluation type is correct.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "evaluation_type", out hv_EvaluationType);
                if ((int)((new HTuple(hv_EvaluationType.TupleNotEqual("anomaly_detection"))).TupleAnd(
                    new HTuple(hv_EvaluationType.TupleNotEqual("gc_anomaly_detection")))) != 0)
                {
                    throw new HalconException("Wrong evaluation type for display");
                }
                //
                //Get thresholds used for evaluation.
                hv_EvalThresholdsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParam, "key_exists", "anomaly_classification_thresholds",
                    out hv_EvalThresholdsExist);
                if ((int)(hv_EvalThresholdsExist) != 0)
                {
                    hv_EvaluationThresholds.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParam, "anomaly_classification_thresholds",
                        out hv_EvaluationThresholds);
                    if ((int)(new HTuple((new HTuple(hv_EvaluationThresholds.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_DisplayThresholds.Dispose();
                        hv_DisplayThresholds = 1;
                        //If no threshold is set, use the last evaluation index as default.
                        if ((int)(new HTuple(hv_EvaluationThresholdIndex.TupleEqual(-1))) != 0)
                        {
                            hv_EvaluationThresholdIndex.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EvaluationThresholdIndex = (new HTuple(hv_EvaluationThresholds.TupleLength()
                                    )) - 1;
                            }
                        }
                    }
                    //Check that the set threshold index is valid.
                    if ((int)(new HTuple(hv_EvaluationThresholdIndex.TupleGreater((new HTuple(hv_EvaluationThresholds.TupleLength()
                        )) - 1))) != 0)
                    {
                        throw new HalconException("No evaluation available for 'classification_threshold_index': " + hv_EvaluationThresholdIndex);
                    }
                    //Remove extra thresholds in case they are already included in the evaluation.
                    if ((int)((new HTuple((new HTuple(hv_AdditionalThresholds.TupleLength())).TupleGreater(
                        0))).TupleAnd(new HTuple((new HTuple(hv_EvaluationThresholds.TupleLength()
                        )).TupleGreater(0)))) != 0)
                    {
                        hv_DiffEpsilon.Dispose();
                        hv_DiffEpsilon = 1e-7;
                        hv_RemoveIndices.Dispose();
                        hv_RemoveIndices = new HTuple();
                        for (hv_ThresholdIdx = 0; (int)hv_ThresholdIdx <= (int)((new HTuple(hv_AdditionalThresholds.TupleLength()
                            )) - 1); hv_ThresholdIdx = (int)hv_ThresholdIdx + 1)
                        {
                            hv_MinThresholdDiff.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinThresholdDiff = ((((hv_EvaluationThresholds - (hv_AdditionalThresholds.TupleSelect(
                                    hv_ThresholdIdx)))).TupleAbs())).TupleMin();
                            }
                            if ((int)(new HTuple(hv_MinThresholdDiff.TupleLess(hv_DiffEpsilon))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_RemoveIndices = hv_RemoveIndices.TupleConcat(
                                            hv_ThresholdIdx);
                                        hv_RemoveIndices.Dispose();
                                        hv_RemoveIndices = ExpTmpLocalVar_RemoveIndices;
                                    }
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AdditionalThresholds = hv_AdditionalThresholds.TupleRemove(
                                    hv_RemoveIndices);
                                hv_AdditionalThresholds.Dispose();
                                hv_AdditionalThresholds = ExpTmpLocalVar_AdditionalThresholds;
                            }
                        }
                    }
                }
                //
                hv_AllThresholds.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllThresholds = new HTuple();
                    hv_AllThresholds = hv_AllThresholds.TupleConcat(hv_EvaluationThresholds, hv_AdditionalThresholds);
                }
                //
                //Set colors for the thresholds.
                hv_ThresholdColors.Dispose();
                hv_ThresholdColors = new HTuple();
                hv_UseSpecificLegend.Dispose();
                hv_UseSpecificLegend = 0;
                //In case the overall number of thresholds is exactly 3 (either passed as EvalParam
                //or GenParam), we assume that they are the ones calculated with
                //compute_dl_anomaly_thresholds and use the specific colors and legend.
                if ((int)((new HTuple((new HTuple(hv_AllThresholds.TupleLength())).TupleEqual(
                    3))).TupleAnd((new HTuple((new HTuple(hv_EvaluationThresholds.TupleLength()
                    )).TupleEqual(0))).TupleOr(new HTuple((new HTuple(hv_AdditionalThresholds.TupleLength()
                    )).TupleEqual(0))))) != 0)
                {
                    hv_UseSpecificLegend.Dispose();
                    hv_UseSpecificLegend = 1;
                    hv_ThresholdColors.Dispose();
                    hv_ThresholdColors = new HTuple(hv_PredefinedColors);
                }
                else if ((int)(new HTuple((new HTuple(hv_AllThresholds.TupleLength()
                    )).TupleNotEqual(0))) != 0)
                {
                    //Get random colors to display thresholds.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RandomColors.Dispose();
                        get_distinct_colors(new HTuple(hv_AllThresholds.TupleLength()), 0, 175, 250,
                            out hv_RandomColors);
                    }
                    if ((int)(new HTuple((new HTuple(hv_EvaluationThresholds.TupleLength())).TupleEqual(
                        3))) != 0)
                    {
                        hv_UseSpecificLegend.Dispose();
                        hv_UseSpecificLegend = 1;
                        hv_ThresholdColors.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThresholdColors = new HTuple();
                            hv_ThresholdColors = hv_ThresholdColors.TupleConcat(hv_PredefinedColors, hv_RandomColors);
                        }
                    }
                    else
                    {
                        hv_ThresholdColors.Dispose();
                        hv_ThresholdColors = new HTuple(hv_RandomColors);
                    }
                }
                //
                if ((int)(hv_DisplayScoreHistogram) != 0)
                {
                    //
                    //Check if the anomaly score histogram is given.
                    try
                    {
                        hv_AnomalyScoreHistogram.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult, "anomaly_score_histogram",
                            out hv_AnomalyScoreHistogram);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException("EvaluationResult must contain the anomaly score histogram.");
                    }
                    //Check if OK score x and y values exist.
                    try
                    {
                        hv_HistoOKXValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "ok_x", out hv_HistoOKXValues);
                        hv_HistoOKYValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "ok_y", out hv_HistoOKYValues);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException("AnomalyScoreHistogram must contain values for 'ok_x' and 'ok_y'.");
                    }
                    //Check if NOK score x and y values exist.
                    try
                    {
                        hv_HistoNOKXValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "nok_x", out hv_HistoNOKXValues);
                        hv_HistoNOKYValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "nok_y", out hv_HistoNOKYValues);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException("AnomalyScoreHistogram must contain values for 'nok_x' and 'nok_y'.");
                    }
                    //
                    //Validate the histogram content.
                    if ((int)(new HTuple((new HTuple(hv_HistoOKXValues.TupleLength())).TupleNotEqual(
                        new HTuple(hv_HistoOKYValues.TupleLength())))) != 0)
                    {
                        throw new HalconException("Number of 'ok_x' values does not match number of 'ok_y' values.");
                    }
                    if ((int)(new HTuple((new HTuple(hv_HistoNOKXValues.TupleLength())).TupleNotEqual(
                        new HTuple(hv_HistoNOKYValues.TupleLength())))) != 0)
                    {
                        throw new HalconException("Number of 'nok_x' values does not match number of 'nok_y' values.");
                    }
                    if ((int)((new HTuple((new HTuple(hv_HistoOKXValues.TupleLength())).TupleEqual(
                        0))).TupleAnd(new HTuple((new HTuple(hv_HistoNOKXValues.TupleLength()
                        )).TupleEqual(0)))) != 0)
                    {
                        throw new HalconException("No data for display");
                    }
                    //
                    //In case the min or max histogram value is not specified, estimate it by
                    //using min/max of the anomaly scores.
                    hv_AnomalyScores.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyScores = new HTuple();
                        hv_AnomalyScores = hv_AnomalyScores.TupleConcat(hv_HistoOKXValues, hv_HistoNOKXValues);
                    }
                    //
                    if ((int)(hv_CalculateHistogramMin) != 0)
                    {
                        hv_HistogramMin.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramMin = hv_AnomalyScores.TupleMin()
                                ;
                        }
                    }
                    if ((int)(hv_CalculateHistogramMax) != 0)
                    {
                        hv_HistogramMax.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramMax = hv_AnomalyScores.TupleMax()
                                ;
                        }
                    }
                    //
                    //Check min and max values.
                    if ((int)(new HTuple(hv_HistogramMin.TupleGreaterEqual(hv_HistogramMax))) != 0)
                    {
                        throw new HalconException(((("Maximum histogram value needs to be greater than the minimum value. Current values: " + hv_HistogramMin) + new HTuple(" (min), ")) + hv_HistogramMax) + " (max).");
                    }
                    //
                    //There are cases where the histogram does not look good if we simply set the
                    //histogram min and max like we do above. In the following, we adapt the min
                    //and max to make the histogram look better.
                    //
                    //Add 10% to the border for better boundary visualization.
                    //Thus, you can see clearly when 100% FPR and 100% FNR are reached.
                    //Also, the histogram should start at zero, if the anomaly scores are all positive.
                    if ((int)(hv_CalculateHistogramMin) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_HistogramMin = (new HTuple(0.0)).TupleMin2(
                                    hv_HistogramMin - (0.1 * (hv_HistogramMax - hv_HistogramMin)));
                                hv_HistogramMin.Dispose();
                                hv_HistogramMin = ExpTmpLocalVar_HistogramMin;
                            }
                        }
                    }
                    if ((int)(hv_CalculateHistogramMax) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_HistogramMax = hv_HistogramMax + (0.1 * (hv_HistogramMax - hv_HistogramMin));
                                hv_HistogramMax.Dispose();
                                hv_HistogramMax = ExpTmpLocalVar_HistogramMax;
                            }
                        }
                    }
                    //
                    //There can be cases where the OK or the NOK values make up most of the histogram.
                    //For example, let OK scores range from 0 to 0.05 and NOK values from 0.04 to 1.
                    //In this case, the OK area will be very small, which might lead to wrong conclusions
                    //about the ratio of OK and NOK images or the performance of the anomaly detection
                    //or Global Context Anomaly Detection.
                    //In the following, we adapt the histogram min and max so that the widths of the OK
                    //and NOK areas make up at least a certain percentage of the total width.
                    if ((int)(hv_CalculateHistogramMin.TupleAnd(new HTuple(hv_HistoOKXValues.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        //Make sure that the distance between the histogram min and the maximum OK score
                        //is large enough. We take the histogram min instead of the minimum OK score, because
                        //the range of the OK area starts at the histogram min and not necessarily at the
                        //minimum OK score (for example when the smallest anomaly score comes from a
                        //NOK image).
                        hv_HistogramWidthOK.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramWidthOK = (hv_HistoOKXValues.TupleMax()
                                ) - hv_HistogramMin;
                        }
                        hv_HistogramRangeWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramRangeWidth = hv_HistogramMax - hv_HistogramMin;
                        }
                        if ((int)(new HTuple(hv_HistogramWidthOK.TupleLess(0.15 * hv_HistogramRangeWidth))) != 0)
                        {
                            hv_HistogramMin.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HistogramMin = (hv_HistoOKXValues.TupleMax()
                                    ) - (0.15 * hv_HistogramRangeWidth);
                            }
                        }
                    }
                    //
                    if ((int)(hv_CalculateHistogramMax.TupleAnd(new HTuple(hv_HistoNOKXValues.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        //Update the histogram max in the same way as the histogram min
                        hv_HistogramWidthNOK.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramWidthNOK = hv_HistogramMax - (hv_HistoNOKXValues.TupleMin()
                                );
                        }
                        hv_HistogramRangeWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HistogramRangeWidth = hv_HistogramMax - hv_HistogramMin;
                        }
                        if ((int)(new HTuple(hv_HistogramWidthNOK.TupleLess(0.15 * hv_HistogramRangeWidth))) != 0)
                        {
                            hv_HistogramMax.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HistogramMax = (hv_HistoNOKXValues.TupleMin()
                                    ) + (0.15 * hv_HistogramRangeWidth);
                            }
                        }
                    }
                    //
                    hv_MaxScore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScore = hv_AnomalyScores.TupleMax()
                            ;
                    }
                    if ((int)(new HTuple(hv_HistogramMin.TupleGreaterEqual(hv_MaxScore))) != 0)
                    {
                        throw new HalconException(((("Minimum histogram value (" + hv_HistogramMin) + ") is larger than the highest score (") + hv_MaxScore) + ").");
                    }
                    hv_MinScore.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScore = hv_AnomalyScores.TupleMin()
                            ;
                    }
                    if ((int)(new HTuple(hv_HistogramMax.TupleLessEqual(hv_MinScore))) != 0)
                    {
                        throw new HalconException(((("Maximum histogram value (" + hv_HistogramMax) + ") is smaller than the lowest score (") + hv_MinScore) + ").");
                    }
                    //
                    //Append HistogramMin/HistogramMax to histogram values if necessary.
                    if ((int)(new HTuple((new HTuple(hv_HistoOKXValues.TupleLength())).TupleNotEqual(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(hv_HistogramMin.TupleLess(hv_HistoOKXValues.TupleMin()
                            ))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_HistoOKXValues = hv_HistogramMin.TupleConcat(
                                        hv_HistoOKXValues);
                                    hv_HistoOKXValues.Dispose();
                                    hv_HistoOKXValues = ExpTmpLocalVar_HistoOKXValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_HistoOKYValues = (new HTuple(1.0)).TupleConcat(
                                        hv_HistoOKYValues);
                                    hv_HistoOKYValues.Dispose();
                                    hv_HistoOKYValues = ExpTmpLocalVar_HistoOKYValues;
                                }
                            }
                        }
                    }
                    if ((int)(new HTuple((new HTuple(hv_HistoNOKXValues.TupleLength())).TupleNotEqual(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(hv_HistogramMax.TupleGreater(hv_HistoNOKXValues.TupleMax()
                            ))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_HistoNOKXValues = hv_HistoNOKXValues.TupleConcat(
                                        hv_HistogramMax);
                                    hv_HistoNOKXValues.Dispose();
                                    hv_HistoNOKXValues = ExpTmpLocalVar_HistoNOKXValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_HistoNOKYValues = hv_HistoNOKYValues.TupleConcat(
                                        1.0);
                                    hv_HistoNOKYValues.Dispose();
                                    hv_HistoNOKYValues = ExpTmpLocalVar_HistoNOKYValues;
                                }
                            }
                        }
                    }
                    //
                    //Specify other plot parameters.
                    hv_TicksX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksX = (((hv_HistogramMax - hv_HistogramMin) / hv_NumXTicks)).TupleReal()
                            ;
                    }
                    if ((int)(new HTuple(hv_HistogramMax.TupleGreaterEqual(10))) != 0)
                    {
                        hv_FormatX.Dispose();
                        hv_FormatX = ".1f";
                    }
                    else
                    {
                        hv_FormatX.Dispose();
                        hv_FormatX = ".2f";
                    }
                    //Find maximum y value to plot.
                    hv_OKMinY.Dispose();
                    hv_OKMinY = 0;
                    hv_OKMinIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OKMinIndex = ((hv_HistoOKXValues.TupleGreaterEqualElem(
                            hv_HistogramMin))).TupleFindFirst(1);
                    }
                    if ((int)(new HTuple(hv_OKMinIndex.TupleNotEqual(-1))) != 0)
                    {
                        hv_OKMinY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OKMinY = hv_HistoOKYValues.TupleSelect(
                                hv_OKMinIndex);
                        }
                    }
                    hv_NOKMaxY.Dispose();
                    hv_NOKMaxY = 0;
                    hv_NOKMaxIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NOKMaxIndex = ((hv_HistoNOKXValues.TupleLessEqualElem(
                            hv_HistogramMax))).TupleFindLast(1);
                    }
                    if ((int)(new HTuple(hv_NOKMaxIndex.TupleNotEqual(-1))) != 0)
                    {
                        hv_NOKMaxY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NOKMaxY = hv_HistoNOKYValues.TupleSelect(
                                hv_NOKMaxIndex);
                        }
                    }
                    hv_MaxY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxY = ((hv_OKMinY.TupleConcat(
                            hv_NOKMaxY))).TupleMax();
                    }
                    //
                    //Extend the histogram values so that they will be plotted as steps with the 'filled' style.
                    hv_PlotOKXValues.Dispose();
                    hv_PlotOKXValues = new HTuple();
                    hv_PlotOKYValues.Dispose();
                    hv_PlotOKYValues = new HTuple();
                    if ((int)(new HTuple((new HTuple(hv_HistoOKXValues.TupleLength())).TupleNotEqual(
                        0))) != 0)
                    {
                        for (hv_OKIndex = 0; (int)hv_OKIndex <= (int)((new HTuple(hv_HistoOKXValues.TupleLength()
                            )) - 2); hv_OKIndex = (int)hv_OKIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PlotOKXValues = ((hv_PlotOKXValues.TupleConcat(
                                        hv_HistoOKXValues.TupleSelect(hv_OKIndex)))).TupleConcat(hv_HistoOKXValues.TupleSelect(
                                        hv_OKIndex));
                                    hv_PlotOKXValues.Dispose();
                                    hv_PlotOKXValues = ExpTmpLocalVar_PlotOKXValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PlotOKYValues = ((hv_PlotOKYValues.TupleConcat(
                                        hv_HistoOKYValues.TupleSelect(hv_OKIndex)))).TupleConcat(hv_HistoOKYValues.TupleSelect(
                                        hv_OKIndex + 1));
                                    hv_PlotOKYValues.Dispose();
                                    hv_PlotOKYValues = ExpTmpLocalVar_PlotOKYValues;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_PlotOKXValues = ((hv_PlotOKXValues.TupleConcat(
                                    hv_HistoOKXValues.TupleSelect(hv_OKIndex)))).TupleConcat(hv_HistoOKXValues.TupleSelect(
                                    hv_OKIndex));
                                hv_PlotOKXValues.Dispose();
                                hv_PlotOKXValues = ExpTmpLocalVar_PlotOKXValues;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_PlotOKYValues = ((hv_PlotOKYValues.TupleConcat(
                                    hv_HistoOKYValues.TupleSelect(hv_OKIndex)))).TupleConcat(0.0);
                                hv_PlotOKYValues.Dispose();
                                hv_PlotOKYValues = ExpTmpLocalVar_PlotOKYValues;
                            }
                        }
                    }
                    //
                    hv_PlotNOKXValues.Dispose();
                    hv_PlotNOKXValues = new HTuple();
                    hv_PlotNOKYValues.Dispose();
                    hv_PlotNOKYValues = new HTuple();
                    if ((int)(new HTuple((new HTuple(hv_HistoNOKXValues.TupleLength())).TupleNotEqual(
                        0))) != 0)
                    {
                        hv_PlotNOKXValues.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PlotNOKXValues = new HTuple();
                            hv_PlotNOKXValues = hv_PlotNOKXValues.TupleConcat(hv_HistoNOKXValues.TupleSelect(
                                0));
                            hv_PlotNOKXValues = hv_PlotNOKXValues.TupleConcat(hv_HistoNOKXValues.TupleSelect(
                                0));
                        }
                        hv_PlotNOKYValues.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PlotNOKYValues = new HTuple();
                            hv_PlotNOKYValues[0] = 0.0;
                            hv_PlotNOKYValues = hv_PlotNOKYValues.TupleConcat(hv_HistoNOKYValues.TupleSelect(
                                0));
                        }
                        for (hv_NOKIndex = 1; (int)hv_NOKIndex <= (int)((new HTuple(hv_HistoNOKXValues.TupleLength()
                            )) - 1); hv_NOKIndex = (int)hv_NOKIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PlotNOKXValues = ((hv_PlotNOKXValues.TupleConcat(
                                        hv_HistoNOKXValues.TupleSelect(hv_NOKIndex)))).TupleConcat(hv_HistoNOKXValues.TupleSelect(
                                        hv_NOKIndex));
                                    hv_PlotNOKXValues.Dispose();
                                    hv_PlotNOKXValues = ExpTmpLocalVar_PlotNOKXValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PlotNOKYValues = ((hv_PlotNOKYValues.TupleConcat(
                                        hv_HistoNOKYValues.TupleSelect(hv_NOKIndex - 1)))).TupleConcat(hv_HistoNOKYValues.TupleSelect(
                                        hv_NOKIndex));
                                    hv_PlotNOKYValues.Dispose();
                                    hv_PlotNOKYValues = ExpTmpLocalVar_PlotNOKYValues;
                                }
                            }
                        }
                    }
                    //
                    //Create drawing window for histogram.
                    hv_WindowScoreHistogramExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_score_histogram",
                        out hv_WindowScoreHistogramExists);
                    if ((int)(hv_WindowScoreHistogramExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", hv_BackgroundColor);
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandleScoreHistogram);
                        HDevWindowStack.Push(hv_WindowHandleScoreHistogram);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_score_histogram",
                            hv_WindowHandleScoreHistogram);
                    }
                    else
                    {
                        hv_WindowHandleScoreHistogram.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_score_histogram",
                            out hv_WindowHandleScoreHistogram);
                    }
                    hv_FlushStateScoreHistogram.Dispose();
                    HOperatorSet.GetWindowParam(hv_WindowHandleScoreHistogram, "flush", out hv_FlushStateScoreHistogram);
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreHistogram, "flush", "false");
                    //
                    //Adapt fonts and background colors in the histogram.
                    set_display_font(hv_WindowHandleScoreHistogram, 14, hv_Font, "true", "false");
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreHistogram, "background_color",
                        hv_BackgroundColor);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        plot_tuple(hv_WindowHandleScoreHistogram, hv_PlotOKXValues, hv_PlotOKYValues,
                            "Score", "Fraction of wrongly classified images", hv_OKColorPlot + "80",
                            ((((((((((new HTuple("start_x")).TupleConcat("end_x")).TupleConcat("start_y")).TupleConcat(
                            "end_y")).TupleConcat("ticks_x")).TupleConcat("ticks_y")).TupleConcat(
                            "axes_color")).TupleConcat("format_x")).TupleConcat("format_y")).TupleConcat(
                            "style")).TupleConcat("clip"), ((((((((((((hv_HistogramMin.TupleConcat(
                            hv_HistogramMax))).TupleConcat(0.0))).TupleConcat(hv_MaxY + 0.05))).TupleConcat(
                            hv_TicksX))).TupleConcat((new HTuple(0.1)).TupleConcat("black")))).TupleConcat(
                            hv_FormatX))).TupleConcat(((new HTuple(".1f")).TupleConcat("filled")).TupleConcat(
                            "yes")));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        plot_tuple(hv_WindowHandleScoreHistogram, hv_PlotNOKXValues, hv_PlotNOKYValues,
                            new HTuple(), new HTuple(), hv_NOKColorPlot + "80", ((((((((new HTuple("start_x")).TupleConcat(
                            "end_x")).TupleConcat("start_y")).TupleConcat("end_y")).TupleConcat("ticks_x")).TupleConcat(
                            "ticks_y")).TupleConcat("axes_color")).TupleConcat("style")).TupleConcat(
                            "clip"), ((((((hv_HistogramMin.TupleConcat(hv_HistogramMax))).TupleConcat(
                            0.0))).TupleConcat(hv_MaxY + 0.05))).TupleConcat(((((new HTuple("none")).TupleConcat(
                            "none")).TupleConcat("none")).TupleConcat("filled")).TupleConcat("yes")));
                    }
                    //
                    //Plot thresholds from evaluation or generic parameters if given.
                    if ((int)(hv_DisplayThresholds) != 0)
                    {
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_AllThresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            hv_Color.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Color = hv_ThresholdColors.TupleSelect(
                                    hv_Index);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                plot_tuple(hv_WindowHandleScoreHistogram, ((hv_AllThresholds.TupleSelect(
                                    hv_Index))).TupleConcat(hv_AllThresholds.TupleSelect(hv_Index)),
                                    (new HTuple(0.0)).TupleConcat(hv_MaxY), new HTuple(), new HTuple(),
                                    hv_Color, (((((((new HTuple("start_x")).TupleConcat("end_x")).TupleConcat(
                                    "start_y")).TupleConcat("end_y")).TupleConcat("ticks_x")).TupleConcat(
                                    "ticks_y")).TupleConcat("axes_color")).TupleConcat("clip"), ((((((hv_HistogramMin.TupleConcat(
                                    hv_HistogramMax))).TupleConcat(0.0))).TupleConcat(hv_MaxY + 0.05))).TupleConcat(
                                    (((new HTuple("none")).TupleConcat("none")).TupleConcat("none")).TupleConcat(
                                    "yes")));
                            }
                        }
                    }
                    //
                    //Recalculate Window Coordinates for the following plots.
                    hv_WindowHandle.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_score_histogram",
                        out hv_WindowHandle);
                    hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_Width,
                        out hv_Height);
                    //Next plots will be shown on the right of the histograms.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(
                                hv_Width);
                            hv_WindowMaxColumn.Dispose();
                            hv_WindowMaxColumn = ExpTmpLocalVar_WindowMaxColumn;
                        }
                    }
                    hv_WindowRow.Dispose();
                    hv_WindowRow = 0;
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowColumn = (hv_WindowColumn + hv_WindowMaxColumn) + hv_WindowColumnSeparator;
                            hv_WindowColumn.Dispose();
                            hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                        }
                    }
                    hv_WindowMaxColumn.Dispose();
                    hv_WindowMaxColumn = 0;
                    //
                    HOperatorSet.FlushBuffer(hv_WindowHandleScoreHistogram);
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreHistogram, "flush", hv_FlushStateScoreHistogram);
                }
                //
                //Plot histogram legend.
                if ((int)(hv_DisplayScoreLegend) != 0)
                {
                    //Create drawing window for legend.
                    hv_WindowScoreLegendExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_score_legend",
                        out hv_WindowScoreLegendExists);
                    if ((int)(hv_WindowScoreLegendExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", hv_BackgroundColor);
                        HOperatorSet.OpenWindow(hv_WindowRow, hv_WindowColumn, 320, 512, 0, "visible", "", out hv_WindowHandleScoreLegend);
                        HDevWindowStack.Push(hv_WindowHandleScoreLegend);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_score_legend", hv_WindowHandleScoreLegend);
                    }
                    else
                    {
                        hv_WindowHandleScoreLegend.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_score_legend", out hv_WindowHandleScoreLegend);
                    }
                    //Adapt fonts and background colors in the histogram.
                    HDevWindowStack.SetActive(hv_WindowHandleScoreLegend);
                    hv_FlushStateScoreLegend.Dispose();
                    HOperatorSet.GetWindowParam(hv_WindowHandleScoreLegend, "flush", out hv_FlushStateScoreLegend);
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreLegend, "flush", "false");
                    //
                    HDevWindowStack.SetActive(hv_WindowHandleScoreLegend);
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreLegend, "background_color",
                        hv_BackgroundColor);
                    set_display_font(hv_WindowHandleScoreLegend, hv_FontSize, hv_Font, "true",
                        "false");
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Area graphs", "image",
                                10 + hv_HistogramLegendVerticalOffset, 5, "black", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "OK", "image", 35 + hv_HistogramLegendVerticalOffset,
                                20, hv_OKColorPlot, "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "NOK", "image", 60 + hv_HistogramLegendVerticalOffset,
                                20, hv_NOKColorPlot, "box", "false");
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Thresholds", "image",
                                100 + hv_HistogramLegendVerticalOffset, 5, "black", "box", "false");
                        }
                    }
                    if ((int)(hv_DisplayThresholds) != 0)
                    {
                        hv_Offset.Dispose();
                        hv_Offset = 25;
                        hv_RunningIndex.Dispose();
                        hv_RunningIndex = 0;
                        if ((int)(hv_UseSpecificLegend) != 0)
                        {
                            hv_ThresholdCaptions.Dispose();
                            hv_ThresholdCaptions = new HTuple();
                            hv_ThresholdCaptions[0] = "No wrongly classified OK images";
                            hv_ThresholdCaptions[1] = "No wrongly classified NOK images";
                            hv_ThresholdCaptions[2] = "Minimal sum of OK and NOK fractions";
                            for (hv_Index = 0; (int)hv_Index <= 2; hv_Index = (int)hv_Index + 1)
                            {
                                hv_Color.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Color = hv_ThresholdColors.TupleSelect(
                                        hv_Index);
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ThresholdCaptions.TupleSelect(
                                            hv_Index), "image", (125 + hv_HistogramLegendVerticalOffset) + (hv_Index * hv_Offset),
                                            20, hv_Color, "box", "false");
                                    }
                                }
                            }
                            hv_RunningIndex.Dispose();
                            hv_RunningIndex = 3;
                        }
                        HTuple end_val411 = (new HTuple(hv_AllThresholds.TupleLength()
                            )) - 1;
                        HTuple step_val411 = 1;
                        for (hv_Index = hv_RunningIndex; hv_Index.Continue(end_val411, step_val411); hv_Index = hv_Index.TupleAdd(step_val411))
                        {
                            hv_Color.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Color = hv_ThresholdColors.TupleSelect(
                                    hv_Index);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Threshold " + (hv_Index + 1),
                                        "image", (125 + hv_HistogramLegendVerticalOffset) + (hv_Index * hv_Offset),
                                        20, hv_Color, "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "None available for display",
                                    "image", 125 + hv_HistogramLegendVerticalOffset, 20, "black", "box",
                                    "false");
                            }
                        }
                    }
                    //
                    //Recalculate Window Coordinates for the following plots.
                    hv_WindowHandle.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_score_legend", out hv_WindowHandle);
                    hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_Width,
                        out hv_Height);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(
                                hv_Width);
                            hv_WindowMaxColumn.Dispose();
                            hv_WindowMaxColumn = ExpTmpLocalVar_WindowMaxColumn;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowColumn = (hv_WindowColumn + hv_WindowMaxColumn) + hv_WindowColumnSeparator;
                            hv_WindowColumn.Dispose();
                            hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                        }
                    }
                    hv_WindowRow.Dispose();
                    hv_WindowRow = 0;
                    hv_WindowMaxColumn.Dispose();
                    hv_WindowMaxColumn = 0;
                    HOperatorSet.FlushBuffer(hv_WindowHandleScoreLegend);
                    HOperatorSet.SetWindowParam(hv_WindowHandleScoreLegend, "flush", hv_FlushStateScoreLegend);
                }
                //
                //Visualization of precision pie charts.
                if ((int)(hv_DisplayPieChartPrecision) != 0)
                {
                    //
                    //Check if there is already a window handle.
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_precision",
                        out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandlePrecision);
                        HDevWindowStack.Push(hv_WindowHandlePrecision);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision",
                            hv_WindowHandlePrecision);
                    }
                    else
                    {
                        hv_WindowHandlePrecision.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision",
                            out hv_WindowHandlePrecision);
                    }
                    //
                    //Display.
                    set_display_font(hv_WindowHandlePrecision, hv_FontSize, hv_Font, "true",
                        "false");
                    dev_display_anomaly_evaluation_pie_chart(hv_WindowHandlePrecision, hv_EvaluationResult,
                        "precision", hv_EvaluationThresholdIndex);
                    //
                    hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetWindowExtents(hv_WindowHandlePrecision, out hv__, out hv__,
                        out hv_Width, out hv_Height);
                    HDevWindowStack.SetActive(hv_WindowHandlePrecision);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_Width, hv_Height);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(
                                hv_Width);
                            hv_WindowMaxColumn.Dispose();
                            hv_WindowMaxColumn = ExpTmpLocalVar_WindowMaxColumn;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowRow = (hv_WindowRow + hv_Height) + 55;
                            hv_WindowRow.Dispose();
                            hv_WindowRow = ExpTmpLocalVar_WindowRow;
                        }
                    }
                }
                //
                // Visualization of recall pie charts.
                if ((int)(hv_DisplayPieChartRecall) != 0)
                {
                    //
                    //Check if there is already a window handle.
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_recall",
                        out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandleRecall);
                        HDevWindowStack.Push(hv_WindowHandleRecall);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall",
                            hv_WindowHandleRecall);
                    }
                    else
                    {
                        hv_WindowHandleRecall.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall",
                            out hv_WindowHandleRecall);
                    }
                    //Display.
                    set_display_font(hv_WindowHandleRecall, hv_FontSize, hv_Font, "true", "false");
                    dev_display_anomaly_evaluation_pie_chart(hv_WindowHandleRecall, hv_EvaluationResult,
                        "recall", hv_EvaluationThresholdIndex);
                    //Recalculate Window Coordinates for the following plots.
                    hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetWindowExtents(hv_WindowHandleRecall, out hv__, out hv__,
                        out hv_Width, out hv_Height);
                    HDevWindowStack.SetActive(hv_WindowHandleRecall);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_Width, hv_Height);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(
                                hv_Width);
                            hv_WindowMaxColumn.Dispose();
                            hv_WindowMaxColumn = ExpTmpLocalVar_WindowMaxColumn;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowRow = (hv_WindowRow + hv_Height) + 55;
                            hv_WindowRow.Dispose();
                            hv_WindowRow = ExpTmpLocalVar_WindowRow;
                        }
                    }
                }
                //
                //Set window coordinates in order to display in a new column.
                hv_WindowRow.Dispose();
                hv_WindowRow = 0;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_WindowColumn = (hv_WindowColumn + hv_WindowMaxColumn) + hv_WindowColumnSeparator;
                        hv_WindowColumn.Dispose();
                        hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                    }
                }
                hv_WindowMaxColumn.Dispose();
                hv_WindowMaxColumn = 0;
                //
                //Visualization of confusion matrices.
                if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
                {
                    //Set general generic parameters for dev_display_matrix.
                    hv_GenParam_COPY_INP_TMP.Dispose();
                    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                        hv_DisplayColumnWidth);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", hv_DisplayMatrixColor);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "row_col_names_color",
                        hv_RowColNameColor);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "axis_titles", (new HTuple("Ground truth")).TupleConcat(
                        "Predicted"));
                    //Set row and column names.
                    hv_RowColumnNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParam, "class_names", out hv_RowColumnNames);
                    if ((int)(new HTuple(hv_DisplayMatrixColor.TupleEqual(1))) != 0)
                    {
                        //Display off-diagonal values in red.
                        hv_ValueColors.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValueColors = HTuple.TupleGenConst(
                                4, "#ff4500");
                        }
                        //Display diagonal values in green.
                        hv_DiagonalColor.Dispose();
                        hv_DiagonalColor = "#00ff00";
                        //Matrix entries get indices numbered as following:
                        //a(1,1), a(1,2), ..., a(1,n), a(2,1), a(2,2), ... , a(2,n), ... a(m,1), a(m,2), ..., a(m,n)
                        hv_DiagonalIndices.Dispose();
                        hv_DiagonalIndices = new HTuple();
                        hv_DiagonalIndices[0] = 0;
                        hv_DiagonalIndices[1] = 3;
                        if (hv_ValueColors == null)
                            hv_ValueColors = new HTuple();
                        hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "value_colors", hv_ValueColors);
                    }
                    //
                    //Display confusion matrices.
                    hv_DisplayMatrices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayMatrices = new HTuple();
                        hv_DisplayMatrices = hv_DisplayMatrices.TupleConcat(hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative);
                    }
                    hv_Strings.Dispose();
                    hv_Strings = new HTuple();
                    hv_Strings[0] = "absolute";
                    hv_Strings[1] = "relative";
                    hv_CapitalStrings.Dispose();
                    hv_CapitalStrings = new HTuple();
                    hv_CapitalStrings[0] = "Absolute";
                    hv_CapitalStrings[1] = "Relative";
                    hv_TitelAdditions.Dispose();
                    hv_TitelAdditions = new HTuple();
                    hv_TitelAdditions[0] = "    ";
                    hv_TitelAdditions[1] = " [%]";
                    //
                    for (hv_IndexMatrixToDisplay = 0; (int)hv_IndexMatrixToDisplay <= (int)((new HTuple(hv_DisplayMatrices.TupleLength()
                        )) - 1); hv_IndexMatrixToDisplay = (int)hv_IndexMatrixToDisplay + 1)
                    {
                        if ((int)(((hv_DisplayMatrices.TupleSelect(hv_IndexMatrixToDisplay))).TupleNot()
                            ) != 0)
                        {
                            continue;
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ConfusionMatrixDictionaries.Dispose();
                                HOperatorSet.GetDictTuple(hv_EvaluationResult, (hv_Strings.TupleSelect(
                                    hv_IndexMatrixToDisplay)) + "_confusion_matrix", out hv_ConfusionMatrixDictionaries);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException(("No evaluation available for " + (hv_Strings.TupleSelect(
                                hv_IndexMatrixToDisplay))) + " confusion matrix");
                        }
                        //Check that the specified index is valid.
                        if ((int)(new HTuple(hv_EvaluationThresholdIndex.TupleGreater((new HTuple(hv_ConfusionMatrixDictionaries.TupleLength()
                            )) - 1))) != 0)
                        {
                            throw new HalconException((("No " + (hv_Strings.TupleSelect(
                                hv_IndexMatrixToDisplay))) + " confusion matrix available for 'classification_threshold_index': ") + hv_EvaluationThresholdIndex);
                        }
                        hv_ConfusionMatrixDictionary.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfusionMatrixDictionary = hv_ConfusionMatrixDictionaries.TupleSelect(
                                hv_EvaluationThresholdIndex);
                        }
                        //
                        hv_ConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_ConfusionMatrixDictionary, "confusion_matrix",
                            out hv_ConfusionMatrix);
                        hv_ThresholdValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_ConfusionMatrixDictionary, "threshold", out hv_ThresholdValue);
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", ((hv_CapitalStrings.TupleSelect(
                                hv_IndexMatrixToDisplay)) + " confusion matrix") + (hv_TitelAdditions.TupleSelect(
                                hv_IndexMatrixToDisplay)));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "subtitle", "Threshold: " + hv_ThresholdValue);
                        }
                        //
                        //Copy matrix for display since it might need to be adapted.
                        hv_ConfusionMatrixDisplay.Dispose();
                        HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out hv_ConfusionMatrixDisplay);
                        //Convert relative matrix values to percent.
                        if ((int)(new HTuple(((hv_Strings.TupleSelect(hv_IndexMatrixToDisplay))).TupleEqual(
                            "relative"))) != 0)
                        {
                            hv_ValuesRelative.Dispose();
                            HOperatorSet.GetFullMatrix(hv_ConfusionMatrixDisplay, out hv_ValuesRelative);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetFullMatrix(hv_ConfusionMatrixDisplay, 100 * hv_ValuesRelative);
                            }
                        }
                        //Calculate proper number format.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_ConfusionMatrixDisplay, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        if ((int)(new HTuple(hv_MaxValue.TupleGreater(0))) != 0)
                        {
                            hv_NumberFormat.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
                                    )).TupleCeil())).TupleInt()) + ".0f";
                            }
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = "1.0f";
                        }
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
                        //
                        //Check if there is already a window handle.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowExists.Dispose();
                            HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", ("window_" + (hv_Strings.TupleSelect(
                                hv_IndexMatrixToDisplay))) + "_confusion_matrix", out hv_WindowExists);
                        }
                        if ((int)(hv_WindowExists.TupleNot()) != 0)
                        {
                            HOperatorSet.SetWindowAttr("background_color", "black");
                            HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandleConfusion);
                            HDevWindowStack.Push(hv_WindowHandleConfusion);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_WindowHandleDict, ("window_" + (hv_Strings.TupleSelect(
                                    hv_IndexMatrixToDisplay))) + "_confusion_matrix", hv_WindowHandleConfusion);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowHandleConfusion.Dispose();
                                HOperatorSet.GetDictTuple(hv_WindowHandleDict, ("window_" + (hv_Strings.TupleSelect(
                                    hv_IndexMatrixToDisplay))) + "_confusion_matrix", out hv_WindowHandleConfusion);
                            }
                        }
                        //
                        //Display.
                        set_display_font(hv_WindowHandleConfusion, hv_FontSize, hv_Font, "true",
                            "false");
                        dev_display_matrix(hv_ConfusionMatrixDisplay, hv_RowColumnNames, hv_RowColumnNames,
                            hv_WindowHandleConfusion, hv_GenParam_COPY_INP_TMP);
                        //Recalculate Window Coordinates for the following plots.
                        hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                        HOperatorSet.GetWindowExtents(hv_WindowHandleConfusion, out hv__, out hv__,
                            out hv_Width, out hv_Height);
                        HDevWindowStack.SetActive(hv_WindowHandleConfusion);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                                    hv_WindowColumn, hv_Width, hv_Height + 15);
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowMaxColumn = hv_WindowMaxColumn.TupleMax2(
                                    hv_Width);
                                hv_WindowMaxColumn.Dispose();
                                hv_WindowMaxColumn = ExpTmpLocalVar_WindowMaxColumn;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowRow = (hv_WindowRow + hv_Height) + 55;
                                hv_WindowRow.Dispose();
                                hv_WindowRow = ExpTmpLocalVar_WindowRow;
                            }
                        }
                    }
                }
                //

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_BackgroundColor.Dispose();
                hv_OKColor.Dispose();
                hv_OKColorPlot.Dispose();
                hv_NOKColor.Dispose();
                hv_NOKColorPlot.Dispose();
                hv_IntermediateColor.Dispose();
                hv_PredefinedColors.Dispose();
                hv_EvaluationThresholds.Dispose();
                hv_AdditionalThresholds.Dispose();
                hv_EvaluationThresholdIndex.Dispose();
                hv_RowColNameColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayMatrixColor.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_HistogramLegendVerticalOffset.Dispose();
                hv_NumXTicks.Dispose();
                hv_HistogramMin.Dispose();
                hv_HistogramMax.Dispose();
                hv_DisplayThresholds.Dispose();
                hv_DisplayScoreHistogram.Dispose();
                hv_DisplayScoreLegend.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartRecall.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowMaxColumn.Dispose();
                hv_WindowColumnSeparator.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_ThresholdValues.Dispose();
                hv_DisplayMode.Dispose();
                hv_DisplayAll.Dispose();
                hv_MinValue.Dispose();
                hv_MaxValue.Dispose();
                hv_CalculateHistogramMin.Dispose();
                hv_CalculateHistogramMax.Dispose();
                hv_EvaluationType.Dispose();
                hv_EvalThresholdsExist.Dispose();
                hv_DiffEpsilon.Dispose();
                hv_RemoveIndices.Dispose();
                hv_ThresholdIdx.Dispose();
                hv_MinThresholdDiff.Dispose();
                hv_AllThresholds.Dispose();
                hv_ThresholdColors.Dispose();
                hv_UseSpecificLegend.Dispose();
                hv_RandomColors.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_AnomalyScores.Dispose();
                hv_HistogramWidthOK.Dispose();
                hv_HistogramRangeWidth.Dispose();
                hv_HistogramWidthNOK.Dispose();
                hv_MaxScore.Dispose();
                hv_MinScore.Dispose();
                hv_TicksX.Dispose();
                hv_FormatX.Dispose();
                hv_OKMinY.Dispose();
                hv_OKMinIndex.Dispose();
                hv_NOKMaxY.Dispose();
                hv_NOKMaxIndex.Dispose();
                hv_MaxY.Dispose();
                hv_PlotOKXValues.Dispose();
                hv_PlotOKYValues.Dispose();
                hv_OKIndex.Dispose();
                hv_PlotNOKXValues.Dispose();
                hv_PlotNOKYValues.Dispose();
                hv_NOKIndex.Dispose();
                hv_WindowScoreHistogramExists.Dispose();
                hv_WindowHandleScoreHistogram.Dispose();
                hv_FlushStateScoreHistogram.Dispose();
                hv_Index.Dispose();
                hv_Color.Dispose();
                hv_WindowHandle.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WindowScoreLegendExists.Dispose();
                hv_WindowHandleScoreLegend.Dispose();
                hv_FlushStateScoreLegend.Dispose();
                hv_Offset.Dispose();
                hv_RunningIndex.Dispose();
                hv_ThresholdCaptions.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandlePrecision.Dispose();
                hv_WindowHandleRecall.Dispose();
                hv_RowColumnNames.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_DisplayMatrices.Dispose();
                hv_Strings.Dispose();
                hv_CapitalStrings.Dispose();
                hv_TitelAdditions.Dispose();
                hv_IndexMatrixToDisplay.Dispose();
                hv_ConfusionMatrixDictionaries.Dispose();
                hv_ConfusionMatrixDictionary.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ThresholdValue.Dispose();
                hv_ConfusionMatrixDisplay.Dispose();
                hv_ValuesRelative.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_NumberFormat.Dispose();
                hv_WindowHandleConfusion.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_BackgroundColor.Dispose();
                hv_OKColor.Dispose();
                hv_OKColorPlot.Dispose();
                hv_NOKColor.Dispose();
                hv_NOKColorPlot.Dispose();
                hv_IntermediateColor.Dispose();
                hv_PredefinedColors.Dispose();
                hv_EvaluationThresholds.Dispose();
                hv_AdditionalThresholds.Dispose();
                hv_EvaluationThresholdIndex.Dispose();
                hv_RowColNameColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayMatrixColor.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_HistogramLegendVerticalOffset.Dispose();
                hv_NumXTicks.Dispose();
                hv_HistogramMin.Dispose();
                hv_HistogramMax.Dispose();
                hv_DisplayThresholds.Dispose();
                hv_DisplayScoreHistogram.Dispose();
                hv_DisplayScoreLegend.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartRecall.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowMaxColumn.Dispose();
                hv_WindowColumnSeparator.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_ThresholdValues.Dispose();
                hv_DisplayMode.Dispose();
                hv_DisplayAll.Dispose();
                hv_MinValue.Dispose();
                hv_MaxValue.Dispose();
                hv_CalculateHistogramMin.Dispose();
                hv_CalculateHistogramMax.Dispose();
                hv_EvaluationType.Dispose();
                hv_EvalThresholdsExist.Dispose();
                hv_DiffEpsilon.Dispose();
                hv_RemoveIndices.Dispose();
                hv_ThresholdIdx.Dispose();
                hv_MinThresholdDiff.Dispose();
                hv_AllThresholds.Dispose();
                hv_ThresholdColors.Dispose();
                hv_UseSpecificLegend.Dispose();
                hv_RandomColors.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_AnomalyScores.Dispose();
                hv_HistogramWidthOK.Dispose();
                hv_HistogramRangeWidth.Dispose();
                hv_HistogramWidthNOK.Dispose();
                hv_MaxScore.Dispose();
                hv_MinScore.Dispose();
                hv_TicksX.Dispose();
                hv_FormatX.Dispose();
                hv_OKMinY.Dispose();
                hv_OKMinIndex.Dispose();
                hv_NOKMaxY.Dispose();
                hv_NOKMaxIndex.Dispose();
                hv_MaxY.Dispose();
                hv_PlotOKXValues.Dispose();
                hv_PlotOKYValues.Dispose();
                hv_OKIndex.Dispose();
                hv_PlotNOKXValues.Dispose();
                hv_PlotNOKYValues.Dispose();
                hv_NOKIndex.Dispose();
                hv_WindowScoreHistogramExists.Dispose();
                hv_WindowHandleScoreHistogram.Dispose();
                hv_FlushStateScoreHistogram.Dispose();
                hv_Index.Dispose();
                hv_Color.Dispose();
                hv_WindowHandle.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WindowScoreLegendExists.Dispose();
                hv_WindowHandleScoreLegend.Dispose();
                hv_FlushStateScoreLegend.Dispose();
                hv_Offset.Dispose();
                hv_RunningIndex.Dispose();
                hv_ThresholdCaptions.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandlePrecision.Dispose();
                hv_WindowHandleRecall.Dispose();
                hv_RowColumnNames.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_DisplayMatrices.Dispose();
                hv_Strings.Dispose();
                hv_CapitalStrings.Dispose();
                hv_TitelAdditions.Dispose();
                hv_IndexMatrixToDisplay.Dispose();
                hv_ConfusionMatrixDictionaries.Dispose();
                hv_ConfusionMatrixDictionary.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ThresholdValue.Dispose();
                hv_ConfusionMatrixDisplay.Dispose();
                hv_ValuesRelative.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_NumberFormat.Dispose();
                hv_WindowHandleConfusion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Display pie charts for prediction or recall of an anomaly detection or Global Context Anomaly Detection evaluation. 
        public void dev_display_anomaly_evaluation_pie_chart(HTuple hv_WindowHandle, HTuple hv_EvaluationResult,
            HTuple hv_Mode, HTuple hv_ThresholdIndex)
        {



            // Local iconic variables 

            HObject ho_Image;

            // Local control variables 

            HTuple hv_FlushValue = new HTuple(), hv_CenterRowOverall = new HTuple();
            HTuple hv_CenterColOverall = new HTuple(), hv_RadiusOverall = new HTuple();
            HTuple hv_RadiusClass = new HTuple(), hv_ChartRowDistance = new HTuple();
            HTuple hv_ChartColDistance = new HTuple(), hv_StartRow = new HTuple();
            HTuple hv_StartCol = new HTuple(), hv_KeyToPlot = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_NumClassCharts = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_AllMeanValues = new HTuple();
            HTuple hv_AllValuesPerClass = new HTuple(), hv_MeanValue = new HTuple();
            HTuple hv_ValuesPerClass = new HTuple(), hv_MainTitle = new HTuple();
            HTuple hv_ClassTitles = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_ColorDataUnavailable = new HTuple(), hv_GenParamPieChart = new HTuple();
            HTuple hv_Description = new HTuple(), hv_PercentStr = new HTuple();
            HTuple hv_Index = new HTuple(), hv_CenterRow = new HTuple();
            HTuple hv_CenterCol = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //
                //This procedure plots pie charts for precision and recall.
                //More detailed, the mean over all classes that have been used for
                //evaluation and the values for each class are plotted.
                //
                //Switch off automatic flushing to make visualization smooth.
                hv_FlushValue.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_FlushValue);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
                //Drawing parameters.
                //Overall pie-chart.
                hv_CenterRowOverall.Dispose();
                hv_CenterRowOverall = 150;
                hv_CenterColOverall.Dispose();
                hv_CenterColOverall = 150;
                hv_RadiusOverall.Dispose();
                hv_RadiusOverall = 100;
                //Per-class pie-chart.
                hv_RadiusClass.Dispose();
                hv_RadiusClass = 40;
                hv_ChartRowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartRowDistance = 3 * hv_RadiusClass;
                }
                hv_ChartColDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartColDistance = 2.5 * hv_RadiusClass;
                }
                hv_StartRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartRow = (hv_CenterRowOverall + (1.5 * hv_RadiusOverall)) + (1.5 * hv_RadiusClass);
                }
                hv_StartCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartCol = 1.5 * hv_RadiusClass;
                }
                //
                //Get values.
                hv_KeyToPlot.Dispose();
                hv_KeyToPlot = "global_evaluation";
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvaluationResult, "key_exists", hv_KeyToPlot,
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_NumClassCharts.Dispose();
                    hv_NumClassCharts = 2;
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_KeyToPlot, out hv_Measures);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AllMeanValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_Measures, "mean_" + hv_Mode, out hv_AllMeanValues);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AllValuesPerClass.Dispose();
                        HOperatorSet.GetDictTuple(hv_Measures, hv_Mode + "_per_class", out hv_AllValuesPerClass);
                    }
                    //Check that the specified index is valid.
                    if ((int)((new HTuple(hv_ThresholdIndex.TupleGreater((new HTuple(hv_AllMeanValues.TupleLength()
                        )) - 1))).TupleOr(new HTuple(hv_ThresholdIndex.TupleGreater(((new HTuple(hv_AllValuesPerClass.TupleLength()
                        )) / 2) - 1)))) != 0)
                    {
                        throw new HalconException((("No " + hv_Mode) + " values available for 'classification_threshold_index': ") + hv_ThresholdIndex);
                    }
                    hv_MeanValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanValue = hv_AllMeanValues.TupleSelect(
                            hv_ThresholdIndex);
                    }
                    hv_ValuesPerClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValuesPerClass = hv_AllValuesPerClass.TupleSelectRange(
                            hv_ThresholdIndex * 2, (hv_ThresholdIndex * 2) + 1);
                    }
                    hv_MainTitle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MainTitle = "Mean class " + hv_Mode;
                    }
                    hv_ClassTitles.Dispose();
                    hv_ClassTitles = new HTuple();
                    hv_ClassTitles[0] = "ok";
                    hv_ClassTitles[1] = "nok";
                }
                else
                {
                    throw new HalconException(((("The dictionary EvaluationResult needs a key '" + hv_KeyToPlot) + "' with the ") + hv_Mode) + " values.");
                }
                //
                //Open Window and set font.
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = (new HTuple(550)).TupleMax2(
                        ((hv_NumClassCharts - 1) * hv_ChartColDistance) + (2 * hv_StartCol));
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = (3 * hv_RadiusOverall) + (3 * hv_RadiusClass);
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 0, 0, hv_WindowWidth,
                        hv_WindowHeight);
                }
                ho_Image.Dispose();
                HOperatorSet.GenImageConst(out ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Draw the pie-chart.
                hv_Colors.Dispose();
                hv_Colors = new HTuple();
                hv_Colors[0] = "green";
                hv_Colors[1] = "red";
                hv_ColorDataUnavailable.Dispose();
                hv_ColorDataUnavailable = "gray";
                hv_GenParamPieChart.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamPieChart);
                HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_MainTitle);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    dev_display_pie_chart(hv_WindowHandle, hv_MeanValue.TupleConcat(1.0 - hv_MeanValue),
                        hv_CenterRowOverall, hv_CenterColOverall, hv_RadiusOverall, hv_Colors,
                        hv_GenParamPieChart);
                }
                //
                //Write description for pie chart.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Results: ", "image",
                            20, (hv_CenterColOverall + hv_RadiusOverall) + 20, "white", "box", "false");
                    }
                }
                if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
                {
                    hv_Description.Dispose();
                    hv_Description = new HTuple();
                    hv_Description[0] = "precision (TP / (TP + FP))";
                    hv_Description[1] = "false positives";
                }
                else if ((int)(new HTuple(hv_Mode.TupleEqual("recall"))) != 0)
                {
                    hv_Description.Dispose();
                    hv_Description = new HTuple();
                    hv_Description[0] = "recall (TP / (TP + FN))";
                    hv_Description[1] = "false negatives";
                }
                else
                {
                    throw new HalconException("Mode not supported: " + hv_Mode);
                }
                hv_PercentStr.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PercentStr = ((((hv_MeanValue.TupleConcat(
                        1.0 - hv_MeanValue)) * 100)).TupleString(".1f")) + "";
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Description.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
                                hv_Index)) + "%: ") + (hv_Description.TupleSelect(hv_Index)), "image",
                                30 + ((hv_Index + 1) * 20), (hv_CenterColOverall + hv_RadiusOverall) + 20, hv_Colors.TupleSelect(
                                hv_Index), "box", "false");
                        }
                    }
                }
                //
                //Per class pie charts.
                HTuple end_val71 = hv_NumClassCharts - 1;
                HTuple step_val71 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val71, step_val71); hv_Index = hv_Index.TupleAdd(step_val71))
                {
                    //Get the position of the class-pie-chart.
                    hv_CenterRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterRow = hv_StartRow + (((((hv_Index.TupleReal()
                            ) / 2)).TupleFloor()) * hv_ChartRowDistance);
                    }
                    hv_CenterCol.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterCol = hv_StartCol + ((hv_Index % 2) * hv_ChartColDistance);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_ClassTitles.TupleSelect(
                            hv_Index));
                    }
                    if ((int)(new HTuple(((hv_ValuesPerClass.TupleSelect(hv_Index))).TupleGreaterEqual(
                        0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            dev_display_pie_chart(hv_WindowHandle, ((hv_ValuesPerClass.TupleSelect(
                                hv_Index))).TupleConcat(1.0 - (hv_ValuesPerClass.TupleSelect(hv_Index))),
                                hv_CenterRow, hv_CenterCol, hv_RadiusClass, hv_Colors, hv_GenParamPieChart);
                        }
                    }
                    else
                    {
                        //No evaluation data was available for this class.
                        dev_display_pie_chart(hv_WindowHandle, 1.0, hv_CenterRow, hv_CenterCol,
                            hv_RadiusClass, hv_ColorDataUnavailable, hv_GenParamPieChart);
                    }
                }
                //
                //Flush buffer and reset value for 'flush'.
                HOperatorSet.FlushBuffer(hv_WindowHandle);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
                //
                ho_Image.Dispose();

                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_KeyToPlot.Dispose();
                hv_KeyExists.Dispose();
                hv_NumClassCharts.Dispose();
                hv_Measures.Dispose();
                hv_AllMeanValues.Dispose();
                hv_AllValuesPerClass.Dispose();
                hv_MeanValue.Dispose();
                hv_ValuesPerClass.Dispose();
                hv_MainTitle.Dispose();
                hv_ClassTitles.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_Colors.Dispose();
                hv_ColorDataUnavailable.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_Description.Dispose();
                hv_PercentStr.Dispose();
                hv_Index.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_KeyToPlot.Dispose();
                hv_KeyExists.Dispose();
                hv_NumClassCharts.Dispose();
                hv_Measures.Dispose();
                hv_AllMeanValues.Dispose();
                hv_AllValuesPerClass.Dispose();
                hv_MeanValue.Dispose();
                hv_ValuesPerClass.Dispose();
                hv_MainTitle.Dispose();
                hv_ClassTitles.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_Colors.Dispose();
                hv_ColorDataUnavailable.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_Description.Dispose();
                hv_PercentStr.Dispose();
                hv_Index.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of the confidences. 
        private void dev_display_confidence_regions(HObject ho_ImageConfidence, HTuple hv_DrawTransparency,
            out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Region = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
            HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Region);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the confidences
                //given in ImageConfidence as regions.
                //DrawTransparency determines the alpha value of the colors.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                //
                //Threshold the image according to
                //the number of colors and
                //display resulting regions.
                HTuple end_val15 = hv_NumColors - 1;
                HTuple step_val15 = 1;
                for (hv_ColorIndex = 0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
                {
                    hv_Threshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Threshold = hv_ColorIndex * (1.0 / hv_NumColors);
                    }
                    hv_MinGray.Dispose();
                    hv_MinGray = new HTuple(hv_Threshold);
                    hv_MaxGray.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxGray = hv_Threshold + (1 / hv_NumColors);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold + (1.0 / hv_NumColors));
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
                    }
                }
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize different images, annotations and inference results for a sample. 
        public void dev_display_dl_data(HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo,
            HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_Domain = null, ho_GrippingMapImageResult = null;
            HObject ho_Cross = null, ho_GrippingMapGroundTruth = null, ho_X = null;
            HObject ho_Y = null, ho_Z = null, ho_AnomalyImage = null, ho_AnomalyRegion = null;
            HObject ho_ConfidenceImage = null, ho_HeatmapScene = null, ho_ScoreMaps = null;
            HObject ho_CharacterScoreMap = null, ho_LinkScoreMap = null;
            HObject ho_OrientationSinScoreMap = null, ho_OrientationCosScoreMap = null;
            HObject ho_ScoreMap = null, ho_OrientationScoreMap = null, ho_PredictionColorFrame = null;
            HObject ho_ImageHeatmap = null, ho_PredictionSymbol = null;
            HObject ho_CrossLineH = null, ho_CrossLineV = null, ho_ImageConfidence = null;
            HObject ho_SegmentationImagGroundTruth = null, ho_SegmentationImageResult = null;
            HObject ho_ImageAbsDiff = null, ho_DiffRegion = null, ho_ImageWeight = null;

            // Local control variables 

            HTuple hv_Params = new HTuple(), hv_GenParamNames = new HTuple();
            HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_SampleKeys = new HTuple();
            HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
            HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
            HTuple hv_IsOCRDetection = new HTuple(), hv_AdditionalGreenClassNames = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_OcrResult = new HTuple();
            HTuple hv_MaxClassIdSample = new HTuple(), hv_EmptySample = new HTuple();
            HTuple hv_MaxClassIdResult = new HTuple(), hv_EmptyResult = new HTuple();
            HTuple hv_MaxClassId = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_ClassNameKey = new HTuple();
            HTuple hv_ClassIdKey = new HTuple(), hv_ResultClassNames = new HTuple();
            HTuple hv_ResultClassIds = new HTuple(), hv_SortIndices = new HTuple();
            HTuple hv_UniqueClassIds = new HTuple(), hv_UniqueClassNames = new HTuple();
            HTuple hv_Colors = new HTuple(), hv_ClassesLegend = new HTuple();
            HTuple hv_InvalidInput = new HTuple(), hv_ClassKeys = new HTuple();
            HTuple hv_ClassKeysExist = new HTuple(), hv_DLDatasetInfoKeys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_MetaInfoExists = new HTuple(), hv_FlushValues = new HTuple();
            HTuple hv_WindowHandleKeys = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
            HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
            HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
            HTuple hv_ColorsGrippingGroundTruth = new HTuple(), hv_ImageClassIDs = new HTuple();
            HTuple hv_GrippingPointsExists = new HTuple(), hv_Rows = new HTuple();
            HTuple hv_Columns = new HTuple(), hv_AnomalyImages = new HTuple();
            HTuple hv_PossibleKeysForDisplay = new HTuple(), hv_AddDisplayKey = new HTuple();
            HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
            HTuple hv_AnomalyResultPostfix = new HTuple(), hv_AnomalyScore = new HTuple();
            HTuple hv_AnomalyClassID = new HTuple(), hv_AnomalyClassThresholdDisplay = new HTuple();
            HTuple hv_AnomalyRegionThresholdDisplay = new HTuple();
            HTuple hv_WindowHandleName = new HTuple(), hv_AnomalyRegionGroundTruthExists = new HTuple();
            HTuple hv_Text = new HTuple(), hv_PredictionColor = new HTuple();
            HTuple hv_LineColors = new HTuple(), hv_ResultColorOffset = new HTuple();
            HTuple hv_AnomalyRegionExists = new HTuple(), hv_AnomalyImageKey = new HTuple();
            HTuple hv_AnomalyScoreKey = new HTuple(), hv_AnomalyResultKey = new HTuple();
            HTuple hv_AnomalyRegionKey = new HTuple(), hv_DisplayDirectionTemp = new HTuple();
            HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxConfidences = new HTuple();
            HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
            HTuple hv_BboxColorsBoth = new HTuple(), hv_BboxClassLabelIndexUniq = new HTuple();
            HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
            HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxColorsResults = new HTuple();
            HTuple hv_BboxClassIndexUniq = new HTuple(), hv_ClassificationLabelIDGroundTruth = new HTuple();
            HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_PredictionText = new HTuple();
            HTuple hv_BoarderOffset = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
            HTuple hv_MarginBottom = new HTuple(), hv_WindowCoordinates = new HTuple();
            HTuple hv_CurrentWindowHeight = new HTuple(), hv__ = new HTuple();
            HTuple hv_MaxHeight = new HTuple(), hv_SelectedHeatmapMethod = new HTuple();
            HTuple hv_DictHeatmap = new HTuple(), hv_MethodName = new HTuple();
            HTuple hv_HeatmapKeys = new HTuple(), hv_HeatmapImageName = new HTuple();
            HTuple hv_TargetClassID = new HTuple(), hv_Confidences = new HTuple();
            HTuple hv_MaxDeviation = new HTuple(), hv_ClassificationLabelNameResult = new HTuple();
            HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
            HTuple hv_ShowGT = new HTuple(), hv_ShowResult = new HTuple();
            HTuple hv_NumLines = new HTuple(), hv_Type = new HTuple();
            HTuple hv_GTWordKeyExists = new HTuple(), hv_HeightWindow = new HTuple();
            HTuple hv_HeightMarginBottom = new HTuple(), hv_Size = new HTuple();
            HTuple hv_Length = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DCompose = new HTuple();
            HTuple hv_PredictionForegroundColor = new HTuple(), hv_PredictionBackgroundColor = new HTuple();
            HTuple hv_Spaces = new HTuple(), hv_ConfidenceColors = new HTuple();
            HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
            HTuple hv_ResultIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
            HTuple hv_ImageClassIDsIndices = new HTuple(), hv_ImageClassIDsIndex = new HTuple();
            HTuple hv_StringSegExcludeClassIDs = new HTuple(), hv_StringIndex = new HTuple();
            HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_ColorsSegmentation = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Width = new HTuple(), hv_MinWeight = new HTuple();
            HTuple hv_WeightsColors = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_WindowHandleKeysNew = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_2 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_3 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_4 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_5 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_6 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_7 = new HTuple();
            HTuple hv___Tmp_Ctrl_1 = new HTuple(), hv___Tmp_Ctrl_Type = new HTuple();
            HTuple hv_DLResult_COPY_INP_TMP = new HTuple(hv_DLResult);
            HTuple hv_KeysForDisplay_COPY_INP_TMP = new HTuple(hv_KeysForDisplay);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_GrippingMapImageResult);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_GrippingMapGroundTruth);
            HOperatorSet.GenEmptyObj(out ho_X);
            HOperatorSet.GenEmptyObj(out ho_Y);
            HOperatorSet.GenEmptyObj(out ho_Z);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            HOperatorSet.GenEmptyObj(out ho_ConfidenceImage);
            HOperatorSet.GenEmptyObj(out ho_HeatmapScene);
            HOperatorSet.GenEmptyObj(out ho_ScoreMaps);
            HOperatorSet.GenEmptyObj(out ho_CharacterScoreMap);
            HOperatorSet.GenEmptyObj(out ho_LinkScoreMap);
            HOperatorSet.GenEmptyObj(out ho_OrientationSinScoreMap);
            HOperatorSet.GenEmptyObj(out ho_OrientationCosScoreMap);
            HOperatorSet.GenEmptyObj(out ho_ScoreMap);
            HOperatorSet.GenEmptyObj(out ho_OrientationScoreMap);
            HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
            HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
            HOperatorSet.GenEmptyObj(out ho_PredictionSymbol);
            HOperatorSet.GenEmptyObj(out ho_CrossLineH);
            HOperatorSet.GenEmptyObj(out ho_CrossLineV);
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
            HOperatorSet.GenEmptyObj(out ho_DiffRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            try
            {
                //
                //This procedure displays the content of the provided DLSample and/or DLResult
                //depending on the input string KeysForDisplay.
                //DLDatasetInfo is a dictionary containing the information about the dataset.
                //The visualization can be adapted with GenParam.
                //
                //** Set the default values: ***
                hv_Params.Dispose();
                HOperatorSet.CreateDict(out hv_Params);
                //
                //Define the screen width when a new window row is started.
                HOperatorSet.SetDictTuple(hv_Params, "threshold_width", 1024);
                //Since potentially a lot of windows are opened,
                //scale the windows consistently.
                HOperatorSet.SetDictTuple(hv_Params, "scale_windows", 0.8);
                //Set a font and a font size.
                HOperatorSet.SetDictTuple(hv_Params, "font", "mono");
                HOperatorSet.SetDictTuple(hv_Params, "font_size", 14);
                //
                HOperatorSet.SetDictTuple(hv_Params, "line_width", 2);
                HOperatorSet.SetDictTuple(hv_Params, "map_transparency", "cc");
                HOperatorSet.SetDictTuple(hv_Params, "map_color_bar_width", 140);
                //
                //Define parameter values specifically for 3d_gripping_point_detection
                HOperatorSet.SetDictTuple(hv_Params, "gripping_point_color", "#00FF0099");
                HOperatorSet.SetDictTuple(hv_Params, "gripping_point_size", 6);
                HOperatorSet.SetDictTuple(hv_Params, "region_color", "#FF000040");
                HOperatorSet.SetDictTuple(hv_Params, "gripping_point_map_color", "#83000080");
                HOperatorSet.SetDictTuple(hv_Params, "gripping_point_background_color", "#00007F80");
                //
                //Define parameter values specifically for anomaly detection
                //and Global Context Anomaly Detection.
                HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_threshold", -1);
                HOperatorSet.SetDictTuple(hv_Params, "anomaly_classification_threshold", -1);
                HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_label_color", "#40e0d0");
                HOperatorSet.SetDictTuple(hv_Params, "anomaly_color_transparency", "40");
                HOperatorSet.SetDictTuple(hv_Params, "anomaly_region_result_color", "#ff0000c0");
                //
                //Define segmentation-specific parameter values.
                HOperatorSet.SetDictTuple(hv_Params, "segmentation_max_weight", 0);
                HOperatorSet.SetDictTuple(hv_Params, "segmentation_draw", "fill");
                HOperatorSet.SetDictTuple(hv_Params, "segmentation_transparency", "aa");
                HOperatorSet.SetDictTuple(hv_Params, "segmentation_exclude_class_ids", new HTuple());
                //
                //Define bounding box-specific parameter values.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_Params, "bbox_label_color", new HTuple("#000000") + "99");
                }
                HOperatorSet.SetDictTuple(hv_Params, "bbox_display_confidence", 1);
                HOperatorSet.SetDictTuple(hv_Params, "bbox_text_color", "#eeeeee");
                //
                //By default, display a description on the bottom.
                HOperatorSet.SetDictTuple(hv_Params, "display_bottom_desc", 1);
                //
                //By default, show a legend with class IDs.
                HOperatorSet.SetDictTuple(hv_Params, "display_legend", 1);
                //
                //By default, show the anomaly ground truth regions.
                HOperatorSet.SetDictTuple(hv_Params, "display_ground_truth_anomaly_regions",
                    1);
                //
                //By default, show class IDs and color frames for classification ground truth/results.
                HOperatorSet.SetDictTuple(hv_Params, "display_classification_ids", 1);
                HOperatorSet.SetDictTuple(hv_Params, "display_classification_color_frame",
                    1);
                //
                //By default, show class labels for detection ground truth/results.
                HOperatorSet.SetDictTuple(hv_Params, "display_labels", 1);
                //
                //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
                HOperatorSet.SetDictTuple(hv_Params, "display_direction", 1);
                //
                //By default, use color scheme 'Jet' for the heatmap display.
                HOperatorSet.SetDictTuple(hv_Params, "heatmap_color_scheme", "jet");
                //** Set user-defined values: ***
                //
                //Overwrite default values by given generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamNames.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
                    for (hv_ParamIndex = 0; (int)hv_ParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                        )) - 1); hv_ParamIndex = (int)hv_ParamIndex + 1)
                    {
                        hv_GenParamName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GenParamName = hv_GenParamNames.TupleSelect(
                                hv_ParamIndex);
                        }
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Params, "key_exists", hv_GenParamName, out hv_KeyExists);
                        if ((int)(hv_KeyExists.TupleNot()) != 0)
                        {
                            throw new HalconException(("Unknown generic parameter: " + hv_GenParamName) + ".");
                        }
                        hv___Tmp_Ctrl_Type.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_data_type", hv_GenParamName,
                            out hv___Tmp_Ctrl_Type);
                        if ((int)(new HTuple(hv___Tmp_Ctrl_Type.TupleEqual("object"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictObject(hv_GenParam.TupleGetDictObject(hv_GenParamName),
                                    hv_Params, hv_GenParamName);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_Params, hv_GenParamName, hv_GenParam.TupleGetDictTuple(
                                    hv_GenParamName));
                            }
                        }
                    }
                }
                //
                if ((int)((new HTuple((new HTuple(hv_DLSample.TupleLength())).TupleGreater(
                    1))).TupleOr(new HTuple((new HTuple(hv_DLResult_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(1)))) != 0)
                {
                    throw new HalconException("Only a single dictionary for DLSample and DLResult is allowed");
                }
                //
                //Get the dictionary keys.
                hv_SampleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
                if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_ResultKeys);
                }
                //
                //Get image ID if it is available.
                hv_ImageIDExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
                if ((int)(hv_ImageIDExists) != 0)
                {
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
                    hv_ImageIDString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDString = "image ID " + hv_ImageID;
                    }
                    hv_ImageIDStringBraces.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringBraces = ("(image ID " + hv_ImageID) + ")";
                    }
                    hv_ImageIDStringCapital.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringCapital = "Image ID " + hv_ImageID;
                    }
                }
                else
                {
                    hv_ImageIDString.Dispose();
                    hv_ImageIDString = "";
                    hv_ImageIDStringBraces.Dispose();
                    hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
                    hv_ImageIDStringCapital.Dispose();
                    hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
                }
                //
                //** Convert a Deep OCR Detection result to an Object Detection result if necessary ***
                //
                hv_IsOCRDetection.Dispose();
                hv_IsOCRDetection = 0;
                hv_AdditionalGreenClassNames.Dispose();
                hv_AdditionalGreenClassNames = new HTuple();
                hv_KeyIndex.Dispose();
                hv_KeyIndex = 0;
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_KeysForDisplay_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    //Check if Deep OCR Detection case
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsOCRDetection.Dispose();
                        HOperatorSet.TupleStrstr(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                            "ocr_detection", out hv_IsOCRDetection);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_IsOCRDetection = new HTuple(hv_IsOCRDetection.TupleEqual(
                                0));
                            hv_IsOCRDetection.Dispose();
                            hv_IsOCRDetection = ExpTmpLocalVar_IsOCRDetection;
                        }
                    }
                    if ((int)(hv_IsOCRDetection) != 0)
                    {
                        //Turn off labels
                        HOperatorSet.SetDictTuple(hv_Params, "bbox_display_confidence", 0);
                        HOperatorSet.SetDictTuple(hv_Params, "display_labels", 0);
                        //Mark the class 'word' as green
                        hv_AdditionalGreenClassNames.Dispose();
                        hv_AdditionalGreenClassNames = "word";
                        if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_OcrResult.Dispose();
                            hv_OcrResult = new HTuple(hv_DLResult_COPY_INP_TMP);
                            hv_DLResult_COPY_INP_TMP.Dispose();
                            convert_ocr_detection_result_to_object_detection(hv_OcrResult, out hv_DLResult_COPY_INP_TMP);
                            hv_ResultKeys.Dispose();
                            HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "keys", new HTuple(),
                                out hv_ResultKeys);
                            break;
                        }
                    }
                }
                //
                //Check if DLDatasetInfo is valid.
                //
                if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
                {
                    hv_MaxClassIdSample.Dispose(); hv_EmptySample.Dispose();
                    dev_display_dl_data_get_max_class_id(hv_DLSample, out hv_MaxClassIdSample,
                        out hv_EmptySample);
                    hv_MaxClassIdResult.Dispose(); hv_EmptyResult.Dispose();
                    dev_display_dl_data_get_max_class_id(hv_DLResult_COPY_INP_TMP, out hv_MaxClassIdResult,
                        out hv_EmptyResult);
                    hv_MaxClassId.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxClassId = hv_MaxClassIdSample.TupleMax2(
                            hv_MaxClassIdResult);
                    }
                    if ((int)(hv_EmptySample.TupleAnd(hv_EmptyResult)) != 0)
                    {
                        hv_MaxClassId.Dispose();
                        hv_MaxClassId = 1;
                    }
                    if ((int)(new HTuple(hv_MaxClassId.TupleEqual(-1))) != 0)
                    {
                        hv_MaxClassId.Dispose();
                        hv_MaxClassId = 1000;
                    }
                    if ((int)(hv_IsOCRDetection) != 0)
                    {
                        hv_ClassNames.Dispose();
                        hv_ClassNames = new HTuple();
                        hv_ClassNames[0] = "word";
                        hv_ClassNames[1] = "char";
                        hv_ClassNames[2] = "ignore";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassIDs.Dispose();
                            HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassNames.TupleLength()
                                )) - 1, 1, out hv_ClassIDs);
                        }
                    }
                    else
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.TupleGenSequence(0, hv_MaxClassId, 1, out hv_ClassIDs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassNames.Dispose();
                            HOperatorSet.TupleGenConst(hv_MaxClassId + 1, "unknown", out hv_ClassNames);
                        }
                    }
                    //Try to get the class names from the result dictionary.
                    //This works only for detection and classification results.
                    if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_ClassNameKey.Dispose();
                        HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*class_name.*", out hv_ClassNameKey);
                        hv_ClassIdKey.Dispose();
                        HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*class_id.*", out hv_ClassIdKey);
                        if ((int)((new HTuple((new HTuple(hv_ClassNameKey.TupleLength())).TupleEqual(
                            1))).TupleAnd(new HTuple((new HTuple(hv_ClassIdKey.TupleLength())).TupleEqual(
                            1)))) != 0)
                        {
                            hv_ResultClassNames.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, hv_ClassNameKey,
                                out hv_ResultClassNames);
                            hv_ResultClassIds.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, hv_ClassIdKey, out hv_ResultClassIds);
                            hv_SortIndices.Dispose();
                            HOperatorSet.TupleSortIndex(hv_ResultClassIds, out hv_SortIndices);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_UniqueClassIds.Dispose();
                                HOperatorSet.TupleUniq(hv_ResultClassIds.TupleSelect(hv_SortIndices),
                                    out hv_UniqueClassIds);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_UniqueClassNames.Dispose();
                                HOperatorSet.TupleUniq(hv_ResultClassNames.TupleSelect(hv_SortIndices),
                                    out hv_UniqueClassNames);
                            }
                            if (hv_ClassNames == null)
                                hv_ClassNames = new HTuple();
                            hv_ClassNames[hv_UniqueClassIds] = hv_UniqueClassNames;
                        }
                    }
                    hv_Colors.Dispose();
                    get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, out hv_Colors);
                    hv_ClassesLegend.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassesLegend = (hv_ClassIDs + " : ") + hv_ClassNames;
                    }
                    hv_InvalidInput.Dispose();
                    hv_InvalidInput = 0;
                }
                else
                {
                    //Check if DLDatasetInfo contains necessary keys.
                    hv_ClassKeys.Dispose();
                    hv_ClassKeys = new HTuple();
                    hv_ClassKeys[0] = "class_names";
                    hv_ClassKeys[1] = "class_ids";
                    hv_ClassKeysExist.Dispose();
                    HOperatorSet.GetHandleParam(hv_DLDatasetInfo, "key_exists", hv_ClassKeys,
                        out hv_ClassKeysExist);
                    if ((int)(new HTuple(((hv_ClassKeysExist.TupleMin())).TupleEqual(0))) != 0)
                    {
                        //In that case we expect that the class names and ids are never used.
                    }
                    else
                    {
                        hv_DLDatasetInfoKeys.Dispose();
                        HOperatorSet.GetHandleParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassKeys.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_ClassKeys.TupleSelect(
                                hv_Index)))).TupleEqual(-1))) != 0)
                            {
                                throw new HalconException(("Key " + (hv_ClassKeys.TupleSelect(
                                    hv_Index))) + " is missing in DLDatasetInfo.");
                            }
                        }
                        //
                        //Get the general dataset information, if available.
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetHandleTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
                        hv_ClassIDs.Dispose();
                        HOperatorSet.GetHandleTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
                        //
                        //Define distinct colors for the classes.
                        hv_Colors.Dispose();
                        get_dl_class_colors(hv_ClassNames, hv_AdditionalGreenClassNames, out hv_Colors);
                        //
                        hv_ClassesLegend.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassesLegend = (hv_ClassIDs + " : ") + hv_ClassNames;
                        }
                    }
                }
                //
                //** Set window parameters: ***
                //
                //Set previous window coordinates.
                hv_PrevWindowCoordinates.Dispose();
                hv_PrevWindowCoordinates = new HTuple();
                hv_PrevWindowCoordinates[0] = 0;
                hv_PrevWindowCoordinates[1] = 0;
                hv_PrevWindowCoordinates[2] = 0;
                hv_PrevWindowCoordinates[3] = 0;
                //
                //Check that the WindowHandleDict is of type dictionary.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
                    {
                        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //For better usage, add meta information about the window handles in WindowHandleDict.
                hv_MetaInfoExists.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "meta_information",
                    out hv_MetaInfoExists);
                if ((int)(hv_MetaInfoExists.TupleNot()) != 0)
                {
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv___Tmp_Ctrl_Dict_Init_1);
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                            "HNULL");
                    }
                }
                //
                //For each window, set 'flush' to 'false' to avoid flickering.
                hv_FlushValues.Dispose();
                hv_FlushValues = new HTuple();
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
                            hv_WindowHandleKeys.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FlushValue.Dispose();
                                HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", out hv_FlushValue);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                                        hv_FlushValue);
                                    hv_FlushValues.Dispose();
                                    hv_FlushValues = ExpTmpLocalVar_FlushValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", "false");
                            }
                        }
                    }
                }
                //
                //** Display the data: ***
                //
                //Display data dictionaries.
                hv_KeyIndex.Dispose();
                hv_KeyIndex = 0;
                while ((int)(new HTuple(hv_KeyIndex.TupleLess(new HTuple(hv_KeysForDisplay_COPY_INP_TMP.TupleLength()
                    )))) != 0)
                {
                    //
                    //Is it an Deep OCR detection case?
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IsOCRDetection.Dispose();
                        HOperatorSet.TupleStrstr(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                            "ocr_detection", out hv_IsOCRDetection);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_IsOCRDetection = new HTuple(hv_IsOCRDetection.TupleEqual(
                                0));
                            hv_IsOCRDetection.Dispose();
                            hv_IsOCRDetection = ExpTmpLocalVar_IsOCRDetection;
                        }
                    }
                    //
                    if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "image"))) != 0)
                    {
                        //
                        //Image.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("image_with_domain"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_Domain.Dispose();
                        HOperatorSet.GetDomain(ho_Image, out ho_Domain);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "region_color"));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Domain, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("normals"))) != 0)
                    {
                        //
                        //Normal image.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_confidence"))) != 0)
                    {
                        //
                        //Confidence image.
                        if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                        {
                            throw new HalconException("DLResult dict is empty.");
                        }
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                            hv_KeyIndex)))).TupleNotEqual(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_Image.Dispose();
                                HOperatorSet.GetDictObject(out ho_Image, hv_DLResult_COPY_INP_TMP, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                    hv_KeyIndex));
                            }
                        }
                        else
                        {
                            throw new HalconException(("Image with key '" + (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex))) + "' could not be found in DLResult.");
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping confidence",
                                "window", "top", "left", "black", "box", "true");
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_map"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Gripping map image result.
                        if ((int)(new HTuple(hv_DLResult_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                        {
                            throw new HalconException("DLResult dict is empty.");
                        }
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("gripping_map"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            ho_GrippingMapImageResult.Dispose();
                            HOperatorSet.GetDictObject(out ho_GrippingMapImageResult, hv_DLResult_COPY_INP_TMP,
                                "gripping_map");
                        }
                        else
                        {
                            throw new HalconException(new HTuple(new HTuple("Image with key '") + "gripping_map") + "' could not be found in DLResult.");
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "background_color",
                            "#000000");
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                        }
                        ho_Domain.Dispose();
                        HOperatorSet.GetDomain(ho_GrippingMapImageResult, out ho_Domain);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ReduceDomain(ho_Image, ho_Domain, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //Display gripping regions.
                        hv_ColorsGrippingGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsGrippingGroundTruth = new HTuple();
                            hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
                                "gripping_point_map_color"));
                            hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
                                "gripping_point_background_color"));
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_GrippingMapImageResult, (new HTuple(1)).TupleConcat(
                            0), hv_ColorsGrippingGroundTruth, new HTuple(), out hv_ImageClassIDs);
                        //Display gripping points.
                        hv_GrippingPointsExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLResult_COPY_INP_TMP, "key_exists", "gripping_points",
                            out hv_GrippingPointsExists);
                        if ((int)(hv_GrippingPointsExists) != 0)
                        {
                            hv_Rows.Dispose(); hv_Columns.Dispose();
                            get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows,
                                out hv_Columns);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_Cross.Dispose();
                                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
                                    "gripping_point_size"), 0.785398);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                        "line_width"));
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                        "gripping_point_color"));
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                            }
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_map_ground_truth"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Gripping map ground truth.
                        if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            ho_GrippingMapGroundTruth.Dispose();
                            HOperatorSet.GetDictObject(out ho_GrippingMapGroundTruth, hv_DLSample,
                                "segmentation_image");
                        }
                        else
                        {
                            throw new HalconException(new HTuple(new HTuple("Image with key '") + "segmentation_image") + "' could not be found in DLSample.");
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display gripping regions.
                        hv_ColorsGrippingGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsGrippingGroundTruth = new HTuple();
                            hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
                                "gripping_point_map_color"));
                            hv_ColorsGrippingGroundTruth = hv_ColorsGrippingGroundTruth.TupleConcat(hv_Params.TupleGetDictTuple(
                                "gripping_point_background_color"));
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_GrippingMapGroundTruth, hv_ClassIDs,
                            hv_ColorsGrippingGroundTruth, new HTuple(), out hv_ImageClassIDs);
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping map ground truth",
                                "window", "top", "left", "black", "box", "true");
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("x"))) != 0)
                    {
                        //
                        //X.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("xyz"))) != 0)
                    {
                        //
                        //XYZ.
                        ho_X.Dispose();
                        get_dl_sample_image(out ho_X, hv_SampleKeys, hv_DLSample, "x");
                        ho_Y.Dispose();
                        get_dl_sample_image(out ho_Y, hv_SampleKeys, hv_DLSample, "y");
                        ho_Z.Dispose();
                        get_dl_sample_image(out ho_Z, hv_SampleKeys, hv_DLSample, "z");
                        ho_Image.Dispose();
                        HOperatorSet.Compose3(ho_X, ho_Y, ho_Z, out ho_Image);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("y"))) != 0)
                    {
                        //
                        //Y.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("z"))) != 0)
                    {
                        //
                        //Z.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_point_cloud"))) != 0)
                    {
                        //
                        //In case of 'gripping_point_cloud' provide a window that can be used by the procedure
                        //dev_display_dl_3d_data. No actual drawing happens  in this procedure to keep it
                        //free from operators not belonging either to the Foundation or Deep Learning
                        //license modules.
                        hv_SampleKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Do nothing here and draw later
                        //
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_both_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_both_global")))) != 0)
                    {
                        //
                        //In case of 'anomaly_both', also plot 'anomaly_both_local'
                        //and 'anomaly_both_global', if available.
                        hv_AnomalyImages.Dispose();
                        HOperatorSet.TupleRegexpSelect(hv_ResultKeys, ".*anomaly_image.*", out hv_AnomalyImages);
                        if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
                            "anomaly_both"))) != 0)
                        {
                            hv_PossibleKeysForDisplay.Dispose();
                            HOperatorSet.TupleRegexpReplace(hv_AnomalyImages, "image", "both", out hv_PossibleKeysForDisplay);
                            hv_AddDisplayKey.Dispose();
                            hv_AddDisplayKey = 0;
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_PossibleKeysForDisplay.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleFindFirst(
                                    hv_PossibleKeysForDisplay.TupleSelect(hv_Index)))).TupleEqual(-1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_KeysForDisplay = hv_KeysForDisplay_COPY_INP_TMP.TupleConcat(
                                                hv_PossibleKeysForDisplay.TupleSelect(hv_Index));
                                            hv_KeysForDisplay_COPY_INP_TMP.Dispose();
                                            hv_KeysForDisplay_COPY_INP_TMP = ExpTmpLocalVar_KeysForDisplay;
                                        }
                                    }
                                    hv_AddDisplayKey.Dispose();
                                    hv_AddDisplayKey = 1;
                                }
                            }
                            //
                            //Display not possible for 'anomaly_both' if key 'anomaly_image' is missing.
                            if ((int)((new HTuple(((hv_PossibleKeysForDisplay.TupleFindFirst(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex)))).TupleEqual(-1))).TupleAnd(hv_AddDisplayKey)) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_KeyIndex = hv_KeyIndex + 1;
                                        hv_KeyIndex.Dispose();
                                        hv_KeyIndex = ExpTmpLocalVar_KeyIndex;
                                    }
                                }
                                continue;
                            }
                        }
                        //
                        //Get image and ground truth.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get the anomaly results either by applying the specified thresholds or out of DLResult.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyResultPostfix.Dispose();
                            HOperatorSet.TupleRegexpMatch(hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex), "anomaly_both(.*)", out hv_AnomalyResultPostfix);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                            get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP,
                                hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
                                "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore,
                                out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
                        }
                        //
                        //Get open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        hv_WindowHandleName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandleName = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_WindowHandleName, out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image, ground truth (if available), and result regions.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_AnomalyRegionGroundTruthExists.Dispose();
                        hv_AnomalyRegionGroundTruthExists = "false";
                        if ((int)(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AnomalyRegionGroundTruthExists.Dispose();
                                dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                    hv_CurrentWindowHandle, hv_Params.TupleGetDictTuple("line_width"),
                                    hv_Params.TupleGetDictTuple("anomaly_region_label_color"), hv_Params.TupleGetDictTuple(
                                    "anomaly_color_transparency"), out hv_AnomalyRegionGroundTruthExists);
                            }
                        }
                        //
                        //Display anomaly regions defined by the specified threshold or out of DLResult.
                        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_2);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_2, "comp", -1);
                        if ((int)((new HTuple(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_2))).TupleTestEqualDictItem(
                            "anomaly_region_threshold", "comp"))).TupleNot())).TupleOr(new HTuple(((hv_ResultKeys.TupleFind(
                            "anomaly_region" + hv_AnomalyResultPostfix))).TupleNotEqual(-1)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle,
                                    hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple(
                                    "anomaly_region_result_color"));
                            }
                        }
                        hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_2 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "GT and detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else if ((int)(new HTuple(hv_AnomalyClassID.TupleNotEqual(-1))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation ground truth found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_3);
                            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_3, "comp", -1);
                            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_3))).TupleTestEqualDictItem(
                                "anomaly_region_threshold", "comp"))).TupleAnd(new HTuple(((hv_ResultKeys.TupleFind(
                                "anomaly_region" + hv_AnomalyResultPostfix))).TupleEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
                            }
                            hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_Dict_Init_3 = HTuple.TupleConstant(
                                    "HNULL");
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = (("anomaly_score" + hv_AnomalyResultPostfix) + ": ") + (hv_AnomalyScore.TupleString(
                                ".3f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassThresholdDisplay.TupleString(
                                    ".3f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThresholdDisplay.TupleString(
                                    ".3f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_WindowHandleName, out hv_WindowImageRatio,
                                    out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            hv_ResultColorOffset.Dispose();
                            hv_ResultColorOffset = 10;
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResultColorOffset = hv_ResultColorOffset + 2;
                                        hv_ResultColorOffset.Dispose();
                                        hv_ResultColorOffset = ExpTmpLocalVar_ResultColorOffset;
                                    }
                                }
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[hv_ResultColorOffset] = hv_PredictionColor;
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_ground_truth"))) != 0)
                    {
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_AnomalyRegionExists.Dispose();
                        hv_AnomalyRegionExists = "false";
                        if ((int)(hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions")) != 0)
                        {
                            //Show the ground truth region.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AnomalyRegionExists.Dispose();
                                dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                    hv_CurrentWindowHandle, hv_Params.TupleGetDictTuple("line_width"),
                                    hv_Params.TupleGetDictTuple("anomaly_region_label_color"), hv_Params.TupleGetDictTuple(
                                    "anomaly_color_transparency"), out hv_AnomalyRegionExists);
                            }
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                                hv_Params.TupleGetDictTuple("display_ground_truth_anomaly_regions"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_image"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_image_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_image_global")))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get the anomaly results either by applying the specified thresholds or out of DLResult.
                        hv_AnomalyImageKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyImageKey = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex);
                        }
                        hv_AnomalyResultPostfix.Dispose();
                        HOperatorSet.TupleRegexpMatch(hv_AnomalyImageKey, "anomaly_image(.*)",
                            out hv_AnomalyResultPostfix);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                            get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP,
                                hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
                                "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore,
                                out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
                        }
                        //
                        //Read in input image.
                        ho_Image.Dispose();
                        HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                        //Add the anomaly image to the input image.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_Params.TupleGetDictTuple(
                                "heatmap_color_scheme"));
                            ho_AnomalyImage.Dispose();
                            ho_AnomalyImage = ExpTmpOutVar_0;
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
                        }
                        hv_Text.Dispose();
                        hv_Text = new HTuple(hv_AnomalyImageKey);
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        hv_AnomalyScoreKey.Dispose();
                        HOperatorSet.TupleRegexpReplace(hv_AnomalyImageKey, "image", "score", out hv_AnomalyScoreKey);
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = (hv_AnomalyScoreKey + ": ") + (hv_AnomalyScore.TupleString(
                                ".3f"));
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_result"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_result_local"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("anomaly_result_global")))) != 0)
                    {
                        //
                        //Get image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get the anomaly results either by applying the specified thresholds or out of DLResult.
                        hv_AnomalyResultKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyResultKey = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex);
                        }
                        hv_AnomalyResultPostfix.Dispose();
                        HOperatorSet.TupleRegexpMatch(hv_AnomalyResultKey, "anomaly_result(.*)",
                            out hv_AnomalyResultPostfix);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                            get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult_COPY_INP_TMP,
                                hv_Params.TupleGetDictTuple("anomaly_classification_threshold"), hv_Params.TupleGetDictTuple(
                                "anomaly_region_threshold"), hv_AnomalyResultPostfix, out hv_AnomalyScore,
                                out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay, out hv_AnomalyRegionThresholdDisplay);
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display anomaly regions defined by the specified threshold or out of DLResult.
                        hv_AnomalyRegionKey.Dispose();
                        HOperatorSet.TupleRegexpReplace(hv_AnomalyResultKey, "result", "region",
                            out hv_AnomalyRegionKey);
                        hv___Tmp_Ctrl_Dict_Init_4.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_4);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_4, "comp", -1);
                        if ((int)((new HTuple(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_4))).TupleTestEqualDictItem(
                            "anomaly_region_threshold", "comp"))).TupleNot())).TupleOr(new HTuple(((hv_ResultKeys.TupleFind(
                            hv_AnomalyRegionKey))).TupleNotEqual(-1)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle,
                                    hv_Params.TupleGetDictTuple("line_width"), hv_Params.TupleGetDictTuple(
                                    "anomaly_region_result_color"));
                            }
                        }
                        hv___Tmp_Ctrl_Dict_Init_4.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_4 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        //
                        hv_AnomalyScoreKey.Dispose();
                        HOperatorSet.TupleRegexpReplace(hv_AnomalyResultKey, "result", "score",
                            out hv_AnomalyScoreKey);
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            hv___Tmp_Ctrl_Dict_Init_5.Dispose();
                            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_5);
                            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_5, "comp", -1);
                            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_5))).TupleTestEqualDictItem(
                                "anomaly_region_threshold", "comp"))).TupleAnd(new HTuple(((hv_ResultKeys.TupleFind(
                                hv_AnomalyRegionKey))).TupleEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
                            }
                            hv___Tmp_Ctrl_Dict_Init_5.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_Dict_Init_5 = HTuple.TupleConstant(
                                    "HNULL");
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = (hv_AnomalyScoreKey + ": ") + (hv_AnomalyScore.TupleString(
                                ".3f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassThresholdDisplay.TupleString(
                                    ".3f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThresholdDisplay.TupleString(
                                    ".3f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_heatmap"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get gripping points
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows, out hv_Columns);
                        //
                        //Confidence image.
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("gripping_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            ho_ConfidenceImage.Dispose();
                            HOperatorSet.GetDictObject(out ho_ConfidenceImage, hv_DLResult_COPY_INP_TMP,
                                "gripping_confidence");
                        }
                        else
                        {
                            throw new HalconException("Image with key 'gripping_confidence' could not be found in DLResult.");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_HeatmapScene.Dispose();
                            add_colormap_to_image(ho_ConfidenceImage, ho_Image, out ho_HeatmapScene,
                                hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_HeatmapScene, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping heatmap",
                                "window", "top", "left", "black", "box", "true");
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Cross.Dispose();
                            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
                                "gripping_point_size"), 0.785398);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "line_width"));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "gripping_point_color"));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("gripping_points"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get gripping points
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        get_gripping_points_from_dict(hv_DLResult_COPY_INP_TMP, out hv_Rows, out hv_Columns);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Gripping points",
                                "window", "top", "left", "black", "box", "true");
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Cross.Dispose();
                            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Rows, hv_Columns, hv_Params.TupleGetDictTuple(
                                "gripping_point_size"), 0.785398);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "line_width"));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "gripping_point_color"));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                        }
                        //
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("bbox_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_detection_both")))) != 0)
                    {
                        //
                        //Ground truth and result bounding boxes on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if ((int)(hv_IsOCRDetection) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Visualization.
                        //
                        hv_DisplayDirectionTemp.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
                                "display_direction");
                        }
                        if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
                            hv_IsOCRDetection)) != 0)
                        {
                            hv_DisplayDirectionTemp.Dispose();
                            hv_DisplayDirectionTemp = -1;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxLabelIndex.Dispose();
                            dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple(
                                "line_width"), hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple(
                                "bbox_label_color"), hv_WindowImageRatio, hv_Params.TupleGetDictTuple(
                                "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"),
                                hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
                        }
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "bbox_confidence",
                                out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result data could not be found in DLResult.");
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("bbox_display_confidence")) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxClassIndex.Dispose();
                            dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, hv_Params.TupleGetDictTuple(
                                "line_width"), hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple(
                                "bbox_label_color"), hv_WindowImageRatio, "bottom", hv_Params.TupleGetDictTuple(
                                "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"),
                                hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxClassIndex);
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and results " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        hv_Text.Dispose();
                        hv_Text = "Ground truth and";
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "results " + hv_ImageIDStringBraces;
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_BboxColorsBoth.Dispose();
                            hv_BboxColorsBoth = new HTuple();
                            hv_BboxColorsBoth[0] = "white";
                            hv_BboxColorsBoth[1] = "white";
                            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                                )) + (new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
                            {
                                hv_BboxClassLabelIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                                        hv_BboxLabelIndex))).TupleSort())).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_BboxColorsBoth.Dispose();
                                        hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth nor results present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsBoth, "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("bbox_ground_truth"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_detection_ground_truth")))) != 0)
                    {
                        //
                        //Sample bounding boxes on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if ((int)(hv_IsOCRDetection) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display smaller arrow for ocr_detection
                        hv_DisplayDirectionTemp.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
                                "display_direction");
                        }
                        if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
                            hv_IsOCRDetection)) != 0)
                        {
                            hv_DisplayDirectionTemp.Dispose();
                            hv_DisplayDirectionTemp = -1;
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxIDs.Dispose();
                            dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_Params.TupleGetDictTuple(
                                "line_width"), hv_ClassIDs, hv_Colors, hv_Params.TupleGetDictTuple(
                                "bbox_label_color"), hv_WindowImageRatio, hv_Params.TupleGetDictTuple(
                                "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"),
                                hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxIDs);
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_BboxColors.Dispose();
                            hv_BboxColors = "white";
                            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
                            {
                                hv_BboxIDsUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxIDsUniq));
                                        hv_BboxColors.Dispose();
                                        hv_BboxColors = ExpTmpLocalVar_BboxColors;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("bbox_result"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_detection_result")))) != 0)
                    {
                        //
                        //Result bounding boxes on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if ((int)(hv_IsOCRDetection) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display smaller arrow for ocr_detection
                        hv_DisplayDirectionTemp.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayDirectionTemp = hv_Params.TupleGetDictTuple(
                                "display_direction");
                        }
                        if ((int)(((hv_Params.TupleGetDictTuple("display_direction"))).TupleAnd(
                            hv_IsOCRDetection)) != 0)
                        {
                            hv_DisplayDirectionTemp.Dispose();
                            hv_DisplayDirectionTemp = -1;
                        }
                        //
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "bbox_confidence",
                                out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result data could not be found in DLResult.");
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("bbox_display_confidence")) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxClassIndex.Dispose();
                            dev_display_result_detection(hv_DLResult_COPY_INP_TMP, hv_ResultKeys, hv_Params.TupleGetDictTuple(
                                "line_width"), hv_ClassIDs, hv_TextConf, hv_Colors, hv_Params.TupleGetDictTuple(
                                "bbox_label_color"), hv_WindowImageRatio, "top", hv_Params.TupleGetDictTuple(
                                "bbox_text_color"), hv_Params.TupleGetDictTuple("display_labels"),
                                hv_DisplayDirectionTemp, hv_CurrentWindowHandle, out hv_BboxClassIndex);
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_BboxColorsResults.Dispose();
                            hv_BboxColorsResults = "white";
                            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_BboxClassIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_BboxColorsResults.Dispose();
                                        hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No results present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsResults, "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_detection_score_map_character"))).TupleOr(
                        new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "ocr_detection_score_map_link"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_detection_score_map_orientation")))) != 0)
                    {
                        //
                        //Extract score maps
                        ho_ScoreMaps.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ScoreMaps = hv_OcrResult.TupleGetDictObject(
                                "score_maps");
                        }
                        ho_CharacterScoreMap.Dispose(); ho_LinkScoreMap.Dispose(); ho_OrientationSinScoreMap.Dispose(); ho_OrientationCosScoreMap.Dispose();
                        HOperatorSet.Decompose4(ho_ScoreMaps, out ho_CharacterScoreMap, out ho_LinkScoreMap,
                            out ho_OrientationSinScoreMap, out ho_OrientationCosScoreMap);
                        //
                        //Select score map to display
                        if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex))).TupleEqual(
                            "ocr_detection_score_map_character"))) != 0)
                        {
                            ho_ScoreMap.Dispose();
                            ho_ScoreMap = new HObject(ho_CharacterScoreMap);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Character score " + hv_ImageIDStringBraces;
                            }
                        }
                        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                            hv_KeyIndex))).TupleEqual("ocr_detection_score_map_link"))) != 0)
                        {
                            ho_ScoreMap.Dispose();
                            ho_ScoreMap = new HObject(ho_LinkScoreMap);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Link score " + hv_ImageIDStringBraces;
                            }
                        }
                        else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                            hv_KeyIndex))).TupleEqual("ocr_detection_score_map_orientation"))) != 0)
                        {
                            ho_OrientationScoreMap.Dispose();
                            HOperatorSet.Compose2(ho_OrientationSinScoreMap, ho_OrientationCosScoreMap,
                                out ho_OrientationScoreMap);
                            ho_ScoreMap.Dispose();
                            ho_ScoreMap = new HObject(ho_OrientationScoreMap);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = new HTuple("Orientation (sin,cos) ") + hv_ImageIDStringBraces;
                            }
                        }
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ScoreMap, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Make sure the minimum and maximum gray values of the score map image
                        //are 0 and 1, respectively. This is necessary to get the correct color
                        //range from the 'jet' color map.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetGrayval(ho_ScoreMap, (new HTuple(0)).TupleConcat(hv_HeightImage - 1),
                                (new HTuple(0)).TupleConcat(hv_WidthImage - 1), (new HTuple(0)).TupleConcat(
                                1));
                        }
                        //
                        //Display the score maps using the 'jet' color map.
                        HOperatorSet.SetLut(hv_CurrentWindowHandle, "jet");
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ScoreMap, HDevWindowStack.GetActive());
                        }
                        //
                        //Display text
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("classification_both"))) != 0)
                    {
                        //
                        //Ground truth and result classification image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Correct";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Wrong";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Generate prediction color frame and show image.
                        if ((int)(hv_Params.TupleGetDictTuple("display_classification_color_frame")) != 0)
                        {
                            //Create a frame with line width 7 that is completely displayed in the window.
                            hv_BoarderOffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffset = 7 / 2.0;
                            }
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_WindowImageRatioHeight.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height",
                                out hv_WindowImageRatioHeight);
                            hv_WindowImageRatioWidth.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width",
                                out hv_WindowImageRatioWidth);
                            hv_BoarderOffsetRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetRow = hv_BoarderOffset / hv_WindowImageRatioHeight;
                            }
                            hv_BoarderOffsetCol.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetCol = hv_BoarderOffset / hv_WindowImageRatioWidth;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_PredictionColorFrame.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow - 0.5)).TupleConcat(
                                    hv_BoarderOffsetRow - 0.5))).TupleConcat((hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(
                                    (hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow - 0.5),
                                    ((((((((hv_BoarderOffsetCol - 0.5)).TupleConcat((hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(
                                    (hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol - 0.5))).TupleConcat(
                                    hv_BoarderOffsetCol - 0.5));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MarginBottom.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                    hv_KeyIndex)) + "_margin_bottom", out hv_MarginBottom);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowCoordinates.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                    hv_KeyIndex)) + "_window_coordinates", out hv_WindowCoordinates);
                            }
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result/GT classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                hv_ClassificationLabelIDGroundTruth);
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                    hv_ClassificationLabelIDResult);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[9] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("classification_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth classification image and class label.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDGroundTruth)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("classification_result"))) != 0)
                    {
                        //
                        //Ground truth classification image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult_COPY_INP_TMP, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display the class IDs.
                        if ((int)(hv_Params.TupleGetDictTuple("display_classification_ids")) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_MarginBottom.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom",
                                out hv_MarginBottom);
                            hv_WindowCoordinates.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates",
                                out hv_WindowCoordinates);
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID " + hv_ImageIDStringBraces;
                            }
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDResult)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_guided_grad_cam"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
                    {
                        //
                        //Display the heatmap image (method 'heatmap_grad_cam', 'heatmap_guided_grad_cam',
                        //or 'heatmap_confidence_based') in the selected color scheme.
                        //Retrieve heatmap image, inferred image, and inference results.
                        hv_SelectedHeatmapMethod.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SelectedHeatmapMethod = hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex);
                        }
                        if ((int)((new HTuple((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
                            -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_guided_grad_cam"))).TupleNotEqual(
                            -1))))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_grad_cam",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Grad-CAM";
                            }
                            else if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual(
                                "heatmap_guided_grad_cam"))) != 0)
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_guided_grad_cam",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Guided-Grad-CAM";
                            }
                            else
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "heatmap_confidence_based",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Confidence based";
                            }
                            hv_HeatmapKeys.Dispose();
                            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
                            //
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_guided_grad_cam"))) != 0)
                            {
                                hv_HeatmapImageName.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                                        "guided_grad_cam_image_class_[0-9]*");
                                }
                                hv_TargetClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                                        "guided_grad_cam_image_class_([0-9]+)$");
                                }
                            }
                            else
                            {
                                hv_HeatmapImageName.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                                        "heatmap_image_class_[0-9]*");
                                }
                                hv_TargetClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                                        "heatmap_image_class_([0-9]+)$");
                                }
                            }
                            ho_ImageHeatmap.Dispose();
                            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
                        }
                        else
                        {
                            throw new HalconException("Heatmap image could not be found in DLResult.");
                        }
                        //
                        //Only for the Grad-Cam heatmap the input image is shown.
                        if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                        {
                            //Read in input image.
                            ho_Image.Dispose();
                            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                            //Add the heatmap to the input image.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0,
                                    hv_Params.TupleGetDictTuple("heatmap_color_scheme"));
                                ho_ImageHeatmap.Dispose();
                                ho_ImageHeatmap = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Classification heatmap " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_class_names",
                                out hv_ClassNames);
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_class_ids",
                                out hv_ClassIDs);
                            hv_Confidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult_COPY_INP_TMP, "classification_confidences",
                                out hv_Confidences);
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                hv_MaxDeviation.Dispose();
                                HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation",
                                    out hv_MaxDeviation);
                            }
                            hv_ClassificationLabelNameResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                                    0);
                            }
                            hv_ClassificationLabelIDResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                                    0);
                            }
                            hv_TargetClassConfidence.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                                    hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
                            }
                            hv_Text.Dispose();
                            hv_Text = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                hv_ClassificationLabelIDGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
                                hv_ClassificationLabelNamesGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
                                //Get prediction color.
                                if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                                    hv_ClassificationLabelIDResult))) != 0)
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "green";
                                }
                                else
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "red";
                                }
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                                    hv_ClassificationLabelIDGroundTruth);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: " + (((hv_Confidences.TupleSelect(
                                0))).TupleString(".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: " + hv_MethodName;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: " + hv_TargetClassID;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: " + (hv_TargetClassConfidence.TupleString(
                                ".2f"));
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: " + (hv_MaxDeviation.TupleString(
                                    ".2f"));
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[8] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_recognition_ground_truth"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_recognition_result"))))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("ocr_recognition_both")))) != 0)
                    {
                        //
                        //OCR Recognition.
                        hv_ShowGT.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ShowGT = (new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex))).TupleEqual("ocr_recognition_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex))).TupleEqual("ocr_recognition_ground_truth")));
                        }
                        hv_ShowResult.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ShowResult = (new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex))).TupleEqual("ocr_recognition_both"))).TupleOr(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                hv_KeyIndex))).TupleEqual("ocr_recognition_result")));
                        }
                        hv_NumLines.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumLines = hv_ShowGT + hv_ShowResult;
                        }
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_NumLines * (hv_Params.TupleGetDictTuple("display_bottom_desc")),
                                hv_WidthImage, hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"),
                                hv_Params.TupleGetDictTuple("threshold_width"), hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                out hv_CurrentWindowHandle, out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                        hv_Type.Dispose();
                        HOperatorSet.GetImageType(ho_Image, out hv_Type);
                        if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
                        {
                            //We assume that real images have been preprocessed
                            //to the range -1,1 already. Hence, we need to rescale
                            //them back to a visible range in byte.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, 255.0 / 2, 127);
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "byte");
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            hv_Text = new HTuple();
                            //Ground truth.
                            if ((int)(hv_ShowGT) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = (("Ground truth: \"" + (hv_DLSample.TupleGetDictTuple(
                                    "word"))) + "\" ") + hv_ImageIDStringBraces;
                            }
                            //Result.
                            if ((int)(hv_ShowResult) != 0)
                            {
                                hv_GTWordKeyExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "word", out hv_GTWordKeyExists);
                                if ((int)(hv_GTWordKeyExists) != 0)
                                {
                                    hv_MetaInfo.Dispose();
                                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information",
                                        out hv_MetaInfo);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_WindowCoordinates.Dispose();
                                        HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                            hv_KeyIndex)) + "_window_coordinates", out hv_WindowCoordinates);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MarginBottom.Dispose();
                                        HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                                            hv_KeyIndex)) + "_margin_bottom", out hv_MarginBottom);
                                    }
                                    hv_HeightWindow.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_HeightWindow = hv_WindowCoordinates.TupleSelect(
                                            3);
                                    }
                                    hv_HeightMarginBottom.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_HeightMarginBottom = (hv_HeightImage * hv_MarginBottom) / (hv_HeightWindow - hv_MarginBottom);
                                    }
                                    hv_Size.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Size = hv_HeightMarginBottom / 2;
                                    }
                                    hv_Length.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Length = hv_Size / 2;
                                    }
                                    hv_Row.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row = hv_HeightImage + (hv_HeightMarginBottom / 2);
                                    }
                                    hv_Column.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Column = hv_WidthImage - (1.5 * hv_Size);
                                    }
                                    hv_HomMat2DIdentity.Dispose();
                                    HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_HomMat2DRotate.Dispose();
                                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, (new HTuple(45)).TupleRad()
                                            , 0, 0, out hv_HomMat2DRotate);
                                    }
                                    hv_HomMat2DCompose.Dispose();
                                    HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row, hv_Column,
                                        out hv_HomMat2DCompose);
                                    if ((int)(((hv_DLResult_COPY_INP_TMP.TupleConcat(hv_DLSample))).TupleTestEqualDictItem(
                                        "word", "word")) != 0)
                                    {
                                        hv_PredictionForegroundColor.Dispose();
                                        hv_PredictionForegroundColor = "green";
                                        hv_PredictionBackgroundColor.Dispose();
                                        hv_PredictionBackgroundColor = "#008000";
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            ho_PredictionSymbol.Dispose();
                                            HOperatorSet.GenContourPolygonXld(out ho_PredictionSymbol, ((-0.75 * hv_Length)).TupleConcat(
                                                (new HTuple(0)).TupleConcat(0)), ((((-hv_Length)).TupleConcat(
                                                -hv_Length))).TupleConcat(hv_Length));
                                        }
                                    }
                                    else
                                    {
                                        hv_PredictionForegroundColor.Dispose();
                                        hv_PredictionForegroundColor = "red";
                                        hv_PredictionBackgroundColor.Dispose();
                                        hv_PredictionBackgroundColor = "#800000";
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            ho_CrossLineH.Dispose();
                                            HOperatorSet.GenContourPolygonXld(out ho_CrossLineH, (new HTuple(0)).TupleConcat(
                                                0), ((-hv_Length)).TupleConcat(hv_Length));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            ho_CrossLineV.Dispose();
                                            HOperatorSet.GenContourPolygonXld(out ho_CrossLineV, ((-hv_Length)).TupleConcat(
                                                hv_Length), (new HTuple(0)).TupleConcat(0));
                                        }
                                        ho_PredictionSymbol.Dispose();
                                        HOperatorSet.ConcatObj(ho_CrossLineH, ho_CrossLineV, out ho_PredictionSymbol
                                            );
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.AffineTransContourXld(ho_PredictionSymbol, out ExpTmpOutVar_0,
                                            hv_HomMat2DCompose);
                                        ho_PredictionSymbol.Dispose();
                                        ho_PredictionSymbol = ExpTmpOutVar_0;
                                    }
                                    HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "background_color",
                                        hv_PredictionBackgroundColor);
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                                    }
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                                    }
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 5);
                                    }
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionForegroundColor);
                                    }
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.DispObj(ho_PredictionSymbol, HDevWindowStack.GetActive()
                                            );
                                    }
                                }
                                else
                                {
                                    hv_PredictionForegroundColor.Dispose();
                                    hv_PredictionForegroundColor = "white";
                                }
                                if ((int)(hv_ShowGT) != 0)
                                {
                                    hv_Spaces.Dispose();
                                    hv_Spaces = "    ";
                                }
                                else
                                {
                                    hv_Spaces.Dispose();
                                    hv_Spaces = "";
                                }
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = ((("Deep OCR:" + hv_Spaces) + " \"") + (hv_DLResult_COPY_INP_TMP.TupleGetDictTuple(
                                    "word"))) + "\"";
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_confidence"))) != 0)
                    {
                        //
                        //Segmentation confidences.
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_confidence_map"))) != 0)
                    {
                        //
                        //Segmentation confidence map on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult_COPY_INP_TMP);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"),
                                hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfidenceColors.Dispose();
                            dev_display_confidence_regions(ho_ImageConfidence, hv_Params.TupleGetDictTuple(
                                "map_transparency"), out hv_ConfidenceColors);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple(
                                "map_color_bar_width"), hv_ConfidenceColors, 1.0, hv_WindowImageRatio,
                                hv_CurrentWindowHandle);
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_image_both"))) != 0)
                    {
                        //
                        //Ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult_COPY_INP_TMP);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + (hv_Params.TupleGetDictTuple(
                                "segmentation_transparency"));
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GroundTruthIDs.Dispose();
                            dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                                hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"),
                                out hv_GroundTruthIDs);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ResultIDs.Dispose();
                            dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                                hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"),
                                out hv_ResultIDs);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                                    hv_ResultIDs))).TupleSort())).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[(new HTuple(hv_Text.TupleLength())) + 1] = new HTuple("- thicker line: result, thinner lines: ground truth");
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
                            hv_StringSegExcludeClassIDs.Dispose();
                            hv_StringSegExcludeClassIDs = "";
                            for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(((hv_Params.TupleGetDictTuple(
                                "segmentation_exclude_class_ids"))).TupleLength())) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                            {
                                if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(((hv_Params.TupleGetDictTuple(
                                    "segmentation_exclude_class_ids"))).TupleLength())) - 1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs + (((hv_Params.TupleGetDictTuple(
                                                "segmentation_exclude_class_ids"))).TupleSelect(hv_StringIndex));
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs + (((hv_Params.TupleGetDictTuple(
                                                "segmentation_exclude_class_ids"))).TupleSelect(hv_StringIndex))) + new HTuple(", ");
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                            }
                            hv___Tmp_Ctrl_Dict_Init_6.Dispose();
                            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_6);
                            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_6, "comp", new HTuple());
                            if ((int)(((((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_6))).TupleTestEqualDictItem(
                                "segmentation_exclude_class_ids", "comp"))).TupleNot()) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) " + hv_StringSegExcludeClassIDs) + " from visualization)";
                            }
                            hv___Tmp_Ctrl_Dict_Init_6.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_Dict_Init_6 = HTuple.TupleConstant(
                                    "HNULL");
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)))).TupleConcat(((new HTuple("white")).TupleConcat(
                                        "white")).TupleConcat("white")), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_image_diff"))) != 0)
                    {
                        //
                        //Difference of ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult_COPY_INP_TMP);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        ho_ImageAbsDiff.Dispose();
                        HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult,
                            out ho_ImageAbsDiff, 1);
                        hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0,
                            out hv_Min, out hv_Max, out hv_Range);
                        if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
                        {
                            ho_DiffRegion.Dispose();
                            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000" + (hv_Params.TupleGetDictTuple(
                                        "segmentation_transparency")));
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.",
                                    "window", "top", "left", "black", new HTuple(), new HTuple());
                            }
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Difference of ground truth and result segmentation " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_image_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth segmentation image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display segmentation regions.
                        hv_ColorsSegmentation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsSegmentation = hv_Colors + (hv_Params.TupleGetDictTuple(
                                "segmentation_transparency"));
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "segmentation_draw"));
                            }
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "line_width"));
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageClassIDs.Dispose();
                            dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                                hv_ColorsSegmentation, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"),
                                out hv_ImageClassIDs);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_image_result"))) != 0)
                    {
                        //
                        //Result segmentation on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult_COPY_INP_TMP);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display result segmentation regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + (hv_Params.TupleGetDictTuple(
                                "segmentation_transparency"));
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "segmentation_draw"));
                            }
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Params.TupleGetDictTuple(
                                    "line_width"));
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageClassIDs.Dispose();
                            dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                                hv_ColorsResults, hv_Params.TupleGetDictTuple("segmentation_exclude_class_ids"),
                                out hv_ImageClassIDs);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_Params.TupleGetDictTuple("display_legend")) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Params.TupleGetDictTuple("font"),
                                    hv_Params.TupleGetDictTuple("font_size"), hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_weight"))) != 0)
                    {
                        //
                        //Weight image.
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, 0, hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                        hv_KeyIndex))).TupleEqual("segmentation_weight_map"))) != 0)
                    {
                        //
                        //Weight map on image.
                        ho_Image.Dispose();
                        get_dl_sample_image(out ho_Image, hv_SampleKeys, hv_DLSample, "image");
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        hv___Tmp_Ctrl_Dict_Init_7.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_7);
                        HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_7, "comp", 0);
                        if ((int)(((hv_Params.TupleConcat(hv___Tmp_Ctrl_Dict_Init_7))).TupleTestEqualDictItem(
                            "segmentation_max_weight", "comp")) != 0)
                        {
                            //Calculate SegMaxWeight if not given in GenParam.
                            hv_MinWeight.Dispose(); hv___Tmp_Ctrl_1.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight,
                                out hv___Tmp_Ctrl_1, out hv_Range);
                            HOperatorSet.SetDictTuple(hv_Params, "segmentation_max_weight", hv___Tmp_Ctrl_1);
                        }
                        hv___Tmp_Ctrl_Dict_Init_7.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_7 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Params.TupleGetDictTuple("font"), hv_Params.TupleGetDictTuple(
                                "font_size"), hv_Params.TupleGetDictTuple("display_bottom_desc"), hv_WidthImage,
                                hv_HeightImage, hv_Params.TupleGetDictTuple("map_color_bar_width"),
                                hv_Params.TupleGetDictTuple("scale_windows"), hv_Params.TupleGetDictTuple(
                                "threshold_width"), hv_PrevWindowCoordinates, hv_WindowHandleDict,
                                hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WeightsColors.Dispose();
                            dev_display_weight_regions(ho_ImageWeight, hv_Params.TupleGetDictTuple(
                                "map_transparency"), hv_Params.TupleGetDictTuple("segmentation_max_weight"),
                                out hv_WeightsColors);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_Params.TupleGetDictTuple(
                                "map_color_bar_width"), hv_WeightsColors, hv_Params.TupleGetDictTuple(
                                "segmentation_max_weight"), hv_WindowImageRatio, hv_CurrentWindowHandle);
                        }
                        if ((int)(hv_Params.TupleGetDictTuple("display_bottom_desc")) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        //Reset flush buffer of existing windows before throwing an exception.
                        hv_WindowHandleKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            //Only consider the WindowHandleKeys that are needed for the current visualization.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
                                    hv_WindowHandleKeys.TupleSelect(hv_Index));
                            }
                            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                                new HTuple())))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_WindowHandles.Dispose();
                                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                        hv_Index), out hv_WindowHandles);
                                }
                                for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                                    )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                                {
                                    //Reset values of windows that have been changed temporarily.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                            "flush", hv_FlushValues.TupleSelect(hv_Index));
                                    }
                                }
                            }
                        }
                        throw new HalconException("Key for display unknown: " + (hv_KeysForDisplay_COPY_INP_TMP.TupleSelect(
                            hv_KeyIndex)));
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_KeyIndex = hv_KeyIndex + 1;
                            hv_KeyIndex.Dispose();
                            hv_KeyIndex = ExpTmpLocalVar_KeyIndex;
                        }
                    }
                }
                //
                //Display results.
                hv_WindowHandleKeysNew.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay_COPY_INP_TMP.TupleFind(
                            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            //Display content of window handle.
                            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
                            {
                                //Reset values of windows that have been changed temporarily.
                                if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                                    "true"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
                                }
                            }
                            else
                            {
                                //Per default, 'flush' of new windows should be set to 'true'.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", "true");
                                }
                            }
                        }
                    }
                }
                //
                ho_Image.Dispose();
                ho_Domain.Dispose();
                ho_GrippingMapImageResult.Dispose();
                ho_Cross.Dispose();
                ho_GrippingMapGroundTruth.Dispose();
                ho_X.Dispose();
                ho_Y.Dispose();
                ho_Z.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_ConfidenceImage.Dispose();
                ho_HeatmapScene.Dispose();
                ho_ScoreMaps.Dispose();
                ho_CharacterScoreMap.Dispose();
                ho_LinkScoreMap.Dispose();
                ho_OrientationSinScoreMap.Dispose();
                ho_OrientationCosScoreMap.Dispose();
                ho_ScoreMap.Dispose();
                ho_OrientationScoreMap.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_PredictionSymbol.Dispose();
                ho_CrossLineH.Dispose();
                ho_CrossLineV.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();
                ho_ImageWeight.Dispose();

                hv_DLResult_COPY_INP_TMP.Dispose();
                hv_KeysForDisplay_COPY_INP_TMP.Dispose();
                hv_Params.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_KeyExists.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_IsOCRDetection.Dispose();
                hv_AdditionalGreenClassNames.Dispose();
                hv_KeyIndex.Dispose();
                hv_OcrResult.Dispose();
                hv_MaxClassIdSample.Dispose();
                hv_EmptySample.Dispose();
                hv_MaxClassIdResult.Dispose();
                hv_EmptyResult.Dispose();
                hv_MaxClassId.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNameKey.Dispose();
                hv_ClassIdKey.Dispose();
                hv_ResultClassNames.Dispose();
                hv_ResultClassIds.Dispose();
                hv_SortIndices.Dispose();
                hv_UniqueClassIds.Dispose();
                hv_UniqueClassNames.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_InvalidInput.Dispose();
                hv_ClassKeys.Dispose();
                hv_ClassKeysExist.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_Index.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoExists.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_ColorsGrippingGroundTruth.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_GrippingPointsExists.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnomalyImages.Dispose();
                hv_PossibleKeysForDisplay.Dispose();
                hv_AddDisplayKey.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyResultPostfix.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_WindowHandleName.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_Text.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ResultColorOffset.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_AnomalyImageKey.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyResultKey.Dispose();
                hv_AnomalyRegionKey.Dispose();
                hv_DisplayDirectionTemp.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_ShowGT.Dispose();
                hv_ShowResult.Dispose();
                hv_NumLines.Dispose();
                hv_Type.Dispose();
                hv_GTWordKeyExists.Dispose();
                hv_HeightWindow.Dispose();
                hv_HeightMarginBottom.Dispose();
                hv_Size.Dispose();
                hv_Length.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_PredictionForegroundColor.Dispose();
                hv_PredictionBackgroundColor.Dispose();
                hv_Spaces.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ImageClassIDsIndices.Dispose();
                hv_ImageClassIDsIndex.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                hv___Tmp_Ctrl_Dict_Init_4.Dispose();
                hv___Tmp_Ctrl_Dict_Init_5.Dispose();
                hv___Tmp_Ctrl_Dict_Init_6.Dispose();
                hv___Tmp_Ctrl_Dict_Init_7.Dispose();
                hv___Tmp_Ctrl_1.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_Domain.Dispose();
                ho_GrippingMapImageResult.Dispose();
                ho_Cross.Dispose();
                ho_GrippingMapGroundTruth.Dispose();
                ho_X.Dispose();
                ho_Y.Dispose();
                ho_Z.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_ConfidenceImage.Dispose();
                ho_HeatmapScene.Dispose();
                ho_ScoreMaps.Dispose();
                ho_CharacterScoreMap.Dispose();
                ho_LinkScoreMap.Dispose();
                ho_OrientationSinScoreMap.Dispose();
                ho_OrientationCosScoreMap.Dispose();
                ho_ScoreMap.Dispose();
                ho_OrientationScoreMap.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_PredictionSymbol.Dispose();
                ho_CrossLineH.Dispose();
                ho_CrossLineV.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();
                ho_ImageWeight.Dispose();

                hv_DLResult_COPY_INP_TMP.Dispose();
                hv_KeysForDisplay_COPY_INP_TMP.Dispose();
                hv_Params.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_KeyExists.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_IsOCRDetection.Dispose();
                hv_AdditionalGreenClassNames.Dispose();
                hv_KeyIndex.Dispose();
                hv_OcrResult.Dispose();
                hv_MaxClassIdSample.Dispose();
                hv_EmptySample.Dispose();
                hv_MaxClassIdResult.Dispose();
                hv_EmptyResult.Dispose();
                hv_MaxClassId.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNameKey.Dispose();
                hv_ClassIdKey.Dispose();
                hv_ResultClassNames.Dispose();
                hv_ResultClassIds.Dispose();
                hv_SortIndices.Dispose();
                hv_UniqueClassIds.Dispose();
                hv_UniqueClassNames.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_InvalidInput.Dispose();
                hv_ClassKeys.Dispose();
                hv_ClassKeysExist.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_Index.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoExists.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_ColorsGrippingGroundTruth.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_GrippingPointsExists.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnomalyImages.Dispose();
                hv_PossibleKeysForDisplay.Dispose();
                hv_AddDisplayKey.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyResultPostfix.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_WindowHandleName.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_Text.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ResultColorOffset.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_AnomalyImageKey.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyResultKey.Dispose();
                hv_AnomalyRegionKey.Dispose();
                hv_DisplayDirectionTemp.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_ShowGT.Dispose();
                hv_ShowResult.Dispose();
                hv_NumLines.Dispose();
                hv_Type.Dispose();
                hv_GTWordKeyExists.Dispose();
                hv_HeightWindow.Dispose();
                hv_HeightMarginBottom.Dispose();
                hv_Size.Dispose();
                hv_Length.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_PredictionForegroundColor.Dispose();
                hv_PredictionBackgroundColor.Dispose();
                hv_Spaces.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ImageClassIDsIndices.Dispose();
                hv_ImageClassIDsIndex.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                hv___Tmp_Ctrl_Dict_Init_3.Dispose();
                hv___Tmp_Ctrl_Dict_Init_4.Dispose();
                hv___Tmp_Ctrl_Dict_Init_5.Dispose();
                hv___Tmp_Ctrl_Dict_Init_6.Dispose();
                hv___Tmp_Ctrl_Dict_Init_7.Dispose();
                hv___Tmp_Ctrl_1.Dispose();
                hv___Tmp_Ctrl_Type.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Try to guess the maximum class id based on the given sample/result. 
        private void dev_display_dl_data_get_max_class_id(HTuple hv_DLSample, out HTuple hv_MaxClassId,
            out HTuple hv_Empty)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Keys = new HTuple(), hv_Matches = new HTuple();
            HTuple hv_Length = new HTuple(), hv_Greatereq = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_LengthAll = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_Key = new HTuple();
            HTuple hv_KeyType = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_MaxTuple = new HTuple(), hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            hv_MaxClassId = new HTuple();
            hv_Empty = new HTuple();
            try
            {
                hv_MaxClassId.Dispose();
                hv_MaxClassId = -1;
                hv_Empty.Dispose();
                hv_Empty = 0;
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_Keys);
                    //Find keys that end on '_id'. (They contain ids!)
                    hv_Matches.Dispose();
                    HOperatorSet.TupleRegexpMatch(hv_Keys, "_id", out hv_Matches);
                    hv_Length.Dispose();
                    HOperatorSet.TupleStrlen(hv_Matches, out hv_Length);
                    hv_Greatereq.Dispose();
                    HOperatorSet.TupleGreaterEqualElem(hv_Length, 1, out hv_Greatereq);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_Greatereq, 1, out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleGreater(-1))) != 0)
                    {
                        //Find the maximum given class id.
                        hv_LengthAll.Dispose();
                        hv_LengthAll = 0;
                        for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_Indices.TupleLength()
                            )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                        {
                            hv_Key.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Key = hv_Keys.TupleSelect(
                                    hv_Indices.TupleSelect(hv_KeyIndex));
                            }
                            //Skip image_id.
                            if ((int)(new HTuple(hv_Key.TupleEqual("image_id"))) != 0)
                            {
                                continue;
                            }
                            hv_KeyType.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSample, "key_data_type", hv_Key, out hv_KeyType);
                            if ((int)(new HTuple(hv_KeyType.TupleNotEqual("tuple"))) != 0)
                            {
                                continue;
                            }
                            hv_Tuple.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSample, hv_Key, out hv_Tuple);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LengthAll = hv_LengthAll + (new HTuple(hv_Tuple.TupleLength()
                                        ));
                                    hv_LengthAll.Dispose();
                                    hv_LengthAll = ExpTmpLocalVar_LengthAll;
                                }
                            }
                            if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(
                                0))) != 0)
                            {
                                continue;
                            }
                            hv_MaxTuple.Dispose();
                            HOperatorSet.TupleMax(hv_Tuple, out hv_MaxTuple);
                            if ((int)(new HTuple(hv_MaxTuple.TupleGreater(hv_MaxClassId))) != 0)
                            {
                                hv_MaxClassId.Dispose();
                                hv_MaxClassId = new HTuple(hv_MaxTuple);
                            }
                        }
                        if ((int)(new HTuple(hv_LengthAll.TupleEqual(0))) != 0)
                        {
                            hv_Empty.Dispose();
                            hv_Empty = 1;
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    //Ignore any exception.
                }

                hv_Keys.Dispose();
                hv_Matches.Dispose();
                hv_Length.Dispose();
                hv_Greatereq.Dispose();
                hv_Indices.Dispose();
                hv_LengthAll.Dispose();
                hv_KeyIndex.Dispose();
                hv_Key.Dispose();
                hv_KeyType.Dispose();
                hv_Tuple.Dispose();
                hv_MaxTuple.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Keys.Dispose();
                hv_Matches.Dispose();
                hv_Length.Dispose();
                hv_Greatereq.Dispose();
                hv_Indices.Dispose();
                hv_LengthAll.Dispose();
                hv_KeyIndex.Dispose();
                hv_Key.Dispose();
                hv_KeyType.Dispose();
                hv_Tuple.Dispose();
                hv_MaxTuple.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize for a given number of samples the raw image, ground truth annotation, and inferred results. 
        public void dev_display_dl_data_tiled(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_NumSamples, HTuple hv_Split, HTuple hv_GenParam, HTuple hv_WindowHandle,
            out HTuple hv_WindowHandleOut)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_FinalRows, ho_SampleImages, ho_SampleImage = null;
            HObject ho_FirstChannel = null, ho_ImageScaled = null, ho_ImageConverted = null;
            HObject ho_TiledImageRow = null, ho_TiledImage = null, ho_Domain = null;
            HObject ho_RegionComplement = null, ho_InstanceMasks = null;
            HObject ho_InstanceMask = null, ho_ResInstanceMasks = null;
            HObject ho_Image = null, ho_ImageCleared = null, ho_Regions = null;
            HObject ho_TiledResult = null;

            // Local control variables 

            HTuple hv_BackGroundColor = new HTuple();
            HTuple hv_SpacingRow = new HTuple(), hv_SpacingCol = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowCol = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_IncludeImage = new HTuple(), hv_IncludeGroundTruth = new HTuple();
            HTuple hv_IncludeResults = new HTuple(), hv_Keys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Key = new HTuple();
            HTuple hv_Value = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_Samples = new HTuple(), hv_AnomalyLabelExists = new HTuple();
            HTuple hv_OCRLabelExists = new HTuple(), hv_ClassificationLabelExists = new HTuple();
            HTuple hv_DetectionLabelExists = new HTuple(), hv_SegmentationLabelExists = new HTuple();
            HTuple hv_XYZExists = new HTuple(), hv_OCRDetectionLabelExists = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_DLResult = new HTuple(), hv_ClassIdsExist = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_BackGroundClass = new HTuple();
            HTuple hv_RGB = new HTuple(), hv_Scale = new HTuple();
            HTuple hv_Shift = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_DLDatasetPreprocessParam = new HTuple(), hv_NormType = new HTuple();
            HTuple hv_KeyMinExists = new HTuple(), hv_KeyMaxExists = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_Channels = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_Crop = new HTuple();
            HTuple hv_OffsetRow = new HTuple(), hv_TiledWidth = new HTuple();
            HTuple hv_TiledHeight = new HTuple(), hv_NumResult = new HTuple();
            HTuple hv_PredictionsCorrect = new HTuple(), hv_ImageConfidences = new HTuple();
            HTuple hv_ResClassIndices = new HTuple(), hv_ResClasses = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_IndexResult = new HTuple(), hv_ImageConfidence = new HTuple();
            HTuple hv_ResClassIndex = new HTuple(), hv_ResClass = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
            HTuple hv_PredictionCorrect = new HTuple(), hv_TextImageRows = new HTuple();
            HTuple hv_TextImageColumns = new HTuple(), hv_TextImageWidth = new HTuple();
            HTuple hv_TextImageHeight = new HTuple(), hv_TopOffset = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_Rect1KeyExists = new HTuple();
            HTuple hv_Rect2KeyExists = new HTuple(), hv_MasksExist = new HTuple();
            HTuple hv_GTLabel = new HTuple(), hv_GTCol1 = new HTuple();
            HTuple hv_GTRow1 = new HTuple(), hv_GTCol2 = new HTuple();
            HTuple hv_GTRow2 = new HTuple(), hv_GTCol = new HTuple();
            HTuple hv_GTRow = new HTuple(), hv_GTLength1 = new HTuple();
            HTuple hv_GTLength2 = new HTuple(), hv_GTPhi = new HTuple();
            HTuple hv_LeftOffset = new HTuple(), hv_LabelId = new HTuple();
            HTuple hv_Col1 = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Col2 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Col = new HTuple(), hv_Row = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_Phi = new HTuple();
            HTuple hv_ResConfidence = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol = new HTuple();
            HTuple hv_ResRow = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            HTuple hv_CurrentResult = new HTuple(), hv_ClassId = new HTuple();
            HTuple hv_Confidence = new HTuple(), hv_ResultMaskExists = new HTuple();
            HTuple hv_ResWords = new HTuple(), hv_GTWord = new HTuple();
            HTuple hv_ResWord = new HTuple(), hv_TiledDLSample = new HTuple();
            HTuple hv_CharIndices = new HTuple(), hv_TiledDLResult = new HTuple();
            HTuple hv_Words = new HTuple(), hv_DisplayGenParam = new HTuple();
            HTuple hv_IgnoreDirection = new HTuple(), hv_WindowHandleDict = new HTuple();
            HTuple hv_NoInputWindow = new HTuple(), hv_Flush = new HTuple();
            HTuple hv_KeyForDisplay = new HTuple(), hv_GTText = new HTuple();
            HTuple hv_PredictionText = new HTuple(), hv__ = new HTuple();
            HTuple hv_GTWidth = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_PredictionWidth = new HTuple(), hv_WindowImageRatio = new HTuple();
            HTuple hv_WindowWidthMax = new HTuple(), hv_WindowHeightMax = new HTuple();
            HTuple hv_Ratio = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_ImageWindowWidthRatio = new HTuple();
            HTuple hv_ImageWindowHeightRatio = new HTuple(), hv_CharWindowWidth = new HTuple();
            HTuple hv_CharWindowHeight = new HTuple(), hv_CharImageWidth = new HTuple();
            HTuple hv_CharImageHeight = new HTuple(), hv_ImageRow = new HTuple();
            HTuple hv_ImageColumn = new HTuple(), hv_String = new HTuple();
            HTuple hv_StringWindowWidth = new HTuple(), hv_StringImageWidth = new HTuple();
            HTuple hv_NumSamples_COPY_INP_TMP = new HTuple(hv_NumSamples);
            HTuple hv_WindowHandle_COPY_INP_TMP = new HTuple(hv_WindowHandle);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_FinalRows);
            HOperatorSet.GenEmptyObj(out ho_SampleImages);
            HOperatorSet.GenEmptyObj(out ho_SampleImage);
            HOperatorSet.GenEmptyObj(out ho_FirstChannel);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted);
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_TiledImage);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_RegionComplement);
            HOperatorSet.GenEmptyObj(out ho_InstanceMasks);
            HOperatorSet.GenEmptyObj(out ho_InstanceMask);
            HOperatorSet.GenEmptyObj(out ho_ResInstanceMasks);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageCleared);
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_TiledResult);
            hv_WindowHandleOut = new HTuple();
            try
            {
                //
                //This procedure visualizes samples, their ground truth annotations, and,
                //if not deactivated, the results obtained by applying the model given by DLModelHandle.
                //
                //** Set the default values for all the generic parameters: ***
                //
                hv_BackGroundColor.Dispose();
                hv_BackGroundColor = "#ffffff";
                hv_SpacingRow.Dispose();
                hv_SpacingRow = 0;
                hv_SpacingCol.Dispose();
                hv_SpacingCol = 0;
                hv_WindowRow.Dispose();
                hv_WindowRow = 0;
                hv_WindowCol.Dispose();
                hv_WindowCol = 0;
                hv_WindowWidth.Dispose();
                hv_WindowWidth = 640;
                hv_WindowHeight.Dispose();
                hv_WindowHeight = 480;
                //
                //For a model of type '3d_gripping_point detection', 'detection', and 'segmentation', it is displayed:
                //- the plain input images in the first row,
                //- the image and their ground truth annotations in the second row,
                //- the image and their inference results in the third row.
                //
                //For models of type 'classification', it is displayed:
                //- the input image with a prediction box.
                //
                //For models of type 'gc_anomaly_detection' no results are displayed.
                //
                hv_IncludeImage.Dispose();
                hv_IncludeImage = 1;
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeGroundTruth = 1;
                hv_IncludeResults.Dispose();
                hv_IncludeResults = 1;
                //
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleEqual(1))) != 0)
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_Keys);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_Keys.TupleSelect(
                                hv_Index);
                        }
                        hv_Value.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_Key, out hv_Value);
                        if ((int)(new HTuple(hv_Key.TupleEqual("background_color"))) != 0)
                        {
                            hv_BackGroundColor.Dispose();
                            hv_BackGroundColor = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_row"))) != 0)
                        {
                            hv_SpacingRow.Dispose();
                            hv_SpacingRow = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_col"))) != 0)
                        {
                            hv_SpacingCol.Dispose();
                            hv_SpacingCol = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_width"))) != 0)
                        {
                            hv_WindowWidth.Dispose();
                            hv_WindowWidth = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_height"))) != 0)
                        {
                            hv_WindowHeight.Dispose();
                            hv_WindowHeight = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_row"))) != 0)
                        {
                            hv_WindowRow.Dispose();
                            hv_WindowRow = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_col"))) != 0)
                        {
                            hv_WindowCol.Dispose();
                            hv_WindowCol = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_input"))) != 0)
                        {
                            hv_IncludeImage.Dispose();
                            hv_IncludeImage = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_ground_truth"))) != 0)
                        {
                            hv_IncludeGroundTruth.Dispose();
                            hv_IncludeGroundTruth = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_result"))) != 0)
                        {
                            hv_IncludeResults.Dispose();
                            hv_IncludeResults = new HTuple(hv_Value);
                        }
                    }
                }
                //
                //If a model was handed over, get model type.
                if ((int)(new HTuple(hv_DLModelHandle.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                    if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual(
                        "classification"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(
                        new HTuple(hv_ModelType.TupleNotEqual("gc_anomaly_detection"))))).TupleAnd(
                        new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                        "ocr_recognition"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                        "segmentation"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("3d_gripping_point_detection")))) != 0)
                    {
                        throw new HalconException("Invalid model type");
                    }
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                    {
                        hv_IncludeResults.Dispose();
                        hv_IncludeResults = 0;
                    }
                }
                else
                {
                    //
                    //If no model was handed over, results are not displayed.
                    hv_IncludeResults.Dispose();
                    hv_IncludeResults = 0;
                    //Conclude the model type from the existing keys
                    hv_Samples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_Samples);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "anomaly_label",
                            out hv_AnomalyLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OCRLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "word",
                            out hv_OCRLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassificationLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "image_label_id",
                            out hv_ClassificationLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DetectionLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "bbox_label_id",
                            out hv_DetectionLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SegmentationLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "segmentation_file_name",
                            out hv_SegmentationLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_XYZExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "xyz_file_name",
                            out hv_XYZExists);
                    }
                    if ((int)(hv_AnomalyLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "gc_anomaly_detction";
                    }
                    else if ((int)(hv_ClassificationLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "classification";
                    }
                    else if ((int)(hv_OCRLabelExists) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OCRDetectionLabelExists.Dispose();
                            HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "bbox_label_id",
                                out hv_OCRDetectionLabelExists);
                        }
                        if ((int)(hv_OCRDetectionLabelExists) != 0)
                        {
                            throw new HalconException("The model handle is required for Deep OCR detection.");
                        }
                        else
                        {
                            throw new HalconException("The model handle is required for Deep OCR recognition.");
                        }
                    }
                    else if ((int)(hv_DetectionLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "detection";
                    }
                    else if ((int)(hv_SegmentationLabelExists) != 0)
                    {
                        if ((int)(hv_XYZExists) != 0)
                        {
                            hv_ModelType.Dispose();
                            hv_ModelType = "3d_gripping_point_detection";
                        }
                        else
                        {
                            hv_ModelType.Dispose();
                            hv_ModelType = "segmentation";
                        }
                    }
                    else
                    {
                        throw new HalconException("Cannot conclude model type from DLDataset.");
                    }
                }
                //
                //** Generate results for a random subset of NumSamples-many samples: ***
                //
                //Select random samples.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_SampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", hv_Split, "or", out hv_SampleIndices);
                {
                    HTuple ExpTmpOutVar_0;
                    tuple_shuffle(hv_SampleIndices, out ExpTmpOutVar_0);
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = ExpTmpOutVar_0;
                }
                //
                //Make sure that NumSamples is not bigger than the found number of SampleIndices
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NumSamples = hv_NumSamples_COPY_INP_TMP.TupleMin2(
                            new HTuple(hv_SampleIndices.TupleLength()));
                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_NumSamples_COPY_INP_TMP = ExpTmpLocalVar_NumSamples;
                    }
                }
                //Calculate the result for the selected samples.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
                            0, hv_NumSamples_COPY_INP_TMP - 1);
                        hv_SampleIndices.Dispose();
                        hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                    }
                }
                //
                if ((int)(hv_IncludeResults) != 0)
                {
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
                    hv_DLResult.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamples, new HTuple(), out hv_DLResult);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLResult = hv_DLResult.TupleSelectRange(
                                0, hv_NumSamples_COPY_INP_TMP - 1);
                            hv_DLResult.Dispose();
                            hv_DLResult = ExpTmpLocalVar_DLResult;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleSelectRange(
                                0, hv_NumSamples_COPY_INP_TMP - 1);
                            hv_DLSamples.Dispose();
                            hv_DLSamples = ExpTmpLocalVar_DLSamples;
                        }
                    }
                }
                else
                {
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
                }
                //
                //** Generate the tiled image and the tiled result data: ***
                //
                hv_ClassIdsExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "class_ids", out hv_ClassIdsExist);
                if ((int)(hv_ClassIdsExist) != 0)
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
                    //For segmentation models, we need a class ID that is not present in class_ids, to
                    //mark regions without region visualization.
                    hv_BackGroundClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BackGroundClass = (hv_ClassIDs.TupleMax()
                            ) + 1;
                    }
                }
                hv_RGB.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RGB = new HTuple();
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        1, 2)))).TupleNumber());
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        3, 4)))).TupleNumber());
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        5, 6)))).TupleNumber());
                }
                //
                ho_FinalRows.Dispose();
                HOperatorSet.GenEmptyObj(out ho_FinalRows);
                //
                //Generate the tiled sample image.
                //For the visualization it is better to use byte images.
                //The problem is that if you don't convert to bytes the range used to display is dynamic.
                //That means there can be strong fluctuations between several images, especially if there are "outliers" in the images.
                //By default expected range of the input image is [-127,128], but this is not the case for the normalization type 'constant_values'.
                hv_Scale.Dispose();
                hv_Scale = 1.0;
                hv_Shift.Dispose();
                hv_Shift = 127.0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "preprocess_param", out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_DLDatasetPreprocessParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "preprocess_param", out hv_DLDatasetPreprocessParam);
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "normalization_type",
                        out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_NormType.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "normalization_type",
                            out hv_NormType);

                        hv_KeyMinExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "image_range_min",
                            out hv_KeyMinExists);
                        hv_KeyMaxExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "image_range_min",
                            out hv_KeyMaxExists);
                        if ((int)(hv_KeyMinExists.TupleAnd(hv_KeyMaxExists)) != 0)
                        {
                            hv_ImageRangeMin.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_min",
                                out hv_ImageRangeMin);
                            hv_ImageRangeMax.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_max",
                                out hv_ImageRangeMax);
                        }
                        else
                        {
                            if ((int)(new HTuple(hv_NormType.TupleEqual("constant_values"))) != 0)
                            {
                                hv_ImageRangeMin.Dispose();
                                hv_ImageRangeMin = -2.0;
                                hv_ImageRangeMax.Dispose();
                                hv_ImageRangeMax = 2.0;
                            }
                            else
                            {
                                hv_ImageRangeMin.Dispose();
                                hv_ImageRangeMin = -127.0;
                                hv_ImageRangeMax.Dispose();
                                hv_ImageRangeMax = 128.0;
                            }
                        }
                        if ((int)(new HTuple(((hv_ImageRangeMax - hv_ImageRangeMin)).TupleEqual(0))) != 0)
                        {
                            hv_Scale.Dispose();
                            hv_Scale = 1.0;
                        }
                        else
                        {
                            hv_Scale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Scale = 255.0 / (hv_ImageRangeMax - hv_ImageRangeMin);
                            }
                        }
                        hv_Shift.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Shift = (-hv_Scale) * hv_ImageRangeMin;
                        }
                    }
                }
                ho_SampleImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_SampleImages);
                HTuple end_val173 = hv_NumSamples_COPY_INP_TMP - 1;
                HTuple step_val173 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val173, step_val173); hv_Index = hv_Index.TupleAdd(step_val173))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_SampleImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_SampleImage, hv_DLSamples.TupleSelect(hv_Index),
                            "image");
                    }
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_SampleImage, out hv_Channels);
                    if ((int)(new HTuple(hv_Channels.TupleNotEqual(3))) != 0)
                    {
                        //For any number of channels, that is not three, just use the first channel.
                        ho_FirstChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_SampleImage, out ho_FirstChannel, 1);
                        ho_SampleImage.Dispose();
                        HOperatorSet.Compose3(ho_FirstChannel, ho_FirstChannel, ho_FirstChannel,
                            out ho_SampleImage);
                    }
                    //Convert the images back to byte.
                    ho_ImageScaled.Dispose();
                    HOperatorSet.ScaleImage(ho_SampleImage, out ho_ImageScaled, hv_Scale, hv_Shift);
                    ho_ImageConverted.Dispose();
                    HOperatorSet.ConvertImageType(ho_ImageScaled, out ho_ImageConverted, "byte");
                    //Add the image to the tuple SampleImages.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_SampleImages, ho_ImageConverted, out ExpTmpOutVar_0
                            );
                        ho_SampleImages.Dispose();
                        ho_SampleImages = ExpTmpOutVar_0;
                    }
                }
                //Tile the images in a row.
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_SampleImages, out hv_Width, out hv_Height);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Crop.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OffsetRow.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
                }

                if ((int)((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleEqual(
                    "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("segmentation"))))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "ocr_recognition"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledImageRow.Dispose();
                        HOperatorSet.TileImagesOffset(ho_SampleImages, out ho_TiledImageRow, hv_OffsetRow,
                            (((new HTuple(0)).TupleConcat(((hv_Width + hv_SpacingCol)).TupleCumul()
                            ))).TupleSelectRange(0, (new HTuple(hv_Width.TupleLength())) - 1), hv_Crop,
                            hv_Crop, hv_Crop, hv_Crop, (((((hv_Width + hv_SpacingCol)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_Width.TupleLength())) - 1)) - hv_SpacingCol,
                            hv_Height.TupleMax());
                    }
                }
                //
                //Generate the columns of images for the tiled output.
                if ((int)(hv_IncludeImage) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        throw new HalconException("The key 'display_input' cannot be set for model type classification.");
                        ho_FinalRows.Dispose();
                        ho_SampleImages.Dispose();
                        ho_SampleImage.Dispose();
                        ho_FirstChannel.Dispose();
                        ho_ImageScaled.Dispose();
                        ho_ImageConverted.Dispose();
                        ho_TiledImageRow.Dispose();
                        ho_TiledImage.Dispose();
                        ho_Domain.Dispose();
                        ho_RegionComplement.Dispose();
                        ho_InstanceMasks.Dispose();
                        ho_InstanceMask.Dispose();
                        ho_ResInstanceMasks.Dispose();
                        ho_Image.Dispose();
                        ho_ImageCleared.Dispose();
                        ho_Regions.Dispose();
                        ho_TiledResult.Dispose();

                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_WindowHandle_COPY_INP_TMP.Dispose();
                        hv_BackGroundColor.Dispose();
                        hv_SpacingRow.Dispose();
                        hv_SpacingCol.Dispose();
                        hv_WindowRow.Dispose();
                        hv_WindowCol.Dispose();
                        hv_WindowWidth.Dispose();
                        hv_WindowHeight.Dispose();
                        hv_IncludeImage.Dispose();
                        hv_IncludeGroundTruth.Dispose();
                        hv_IncludeResults.Dispose();
                        hv_Keys.Dispose();
                        hv_Index.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_ModelType.Dispose();
                        hv_Samples.Dispose();
                        hv_AnomalyLabelExists.Dispose();
                        hv_OCRLabelExists.Dispose();
                        hv_ClassificationLabelExists.Dispose();
                        hv_DetectionLabelExists.Dispose();
                        hv_SegmentationLabelExists.Dispose();
                        hv_XYZExists.Dispose();
                        hv_OCRDetectionLabelExists.Dispose();
                        hv_DLSamples.Dispose();
                        hv_SampleIndices.Dispose();
                        hv_DLResult.Dispose();
                        hv_ClassIdsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_BackGroundClass.Dispose();
                        hv_RGB.Dispose();
                        hv_Scale.Dispose();
                        hv_Shift.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLDatasetPreprocessParam.Dispose();
                        hv_NormType.Dispose();
                        hv_KeyMinExists.Dispose();
                        hv_KeyMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_Channels.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_Crop.Dispose();
                        hv_OffsetRow.Dispose();
                        hv_TiledWidth.Dispose();
                        hv_TiledHeight.Dispose();
                        hv_NumResult.Dispose();
                        hv_PredictionsCorrect.Dispose();
                        hv_ImageConfidences.Dispose();
                        hv_ResClassIndices.Dispose();
                        hv_ResClasses.Dispose();
                        hv_ImageIDs.Dispose();
                        hv_ImageLabelIDs.Dispose();
                        hv_IndexResult.Dispose();
                        hv_ImageConfidence.Dispose();
                        hv_ResClassIndex.Dispose();
                        hv_ResClass.Dispose();
                        hv_ImageID.Dispose();
                        hv_ImageLabelID.Dispose();
                        hv_PredictionCorrect.Dispose();
                        hv_TextImageRows.Dispose();
                        hv_TextImageColumns.Dispose();
                        hv_TextImageWidth.Dispose();
                        hv_TextImageHeight.Dispose();
                        hv_TopOffset.Dispose();
                        hv_InstanceType.Dispose();
                        hv_Rect1KeyExists.Dispose();
                        hv_Rect2KeyExists.Dispose();
                        hv_MasksExist.Dispose();
                        hv_GTLabel.Dispose();
                        hv_GTCol1.Dispose();
                        hv_GTRow1.Dispose();
                        hv_GTCol2.Dispose();
                        hv_GTRow2.Dispose();
                        hv_GTCol.Dispose();
                        hv_GTRow.Dispose();
                        hv_GTLength1.Dispose();
                        hv_GTLength2.Dispose();
                        hv_GTPhi.Dispose();
                        hv_LeftOffset.Dispose();
                        hv_LabelId.Dispose();
                        hv_Col1.Dispose();
                        hv_Row1.Dispose();
                        hv_Col2.Dispose();
                        hv_Row2.Dispose();
                        hv_Col.Dispose();
                        hv_Row.Dispose();
                        hv_Length1.Dispose();
                        hv_Length2.Dispose();
                        hv_Phi.Dispose();
                        hv_ResConfidence.Dispose();
                        hv_ResCol1.Dispose();
                        hv_ResRow1.Dispose();
                        hv_ResCol2.Dispose();
                        hv_ResRow2.Dispose();
                        hv_ResCol.Dispose();
                        hv_ResRow.Dispose();
                        hv_ResLength1.Dispose();
                        hv_ResLength2.Dispose();
                        hv_ResPhi.Dispose();
                        hv_CurrentResult.Dispose();
                        hv_ClassId.Dispose();
                        hv_Confidence.Dispose();
                        hv_ResultMaskExists.Dispose();
                        hv_ResWords.Dispose();
                        hv_GTWord.Dispose();
                        hv_ResWord.Dispose();
                        hv_TiledDLSample.Dispose();
                        hv_CharIndices.Dispose();
                        hv_TiledDLResult.Dispose();
                        hv_Words.Dispose();
                        hv_DisplayGenParam.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_WindowHandleDict.Dispose();
                        hv_NoInputWindow.Dispose();
                        hv_Flush.Dispose();
                        hv_KeyForDisplay.Dispose();
                        hv_GTText.Dispose();
                        hv_PredictionText.Dispose();
                        hv__.Dispose();
                        hv_GTWidth.Dispose();
                        hv_TextHeight.Dispose();
                        hv_PredictionWidth.Dispose();
                        hv_WindowImageRatio.Dispose();
                        hv_WindowWidthMax.Dispose();
                        hv_WindowHeightMax.Dispose();
                        hv_Ratio.Dispose();
                        hv_ImageWidth.Dispose();
                        hv_ImageHeight.Dispose();
                        hv_ImageWindowWidthRatio.Dispose();
                        hv_ImageWindowHeightRatio.Dispose();
                        hv_CharWindowWidth.Dispose();
                        hv_CharWindowHeight.Dispose();
                        hv_CharImageWidth.Dispose();
                        hv_CharImageHeight.Dispose();
                        hv_ImageRow.Dispose();
                        hv_ImageColumn.Dispose();
                        hv_String.Dispose();
                        hv_StringWindowWidth.Dispose();
                        hv_StringImageWidth.Dispose();

                        return;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                            );
                        ho_FinalRows.Dispose();
                        ho_FinalRows = ExpTmpOutVar_0;
                    }
                }
                if ((int)(hv_IncludeGroundTruth) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        throw new HalconException("The key 'display_ground_truth' cannot be set for model type classification.");
                        ho_FinalRows.Dispose();
                        ho_SampleImages.Dispose();
                        ho_SampleImage.Dispose();
                        ho_FirstChannel.Dispose();
                        ho_ImageScaled.Dispose();
                        ho_ImageConverted.Dispose();
                        ho_TiledImageRow.Dispose();
                        ho_TiledImage.Dispose();
                        ho_Domain.Dispose();
                        ho_RegionComplement.Dispose();
                        ho_InstanceMasks.Dispose();
                        ho_InstanceMask.Dispose();
                        ho_ResInstanceMasks.Dispose();
                        ho_Image.Dispose();
                        ho_ImageCleared.Dispose();
                        ho_Regions.Dispose();
                        ho_TiledResult.Dispose();

                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_WindowHandle_COPY_INP_TMP.Dispose();
                        hv_BackGroundColor.Dispose();
                        hv_SpacingRow.Dispose();
                        hv_SpacingCol.Dispose();
                        hv_WindowRow.Dispose();
                        hv_WindowCol.Dispose();
                        hv_WindowWidth.Dispose();
                        hv_WindowHeight.Dispose();
                        hv_IncludeImage.Dispose();
                        hv_IncludeGroundTruth.Dispose();
                        hv_IncludeResults.Dispose();
                        hv_Keys.Dispose();
                        hv_Index.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_ModelType.Dispose();
                        hv_Samples.Dispose();
                        hv_AnomalyLabelExists.Dispose();
                        hv_OCRLabelExists.Dispose();
                        hv_ClassificationLabelExists.Dispose();
                        hv_DetectionLabelExists.Dispose();
                        hv_SegmentationLabelExists.Dispose();
                        hv_XYZExists.Dispose();
                        hv_OCRDetectionLabelExists.Dispose();
                        hv_DLSamples.Dispose();
                        hv_SampleIndices.Dispose();
                        hv_DLResult.Dispose();
                        hv_ClassIdsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_BackGroundClass.Dispose();
                        hv_RGB.Dispose();
                        hv_Scale.Dispose();
                        hv_Shift.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLDatasetPreprocessParam.Dispose();
                        hv_NormType.Dispose();
                        hv_KeyMinExists.Dispose();
                        hv_KeyMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_Channels.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_Crop.Dispose();
                        hv_OffsetRow.Dispose();
                        hv_TiledWidth.Dispose();
                        hv_TiledHeight.Dispose();
                        hv_NumResult.Dispose();
                        hv_PredictionsCorrect.Dispose();
                        hv_ImageConfidences.Dispose();
                        hv_ResClassIndices.Dispose();
                        hv_ResClasses.Dispose();
                        hv_ImageIDs.Dispose();
                        hv_ImageLabelIDs.Dispose();
                        hv_IndexResult.Dispose();
                        hv_ImageConfidence.Dispose();
                        hv_ResClassIndex.Dispose();
                        hv_ResClass.Dispose();
                        hv_ImageID.Dispose();
                        hv_ImageLabelID.Dispose();
                        hv_PredictionCorrect.Dispose();
                        hv_TextImageRows.Dispose();
                        hv_TextImageColumns.Dispose();
                        hv_TextImageWidth.Dispose();
                        hv_TextImageHeight.Dispose();
                        hv_TopOffset.Dispose();
                        hv_InstanceType.Dispose();
                        hv_Rect1KeyExists.Dispose();
                        hv_Rect2KeyExists.Dispose();
                        hv_MasksExist.Dispose();
                        hv_GTLabel.Dispose();
                        hv_GTCol1.Dispose();
                        hv_GTRow1.Dispose();
                        hv_GTCol2.Dispose();
                        hv_GTRow2.Dispose();
                        hv_GTCol.Dispose();
                        hv_GTRow.Dispose();
                        hv_GTLength1.Dispose();
                        hv_GTLength2.Dispose();
                        hv_GTPhi.Dispose();
                        hv_LeftOffset.Dispose();
                        hv_LabelId.Dispose();
                        hv_Col1.Dispose();
                        hv_Row1.Dispose();
                        hv_Col2.Dispose();
                        hv_Row2.Dispose();
                        hv_Col.Dispose();
                        hv_Row.Dispose();
                        hv_Length1.Dispose();
                        hv_Length2.Dispose();
                        hv_Phi.Dispose();
                        hv_ResConfidence.Dispose();
                        hv_ResCol1.Dispose();
                        hv_ResRow1.Dispose();
                        hv_ResCol2.Dispose();
                        hv_ResRow2.Dispose();
                        hv_ResCol.Dispose();
                        hv_ResRow.Dispose();
                        hv_ResLength1.Dispose();
                        hv_ResLength2.Dispose();
                        hv_ResPhi.Dispose();
                        hv_CurrentResult.Dispose();
                        hv_ClassId.Dispose();
                        hv_Confidence.Dispose();
                        hv_ResultMaskExists.Dispose();
                        hv_ResWords.Dispose();
                        hv_GTWord.Dispose();
                        hv_ResWord.Dispose();
                        hv_TiledDLSample.Dispose();
                        hv_CharIndices.Dispose();
                        hv_TiledDLResult.Dispose();
                        hv_Words.Dispose();
                        hv_DisplayGenParam.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_WindowHandleDict.Dispose();
                        hv_NoInputWindow.Dispose();
                        hv_Flush.Dispose();
                        hv_KeyForDisplay.Dispose();
                        hv_GTText.Dispose();
                        hv_PredictionText.Dispose();
                        hv__.Dispose();
                        hv_GTWidth.Dispose();
                        hv_TextHeight.Dispose();
                        hv_PredictionWidth.Dispose();
                        hv_WindowImageRatio.Dispose();
                        hv_WindowWidthMax.Dispose();
                        hv_WindowHeightMax.Dispose();
                        hv_Ratio.Dispose();
                        hv_ImageWidth.Dispose();
                        hv_ImageHeight.Dispose();
                        hv_ImageWindowWidthRatio.Dispose();
                        hv_ImageWindowHeightRatio.Dispose();
                        hv_CharWindowWidth.Dispose();
                        hv_CharWindowHeight.Dispose();
                        hv_CharImageWidth.Dispose();
                        hv_CharImageHeight.Dispose();
                        hv_ImageRow.Dispose();
                        hv_ImageColumn.Dispose();
                        hv_String.Dispose();
                        hv_StringWindowWidth.Dispose();
                        hv_StringImageWidth.Dispose();

                        return;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                            );
                        ho_FinalRows.Dispose();
                        ho_FinalRows = ExpTmpOutVar_0;
                    }
                }
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("segmentation"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "ocr_detection"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                {
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledImage.Dispose();
                        HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledImage, (((new HTuple(0)).TupleConcat(
                            ((hv_TiledHeight + hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0, (new HTuple(hv_TiledHeight.TupleLength()
                            )) - 1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),
                            0), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1),
                            HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(
                            new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
                            ), -1), hv_TiledWidth.TupleMax(), (((((hv_TiledHeight + hv_SpacingRow)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength())) - 1)) - hv_SpacingRow);
                    }
                    //Fill up with the background color.
                    if ((int)(new HTuple(hv_ModelType.TupleNotEqual("3d_gripping_point_detection"))) != 0)
                    {
                        ho_Domain.Dispose();
                        HOperatorSet.GetDomain(ho_TiledImage, out ho_Domain);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_TiledImage, out ExpTmpOutVar_0);
                            ho_TiledImage.Dispose();
                            ho_TiledImage = ExpTmpOutVar_0;
                        }
                        ho_RegionComplement.Dispose();
                        HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
                        HOperatorSet.OverpaintRegion(ho_TiledImage, ho_RegionComplement, hv_RGB,
                            "fill");
                    }
                }
                //
                //Generate the tiled data (classification prediction / detection bounding boxes /
                //ocr colored bar / segmentation regions ).
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    //
                    //For classification results the image is shown within a colored frame.
                    //
                    ho_FinalRows.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_FinalRows);
                    //
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        hv_NumResult.Dispose();
                        HOperatorSet.TupleLength(hv_DLResult, out hv_NumResult);
                        hv_PredictionsCorrect.Dispose();
                        hv_PredictionsCorrect = new HTuple();
                        hv_ImageConfidences.Dispose();
                        hv_ImageConfidences = new HTuple();
                        hv_ResClassIndices.Dispose();
                        hv_ResClassIndices = new HTuple();
                        hv_ResClasses.Dispose();
                        hv_ResClasses = new HTuple();
                        hv_ImageIDs.Dispose();
                        hv_ImageIDs = new HTuple();
                        hv_ImageLabelIDs.Dispose();
                        hv_ImageLabelIDs = new HTuple();
                        //
                        HTuple end_val243 = hv_NumResult - 1;
                        HTuple step_val243 = 1;
                        for (hv_IndexResult = 0; hv_IndexResult.Continue(end_val243, step_val243); hv_IndexResult = hv_IndexResult.TupleAdd(step_val243))
                        {
                            //
                            //Get labels and classes.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageConfidence.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_confidences",
                                    out hv_ImageConfidence);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ResClassIndex.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_class_ids",
                                    out hv_ResClassIndex);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ResClass.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_class_names",
                                    out hv_ResClass);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexResult), "image_id",
                                    out hv_ImageID);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageLabelID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexResult), "image_label_id",
                                    out hv_ImageLabelID);
                            }
                            //
                            //Check whether the actual sample prediction is false or correct.
                            hv_PredictionCorrect.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictionCorrect = new HTuple(((hv_ResClassIndex.TupleSelect(
                                    0))).TupleEqual(hv_ImageLabelID));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PredictionsCorrect = hv_PredictionsCorrect.TupleConcat(
                                        hv_PredictionCorrect);
                                    hv_PredictionsCorrect.Dispose();
                                    hv_PredictionsCorrect = ExpTmpLocalVar_PredictionsCorrect;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageConfidences = hv_ImageConfidences.TupleConcat(
                                        hv_ImageConfidence.TupleSelect(0));
                                    hv_ImageConfidences.Dispose();
                                    hv_ImageConfidences = ExpTmpLocalVar_ImageConfidences;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResClassIndices = hv_ResClassIndices.TupleConcat(
                                        hv_ResClassIndex.TupleSelect(0));
                                    hv_ResClassIndices.Dispose();
                                    hv_ResClassIndices = ExpTmpLocalVar_ResClassIndices;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResClasses = hv_ResClasses.TupleConcat(
                                        hv_ResClass.TupleSelect(0));
                                    hv_ResClasses.Dispose();
                                    hv_ResClasses = ExpTmpLocalVar_ResClasses;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                        hv_ImageID);
                                    hv_ImageIDs.Dispose();
                                    hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                        hv_ImageLabelID);
                                    hv_ImageLabelIDs.Dispose();
                                    hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                                }
                            }
                        }
                        //
                        //Tile the sample images.
                        ho_TiledImageRow.Dispose(); hv_TextImageRows.Dispose(); hv_TextImageColumns.Dispose(); hv_TextImageWidth.Dispose(); hv_TextImageHeight.Dispose();
                        gen_tiled_classification_image_result(out ho_TiledImageRow, hv_DLSamples,
                            hv_SpacingCol, hv_PredictionsCorrect, hv_ResClasses, out hv_TextImageRows,
                            out hv_TextImageColumns, out hv_TextImageWidth, out hv_TextImageHeight);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    ho_TiledImage.Dispose();
                    ho_TiledImage = new HObject(ho_TiledImageRow);
                    //
                }
                else if ((int)((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("ocr_detection")))) != 0)
                {
                    //
                    //For detection results the detected boxes must be moved
                    //to the positions of the respective image.
                    hv_TopOffset.Dispose();
                    hv_TopOffset = 0;
                    if ((int)(hv_IncludeImage) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopOffset = (hv_TopOffset + hv_SpacingRow) + (hv_TiledHeight.TupleSelect(
                                    0));
                                hv_TopOffset.Dispose();
                                hv_TopOffset = ExpTmpLocalVar_TopOffset;
                            }
                        }
                    }
                    //Check the detection type.
                    if ((int)((new HTuple((new HTuple(hv_DLModelHandle.TupleLength())).TupleGreater(
                        0))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Rect1KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "bbox_row1",
                                out hv_Rect1KeyExists);
                        }
                        if ((int)(hv_Rect1KeyExists) != 0)
                        {
                            hv_InstanceType.Dispose();
                            hv_InstanceType = "rectangle1";
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Rect2KeyExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists",
                                    "bbox_phi", out hv_Rect2KeyExists);
                            }
                            if ((int)(hv_Rect2KeyExists) != 0)
                            {
                                hv_InstanceType.Dispose();
                                hv_InstanceType = "rectangle2";
                            }
                            else
                            {
                                throw new HalconException("Not suitable sample keys!");
                            }
                        }
                    }
                    //Check if masks exist.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MasksExist.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "mask",
                            out hv_MasksExist);
                    }
                    if ((int)(hv_MasksExist) != 0)
                    {
                        ho_InstanceMasks.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_InstanceMasks);
                    }
                    //Move the ground truth labels.
                    hv_GTLabel.Dispose();
                    hv_GTLabel = new HTuple();
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        hv_GTCol1.Dispose();
                        hv_GTCol1 = new HTuple();
                        hv_GTRow1.Dispose();
                        hv_GTRow1 = new HTuple();
                        hv_GTCol2.Dispose();
                        hv_GTCol2 = new HTuple();
                        hv_GTRow2.Dispose();
                        hv_GTRow2 = new HTuple();
                    }
                    else
                    {
                        hv_GTCol.Dispose();
                        hv_GTCol = new HTuple();
                        hv_GTRow.Dispose();
                        hv_GTRow = new HTuple();
                        hv_GTLength1.Dispose();
                        hv_GTLength1 = new HTuple();
                        hv_GTLength2.Dispose();
                        hv_GTLength2 = new HTuple();
                        hv_GTPhi.Dispose();
                        hv_GTPhi = new HTuple();
                    }
                    if ((int)(hv_IncludeGroundTruth) != 0)
                    {
                        hv_LeftOffset.Dispose();
                        hv_LeftOffset = 0;
                        HTuple end_val314 = hv_NumSamples_COPY_INP_TMP - 1;
                        HTuple step_val314 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val314, step_val314); hv_Index = hv_Index.TupleAdd(step_val314))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelId.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_label_id",
                                    out hv_LabelId);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_GTLabel = hv_GTLabel.TupleConcat(
                                        hv_LabelId);
                                    hv_GTLabel.Dispose();
                                    hv_GTLabel = ExpTmpLocalVar_GTLabel;
                                }
                            }
                            if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col1",
                                        out hv_Col1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol1 = hv_GTCol1.TupleConcat(
                                            hv_Col1 + hv_LeftOffset);
                                        hv_GTCol1.Dispose();
                                        hv_GTCol1 = ExpTmpLocalVar_GTCol1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row1",
                                        out hv_Row1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow1 = hv_GTRow1.TupleConcat(
                                            hv_Row1 + hv_TopOffset);
                                        hv_GTRow1.Dispose();
                                        hv_GTRow1 = ExpTmpLocalVar_GTRow1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col2",
                                        out hv_Col2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol2 = hv_GTCol2.TupleConcat(
                                            hv_Col2 + hv_LeftOffset);
                                        hv_GTCol2.Dispose();
                                        hv_GTCol2 = ExpTmpLocalVar_GTCol2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row2",
                                        out hv_Row2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow2 = hv_GTRow2.TupleConcat(
                                            hv_Row2 + hv_TopOffset);
                                        hv_GTRow2.Dispose();
                                        hv_GTRow2 = ExpTmpLocalVar_GTRow2;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col",
                                        out hv_Col);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol = hv_GTCol.TupleConcat(
                                            hv_Col + hv_LeftOffset);
                                        hv_GTCol.Dispose();
                                        hv_GTCol = ExpTmpLocalVar_GTCol;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row",
                                        out hv_Row);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow = hv_GTRow.TupleConcat(
                                            hv_Row + hv_TopOffset);
                                        hv_GTRow.Dispose();
                                        hv_GTRow = ExpTmpLocalVar_GTRow;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_length1",
                                        out hv_Length1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTLength1 = hv_GTLength1.TupleConcat(
                                            hv_Length1);
                                        hv_GTLength1.Dispose();
                                        hv_GTLength1 = ExpTmpLocalVar_GTLength1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_length2",
                                        out hv_Length2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTLength2 = hv_GTLength2.TupleConcat(
                                            hv_Length2);
                                        hv_GTLength2.Dispose();
                                        hv_GTLength2 = ExpTmpLocalVar_GTLength2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Phi.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_phi",
                                        out hv_Phi);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTPhi = hv_GTPhi.TupleConcat(
                                            hv_Phi);
                                        hv_GTPhi.Dispose();
                                        hv_GTPhi = ExpTmpLocalVar_GTPhi;
                                    }
                                }
                            }
                            if ((int)(hv_MasksExist) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_InstanceMask.Dispose();
                                    HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLSamples.TupleSelect(
                                        hv_Index), "mask");
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MoveRegion(ho_InstanceMask, out ExpTmpOutVar_0, hv_TopOffset,
                                        hv_LeftOffset);
                                    ho_InstanceMask.Dispose();
                                    ho_InstanceMask = ExpTmpOutVar_0;
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_InstanceMasks, ho_InstanceMask, out ExpTmpOutVar_0
                                        );
                                    ho_InstanceMasks.Dispose();
                                    ho_InstanceMasks = ExpTmpOutVar_0;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LeftOffset = (hv_LeftOffset + hv_SpacingCol) + (hv_Width.TupleSelect(
                                        hv_Index));
                                    hv_LeftOffset.Dispose();
                                    hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopOffset = (hv_TopOffset + hv_SpacingRow) + (hv_TiledHeight.TupleSelect(
                                    0));
                                hv_TopOffset.Dispose();
                                hv_TopOffset = ExpTmpLocalVar_TopOffset;
                            }
                        }
                    }
                    hv_ResClass.Dispose();
                    hv_ResClass = new HTuple();
                    hv_ResConfidence.Dispose();
                    hv_ResConfidence = new HTuple();
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        hv_ResCol1.Dispose();
                        hv_ResCol1 = new HTuple();
                        hv_ResRow1.Dispose();
                        hv_ResRow1 = new HTuple();
                        hv_ResCol2.Dispose();
                        hv_ResCol2 = new HTuple();
                        hv_ResRow2.Dispose();
                        hv_ResRow2 = new HTuple();
                    }
                    else
                    {
                        hv_ResCol.Dispose();
                        hv_ResCol = new HTuple();
                        hv_ResRow.Dispose();
                        hv_ResRow = new HTuple();
                        hv_ResLength1.Dispose();
                        hv_ResLength1 = new HTuple();
                        hv_ResLength2.Dispose();
                        hv_ResLength2 = new HTuple();
                        hv_ResPhi.Dispose();
                        hv_ResPhi = new HTuple();
                    }
                    if ((int)(hv_MasksExist) != 0)
                    {
                        ho_ResInstanceMasks.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_ResInstanceMasks);
                    }
                    //Move the result classes.
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        hv_LeftOffset.Dispose();
                        hv_LeftOffset = 0;
                        HTuple end_val367 = hv_NumSamples_COPY_INP_TMP - 1;
                        HTuple step_val367 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val367, step_val367); hv_Index = hv_Index.TupleAdd(step_val367))
                        {
                            if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                            {
                                hv_CurrentResult.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResult = hv_DLResult.TupleSelect(
                                        hv_Index);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentResult = hv_CurrentResult.TupleGetDictTuple(
                                            "words");
                                        hv_CurrentResult.Dispose();
                                        hv_CurrentResult = ExpTmpLocalVar_CurrentResult;
                                    }
                                }
                                hv_Col.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentResult, "col", out hv_Col);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResCol = hv_ResCol.TupleConcat(
                                            hv_Col + hv_LeftOffset);
                                        hv_ResCol.Dispose();
                                        hv_ResCol = ExpTmpLocalVar_ResCol;
                                    }
                                }
                                hv_Row.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentResult, "row", out hv_Row);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResRow = hv_ResRow.TupleConcat(
                                            hv_Row + hv_TopOffset);
                                        hv_ResRow.Dispose();
                                        hv_ResRow = ExpTmpLocalVar_ResRow;
                                    }
                                }
                                hv_Length1.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentResult, "length1", out hv_Length1);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleConcat(
                                            hv_Length1);
                                        hv_ResLength1.Dispose();
                                        hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                                    }
                                }
                                hv_Length2.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentResult, "length2", out hv_Length2);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleConcat(
                                            hv_Length2);
                                        hv_ResLength2.Dispose();
                                        hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                                    }
                                }
                                hv_Phi.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentResult, "phi", out hv_Phi);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleConcat(
                                            hv_Phi);
                                        hv_ResPhi.Dispose();
                                        hv_ResPhi = ExpTmpLocalVar_ResPhi;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassId.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_class_id",
                                        out hv_ClassId);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResClass = hv_ResClass.TupleConcat(
                                            hv_ClassId);
                                        hv_ResClass.Dispose();
                                        hv_ResClass = ExpTmpLocalVar_ResClass;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Confidence.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_confidence",
                                        out hv_Confidence);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResConfidence = hv_ResConfidence.TupleConcat(
                                            hv_Confidence);
                                        hv_ResConfidence.Dispose();
                                        hv_ResConfidence = ExpTmpLocalVar_ResConfidence;
                                    }
                                }
                                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col1.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col1",
                                            out hv_Col1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleConcat(
                                                hv_Col1 + hv_LeftOffset);
                                            hv_ResCol1.Dispose();
                                            hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row1.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row1",
                                            out hv_Row1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleConcat(
                                                hv_Row1 + hv_TopOffset);
                                            hv_ResRow1.Dispose();
                                            hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col2.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col2",
                                            out hv_Col2);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleConcat(
                                                hv_Col2 + hv_LeftOffset);
                                            hv_ResCol2.Dispose();
                                            hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row2.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row2",
                                            out hv_Row2);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleConcat(
                                                hv_Row2 + hv_TopOffset);
                                            hv_ResRow2.Dispose();
                                            hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col",
                                            out hv_Col);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResCol = hv_ResCol.TupleConcat(
                                                hv_Col + hv_LeftOffset);
                                            hv_ResCol.Dispose();
                                            hv_ResCol = ExpTmpLocalVar_ResCol;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row",
                                            out hv_Row);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResRow = hv_ResRow.TupleConcat(
                                                hv_Row + hv_TopOffset);
                                            hv_ResRow.Dispose();
                                            hv_ResRow = ExpTmpLocalVar_ResRow;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Length1.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_length1",
                                            out hv_Length1);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleConcat(
                                                hv_Length1);
                                            hv_ResLength1.Dispose();
                                            hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Length2.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_length2",
                                            out hv_Length2);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleConcat(
                                                hv_Length2);
                                            hv_ResLength2.Dispose();
                                            hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Phi.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_phi",
                                            out hv_Phi);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleConcat(
                                                hv_Phi);
                                            hv_ResPhi.Dispose();
                                            hv_ResPhi = ExpTmpLocalVar_ResPhi;
                                        }
                                    }
                                }
                            }
                            if ((int)(hv_MasksExist) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ResultMaskExists.Dispose();
                                    HOperatorSet.GetDictParam(hv_DLResult.TupleSelect(hv_Index), "key_exists",
                                        "mask", out hv_ResultMaskExists);
                                }
                                if ((int)(hv_ResultMaskExists) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_InstanceMask.Dispose();
                                        HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLResult.TupleSelect(
                                            hv_Index), "mask");
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.MoveRegion(ho_InstanceMask, out ExpTmpOutVar_0, hv_TopOffset,
                                            hv_LeftOffset);
                                        ho_InstanceMask.Dispose();
                                        ho_InstanceMask = ExpTmpOutVar_0;
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_ResInstanceMasks, ho_InstanceMask, out ExpTmpOutVar_0
                                            );
                                        ho_ResInstanceMasks.Dispose();
                                        ho_ResInstanceMasks = ExpTmpOutVar_0;
                                    }
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LeftOffset = (hv_LeftOffset + hv_SpacingCol) + (hv_Width.TupleSelect(
                                        hv_Index));
                                    hv_LeftOffset.Dispose();
                                    hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
                                }
                            }
                        }
                    }
                    //
                }
                else if ((int)((new HTuple(hv_ModelType.TupleEqual("segmentation"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection")))) != 0)
                {
                    //
                    //The tiled segmentation result image is constructed in the same way as the tiled sample image.
                    ho_FinalRows.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_FinalRows);
                    if ((int)(hv_IncludeImage) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            HOperatorSet.GenImageConst(out ho_Image, "real", hv_TiledWidth.TupleSelect(
                                0), hv_TiledHeight.TupleSelect(0));
                        }
                        //For the top (image) row, set the (virtual) background class as segmentation result.
                        ho_ImageCleared.Dispose();
                        HOperatorSet.GenImageProto(ho_Image, out ho_ImageCleared, hv_BackGroundClass);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_ImageCleared, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    //
                    if ((int)(hv_IncludeGroundTruth) != 0)
                    {
                        ho_TiledImageRow.Dispose();
                        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLSamples, hv_SpacingCol,
                            hv_Width, hv_Height);
                        if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                        {
                            //Map the ground truth class IDs to [1, 0].
                            ho_Regions.Dispose();
                            HOperatorSet.Threshold(ho_TiledImageRow, out ho_Regions, hv_ClassIDs,
                                hv_ClassIDs);
                            HOperatorSet.OverpaintRegion(ho_TiledImageRow, ho_Regions, (new HTuple(1)).TupleConcat(
                                0), "fill");
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    //
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        ho_TiledImageRow.Dispose();
                        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLResult, hv_SpacingCol,
                            hv_Width, hv_Height);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledResult.Dispose();
                        HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledResult, (((new HTuple(0)).TupleConcat(
                            ((hv_TiledHeight + hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0, (new HTuple(hv_TiledHeight.TupleLength()
                            )) - 1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),
                            0), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1),
                            HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(
                            new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
                            ), -1), hv_TiledWidth.TupleMax(), (((((hv_TiledHeight + hv_SpacingRow)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength())) - 1)) - hv_SpacingRow);
                    }
                    //Fill up with the background color.
                    if ((int)(new HTuple(hv_ModelType.TupleNotEqual("3d_gripping_point_detection"))) != 0)
                    {
                        ho_Domain.Dispose();
                        HOperatorSet.GetDomain(ho_TiledResult, out ho_Domain);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.FullDomain(ho_TiledResult, out ExpTmpOutVar_0);
                            ho_TiledResult.Dispose();
                            ho_TiledResult = ExpTmpOutVar_0;
                        }
                        ho_RegionComplement.Dispose();
                        HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
                        HOperatorSet.OverpaintRegion(ho_TiledResult, ho_RegionComplement, hv_BackGroundClass,
                            "fill");
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    //
                    //For ocr_recognition the results are shown within a colored bar below the images.
                    ho_FinalRows.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_FinalRows);
                    //
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        hv_NumResult.Dispose();
                        HOperatorSet.TupleLength(hv_DLResult, out hv_NumResult);
                        hv_PredictionsCorrect.Dispose();
                        hv_PredictionsCorrect = new HTuple();
                        hv_ResWords.Dispose();
                        hv_ResWords = new HTuple();
                        //
                        HTuple end_val464 = hv_NumResult - 1;
                        HTuple step_val464 = 1;
                        for (hv_IndexResult = 0; hv_IndexResult.Continue(end_val464, step_val464); hv_IndexResult = hv_IndexResult.TupleAdd(step_val464))
                        {
                            //
                            //Get ground truth word and resulting word.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GTWord.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexResult), "word",
                                    out hv_GTWord);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ResWord.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "word",
                                    out hv_ResWord);
                            }
                            //
                            //Check whether the sample prediction is correct or not.
                            hv_PredictionCorrect.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictionCorrect = new HTuple(hv_ResWord.TupleEqual(
                                    hv_GTWord));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResWords = hv_ResWords.TupleConcat(
                                        hv_ResWord);
                                    hv_ResWords.Dispose();
                                    hv_ResWords = ExpTmpLocalVar_ResWords;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PredictionsCorrect = hv_PredictionsCorrect.TupleConcat(
                                        hv_PredictionCorrect);
                                    hv_PredictionsCorrect.Dispose();
                                    hv_PredictionsCorrect = ExpTmpLocalVar_PredictionsCorrect;
                                }
                            }
                        }
                        //
                        //Tile the sample images.
                        ho_TiledImageRow.Dispose(); hv_TextImageRows.Dispose(); hv_TextImageColumns.Dispose(); hv_TextImageWidth.Dispose(); hv_TextImageHeight.Dispose();
                        gen_tiled_ocr_recognition_image_result(out ho_TiledImageRow, hv_DLSamples,
                            hv_PredictionsCorrect, out hv_TextImageRows, out hv_TextImageColumns,
                            out hv_TextImageWidth, out hv_TextImageHeight);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    ho_TiledImage.Dispose();
                    ho_TiledImage = new HObject(ho_TiledImageRow);
                }
                //
                //** Generate a TiledDLSample and a TiledDLResult to display them with dev_display_dl_data: ***
                //
                //Generate a tiled DLSample.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "image_id", hv_ImageID);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "image_label_id", hv_ImageLabelID);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col1", hv_GTCol1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row1", hv_GTRow1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col2", hv_GTCol2);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row2", hv_GTRow2);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col", hv_GTCol);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row", hv_GTRow);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length1", hv_GTLength1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length2", hv_GTLength2);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_phi", hv_GTPhi);
                    }
                    if ((int)(hv_MasksExist) != 0)
                    {
                        HOperatorSet.SetDictObject(ho_InstanceMasks, hv_TiledDLSample, "mask");
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                    hv_CharIndices.Dispose();
                    HOperatorSet.TupleFind(hv_GTLabel, 1, out hv_CharIndices);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTLabel, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTLabel.Dispose();
                        hv_GTLabel = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTCol, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTCol.Dispose();
                        hv_GTCol = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col", hv_GTCol);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTRow, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTRow.Dispose();
                        hv_GTRow = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row", hv_GTRow);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTLength1, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTLength1.Dispose();
                        hv_GTLength1 = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length1", hv_GTLength1);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTLength2, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTLength2.Dispose();
                        hv_GTLength2 = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length2", hv_GTLength2);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_GTPhi, hv_CharIndices, out ExpTmpOutVar_0);
                        hv_GTPhi.Dispose();
                        hv_GTPhi = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_phi", hv_GTPhi);
                }
                //
                //Generate a tiled DLResult.
                hv_TiledDLResult.Dispose();
                HOperatorSet.CreateDict(out hv_TiledDLResult);
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "image_class_id", hv_ResClassIndices.TupleSelect(
                            0));
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "image_confidence", hv_ImageConfidences);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "word", hv_ResWords);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    hv_Words.Dispose();
                    HOperatorSet.CreateDict(out hv_Words);
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "words", hv_Words);
                    HOperatorSet.SetDictTuple(hv_Words, "col", hv_ResCol);
                    HOperatorSet.SetDictTuple(hv_Words, "row", hv_ResRow);
                    HOperatorSet.SetDictTuple(hv_Words, "length1", hv_ResLength1);
                    HOperatorSet.SetDictTuple(hv_Words, "length2", hv_ResLength2);
                    HOperatorSet.SetDictTuple(hv_Words, "phi", hv_ResPhi);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    HOperatorSet.SetDictObject(ho_TiledResult, hv_TiledDLResult, "segmentation_image");
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    HOperatorSet.SetDictObject(ho_TiledResult, hv_TiledDLResult, "gripping_map");
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_class_id", hv_ResClass);
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_confidence", hv_ResConfidence);
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col1", hv_ResCol1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row1", hv_ResRow1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col2", hv_ResCol2);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row2", hv_ResRow2);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col", hv_ResCol);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row", hv_ResRow);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_length1", hv_ResLength1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_length2", hv_ResLength2);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_phi", hv_ResPhi);
                    }
                    if ((int)(hv_MasksExist) != 0)
                    {
                        HOperatorSet.SetDictObject(ho_ResInstanceMasks, hv_TiledDLResult, "mask");
                    }
                }
                //
                //Set display parameters.
                hv_DisplayGenParam.Dispose();
                HOperatorSet.CreateDict(out hv_DisplayGenParam);
                //Pinch off all text display from dev_display_dl_data for a visualization without clutter.
                HOperatorSet.SetDictTuple(hv_DisplayGenParam, "display_bottom_desc", 0);
                HOperatorSet.SetDictTuple(hv_DisplayGenParam, "display_legend", 0);
                HOperatorSet.SetDictTuple(hv_DisplayGenParam, "display_labels", 0);
                if ((int)((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleAnd(new HTuple((new HTuple(hv_DLModelHandle.TupleLength()
                    )).TupleGreater(0)))) != 0)
                {
                    //Don't display directions if 'ignore_direction' is set to 'true'.
                    hv_IgnoreDirection.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                    if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DisplayGenParam, "display_direction", 0);
                    }
                }
                //
                //Initialize the window for displaying the tiled comparison of input and result.
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_NoInputWindow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NoInputWindow = new HTuple((new HTuple(hv_WindowHandle_COPY_INP_TMP.TupleLength()
                        )).TupleEqual(0));
                }
                if ((int)(hv_NoInputWindow) != 0)
                {
                    hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
                    hv_WindowHandle_COPY_INP_TMP.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowCol, hv_Width, hv_Height,
                        hv_WindowWidth, hv_WindowHeight, out hv_WindowHandle_COPY_INP_TMP);
                }
                hv_Flush.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", out hv_Flush);
                if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
                {
                    HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", "false");
                }
                HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "background_color",
                    hv_BackGroundColor);
                HDevWindowStack.SetActive(hv_WindowHandle_COPY_INP_TMP);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                hv_WindowHandleOut.Dispose();
                hv_WindowHandleOut = new HTuple(hv_WindowHandle_COPY_INP_TMP);
                //
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "image";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "segmentation_image_result";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "bbox_both";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "image";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "ocr_detection_both";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "gripping_map";
                }
                //
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_KeyForDisplay, hv_WindowHandle_COPY_INP_TMP);
                //
                //Display the tiled image.
                dev_display_dl_data(hv_TiledDLSample, hv_TiledDLResult, hv_DLDataset, hv_KeyForDisplay,
                    hv_DisplayGenParam, hv_WindowHandleDict);
                //
                //For classification and ocr_recognition, display additional text.
                if ((int)((new HTuple(hv_ModelType.TupleEqual("classification"))).TupleAnd(
                    hv_IncludeResults)) != 0)
                {
                    hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
                    HTuple end_val623 = hv_NumSamples_COPY_INP_TMP - 1;
                    HTuple step_val623 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val623, step_val623); hv_Index = hv_Index.TupleAdd(step_val623))
                    {
                        hv_GTText.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GTText = "Ground truth: " + (hv_ImageLabelIDs.TupleSelect(
                                hv_Index));
                        }
                        hv_PredictionText.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictionText = "Prediction: " + (hv_ResClassIndices.TupleSelect(
                                hv_Index));
                        }
                        hv__.Dispose(); hv__.Dispose(); hv_GTWidth.Dispose(); hv_TextHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_GTText,
                            out hv__, out hv__, out hv_GTWidth, out hv_TextHeight);
                        hv__.Dispose(); hv__.Dispose(); hv_PredictionWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_PredictionText,
                            out hv__, out hv__, out hv_PredictionWidth, out hv__);
                        //Get ratio between image and window coordinate system.
                        hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_WindowHandle_COPY_INP_TMP, out hv__, out hv__,
                            out hv_WindowWidth, out hv_WindowHeight);
                        //Adapt widths of texts to plot it correctly in window coordinate system.
                        if ((int)(new HTuple(((hv_Height / (hv_Width.TupleReal()))).TupleGreater(
                            hv_WindowHeight / (hv_WindowWidth.TupleReal())))) != 0)
                        {
                            hv_WindowImageRatio.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio = 1.0 / (hv_WindowHeight / (((hv_Height.TupleSelect(
                                    0))).TupleReal()));
                            }
                        }
                        else
                        {
                            hv_WindowImageRatio.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio = 1.0 / (hv_WindowWidth / (((hv_Width.TupleSelect(
                                    0))).TupleReal()));
                            }
                        }
                        if ((int)(new HTuple(hv_TextImageWidth.TupleLess(((hv_GTWidth + hv_PredictionWidth) * hv_WindowImageRatio) + 30))) != 0)
                        {
                            //Make shorter text.
                            hv_GTText.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GTText = "GT: " + (hv_ImageLabelIDs.TupleSelect(
                                    hv_Index));
                            }
                            hv_PredictionText.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictionText = "Pred.: " + (hv_ResClassIndices.TupleSelect(
                                    hv_Index));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv_GTWidth.Dispose(); hv_TextHeight.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_GTText,
                                out hv__, out hv__, out hv_GTWidth, out hv_TextHeight);
                            hv__.Dispose(); hv__.Dispose(); hv_PredictionWidth.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_PredictionText,
                                out hv__, out hv__, out hv_PredictionWidth, out hv__);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_GTText, "image",
                                    ((hv_TextImageRows.TupleSelect(hv_Index)) + (hv_TextImageHeight / 2)) - hv_TextHeight,
                                    (hv_TextImageColumns.TupleSelect(hv_Index)) + 10, "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_PredictionText,
                                    "image", ((hv_TextImageRows.TupleSelect(hv_Index)) + (hv_TextImageHeight / 2)) - hv_TextHeight,
                                    (((hv_TextImageColumns.TupleSelect(hv_Index)) + hv_TextImageWidth) - (hv_PredictionWidth * hv_WindowImageRatio)) - 10,
                                    "white", "box", "false");
                            }
                        }
                    }
                }
                else if ((int)((new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))).TupleAnd(
                    hv_IncludeResults)) != 0)
                {
                    //Get the actual window dimensions.
                    hv_WindowWidthMax.Dispose();
                    hv_WindowWidthMax = new HTuple(hv_WindowWidth);
                    hv_WindowHeightMax.Dispose();
                    hv_WindowHeightMax = new HTuple(hv_WindowHeight);
                    hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                    HOperatorSet.GetWindowExtents(hv_WindowHandle_COPY_INP_TMP, out hv__, out hv__,
                        out hv_WindowWidth, out hv_WindowHeight);
                    //If the window was created here increase its size fitting the specified limits and keeping its aspect ratio.
                    if ((int)((new HTuple(hv_NoInputWindow.TupleAnd(new HTuple(hv_WindowWidth.TupleLess(
                        hv_WindowWidthMax))))).TupleAnd(new HTuple(hv_WindowHeight.TupleLess(
                        hv_WindowHeightMax)))) != 0)
                    {
                        hv_Ratio.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Ratio = (((hv_WindowWidthMax.TupleReal()
                                ) / hv_WindowWidth)).TupleMin2((hv_WindowHeightMax.TupleReal()) / hv_WindowHeight);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowWidth = ((hv_Ratio * hv_WindowWidth)).TupleRound()
                                    ;
                                hv_WindowWidth.Dispose();
                                hv_WindowWidth = ExpTmpLocalVar_WindowWidth;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowHeight = ((hv_Ratio * hv_WindowHeight)).TupleRound()
                                    ;
                                hv_WindowHeight.Dispose();
                                hv_WindowHeight = ExpTmpLocalVar_WindowHeight;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), -1, -1, hv_WindowWidth,
                                hv_WindowHeight);
                        }
                    }
                    //Calculate window/image size ratios.
                    hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_TiledImage, out hv_ImageWidth, out hv_ImageHeight);
                    hv_ImageWindowWidthRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowWidthRatio = (hv_ImageWidth.TupleReal()
                            ) / hv_WindowWidth;
                    }
                    hv_ImageWindowHeightRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowHeightRatio = (hv_ImageHeight.TupleReal()
                            ) / hv_WindowHeight;
                    }
                    //Calculate character image size.
                    hv__.Dispose(); hv__.Dispose(); hv_CharWindowWidth.Dispose(); hv_CharWindowHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, "H", out hv__,
                        out hv__, out hv_CharWindowWidth, out hv_CharWindowHeight);
                    hv_CharImageWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CharImageWidth = hv_CharWindowWidth * hv_ImageWindowWidthRatio;
                    }
                    hv_CharImageHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CharImageHeight = hv_CharWindowHeight * hv_ImageWindowHeightRatio;
                    }
                    //Display resulting words.
                    HTuple end_val667 = hv_NumSamples_COPY_INP_TMP - 1;
                    HTuple step_val667 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val667, step_val667); hv_Index = hv_Index.TupleAdd(step_val667))
                    {
                        hv_ImageRow.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageRow = (((hv_TextImageRows.TupleSelect(
                                hv_Index)) + (0.5 * hv_TextImageHeight)) - hv_CharImageHeight) + 1;
                        }
                        hv_ImageColumn.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageColumn = (hv_TextImageColumns.TupleSelect(
                                hv_Index)) + (0.5 * hv_CharImageWidth);
                        }
                        hv_String.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_String = ("\"" + (hv_ResWords.TupleSelect(
                                hv_Index))) + "\"";
                        }
                        //Reduce string length if it is too long.
                        hv__.Dispose(); hv__.Dispose(); hv_StringWindowWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_String,
                            out hv__, out hv__, out hv_StringWindowWidth, out hv__);
                        hv_StringImageWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StringImageWidth = hv_StringWindowWidth * hv_ImageWindowWidthRatio;
                        }
                        while ((int)((new HTuple(((hv_String.TupleStrlen())).TupleGreater(5))).TupleAnd(
                            new HTuple(hv_StringImageWidth.TupleGreater(0.8 * hv_TextImageWidth)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_String = (hv_String.TupleStrFirstN(
                                        (hv_String.TupleStrlen()) - 5)) + "...";
                                    hv_String.Dispose();
                                    hv_String = ExpTmpLocalVar_String;
                                }
                            }
                            hv__.Dispose(); hv__.Dispose(); hv_StringWindowWidth.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_String,
                                out hv__, out hv__, out hv_StringWindowWidth, out hv__);
                            hv_StringImageWidth.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StringImageWidth = hv_StringWindowWidth * hv_ImageWindowWidthRatio;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_String, "image",
                                hv_ImageRow, hv_ImageColumn, "white", "box", "false");
                        }
                    }
                }
                //
                if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
                {
                    //Only flush the window, if 'flush' is 'true'. Otherwise the caller
                    //(who set flush to 'false' on purpose) is responsible for flushing.
                    HOperatorSet.FlushBuffer(hv_WindowHandle_COPY_INP_TMP);
                }
                HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", hv_Flush);
                //
                ho_FinalRows.Dispose();
                ho_SampleImages.Dispose();
                ho_SampleImage.Dispose();
                ho_FirstChannel.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageConverted.Dispose();
                ho_TiledImageRow.Dispose();
                ho_TiledImage.Dispose();
                ho_Domain.Dispose();
                ho_RegionComplement.Dispose();
                ho_InstanceMasks.Dispose();
                ho_InstanceMask.Dispose();
                ho_ResInstanceMasks.Dispose();
                ho_Image.Dispose();
                ho_ImageCleared.Dispose();
                ho_Regions.Dispose();
                ho_TiledResult.Dispose();

                hv_NumSamples_COPY_INP_TMP.Dispose();
                hv_WindowHandle_COPY_INP_TMP.Dispose();
                hv_BackGroundColor.Dispose();
                hv_SpacingRow.Dispose();
                hv_SpacingCol.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_IncludeImage.Dispose();
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeResults.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_ModelType.Dispose();
                hv_Samples.Dispose();
                hv_AnomalyLabelExists.Dispose();
                hv_OCRLabelExists.Dispose();
                hv_ClassificationLabelExists.Dispose();
                hv_DetectionLabelExists.Dispose();
                hv_SegmentationLabelExists.Dispose();
                hv_XYZExists.Dispose();
                hv_OCRDetectionLabelExists.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLResult.Dispose();
                hv_ClassIdsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_BackGroundClass.Dispose();
                hv_RGB.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_KeyExists.Dispose();
                hv_DLDatasetPreprocessParam.Dispose();
                hv_NormType.Dispose();
                hv_KeyMinExists.Dispose();
                hv_KeyMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_Channels.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_TiledWidth.Dispose();
                hv_TiledHeight.Dispose();
                hv_NumResult.Dispose();
                hv_PredictionsCorrect.Dispose();
                hv_ImageConfidences.Dispose();
                hv_ResClassIndices.Dispose();
                hv_ResClasses.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_IndexResult.Dispose();
                hv_ImageConfidence.Dispose();
                hv_ResClassIndex.Dispose();
                hv_ResClass.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_PredictionCorrect.Dispose();
                hv_TextImageRows.Dispose();
                hv_TextImageColumns.Dispose();
                hv_TextImageWidth.Dispose();
                hv_TextImageHeight.Dispose();
                hv_TopOffset.Dispose();
                hv_InstanceType.Dispose();
                hv_Rect1KeyExists.Dispose();
                hv_Rect2KeyExists.Dispose();
                hv_MasksExist.Dispose();
                hv_GTLabel.Dispose();
                hv_GTCol1.Dispose();
                hv_GTRow1.Dispose();
                hv_GTCol2.Dispose();
                hv_GTRow2.Dispose();
                hv_GTCol.Dispose();
                hv_GTRow.Dispose();
                hv_GTLength1.Dispose();
                hv_GTLength2.Dispose();
                hv_GTPhi.Dispose();
                hv_LeftOffset.Dispose();
                hv_LabelId.Dispose();
                hv_Col1.Dispose();
                hv_Row1.Dispose();
                hv_Col2.Dispose();
                hv_Row2.Dispose();
                hv_Col.Dispose();
                hv_Row.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_Phi.Dispose();
                hv_ResConfidence.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol2.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol.Dispose();
                hv_ResRow.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv_CurrentResult.Dispose();
                hv_ClassId.Dispose();
                hv_Confidence.Dispose();
                hv_ResultMaskExists.Dispose();
                hv_ResWords.Dispose();
                hv_GTWord.Dispose();
                hv_ResWord.Dispose();
                hv_TiledDLSample.Dispose();
                hv_CharIndices.Dispose();
                hv_TiledDLResult.Dispose();
                hv_Words.Dispose();
                hv_DisplayGenParam.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_NoInputWindow.Dispose();
                hv_Flush.Dispose();
                hv_KeyForDisplay.Dispose();
                hv_GTText.Dispose();
                hv_PredictionText.Dispose();
                hv__.Dispose();
                hv_GTWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_PredictionWidth.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_WindowWidthMax.Dispose();
                hv_WindowHeightMax.Dispose();
                hv_Ratio.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageWindowWidthRatio.Dispose();
                hv_ImageWindowHeightRatio.Dispose();
                hv_CharWindowWidth.Dispose();
                hv_CharWindowHeight.Dispose();
                hv_CharImageWidth.Dispose();
                hv_CharImageHeight.Dispose();
                hv_ImageRow.Dispose();
                hv_ImageColumn.Dispose();
                hv_String.Dispose();
                hv_StringWindowWidth.Dispose();
                hv_StringImageWidth.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_FinalRows.Dispose();
                ho_SampleImages.Dispose();
                ho_SampleImage.Dispose();
                ho_FirstChannel.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageConverted.Dispose();
                ho_TiledImageRow.Dispose();
                ho_TiledImage.Dispose();
                ho_Domain.Dispose();
                ho_RegionComplement.Dispose();
                ho_InstanceMasks.Dispose();
                ho_InstanceMask.Dispose();
                ho_ResInstanceMasks.Dispose();
                ho_Image.Dispose();
                ho_ImageCleared.Dispose();
                ho_Regions.Dispose();
                ho_TiledResult.Dispose();

                hv_NumSamples_COPY_INP_TMP.Dispose();
                hv_WindowHandle_COPY_INP_TMP.Dispose();
                hv_BackGroundColor.Dispose();
                hv_SpacingRow.Dispose();
                hv_SpacingCol.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_IncludeImage.Dispose();
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeResults.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_ModelType.Dispose();
                hv_Samples.Dispose();
                hv_AnomalyLabelExists.Dispose();
                hv_OCRLabelExists.Dispose();
                hv_ClassificationLabelExists.Dispose();
                hv_DetectionLabelExists.Dispose();
                hv_SegmentationLabelExists.Dispose();
                hv_XYZExists.Dispose();
                hv_OCRDetectionLabelExists.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLResult.Dispose();
                hv_ClassIdsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_BackGroundClass.Dispose();
                hv_RGB.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_KeyExists.Dispose();
                hv_DLDatasetPreprocessParam.Dispose();
                hv_NormType.Dispose();
                hv_KeyMinExists.Dispose();
                hv_KeyMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_Channels.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_TiledWidth.Dispose();
                hv_TiledHeight.Dispose();
                hv_NumResult.Dispose();
                hv_PredictionsCorrect.Dispose();
                hv_ImageConfidences.Dispose();
                hv_ResClassIndices.Dispose();
                hv_ResClasses.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_IndexResult.Dispose();
                hv_ImageConfidence.Dispose();
                hv_ResClassIndex.Dispose();
                hv_ResClass.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_PredictionCorrect.Dispose();
                hv_TextImageRows.Dispose();
                hv_TextImageColumns.Dispose();
                hv_TextImageWidth.Dispose();
                hv_TextImageHeight.Dispose();
                hv_TopOffset.Dispose();
                hv_InstanceType.Dispose();
                hv_Rect1KeyExists.Dispose();
                hv_Rect2KeyExists.Dispose();
                hv_MasksExist.Dispose();
                hv_GTLabel.Dispose();
                hv_GTCol1.Dispose();
                hv_GTRow1.Dispose();
                hv_GTCol2.Dispose();
                hv_GTRow2.Dispose();
                hv_GTCol.Dispose();
                hv_GTRow.Dispose();
                hv_GTLength1.Dispose();
                hv_GTLength2.Dispose();
                hv_GTPhi.Dispose();
                hv_LeftOffset.Dispose();
                hv_LabelId.Dispose();
                hv_Col1.Dispose();
                hv_Row1.Dispose();
                hv_Col2.Dispose();
                hv_Row2.Dispose();
                hv_Col.Dispose();
                hv_Row.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_Phi.Dispose();
                hv_ResConfidence.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol2.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol.Dispose();
                hv_ResRow.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv_CurrentResult.Dispose();
                hv_ClassId.Dispose();
                hv_Confidence.Dispose();
                hv_ResultMaskExists.Dispose();
                hv_ResWords.Dispose();
                hv_GTWord.Dispose();
                hv_ResWord.Dispose();
                hv_TiledDLSample.Dispose();
                hv_CharIndices.Dispose();
                hv_TiledDLResult.Dispose();
                hv_Words.Dispose();
                hv_DisplayGenParam.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_NoInputWindow.Dispose();
                hv_Flush.Dispose();
                hv_KeyForDisplay.Dispose();
                hv_GTText.Dispose();
                hv_PredictionText.Dispose();
                hv__.Dispose();
                hv_GTWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_PredictionWidth.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_WindowWidthMax.Dispose();
                hv_WindowHeightMax.Dispose();
                hv_Ratio.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageWindowWidthRatio.Dispose();
                hv_ImageWindowHeightRatio.Dispose();
                hv_CharWindowWidth.Dispose();
                hv_CharWindowHeight.Dispose();
                hv_CharImageWidth.Dispose();
                hv_CharImageHeight.Dispose();
                hv_ImageRow.Dispose();
                hv_ImageColumn.Dispose();
                hv_String.Dispose();
                hv_StringWindowWidth.Dispose();
                hv_StringImageWidth.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Display the ground truth anomaly regions of the given DLSample. 
        private void dev_display_ground_truth_anomaly_regions(HTuple hv_SampleKeys, HTuple hv_DLSample,
            HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor,
            HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_AnomalyRegion = null;

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyRegionExists = new HTuple();
            try
            {
                //
                //This procedure visualizes the ground truth anomalies
                //if there is an anomaly_ground_truth in DLSample.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
                    -1))) != 0)
                {
                    ho_AnomalyImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
                    //Get non-empty regions.
                    hv_Area.Dispose();
                    HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                    if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor + hv_AnomalyColorTransparency);
                            }
                        }
                        //Display the anomaly region.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                        }
                    }
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "true";
                }
                else
                {
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "false";
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth bounding boxes of DLSample. 
        private void dev_display_ground_truth_detection(HTuple hv_DLSample, HTuple hv_SampleKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor,
            HTuple hv_WindowImageRatio, HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection,
            HTuple hv_WindowHandle, out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_InstanceMask = null, ho_BboxRectangle = null;
            HObject ho_OrientationArrows = null, ho_RectangleSelected = null;
            HObject ho_MaskSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_MaskExists = new HTuple();
            HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
            HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_BboxLabels = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv__ = new HTuple();
            HTuple hv_TextOffset = new HTuple(), hv_LabelRow = new HTuple();
            HTuple hv_LabelCol = new HTuple(), hv_ArrowSizeFactorLength = new HTuple();
            HTuple hv_ArrowSizeFactorHead = new HTuple(), hv_MaxLengthArrow = new HTuple();
            HTuple hv_HalfLengthArrow = new HTuple(), hv_ArrowBaseRow = new HTuple();
            HTuple hv_ArrowBaseCol = new HTuple(), hv_ArrowHeadRow = new HTuple();
            HTuple hv_ArrowHeadCol = new HTuple(), hv_ArrowHeadSize = new HTuple();
            HTuple hv_ContourStyle = new HTuple(), hv_Style = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_TextColorClasses = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_InstanceMask);
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_MaskSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth bounding boxes and masks (if present) of a DLSample.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "";
                hv_MaskExists.Dispose();
                hv_MaskExists = 0;
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle1";
                }
                else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
                }
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("mask"))).TupleNotEqual(-1))) != 0)
                {
                    ho_InstanceMask.Dispose();
                    HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLSample, "mask");
                    hv_MaskExists.Dispose();
                    hv_MaskExists = 1;
                }
                if ((int)((new HTuple((new HTuple(hv_InstanceType.TupleNotEqual("rectangle1"))).TupleAnd(
                    new HTuple(hv_InstanceType.TupleNotEqual("rectangle2"))))).TupleAnd(hv_MaskExists.TupleNot()
                    )) != 0)
                {
                    throw new HalconException("Ground truth bounding box or mask data could not be found in DLSample.");
                }
                hv_BboxLabels.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //
                    //Get text and text size for correct positioning of label IDs.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        hv_Text.Dispose();
                        hv_Text = new HTuple(hv_BboxLabels);
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_TextOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextOffset = (hv_Ascent + hv_Descent) / hv_WindowImageRatio;
                        }
                    }
                    //
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRow.Dispose();
                            hv_LabelRow = new HTuple(hv_BboxRow1);
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol1);
                        }
                    }
                    else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRow = hv_BboxRow - hv_TextOffset;
                            }
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol);
                        }
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            if ((int)(new HTuple(hv_ShowDirection.TupleEqual(-1))) != 0)
                            {
                                hv_ArrowSizeFactorLength.Dispose();
                                hv_ArrowSizeFactorLength = 0.4;
                                hv_ArrowSizeFactorHead.Dispose();
                                hv_ArrowSizeFactorHead = 0.2;
                                hv_MaxLengthArrow.Dispose();
                                hv_MaxLengthArrow = 20;
                                hv_HalfLengthArrow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(
                                        hv_BboxLength1 * hv_ArrowSizeFactorLength);
                                }
                                hv_ArrowBaseRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowBaseRow = hv_BboxRow - ((hv_BboxLength1 - hv_HalfLengthArrow) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowBaseCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowBaseCol = hv_BboxCol + ((hv_BboxLength1 - hv_HalfLengthArrow) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                                hv_ArrowHeadRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadRow = hv_BboxRow - ((hv_BboxLength1 + hv_HalfLengthArrow) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowHeadCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadCol = hv_BboxCol + ((hv_BboxLength1 + hv_HalfLengthArrow) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                                hv_ArrowHeadSize.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(
                                        hv_BboxLength1.TupleMin2(hv_BboxLength2))) * hv_ArrowSizeFactorHead;
                                }
                            }
                            else
                            {
                                hv_ArrowHeadSize.Dispose();
                                hv_ArrowHeadSize = 20.0;
                                hv_ArrowBaseRow.Dispose();
                                hv_ArrowBaseRow = new HTuple(hv_BboxRow);
                                hv_ArrowBaseCol.Dispose();
                                hv_ArrowBaseCol = new HTuple(hv_BboxCol);
                                hv_ArrowHeadRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadRow = hv_BboxRow - ((hv_BboxLength1 + hv_ArrowHeadSize) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowHeadCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadCol = hv_BboxCol + ((hv_BboxLength1 + hv_ArrowHeadSize) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                            }
                            ho_OrientationArrows.Dispose();
                            gen_arrow_contour_xld(out ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol,
                                hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
                        }
                    }
                    else if ((int)(hv_MaskExists) != 0)
                    {
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv__.Dispose(); hv_LabelRow.Dispose(); hv_LabelCol.Dispose();
                            HOperatorSet.AreaCenter(ho_InstanceMask, out hv__, out hv_LabelRow, out hv_LabelCol);
                        }
                    }
                    else
                    {
                        throw new HalconException("Unknown instance_type: " + hv_InstanceType);
                    }
                    //
                    //Collect the ClassIDs of the bounding boxes.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BboxIDs.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_BboxLabels.TupleLength()), 0, out hv_BboxIDs);
                    }
                    //
                    //Draw the bounding boxes.
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxLabels.TupleSelect(hv_IndexBbox));
                        }
                        if (hv_BboxIDs == null)
                            hv_BboxIDs = new HTuple();
                        hv_BboxIDs[hv_IndexBbox] = hv_ClassID;
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                    hv_ClassID)) + "60");
                            }
                        }
                        if ((int)(hv_MaskExists) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_MaskSelected.Dispose();
                                HOperatorSet.SelectObj(ho_InstanceMask, out ho_MaskSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_MaskSelected, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
                            }
                        }
                        if ((int)(new HTuple(hv_InstanceType.TupleNotEqual(""))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_RectangleSelected.Dispose();
                                HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                    );
                            }
                            if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                                hv_ShowDirection)) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ArrowSelected.Dispose();
                                    HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected,
                                        hv_IndexBbox + 1);
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                            hv_ClassID)) + "FF");
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive()
                                        );
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                            hv_ClassID)) + "60");
                                    }
                                }
                            }
                        }
                    }
                    //
                    //Write text to the bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        //Select text color.
                        if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                        {
                            hv_TextColorClasses.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses = hv_BboxColors.TupleSelect(
                                    hv_BboxIDs);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_BboxIDs.TupleLength()), hv_TextColor,
                                    out hv_TextColorClasses);
                            }
                        }
                        //Display text.
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels, "image",
                                    hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                                    "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                                    (new HTuple("false")).TupleConcat(0)));
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if there are no ground truth bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_InstanceMask.Dispose();
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_MaskSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_MaskExists.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_BboxLabels.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_ArrowSizeFactorLength.Dispose();
                hv_ArrowSizeFactorHead.Dispose();
                hv_MaxLengthArrow.Dispose();
                hv_HalfLengthArrow.Dispose();
                hv_ArrowBaseRow.Dispose();
                hv_ArrowBaseCol.Dispose();
                hv_ArrowHeadRow.Dispose();
                hv_ArrowHeadCol.Dispose();
                hv_ArrowHeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TextColorClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_InstanceMask.Dispose();
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_MaskSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_MaskExists.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_BboxLabels.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_ArrowSizeFactorLength.Dispose();
                hv_ArrowSizeFactorHead.Dispose();
                hv_MaxLengthArrow.Dispose();
                hv_HalfLengthArrow.Dispose();
                hv_ArrowBaseRow.Dispose();
                hv_ArrowBaseCol.Dispose();
                hv_ArrowHeadRow.Dispose();
                hv_ArrowHeadCol.Dispose();
                hv_ArrowHeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TextColorClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize the visualization of the training progress. This includes setting default values for visualization parameters. 
        private void dev_display_init_train_dl_model(HTuple hv_DLModelHandle, HTuple hv_TrainParam,
            out HTuple hv_DisplayData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_DisplayParam = new HTuple();
            HTuple hv_DisplayEnabled = new HTuple(), hv_UpdateImagesIntervalEpochs = new HTuple();
            HTuple hv_NumImagesPreview = new HTuple(), hv_ChangePlotIntervalSeconds = new HTuple();
            HTuple hv_SelectedPercentageTrainSamples = new HTuple();
            HTuple hv_XAxisLabel = new HTuple(), hv_DisplayParamNames = new HTuple();
            HTuple hv_DisplayDefaultValues = new HTuple(), hv_Index = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_DisplayIntervalSeconds = new HTuple();
            HTuple hv_Time = new HTuple(), hv_StatusModelParamNames = new HTuple();
            HTuple hv_WindowTextWidth = new HTuple(), hv_WindowTextHeight = new HTuple();
            HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesHeight = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            HTuple hv_WindowImagesRow = new HTuple(), hv_WindowImagesCol = new HTuple();
            HTuple hv_TiledParam = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_TiledParamNames = new HTuple(), hv_TiledDefaultValues = new HTuple();
            // Initialize local and output iconic variables 
            hv_DisplayData = new HTuple();
            try
            {
                //
                //This procedure initializes the visualization of the training progress.
                //This includes setting default values for visualization parameters.
                //
                //Get the actual model type.
                if ((int)(new HTuple(hv_DLModelHandle.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                }
                else
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "type", out hv_ModelType);
                }
                //
                //Initialize display data.
                hv_DisplayData.Dispose();
                HOperatorSet.CreateDict(out hv_DisplayData);
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                HOperatorSet.SetDictTuple(hv_DisplayData, "display_param", hv_DisplayParam);
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
                HOperatorSet.SetDictTuple(hv_DisplayData, "enabled", hv_DisplayEnabled);
                //
                //Set default values if not set by the user.
                //
                //Default interval (in epochs) for the preview update
                //depending on the model type.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_UpdateImagesIntervalEpochs = 4;
                }
                else
                {
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_UpdateImagesIntervalEpochs = 0.5;
                }
                //
                //Default number of images to display in the images preview.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 6;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 2;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                {
                    //No images are displayed in case of
                    //model type 'gc_anomaly_detection'.
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 0;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 2;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 12;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 4;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 4;
                }
                //
                //Default interval (in seconds) to switch between plots.
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_ChangePlotIntervalSeconds = 10;
                //
                //Default percentage of images that is used for evaluation on training set.
                //If set to zero no evaluation on training set is done.
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_SelectedPercentageTrainSamples = 0;
                //
                //Default x_axis_label: Show 'iterations' or 'epochs' as x-values in plots.
                hv_XAxisLabel.Dispose();
                hv_XAxisLabel = "epochs";
                //
                //Collect all display params and overwrite if user values are given.
                //Note, some parameters are also used for the evaluation.
                //Thus, write its value even for DisplayEnabled = false.
                hv_DisplayParamNames.Dispose();
                hv_DisplayParamNames = new HTuple();
                hv_DisplayParamNames[0] = "change_plot_interval_seconds";
                hv_DisplayParamNames[1] = "num_images";
                hv_DisplayParamNames[2] = "selected_percentage_train_samples";
                hv_DisplayParamNames[3] = "update_images_interval_epochs";
                hv_DisplayParamNames[4] = "x_axis_label";
                hv_DisplayDefaultValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DisplayDefaultValues = new HTuple();
                    hv_DisplayDefaultValues = hv_DisplayDefaultValues.TupleConcat(hv_ChangePlotIntervalSeconds, hv_NumImagesPreview, hv_SelectedPercentageTrainSamples, hv_UpdateImagesIntervalEpochs, hv_XAxisLabel);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DisplayParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DisplayParam, "key_exists", hv_DisplayParamNames.TupleSelect(
                            hv_Index), out hv_KeyExists);
                    }
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DisplayParam, hv_DisplayParamNames.TupleSelect(
                                hv_Index), hv_DisplayDefaultValues.TupleSelect(hv_Index));
                        }
                    }
                }
                //
                //Set last_update, which is needed to determine when updates are needed.
                hv_DisplayIntervalSeconds.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_DisplayIntervalSeconds);
                hv_Time.Dispose();
                HOperatorSet.CountSeconds(out hv_Time);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Time - (hv_DisplayIntervalSeconds * 2));
                }
                //
                //Some entries in DisplayParam are also needed in case of disabled display.
                //They are all set yet.
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {

                    hv_ModelType.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_NumImagesPreview.Dispose();
                    hv_ChangePlotIntervalSeconds.Dispose();
                    hv_SelectedPercentageTrainSamples.Dispose();
                    hv_XAxisLabel.Dispose();
                    hv_DisplayParamNames.Dispose();
                    hv_DisplayDefaultValues.Dispose();
                    hv_Index.Dispose();
                    hv_KeyExists.Dispose();
                    hv_DisplayIntervalSeconds.Dispose();
                    hv_Time.Dispose();
                    hv_StatusModelParamNames.Dispose();
                    hv_WindowTextWidth.Dispose();
                    hv_WindowTextHeight.Dispose();
                    hv_WindowImagesWidth.Dispose();
                    hv_WindowImagesHeight.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_WindowImagesRow.Dispose();
                    hv_WindowImagesCol.Dispose();
                    hv_TiledParam.Dispose();
                    hv_Exception.Dispose();
                    hv_TiledParamNames.Dispose();
                    hv_TiledDefaultValues.Dispose();

                    return;
                }
                //
                //Separate handling for parameters that are specified by tuples.
                //
                //These model parameters are displayed in the text window if available.
                hv_StatusModelParamNames.Dispose();
                hv_StatusModelParamNames = new HTuple();
                hv_StatusModelParamNames[0] = "learning_rate";
                hv_StatusModelParamNames[1] = "batch_size";
                hv_StatusModelParamNames[2] = "batch_size_multiplier";
                hv_StatusModelParamNames[3] = "momentum";
                hv_StatusModelParamNames[4] = "weight_prior";
                hv_StatusModelParamNames[5] = "image_dimensions";
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayParam, "key_exists", "status_model_params",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleNot()) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "status_model_params", hv_StatusModelParamNames);
                }
                //
                //
                //Setup and open text window.
                hv_WindowTextWidth.Dispose();
                hv_WindowTextWidth = 700;
                hv_WindowTextHeight.Dispose();
                hv_WindowTextHeight = 750;
                hv_WindowImagesWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImagesWidth = 1200 - hv_WindowTextWidth;
                }
                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesHeight = new HTuple(hv_WindowTextHeight);
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "light gray";
                //
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowTextWidth, hv_WindowTextHeight, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_width", hv_WindowTextWidth);
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_height", hv_WindowTextHeight);
                //
                //Configure images window, which is opened later by another procedure.
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesRow = 0;
                hv_WindowImagesCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImagesCol = hv_WindowTextWidth + 10;
                }
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", new HTuple());
                //
                //Set user specified parameters used for the display of tiled images.
                try
                {
                    hv_TiledParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayParam, "tiled_param", out hv_TiledParam);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_TiledParam.Dispose();
                    HOperatorSet.CreateDict(out hv_TiledParam);
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "tiled_param", hv_TiledParam);
                }
                //
                //Only set values if they are not already given.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    hv_WindowImagesHeight.Dispose();
                    hv_WindowImagesHeight = 500;
                }
                hv_TiledParamNames.Dispose();
                hv_TiledParamNames = new HTuple();
                hv_TiledParamNames[0] = "window_row";
                hv_TiledParamNames[1] = "window_col";
                hv_TiledParamNames[2] = "window_width";
                hv_TiledParamNames[3] = "window_height";
                hv_TiledDefaultValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledDefaultValues = new HTuple();
                    hv_TiledDefaultValues = hv_TiledDefaultValues.TupleConcat(hv_WindowImagesRow, hv_WindowImagesCol, hv_WindowImagesWidth, hv_WindowImagesHeight);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TiledParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_TiledParam, "key_exists", hv_TiledParamNames.TupleSelect(
                            hv_Index), out hv_KeyExists);
                    }
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_TiledParam, hv_TiledParamNames.TupleSelect(
                                hv_Index), hv_TiledDefaultValues.TupleSelect(hv_Index));
                        }
                    }
                }
                //
                //Set specific display parameters for all available model types.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_input", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_ground_truth", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_legend", 0);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_input", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_ground_truth", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_legend", 0);
                }
                //
                //
                //Start with loss plot since usually no evaluation is available in the beginning.
                HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Time);
                HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", 0);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //

                hv_ModelType.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_NumImagesPreview.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_XAxisLabel.Dispose();
                hv_DisplayParamNames.Dispose();
                hv_DisplayDefaultValues.Dispose();
                hv_Index.Dispose();
                hv_KeyExists.Dispose();
                hv_DisplayIntervalSeconds.Dispose();
                hv_Time.Dispose();
                hv_StatusModelParamNames.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesCol.Dispose();
                hv_TiledParam.Dispose();
                hv_Exception.Dispose();
                hv_TiledParamNames.Dispose();
                hv_TiledDefaultValues.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_NumImagesPreview.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_XAxisLabel.Dispose();
                hv_DisplayParamNames.Dispose();
                hv_DisplayDefaultValues.Dispose();
                hv_Index.Dispose();
                hv_KeyExists.Dispose();
                hv_DisplayIntervalSeconds.Dispose();
                hv_Time.Dispose();
                hv_StatusModelParamNames.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesCol.Dispose();
                hv_TiledParam.Dispose();
                hv_Exception.Dispose();
                hv_TiledParamNames.Dispose();
                hv_TiledDefaultValues.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a color bar next to an image. 
        private void dev_display_map_color_bar(HTuple hv_ImageWidth, HTuple hv_ImageHeight,
            HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio,
            HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            HObject ho_Rectangle = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
            HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //
                //This procedure displays a color bar next to the image
                //specified with ImageWidth and ImageHeight.
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                HOperatorSet.SetSystem("clip_region", "false");
                //
                //Display the color bar.
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                hv_RectHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RectHeight = (1.0 * hv_ImageHeight) / (new HTuple(hv_Colors.TupleLength()
                        ));
                }
                //Set draw mode to fill
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                }
                HTuple end_val13 = 0;
                HTuple step_val13 = -hv_RectHeight;
                for (hv_Row = hv_ImageHeight - 1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
                {
                    //The color bar consists of multiple rectangle1.
                    hv_Row1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row1 = hv_Row - hv_RectHeight;
                    }
                    hv_Column1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column1 = hv_ImageWidth + (20 / hv_WindowImageRatio);
                    }
                    hv_Row2.Dispose();
                    hv_Row2 = new HTuple(hv_Row);
                    hv_Column2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column2 = (hv_ImageWidth + 20) + (hv_MapColorBarWidth / hv_WindowImageRatio);
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2,
                        hv_Column2);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColorIndex = hv_ColorIndex + 1;
                            hv_ColorIndex.Dispose();
                            hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
                        }
                    }
                }
                //
                //Display labels for color bar.
                hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_TextHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__,
                    out hv__, out hv_TextHeight);
                for (hv_Index = (double)(0); (double)hv_Index <= 1; hv_Index = (double)hv_Index + 0.2)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = ((hv_MaxValue - (hv_Index * hv_MaxValue))).TupleString(
                            ".1f");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index * (hv_ImageHeight - (2 * (hv_TextHeight / hv_WindowImageRatio))),
                                hv_ImageWidth + (40 / hv_WindowImageRatio), "black", "box", "false");
                        }
                    }
                }
                //
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a matrix inside a window 
        private void dev_display_matrix(HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames,
            HTuple hv_WindowHandle, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_IdxsNoDisplay = new HTuple(), hv_ValueColors = new HTuple();
            HTuple hv_NumberFormat = new HTuple(), hv_TitleExists = new HTuple();
            HTuple hv_Title = new HTuple(), hv_SubtitleExists = new HTuple();
            HTuple hv_Subtitle = new HTuple(), hv_AxisTitlesExists = new HTuple();
            HTuple hv_AxisTitles = new HTuple(), hv_AxisColor = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_ValueTmp = new HTuple(), hv_ColStringWidths = new HTuple();
            HTuple hv_AllNames = new HTuple(), hv_MaxStringWidth = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_RowSeparator = new HTuple(), hv_RowStart = new HTuple();
            HTuple hv_TitleHeight = new HTuple(), hv_TitleWidth = new HTuple();
            HTuple hv_SubtitleHeight = new HTuple(), hv_SubtitleWidth = new HTuple();
            HTuple hv_AxisTitleHeight = new HTuple(), hv_TitleAscent = new HTuple();
            HTuple hv_TitleDescent = new HTuple(), hv_TitleRowStart = new HTuple();
            HTuple hv_SubtitleAscent = new HTuple(), hv_SubtitleDescent = new HTuple();
            HTuple hv_SubtitleRowStart = new HTuple(), hv_AxisTitleAscent = new HTuple();
            HTuple hv_AxisTitleDescent = new HTuple(), hv_AxisTitleWidth = new HTuple();
            HTuple hv_AxisTitleRowStart = new HTuple(), hv_LabelRowStart = new HTuple();
            HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
            HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
            HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TextColumn = new HTuple(), hv_RowStartTmp = new HTuple();
            HTuple hv_ColumnDistance = new HTuple(), hv_Index = new HTuple();
            HTuple hv_MatrixText = new HTuple(), hv_IdxsDisplay = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //Display a matrix in a window.
                //
                //GenParam (all are optional):
                //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
                //                          that equals the width of the longest row or column-name.
                //  - display_color:        If true, the values will be displayed with the colors that are given by
                //                          'value_colors'.
                //                          Else, all values are displayed in white.
                //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
                //                          given in row-major order, according to get_full_matrix. If not given or if
                //                          set to an empty tuple, all matrix values are displayed.
                //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
                //                          and bottom-left of the matrix, respectively. Should be a tuple of length
                //                          two or an empty tuple if no axis titles should be displayed.
                //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
                //                          single value is given, this color is used for all values, else it must have
                //                          the length of the number of values in the matrix. Is ignored if
                //                          display_color is false.
                //  - number_format:        Format of the numbers when they are converted to strings for display.
                //                          Default: 2.0f
                //  - title:                Title of the displayed matrix, if given shown in the top-left.
                //  - subtitle:             Subtitle of the displayed matrix, if given shown beyond the title.
                //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
                //
                //
                //Get the matrix dimensions.
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_Matrix, out hv_NumRows, out hv_NumColumns);
                //Set defaults parameters.
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 0;
                hv_IdxsNoDisplay.Dispose();
                hv_IdxsNoDisplay = new HTuple();
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        hv_NumRows * hv_NumColumns, "white");
                }
                hv_NumberFormat.Dispose();
                hv_NumberFormat = "2.0f";
                hv_TitleExists.Dispose();
                hv_TitleExists = 0;
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_SubtitleExists.Dispose();
                hv_SubtitleExists = 0;
                hv_Subtitle.Dispose();
                hv_Subtitle = new HTuple();
                hv_AxisTitlesExists.Dispose();
                hv_AxisTitlesExists = 0;
                hv_AxisTitles.Dispose();
                hv_AxisTitles = new HTuple();
                hv_AxisColor.Dispose();
                hv_AxisColor = "light gray";
                //Get parameters and overwrite
                //
                hv_GenParamKeys.Dispose();
                hv_GenParamKeys = new HTuple();
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                }
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    //DisplayColumnWidth.
                    if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_column_width"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_ValueTmp);
                        }
                        //DisplayColor.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_color"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            hv_DisplayColor.Dispose();
                            hv_DisplayColor = new HTuple(hv_ValueTmp);
                        }
                        //ValueIdxsNoDisplay.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "idxs_no_display"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "idxs_no_display", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(((hv_ValueTmp.TupleMin()
                                )).TupleLess(0))).TupleOr(new HTuple(((hv_ValueTmp.TupleMax())).TupleGreater(
                                (hv_NumRows * hv_NumColumns) - 1))))).TupleOr(((hv_ValueTmp.TupleIsInt()
                                )).TupleNot()))).TupleOr(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleGreater(hv_NumRows * hv_NumColumns)))) != 0)
                            {
                                throw new HalconException("Invalid value for 'idxs_no_display'");
                            }
                            hv_IdxsNoDisplay.Dispose();
                            hv_IdxsNoDisplay = new HTuple(hv_ValueTmp);
                        }
                        //ValueColors.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "value_colors"))) != 0)
                    {
                        if ((int)(hv_DisplayColor) != 0)
                        {
                            hv_ValueTmp.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "value_colors", out hv_ValueTmp);
                            if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)((new HTuple((new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                    )).TupleNotEqual(hv_NumColumns * hv_NumRows))).TupleAnd(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                    )).TupleNotEqual(1))))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot()
                                    )) != 0)
                                {
                                    throw new HalconException("Invalid value for 'value_colors'");
                                }
                                if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleEqual(
                                    1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_ValueTmp = HTuple.TupleGenConst(
                                                hv_NumRows * hv_NumColumns, hv_ValueTmp);
                                            hv_ValueTmp.Dispose();
                                            hv_ValueTmp = ExpTmpLocalVar_ValueTmp;
                                        }
                                    }
                                }
                                hv_ValueColors.Dispose();
                                hv_ValueColors = new HTuple(hv_ValueTmp);
                            }
                        }
                        //NumberFormat.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "number_format"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "number_format", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'number_format'");
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = new HTuple(hv_ValueTmp);
                        }
                        //Title.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "title"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'title'");
                        }
                        else
                        {
                            hv_TitleExists.Dispose();
                            hv_TitleExists = 1;
                            hv_Title.Dispose();
                            hv_Title = new HTuple(hv_ValueTmp);
                        }
                        //Subtitle.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "subtitle"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "subtitle", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'subtitle'");
                        }
                        else
                        {
                            hv_SubtitleExists.Dispose();
                            hv_SubtitleExists = 1;
                            hv_Subtitle.Dispose();
                            hv_Subtitle = new HTuple(hv_ValueTmp);
                        }
                        //AxisTitles.
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_titles"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "axis_titles", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                                2))).TupleOr(new HTuple(((hv_ValueTmp.TupleIsStringElem())).TupleNotEqual(
                                HTuple.TupleGenConst(new HTuple(hv_ValueTmp.TupleLength()), 1))))) != 0)
                            {
                                throw new HalconException("Invalid value for 'axis_titles'");
                            }
                            hv_AxisTitlesExists.Dispose();
                            hv_AxisTitlesExists = 1;
                            hv_AxisTitles.Dispose();
                            hv_AxisTitles = new HTuple(hv_ValueTmp);
                        }
                        //Color for row and column names
                    }
                    else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "row_col_names_color"))) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "row_col_names_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'row_col_names_color'");
                        }
                        else
                        {
                            hv_AxisColor.Dispose();
                            hv_AxisColor = new HTuple(hv_ValueTmp);
                        }
                    }
                }
                //
                //Calculate the width of row and column-name-strings.
                hv_ColStringWidths.Dispose();
                hv_ColStringWidths = new HTuple();
                hv_AllNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllNames = new HTuple();
                    hv_AllNames = hv_AllNames.TupleConcat(hv_ColumnNames, hv_RowNames);
                }
                hv_MaxStringWidth.Dispose();
                hv_MaxStringWidth = 0;
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_AllNames.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    hv_String.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_String = hv_AllNames.TupleSelect(
                            hv_StringIndex);
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                        out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                    if ((int)(new HTuple(hv_StringIndex.TupleLess(new HTuple(hv_ColumnNames.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_ColStringWidths.Dispose();
                                hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                                hv_StringWidth);
                            hv_MaxStringWidth.Dispose();
                            hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                        }
                    }
                }
                //The columns should have a minimum width for 4 characters.
                hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                    out hv_StringWidth, out hv_StringHeight);
                //Update the maximum string width.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                            hv_StringWidth);
                        hv_MaxStringWidth.Dispose();
                        hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                    }
                }
                //
                //Set parameters for nice display, e.g., distances from window border, row- and column-offsets,
                //axis titles and title.
                //Begin
                //Title
                //Subtitle
                //                   AxisLabel
                //         Class 1     Class n
                //Label 1  a(1,1) ...  a(1,n)
                //                ...
                //Label m  a(m,1) ...  a(m,n)
                //End
                //Thereby entries are vertically separated by RowSeparator
                hv_RowSeparator.Dispose();
                hv_RowSeparator = 10;
                hv_RowStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowStart = hv_StringHeight + hv_RowSeparator;
                }
                hv_TitleHeight.Dispose();
                hv_TitleHeight = 0;
                hv_TitleWidth.Dispose();
                hv_TitleWidth = 0;
                hv_SubtitleHeight.Dispose();
                hv_SubtitleHeight = 0;
                hv_SubtitleWidth.Dispose();
                hv_SubtitleWidth = 0;
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleHeight = 0;
                if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                        out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                    hv_TitleRowStart.Dispose();
                    hv_TitleRowStart = new HTuple(hv_RowStart);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStart = (hv_RowStart + hv_TitleHeight) + hv_RowSeparator;
                            hv_RowStart.Dispose();
                            hv_RowStart = ExpTmpLocalVar_RowStart;
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_Subtitle.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_SubtitleAscent.Dispose(); hv_SubtitleDescent.Dispose(); hv_SubtitleWidth.Dispose(); hv_SubtitleHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Subtitle, out hv_SubtitleAscent,
                        out hv_SubtitleDescent, out hv_SubtitleWidth, out hv_SubtitleHeight);
                    hv_SubtitleRowStart.Dispose();
                    hv_SubtitleRowStart = new HTuple(hv_RowStart);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStart = (hv_RowStart + hv_SubtitleHeight) + hv_RowSeparator;
                            hv_RowStart.Dispose();
                            hv_RowStart = ExpTmpLocalVar_RowStart;
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_RowStart = (hv_RowStart + hv_StringHeight) + hv_RowSeparator;
                        hv_RowStart.Dispose();
                        hv_RowStart = ExpTmpLocalVar_RowStart;
                    }
                }
                if ((int)(new HTuple(hv_AxisTitles.TupleLength())) != 0)
                {
                    hv_AxisTitleAscent.Dispose(); hv_AxisTitleDescent.Dispose(); hv_AxisTitleWidth.Dispose(); hv_AxisTitleHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_AxisTitles, out hv_AxisTitleAscent,
                        out hv_AxisTitleDescent, out hv_AxisTitleWidth, out hv_AxisTitleHeight);
                    hv_AxisTitleRowStart.Dispose();
                    hv_AxisTitleRowStart = new HTuple(hv_RowStart);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStart = (hv_RowStart + hv_AxisTitleHeight) + hv_RowSeparator;
                            hv_RowStart.Dispose();
                            hv_RowStart = ExpTmpLocalVar_RowStart;
                        }
                    }
                }
                //Add space for label names
                hv_LabelRowStart.Dispose();
                hv_LabelRowStart = new HTuple(hv_RowStart);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_RowStart = (hv_RowStart + hv_StringHeight) + hv_RowSeparator;
                        hv_RowStart.Dispose();
                        hv_RowStart = ExpTmpLocalVar_RowStart;
                    }
                }
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + hv_RowSeparator;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = (hv_StringHeight * 2) + (hv_RowSeparator * 2);
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 30;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_ColStringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumColumns)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumColumns) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                //Make sure, window is large enough for the title / subtitle:
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Width = hv_Width.TupleMax2(
                            (hv_TitleWidth.TupleMax2(hv_SubtitleWidth)) + (2 * hv_ColumnOffset));
                        hv_Width.Dispose();
                        hv_Width = ExpTmpLocalVar_Width;
                    }
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumRows) + hv_RowStart) + hv_RowEnd;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
                }
                hv_HeightLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
                }
                dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                //
                //Calculate row and column coordinates for display of values.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                hv_RowStartTmp.Dispose();
                hv_RowStartTmp = 0;
                hv_ColumnDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnDistance = new HTuple();
                    hv_ColumnDistance[0] = 0;
                    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
                        0, hv_NumColumns - 2)) + hv_ColumnOffset)).TupleCumul());
                }
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    hv_ColumnDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnDistance = HTuple.TupleGenSequence(
                            0, hv_NumColumns - 1, 1) * (hv_MaxStringWidth + hv_ColumnOffset);
                    }
                }
                HTuple end_val224 = hv_NumRows - 1;
                HTuple step_val224 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val224, step_val224); hv_Index = hv_Index.TupleAdd(step_val224))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenConst(hv_NumColumns, hv_RowStartTmp));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp + hv_RowDistance;
                            hv_RowStartTmp.Dispose();
                            hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                hv_ColumnDistance);
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top and left.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn + hv_ColumnStart;
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //
                //Display title.
                if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "window",
                            hv_TitleRowStart, "left", "white", "box", "false");
                    }
                }
                //Display subtitle.
                if ((int)(new HTuple((new HTuple(hv_Subtitle.TupleLength())).TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Subtitle, "window",
                            hv_SubtitleRowStart, "left", "white", "box", "false");
                    }
                }
                //Display axis.
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", hv_AxisTitleRowStart, "right", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", ((hv_TextRow.TupleMax()) + hv_StringHeight) + hv_RowSeparator,
                                "left", "white", "box", "false");
                        }
                    }
                }
                //
                //Display row names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                            hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                            hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                            0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                    }
                }
                //
                //Display column names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                            HTuple.TupleGenConst(hv_NumColumns, hv_LabelRowStart), hv_TextColumn.TupleSelectRange(
                            0, hv_NumColumns - 1), hv_AxisColor, "box", "false");
                    }
                }
                //
                //
                //Align the numbers right.
                hv_MatrixText.Dispose();
                HOperatorSet.GetFullMatrix(hv_Matrix, out hv_MatrixText);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                            hv_NumberFormat);
                        hv_MatrixText.Dispose();
                        hv_MatrixText = ExpTmpLocalVar_MatrixText;
                    }
                }
                //
                //
                //Handle no-display indices.
                hv_IdxsDisplay.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IdxsDisplay = (HTuple.TupleGenSequence(
                        0, (new HTuple(hv_MatrixText.TupleLength())) - 1, 1)).TupleDifference(hv_IdxsNoDisplay);
                }
                //
                //Display confusion matrix.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                            hv_IdxsDisplay), "window", hv_TextRow.TupleSelect(hv_IdxsDisplay), hv_TextColumn.TupleSelect(
                            hv_IdxsDisplay), hv_ValueColors.TupleSelect(hv_IdxsDisplay), "box", "false");
                    }
                }

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_TitleExists.Dispose();
                hv_Title.Dispose();
                hv_SubtitleExists.Dispose();
                hv_Subtitle.Dispose();
                hv_AxisTitlesExists.Dispose();
                hv_AxisTitles.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_RowSeparator.Dispose();
                hv_RowStart.Dispose();
                hv_TitleHeight.Dispose();
                hv_TitleWidth.Dispose();
                hv_SubtitleHeight.Dispose();
                hv_SubtitleWidth.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleRowStart.Dispose();
                hv_SubtitleAscent.Dispose();
                hv_SubtitleDescent.Dispose();
                hv_SubtitleRowStart.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_AxisTitleRowStart.Dispose();
                hv_LabelRowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_TitleExists.Dispose();
                hv_Title.Dispose();
                hv_SubtitleExists.Dispose();
                hv_Subtitle.Dispose();
                hv_AxisTitlesExists.Dispose();
                hv_AxisTitles.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_RowSeparator.Dispose();
                hv_RowStart.Dispose();
                hv_TitleHeight.Dispose();
                hv_TitleWidth.Dispose();
                hv_SubtitleHeight.Dispose();
                hv_SubtitleWidth.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleRowStart.Dispose();
                hv_SubtitleAscent.Dispose();
                hv_SubtitleDescent.Dispose();
                hv_SubtitleRowStart.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_AxisTitleRowStart.Dispose();
                hv_LabelRowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a pie chart inside a window. 
        public void dev_display_pie_chart(HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row,
            HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Sectors, ho_Arc = null, ho_Sector = null;

            // Local control variables 

            HTuple hv_Tolerance = new HTuple(), hv_InitialWindowHandle = new HTuple();
            HTuple hv_NoInitialWindow = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_Alpha = new HTuple(), hv_InitialColor = new HTuple();
            HTuple hv_IndexColor = new HTuple(), hv_Color_RGBA = new HTuple();
            HTuple hv_Title = new HTuple(), hv_TitleColor = new HTuple();
            HTuple hv_Footnote = new HTuple(), hv_FootnoteColor = new HTuple();
            HTuple hv_TitleKeyExists = new HTuple(), hv_TitleColorKeyExists = new HTuple();
            HTuple hv_FootnoteKeyExists = new HTuple(), hv_FootnoteColorKeyExists = new HTuple();
            HTuple hv_GivenTitle = new HTuple(), hv_GivenTitleColor = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_GivenFootnote = new HTuple();
            HTuple hv_GivenFootnoteColor = new HTuple(), hv_FullCircleAngle = new HTuple();
            HTuple hv_StartAngle = new HTuple(), hv_DrawColors = new HTuple();
            HTuple hv_K = new HTuple(), hv_EndAngle = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv_ContourStyle = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple();
            HTuple hv_Colors_COPY_INP_TMP = new HTuple(hv_Colors);
            HTuple hv_Ratios_COPY_INP_TMP = new HTuple(hv_Ratios);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Sectors);
            HOperatorSet.GenEmptyObj(out ho_Arc);
            HOperatorSet.GenEmptyObj(out ho_Sector);
            try
            {
                //
                //Draw a pie-chart into the active window.
                //
                //Check input Ratios.
                if ((int)(new HTuple(((((hv_Ratios_COPY_INP_TMP.TupleLessElem(0.0))).TupleSum()
                    )).TupleGreater(0))) != 0)
                {
                    throw new HalconException("Values of parameter Ratios must be positive.");
                }
                hv_Tolerance.Dispose();
                hv_Tolerance = 0.1;
                if ((int)(new HTuple(((((1 - (hv_Ratios_COPY_INP_TMP.TupleSum()))).TupleAbs()
                    )).TupleGreaterEqual(hv_Tolerance))) != 0)
                {
                    throw new HalconException("Sum of Ratios differs too much from 1.");
                }
                //
                //Get current window handle.
                if (HDevWindowStack.IsOpen())
                {
                    hv_InitialWindowHandle = HDevWindowStack.GetActive();
                }
                //In case there is no open window, no initial values are to be reset.
                hv_NoInitialWindow.Dispose();
                hv_NoInitialWindow = 0;
                if ((int)(new HTuple(hv_InitialWindowHandle.TupleEqual(-1))) != 0)
                {
                    hv_NoInitialWindow.Dispose();
                    hv_NoInitialWindow = 1;
                }
                else
                {
                    //Get current set color.
                    hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                    HOperatorSet.GetRgba(hv_InitialWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                        out hv_Alpha);
                    hv_InitialColor.Dispose();
                    hv_InitialColor = new HTuple();
                    for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                        )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                    {
                        hv_Color_RGBA.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                                hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                                "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                                hv_IndexColor))).TupleString("2x"));
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                                "replace_all"), "0", out ExpTmpOutVar_0);
                            hv_Color_RGBA.Dispose();
                            hv_Color_RGBA = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                    hv_Color_RGBA);
                                hv_InitialColor.Dispose();
                                hv_InitialColor = ExpTmpLocalVar_InitialColor;
                            }
                        }
                    }
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                //
                //In case no segment colors are specified, generate random colors.
                if ((int)(new HTuple((new HTuple(hv_Colors_COPY_INP_TMP.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    //Generate random colors.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors_COPY_INP_TMP.Dispose();
                        get_distinct_colors_dev_display_pie_chart(new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                            ), 1, 0, 220, out hv_Colors_COPY_INP_TMP);
                    }
                }
                //
                //Set default parameters.
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_TitleColor.Dispose();
                hv_TitleColor = "white";
                hv_Footnote.Dispose();
                hv_Footnote = new HTuple();
                hv_FootnoteColor.Dispose();
                hv_FootnoteColor = "white";
                //Get generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_TitleKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title", out hv_TitleKeyExists);
                    hv_TitleColorKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title_color", out hv_TitleColorKeyExists);
                    hv_FootnoteKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "footnote", out hv_FootnoteKeyExists);
                    hv_FootnoteColorKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "footnote_color", out hv_FootnoteColorKeyExists);
                    //
                    //Title text.
                    if ((int)(hv_TitleKeyExists) != 0)
                    {
                        hv_GivenTitle.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_GivenTitle);
                        if ((int)((new HTuple(((hv_GivenTitle.TupleIsString())).TupleNot())).TupleOr(
                            new HTuple(((hv_GivenTitle.TupleStrlen())).TupleLess(1)))) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title'");
                        }
                        hv_Title.Dispose();
                        hv_Title = new HTuple(hv_GivenTitle);
                    }
                    //Title color.
                    if ((int)(hv_TitleColorKeyExists) != 0)
                    {
                        hv_GivenTitleColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title_color", out hv_GivenTitleColor);
                        if ((int)(((hv_GivenTitleColor.TupleIsString())).TupleNot()) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        try
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GivenTitleColor);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        hv_TitleColor.Dispose();
                        hv_TitleColor = new HTuple(hv_GivenTitleColor);
                    }
                    //
                    //Footnote text.
                    if ((int)(hv_FootnoteKeyExists) != 0)
                    {
                        hv_GivenFootnote.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "footnote", out hv_GivenFootnote);
                        if ((int)((new HTuple(((hv_GivenFootnote.TupleIsString())).TupleNot())).TupleOr(
                            new HTuple(((hv_GivenFootnote.TupleStrlen())).TupleLess(1)))) != 0)
                        {
                            throw new HalconException("Invalid value for key 'footnote'");
                        }
                        hv_Footnote.Dispose();
                        hv_Footnote = new HTuple(hv_GivenFootnote);
                    }
                    //Footnote color.
                    if ((int)(hv_FootnoteColorKeyExists) != 0)
                    {
                        hv_GivenFootnoteColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "footnote_color", out hv_GivenFootnoteColor);
                        if ((int)(((hv_GivenFootnoteColor.TupleIsString())).TupleNot()) != 0)
                        {
                            throw new HalconException("Invalid value for key 'footnote_color'");
                        }
                        try
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GivenFootnoteColor);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid value for key 'footnote_color'");
                        }
                        hv_FootnoteColor.Dispose();
                        hv_FootnoteColor = new HTuple(hv_GivenFootnoteColor);
                    }
                }
                hv_FullCircleAngle.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FullCircleAngle = 2 * 3.14159;
                }
                hv_StartAngle.Dispose();
                hv_StartAngle = 0;
                //
                //Generate circle-sectors.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Ratios = hv_Ratios_COPY_INP_TMP / (hv_Ratios_COPY_INP_TMP.TupleSum()
                            );
                        hv_Ratios_COPY_INP_TMP.Dispose();
                        hv_Ratios_COPY_INP_TMP = ExpTmpLocalVar_Ratios;
                    }
                }
                hv_DrawColors.Dispose();
                hv_DrawColors = new HTuple();
                ho_Sectors.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Sectors);
                for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_K = (int)hv_K + 1)
                {
                    if ((int)(new HTuple(((hv_Ratios_COPY_INP_TMP.TupleSelect(hv_K))).TupleGreater(
                        0))) != 0)
                    {
                        hv_EndAngle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndAngle = hv_StartAngle + ((hv_Ratios_COPY_INP_TMP.TupleSelect(
                                hv_K)) * hv_FullCircleAngle);
                        }
                        ho_Arc.Dispose();
                        HOperatorSet.GenCircleContourXld(out ho_Arc, hv_Row, hv_Column, hv_Radius,
                            hv_StartAngle, hv_EndAngle, "positive", 1);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetContourXld(ho_Arc, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Sector.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_Sector, ((hv_Row.TupleConcat(hv_Rows))).TupleConcat(
                                hv_Row), ((hv_Column.TupleConcat(hv_Columns))).TupleConcat(hv_Column));
                        }
                        hv_StartAngle.Dispose();
                        hv_StartAngle = new HTuple(hv_EndAngle);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DrawColors = hv_DrawColors.TupleConcat(
                                    hv_Colors_COPY_INP_TMP.TupleSelect(hv_K));
                                hv_DrawColors.Dispose();
                                hv_DrawColors = ExpTmpLocalVar_DrawColors;
                            }
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Sectors, ho_Sector, out ExpTmpOutVar_0);
                            ho_Sectors.Dispose();
                            ho_Sectors = ExpTmpOutVar_0;
                        }
                    }
                }
                //Rotate 90 degrees such that the first sector starts at the top.
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25 * hv_FullCircleAngle, hv_Row,
                        hv_Column, out hv_HomMat2DRotate);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_Sectors, out ExpTmpOutVar_0, hv_HomMat2DRotate);
                    ho_Sectors.Dispose();
                    ho_Sectors = ExpTmpOutVar_0;
                }
                //
                //Display sectors.
                HDevWindowStack.SetActive(hv_WindowHandle);
                hv_ContourStyle.Dispose();
                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_DrawColors);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Sectors, HDevWindowStack.GetActive());
                }
                //(Optional) title.
                if ((int)(new HTuple(hv_Title.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_Ascent, out hv_Descent,
                        out hv_Width, out hv_Height);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", (((hv_Row - hv_Radius) - hv_Height) - hv_Ascent) - hv_Descent,
                                hv_Column - (hv_Width / 2), hv_TitleColor, "box", "false");
                        }
                    }
                }
                //(Optional) footnote.
                if ((int)(new HTuple(hv_Footnote.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Footnote, out hv_Ascent,
                        out hv_Descent, out hv_Width, out hv_Height);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Footnote, "image",
                                (((hv_Row + hv_Radius) - hv_Height) + hv_Ascent) + hv_Descent, hv_Column - (hv_Width / 2),
                                hv_FootnoteColor, "box", "false");
                        }
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                }
                //
                //Reset original window and colors (and close the window in case there was none open).
                if ((int)(hv_NoInitialWindow) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                else
                {
                    HDevWindowStack.SetActive(hv_InitialWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                    }
                }
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_Footnote.Dispose();
                hv_FootnoteColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_FootnoteKeyExists.Dispose();
                hv_FootnoteColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_GivenFootnote.Dispose();
                hv_GivenFootnoteColor.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_Footnote.Dispose();
                hv_FootnoteColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_FootnoteKeyExists.Dispose();
                hv_FootnoteColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_GivenFootnote.Dispose();
                hv_GivenFootnoteColor.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Display the detected anomaly regions. 
        private void dev_display_result_anomaly_regions(HObject ho_AnomalyRegion, HTuple hv_CurrentWindowHandle,
            HTuple hv_LineWidth, HTuple hv_AnomalyRegionResultColor)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays the result anomaly regions.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                //Display anomaly regions.
                //Get non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                //
                //Display all non-empty class regions in distinct colors.
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                    }
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display result bounding boxes. 
        private void dev_display_result_detection(HTuple hv_DLResult, HTuple hv_ResultKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors,
            HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxClassIndices)
        {



            // Local iconic variables 

            HObject ho_InstanceMask = null, ho_BboxRectangle = null;
            HObject ho_OrientationArrows = null, ho_MaskSelected = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_MaskExists = new HTuple();
            HTuple hv_BboxRow1 = new HTuple(), hv_BboxCol1 = new HTuple();
            HTuple hv_BboxRow2 = new HTuple(), hv_BboxCol2 = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_BboxClasses = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv__ = new HTuple();
            HTuple hv_TextOffset = new HTuple(), hv_LabelRowTop = new HTuple();
            HTuple hv_LabelRowBottom = new HTuple(), hv_LabelCol = new HTuple();
            HTuple hv_ArrowSizeFactorLength = new HTuple(), hv_ArrowSizeFactorHead = new HTuple();
            HTuple hv_MaxLengthArrow = new HTuple(), hv_HalfLengthArrow = new HTuple();
            HTuple hv_ArrowBaseRow = new HTuple(), hv_ArrowBaseCol = new HTuple();
            HTuple hv_ArrowHeadRow = new HTuple(), hv_ArrowHeadCol = new HTuple();
            HTuple hv_ArrowHeadSize = new HTuple(), hv_MaskRow = new HTuple();
            HTuple hv_MaskCol = new HTuple(), hv_ContourStyle = new HTuple();
            HTuple hv_Style = new HTuple(), hv_LineWidths = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_CurrentColors = new HTuple(), hv_IndexStyle = new HTuple();
            HTuple hv_TextColorClasses = new HTuple(), hv_LabelRow = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_InstanceMask);
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_MaskSelected);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxClassIndices = new HTuple();
            try
            {
                //
                //This procedure displays the bounding boxes and masks (if present) defined by a DLResult.
                //The ClassIDs are necessary to display bounding boxes from the same class
                //always with the same color.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "";
                hv_MaskExists.Dispose();
                hv_MaskExists = 0;
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle1";
                }
                else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Result bounding box data could not be found in DLResult.");
                }
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("mask"))).TupleNotEqual(-1))) != 0)
                {
                    ho_InstanceMask.Dispose();
                    HOperatorSet.GetDictObject(out ho_InstanceMask, hv_DLResult, "mask");
                    hv_MaskExists.Dispose();
                    hv_MaskExists = 1;
                }
                if ((int)((new HTuple((new HTuple(hv_InstanceType.TupleNotEqual("rectangle1"))).TupleAnd(
                    new HTuple(hv_InstanceType.TupleNotEqual("rectangle2"))))).TupleAnd(hv_MaskExists.TupleNot()
                    )) != 0)
                {
                    throw new HalconException("Result bounding box or mask data could not be found in DLSample.");
                }
                hv_BboxClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //
                    //Get text and text size for correct positioning of result class IDs.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_BboxClasses + hv_TextConf;
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_TextOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextOffset = (hv_Ascent + hv_Descent) / hv_WindowImageRatio;
                        }
                    }
                    //
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRowTop.Dispose();
                            hv_LabelRowTop = new HTuple(hv_BboxRow1);
                            hv_LabelRowBottom.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRowBottom = hv_BboxRow2 - hv_TextOffset;
                            }
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol1);
                        }
                    }
                    else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRowTop.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRowTop = hv_BboxRow - hv_TextOffset;
                            }
                            hv_LabelRowBottom.Dispose();
                            hv_LabelRowBottom = new HTuple(hv_BboxRow);
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol);
                        }
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            if ((int)(new HTuple(hv_ShowDirection.TupleEqual(-1))) != 0)
                            {
                                hv_ArrowSizeFactorLength.Dispose();
                                hv_ArrowSizeFactorLength = 0.4;
                                hv_ArrowSizeFactorHead.Dispose();
                                hv_ArrowSizeFactorHead = 0.2;
                                hv_MaxLengthArrow.Dispose();
                                hv_MaxLengthArrow = 20;
                                hv_HalfLengthArrow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_HalfLengthArrow = hv_MaxLengthArrow.TupleMin2(
                                        hv_BboxLength1 * hv_ArrowSizeFactorLength);
                                }
                                hv_ArrowBaseRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowBaseRow = hv_BboxRow - ((hv_BboxLength1 - hv_HalfLengthArrow) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowBaseCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowBaseCol = hv_BboxCol + ((hv_BboxLength1 - hv_HalfLengthArrow) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                                hv_ArrowHeadRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadRow = hv_BboxRow - ((hv_BboxLength1 + hv_HalfLengthArrow) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowHeadCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadCol = hv_BboxCol + ((hv_BboxLength1 + hv_HalfLengthArrow) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                                hv_ArrowHeadSize.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadSize = (hv_MaxLengthArrow.TupleMin2(
                                        hv_BboxLength1.TupleMin2(hv_BboxLength2))) * hv_ArrowSizeFactorHead;
                                }
                            }
                            else
                            {
                                hv_ArrowHeadSize.Dispose();
                                hv_ArrowHeadSize = 20.0;
                                hv_ArrowBaseRow.Dispose();
                                hv_ArrowBaseRow = new HTuple(hv_BboxRow);
                                hv_ArrowBaseCol.Dispose();
                                hv_ArrowBaseCol = new HTuple(hv_BboxCol);
                                hv_ArrowHeadRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadRow = hv_BboxRow - ((hv_BboxLength1 + hv_ArrowHeadSize) * (hv_BboxPhi.TupleSin()
                                        ));
                                }
                                hv_ArrowHeadCol.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ArrowHeadCol = hv_BboxCol + ((hv_BboxLength1 + hv_ArrowHeadSize) * (hv_BboxPhi.TupleCos()
                                        ));
                                }
                            }
                            ho_OrientationArrows.Dispose();
                            gen_arrow_contour_xld(out ho_OrientationArrows, hv_ArrowBaseRow, hv_ArrowBaseCol,
                                hv_ArrowHeadRow, hv_ArrowHeadCol, hv_ArrowHeadSize, hv_ArrowHeadSize);
                        }
                    }
                    else if ((int)(hv_MaskExists) != 0)
                    {
                        hv__.Dispose(); hv_MaskRow.Dispose(); hv_MaskCol.Dispose();
                        HOperatorSet.AreaCenter(ho_InstanceMask, out hv__, out hv_MaskRow, out hv_MaskCol);
                        hv_LabelRowTop.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LabelRowTop = hv_MaskRow - hv_TextOffset;
                        }
                        hv_LabelRowBottom.Dispose();
                        hv_LabelRowBottom = new HTuple(hv_MaskRow);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_MaskCol);
                    }
                    else
                    {
                        throw new HalconException("Unknown instance_type: " + hv_InstanceType);
                    }
                    //
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    hv_LineWidths.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LineWidths = new HTuple();
                        hv_LineWidths = hv_LineWidths.TupleConcat(hv_LineWidthBbox + 2);
                        hv_LineWidths = hv_LineWidths.TupleConcat(hv_LineWidthBbox);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect ClassIDs of the bounding boxes.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BboxClassIndices.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_BboxClasses.TupleLength()), 0, out hv_BboxClassIndices);
                    }
                    //
                    //Draw bounding boxes.
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxClasses.TupleSelect(hv_IndexBbox));
                        }
                        if (hv_BboxClassIndices == null)
                            hv_BboxClassIndices = new HTuple();
                        hv_BboxClassIndices[hv_IndexBbox] = hv_ClassID;
                        //First draw in black to make the class-color visible.
                        hv_CurrentColors.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentColors = new HTuple();
                            hv_CurrentColors[0] = "black";
                            hv_CurrentColors = hv_CurrentColors.TupleConcat(hv_Colors.TupleSelect(
                                hv_ClassID));
                        }
                        if ((int)(hv_MaskExists) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_MaskSelected.Dispose();
                                HOperatorSet.SelectObj(ho_InstanceMask, out ho_MaskSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_Colors.TupleSelect(
                                        hv_ClassID)) + "80");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_MaskSelected, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                            }
                        }
                        for (hv_IndexStyle = 0; (int)hv_IndexStyle <= (int)((new HTuple(hv_CurrentColors.TupleLength()
                            )) - 1); hv_IndexStyle = (int)hv_IndexStyle + 1)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_CurrentColors.TupleSelect(
                                        hv_IndexStyle));
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidths.TupleSelect(
                                        hv_IndexStyle));
                                }
                            }
                            if ((int)(new HTuple(hv_InstanceType.TupleNotEqual(""))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_RectangleSelected.Dispose();
                                    HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected,
                                        hv_IndexBbox + 1);
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                        );
                                }
                                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                                    hv_ShowDirection)) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_ArrowSelected.Dispose();
                                        HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected,
                                            hv_IndexBbox + 1);
                                    }
                                    if (HDevWindowStack.IsOpen())
                                    {
                                        HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive()
                                            );
                                    }
                                }
                            }
                        }
                    }
                    //
                    //Draw text of bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        //Get text and text size for correct positioning of result class IDs.
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_BboxClasses + hv_TextConf;
                        }
                        //Select text color.
                        if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                        {
                            hv_TextColorClasses.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses = hv_Colors.TupleSelect(
                                    hv_BboxClassIndices);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_BboxClassIndices.TupleLength()
                                    ), hv_TextColor, out hv_TextColorClasses);
                            }
                        }
                        //Select correct position of the text.
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_LabelRowTop);
                        if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
                        {
                            hv_LabelRow.Dispose();
                            hv_LabelRow = new HTuple(hv_LabelRowBottom);
                        }
                        //Display text.
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image",
                                    hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                                    "shadow")).TupleConcat("border_radius"), hv_BoxLabelColor.TupleConcat(
                                    (new HTuple("false")).TupleConcat(0)));
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if no results are present.
                    hv_BboxClassIndices.Dispose();
                    hv_BboxClassIndices = new HTuple();
                }
                //
                ho_InstanceMask.Dispose();
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_MaskSelected.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_MaskExists.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_BboxClasses.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRowTop.Dispose();
                hv_LabelRowBottom.Dispose();
                hv_LabelCol.Dispose();
                hv_ArrowSizeFactorLength.Dispose();
                hv_ArrowSizeFactorHead.Dispose();
                hv_MaxLengthArrow.Dispose();
                hv_HalfLengthArrow.Dispose();
                hv_ArrowBaseRow.Dispose();
                hv_ArrowBaseCol.Dispose();
                hv_ArrowHeadRow.Dispose();
                hv_ArrowHeadCol.Dispose();
                hv_ArrowHeadSize.Dispose();
                hv_MaskRow.Dispose();
                hv_MaskCol.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_LineWidths.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_CurrentColors.Dispose();
                hv_IndexStyle.Dispose();
                hv_TextColorClasses.Dispose();
                hv_LabelRow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_InstanceMask.Dispose();
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_MaskSelected.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_MaskExists.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_BboxClasses.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRowTop.Dispose();
                hv_LabelRowBottom.Dispose();
                hv_LabelCol.Dispose();
                hv_ArrowSizeFactorLength.Dispose();
                hv_ArrowSizeFactorHead.Dispose();
                hv_MaxLengthArrow.Dispose();
                hv_HalfLengthArrow.Dispose();
                hv_ArrowBaseRow.Dispose();
                hv_ArrowBaseCol.Dispose();
                hv_ArrowHeadRow.Dispose();
                hv_ArrowHeadCol.Dispose();
                hv_ArrowHeadSize.Dispose();
                hv_MaskRow.Dispose();
                hv_MaskCol.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_LineWidths.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_CurrentColors.Dispose();
                hv_IndexStyle.Dispose();
                hv_TextColorClasses.Dispose();
                hv_LabelRow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth/result segmentation as regions. 
        private void dev_display_segmentation_regions(HObject ho_SegmentationImage, HTuple hv_ClassIDs,
            HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
        {




            // Local iconic variables 

            HObject ho_Regions, ho_SelectedRegion = null;

            // Local control variables 

            HTuple hv_IncludedClassIDs = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
            hv_ImageClassIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth/result segmentation
                //given in SegmentationImage as regions. The ClassIDs are necessary to
                //display ground truth/result segmentations from the same class
                //always with the same color. It is possible to exclude certain ClassIDs
                //from being displayed. The displayed classes are returned in ImageClassIDs.
                //
                //
                //Remove excluded class IDs from the list.
                hv_IncludedClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
                        hv_ExcludeClassIDs);
                }
                //
                //Get a region for each class ID.
                ho_Regions.Dispose();
                HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs,
                    hv_IncludedClassIDs);
                //
                //Get classes with non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
                if ((int)(new HTuple((new HTuple(hv_Area.TupleLength())).TupleNotEqual(new HTuple(hv_IncludedClassIDs.TupleLength()
                    )))) != 0)
                {
                    throw new HalconException("No equal number of class IDs and segmentation regions.");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageClassIDs.Dispose();
                    HOperatorSet.TupleSelectMask(hv_IncludedClassIDs, hv_Area.TupleGreaterElem(
                        0), out hv_ImageClassIDs);
                }
                //
                //Display all non-empty class regions in distinct colors.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_IncludedClassIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
                    {
                        //Use class ID to determine region color.
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_IncludedClassIDs.TupleSelect(
                                hv_Index);
                        }
                        hv_IndexColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexColor = hv_ClassIDs.TupleFindFirst(
                                hv_ClassID);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                                    hv_IndexColor));
                            }
                        }
                        //Display the segmentation region.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_SelectedRegion.Dispose();
                            HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index + 1);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
                        }
                    }
                }
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Display a legend according to the generic parameters. 
        private void dev_display_tiled_legend(HTuple hv_WindowImages, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayLegend = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_LegendText = new HTuple(), hv_Flag = new HTuple();
            HTuple hv_PosTexts = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays a legend of dev_display_dl_data_tiled
                //according to the generic parameters.
                //
                try
                {
                    hv_DisplayLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_legend", out hv_DisplayLegend);
                    if ((int)(hv_DisplayLegend.TupleNot()) != 0)
                    {

                        hv_DisplayLegend.Dispose();
                        hv_Exception.Dispose();
                        hv_LegendText.Dispose();
                        hv_Flag.Dispose();
                        hv_PosTexts.Dispose();
                        hv_Text.Dispose();

                        return;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                hv_LegendText.Dispose();
                hv_LegendText = new HTuple();
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_input", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "input");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "input");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_ground_truth", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "ground truth");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "ground truth");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_result", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "result");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "result");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(3))) != 0)
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = new HTuple();
                    hv_PosTexts[0] = "Top:    ";
                    hv_PosTexts[1] = "Center: ";
                    hv_PosTexts[2] = "Bottom: ";
                }
                else if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = new HTuple();
                    hv_PosTexts[0] = "Top:    ";
                    hv_PosTexts[1] = "Bottom: ";
                }
                else
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = "";
                }
                HDevWindowStack.SetActive(hv_WindowImages);
                hv_Text.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Text = hv_PosTexts + hv_LegendText;
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "right", "black", new HTuple(), new HTuple());
                }

                hv_DisplayLegend.Dispose();
                hv_Exception.Dispose();
                hv_LegendText.Dispose();
                hv_Flag.Dispose();
                hv_PosTexts.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayLegend.Dispose();
                hv_Exception.Dispose();
                hv_LegendText.Dispose();
                hv_Flag.Dispose();
                hv_PosTexts.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Display information about the training of an anomaly detection model. 
        private void dev_display_train_info_anomaly_detection(HTuple hv_TrainParam, out HTuple hv_WindowHandleInfo)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayParam = new HTuple(), hv_DisplayEnabled = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_TrainParamAnomaly = new HTuple();
            HTuple hv_DomainRatio = new HTuple(), hv_ErrorThreshold = new HTuple();
            HTuple hv_RegularizationNoise = new HTuple(), hv_MaxNumEpochs = new HTuple();
            HTuple hv_TrainInformationLeft = new HTuple(), hv_TrainInformationRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleInfo = new HTuple();
            try
            {
                //
                //This procedure displays information about the training parameters of an anomaly detection model.
                //
                //Initialize display data.
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
                //
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {

                    hv_DisplayParam.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_WindowWidth.Dispose();
                    hv_WindowHeight.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatio.Dispose();
                    hv_ErrorThreshold.Dispose();
                    hv_RegularizationNoise.Dispose();
                    hv_MaxNumEpochs.Dispose();
                    hv_TrainInformationLeft.Dispose();
                    hv_TrainInformationRight.Dispose();

                    return;
                }
                //
                hv_WindowWidth.Dispose();
                hv_WindowWidth = 500;
                hv_WindowHeight.Dispose();
                hv_WindowHeight = 230;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "light gray";
                //
                //Open and setup text window.
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleInfo);
                HDevWindowStack.Push(hv_WindowHandleInfo);
                set_display_font(hv_WindowHandleInfo, 16, "mono", "true", "false");
                HDevWindowStack.SetActive(hv_WindowHandleInfo);
                //
                //Display information.
                hv_TrainParamAnomaly.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                hv_DomainRatio.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "domain_ratio", out hv_DomainRatio);
                hv_ErrorThreshold.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "error_threshold", out hv_ErrorThreshold);
                hv_RegularizationNoise.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "regularization_noise", out hv_RegularizationNoise);
                hv_MaxNumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "max_num_epochs", out hv_MaxNumEpochs);
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationLeft = new HTuple();
                hv_TrainInformationLeft[0] = "Training anomaly detection model.";
                hv_TrainInformationLeft[1] = "";
                hv_TrainInformationLeft[2] = "Max. number of epochs:";
                hv_TrainInformationLeft[3] = "Domain ratio:";
                hv_TrainInformationLeft[4] = "Error threshold:";
                hv_TrainInformationLeft[5] = "Regularization noise:";
                hv_TrainInformationLeft[6] = "";
                hv_TrainInformationLeft[7] = "This may take some time...";
                hv_TrainInformationRight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TrainInformationRight = new HTuple();
                    hv_TrainInformationRight[0] = "";
                    hv_TrainInformationRight[1] = "";
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_MaxNumEpochs);
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_DomainRatio.TupleString(
                        ".4f"));
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_ErrorThreshold.TupleString(
                        ".4f"));
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_RegularizationNoise.TupleString(
                        ".4f"));
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TrainInformationLeft,
                        "window", "top", "left", "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TrainInformationRight,
                        "window", "top", "right", "black", "box", "false");
                }
                //

                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_MaxNumEpochs.Dispose();
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_MaxNumEpochs.Dispose();
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update the various texts and plots during training. 
        private void dev_display_update_train_dl_model(HTuple hv_TrainParam, HTuple hv_DisplayData,
            HTuple hv_TrainInfo, HTuple hv_Epochs, HTuple hv_Loss, HTuple hv_LearningRate,
            HTuple hv_EvalEpochs, HTuple hv_EvalValues, HTuple hv_EvalValuesTrain)
        {



            // Local iconic variables 

            HObject ho_PlotBackground;

            // Local control variables 

            HTuple hv_DisplayEnabled = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_WindowText = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv_ChangePlotIntervalSeconds = new HTuple();
            HTuple hv_LastChange = new HTuple(), hv_Seconds = new HTuple();
            HTuple hv_PlotEval = new HTuple(), hv_PlotFunctionExists = new HTuple();
            HTuple hv_PlotFunction = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_TextPlot = new HTuple(), hv_PlotTrainEval = new HTuple();
            HTuple hv_HeadlineText = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_Index = new HTuple(), hv_PartRow1 = new HTuple();
            HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
            HTuple hv_PartColumn2 = new HTuple(), hv__ = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_ClipRegionValue = new HTuple(), hv_PlotHeight = new HTuple();
            HTuple hv_LegendRow = new HTuple(), hv_LegendDistanceLeft = new HTuple();
            HTuple hv_LegendDistanceRight = new HTuple(), hv_PlotLearningRateStrategy = new HTuple();
            HTuple hv_RightMargin = new HTuple(), hv_ChangeStrategies = new HTuple();
            HTuple hv_Idx = new HTuple(), hv_ChangeStrategy = new HTuple();
            HTuple hv_ChangeStrategyName = new HTuple(), hv_ChangeStrategiesValues = new HTuple();
            HTuple hv_ChangeStrategiesInitial = new HTuple(), hv_StrategyMin = new HTuple();
            HTuple hv_StrategyMax = new HTuple(), hv_LogLRMin = new HTuple();
            HTuple hv_LogLRMax = new HTuple(), hv_LRScale = new HTuple();
            HTuple hv_LROffset = new HTuple(), hv_LogLROffset = new HTuple();
            HTuple hv_StartYLearningRate = new HTuple(), hv_EndYLearningRate = new HTuple();
            HTuple hv_TicksYLearningRate = new HTuple(), hv_LogYLearningRate = new HTuple();
            HTuple hv_LRColor = new HTuple(), hv_LRLineWidth = new HTuple();
            HTuple hv_LRTextLegend = new HTuple(), hv_TopMarginPlots = new HTuple();
            HTuple hv_NumIterationsPerEpoch = new HTuple(), hv_Iterations = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_NumIterations = new HTuple();
            HTuple hv_CurrentIteration = new HTuple(), hv_XAxisLabel = new HTuple();
            HTuple hv_ValuesX = new HTuple(), hv_TicksX = new HTuple();
            HTuple hv_EvalValuesX = new HTuple(), hv_EvalTicksX = new HTuple();
            HTuple hv_TitleX = new HTuple(), hv_EvalIterations = new HTuple();
            HTuple hv_EvalValuesMin = new HTuple(), hv_EvalValuesMax = new HTuple();
            HTuple hv_TicksY = new HTuple(), hv_StartY = new HTuple();
            HTuple hv_EndY = new HTuple(), hv_YAxisLabel = new HTuple();
            HTuple hv_BestEvaluationData = new HTuple(), hv_BestEvaluationComparisonKeys = new HTuple();
            HTuple hv_StringExtendsLegendRight = new HTuple(), hv_Bullet = new HTuple();
            HTuple hv_Line = new HTuple(), hv_YAxisTitle = new HTuple();
            HTuple hv_Offset = new HTuple(), hv_LogMin = new HTuple();
            HTuple hv_LogMax = new HTuple(), hv_Scale = new HTuple();
            HTuple hv_LogOffset = new HTuple(), hv_LogY = new HTuple();
            HTuple hv_TextModelParams = new HTuple(), hv_ModelParams = new HTuple();
            HTuple hv_StatusModelParamsLeft = new HTuple(), hv_StatusModelParamsRight = new HTuple();
            HTuple hv_ParName = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_TupleStr = new HTuple();
            HTuple hv_StatusEvaluationLeft = new HTuple(), hv_StatusEvaluationRight = new HTuple();
            HTuple hv_BestEvaluationValue = new HTuple(), hv_BestEvaluationInfo = new HTuple();
            HTuple hv_BestEvaluationEpoch = new HTuple(), hv_BestTrainEvaluationValue = new HTuple();
            HTuple hv_BestTrainEvaluationInfo = new HTuple(), hv_BestTrainEvaluationEpoch = new HTuple();
            HTuple hv_BestEvaluationComparisonKeysStr = new HTuple();
            HTuple hv_StatusTrainLeft = new HTuple(), hv_StatusTrainRight = new HTuple();
            HTuple hv_EpochReal = new HTuple(), hv_MeanLoss = new HTuple();
            HTuple hv_MeanLossStr = new HTuple(), hv_TimeElapsedExists = new HTuple();
            HTuple hv_StartEpoch = new HTuple(), hv_StartTime = new HTuple();
            HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
            HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
            HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
            HTuple hv_DeviceNameExists = new HTuple(), hv_DeviceName = new HTuple();
            HTuple hv_StatusLeft = new HTuple(), hv_StatusRight = new HTuple();
            HTuple hv_MaxChars = new HTuple(), hv_Str = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_Length = new HTuple();
            HTuple hv_SubStr = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_WindowTextWidth = new HTuple();
            HTuple hv_WindowTextHeight = new HTuple();
            HTuple hv_EvalValuesTrain_COPY_INP_TMP = new HTuple(hv_EvalValuesTrain);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_PlotBackground);
            try
            {
                //
                //This procedure updates the various texts and plots.
                //It uses precomputed information (TrainInfo, EvaluationInfos,...).
                //
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {
                    ho_PlotBackground.Dispose();

                    hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_WindowText.Dispose();
                    hv_WindowHandle.Dispose();
                    hv_ChangePlotIntervalSeconds.Dispose();
                    hv_LastChange.Dispose();
                    hv_Seconds.Dispose();
                    hv_PlotEval.Dispose();
                    hv_PlotFunctionExists.Dispose();
                    hv_PlotFunction.Dispose();
                    hv_ModelType.Dispose();
                    hv_TextPlot.Dispose();
                    hv_PlotTrainEval.Dispose();
                    hv_HeadlineText.Dispose();
                    hv_Indices.Dispose();
                    hv_Index.Dispose();
                    hv_PartRow1.Dispose();
                    hv_PartColumn1.Dispose();
                    hv_PartRow2.Dispose();
                    hv_PartColumn2.Dispose();
                    hv__.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_ClipRegionValue.Dispose();
                    hv_PlotHeight.Dispose();
                    hv_LegendRow.Dispose();
                    hv_LegendDistanceLeft.Dispose();
                    hv_LegendDistanceRight.Dispose();
                    hv_PlotLearningRateStrategy.Dispose();
                    hv_RightMargin.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_Idx.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ChangeStrategyName.Dispose();
                    hv_ChangeStrategiesValues.Dispose();
                    hv_ChangeStrategiesInitial.Dispose();
                    hv_StrategyMin.Dispose();
                    hv_StrategyMax.Dispose();
                    hv_LogLRMin.Dispose();
                    hv_LogLRMax.Dispose();
                    hv_LRScale.Dispose();
                    hv_LROffset.Dispose();
                    hv_LogLROffset.Dispose();
                    hv_StartYLearningRate.Dispose();
                    hv_EndYLearningRate.Dispose();
                    hv_TicksYLearningRate.Dispose();
                    hv_LogYLearningRate.Dispose();
                    hv_LRColor.Dispose();
                    hv_LRLineWidth.Dispose();
                    hv_LRTextLegend.Dispose();
                    hv_TopMarginPlots.Dispose();
                    hv_NumIterationsPerEpoch.Dispose();
                    hv_Iterations.Dispose();
                    hv_NumEpochs.Dispose();
                    hv_NumIterations.Dispose();
                    hv_CurrentIteration.Dispose();
                    hv_XAxisLabel.Dispose();
                    hv_ValuesX.Dispose();
                    hv_TicksX.Dispose();
                    hv_EvalValuesX.Dispose();
                    hv_EvalTicksX.Dispose();
                    hv_TitleX.Dispose();
                    hv_EvalIterations.Dispose();
                    hv_EvalValuesMin.Dispose();
                    hv_EvalValuesMax.Dispose();
                    hv_TicksY.Dispose();
                    hv_StartY.Dispose();
                    hv_EndY.Dispose();
                    hv_YAxisLabel.Dispose();
                    hv_BestEvaluationData.Dispose();
                    hv_BestEvaluationComparisonKeys.Dispose();
                    hv_StringExtendsLegendRight.Dispose();
                    hv_Bullet.Dispose();
                    hv_Line.Dispose();
                    hv_YAxisTitle.Dispose();
                    hv_Offset.Dispose();
                    hv_LogMin.Dispose();
                    hv_LogMax.Dispose();
                    hv_Scale.Dispose();
                    hv_LogOffset.Dispose();
                    hv_LogY.Dispose();
                    hv_TextModelParams.Dispose();
                    hv_ModelParams.Dispose();
                    hv_StatusModelParamsLeft.Dispose();
                    hv_StatusModelParamsRight.Dispose();
                    hv_ParName.Dispose();
                    hv_Tuple.Dispose();
                    hv_Exception.Dispose();
                    hv_TupleStr.Dispose();
                    hv_StatusEvaluationLeft.Dispose();
                    hv_StatusEvaluationRight.Dispose();
                    hv_BestEvaluationValue.Dispose();
                    hv_BestEvaluationInfo.Dispose();
                    hv_BestEvaluationEpoch.Dispose();
                    hv_BestTrainEvaluationValue.Dispose();
                    hv_BestTrainEvaluationInfo.Dispose();
                    hv_BestTrainEvaluationEpoch.Dispose();
                    hv_BestEvaluationComparisonKeysStr.Dispose();
                    hv_StatusTrainLeft.Dispose();
                    hv_StatusTrainRight.Dispose();
                    hv_EpochReal.Dispose();
                    hv_MeanLoss.Dispose();
                    hv_MeanLossStr.Dispose();
                    hv_TimeElapsedExists.Dispose();
                    hv_StartEpoch.Dispose();
                    hv_StartTime.Dispose();
                    hv_SecondsElapsed.Dispose();
                    hv_SecondsRemaining.Dispose();
                    hv_ProgressPercent.Dispose();
                    hv_ProgressPerSecond.Dispose();
                    hv_TimeElapsedString.Dispose();
                    hv_TimeRemainingString.Dispose();
                    hv_DeviceNameExists.Dispose();
                    hv_DeviceName.Dispose();
                    hv_StatusLeft.Dispose();
                    hv_StatusRight.Dispose();
                    hv_MaxChars.Dispose();
                    hv_Str.Dispose();
                    hv_IsString.Dispose();
                    hv_Length.Dispose();
                    hv_SubStr.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column2.Dispose();
                    hv_WindowTextWidth.Dispose();
                    hv_WindowTextHeight.Dispose();

                    return;
                }
                //
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
                //
                hv_WindowText.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
                HOperatorSet.SetWindowParam(hv_WindowText, "flush", "false");
                //Only switch to window if the current window is not the text window (performance).
                if (HDevWindowStack.IsOpen())
                {
                    hv_WindowHandle = HDevWindowStack.GetActive();
                }
                if ((int)(new HTuple(hv_WindowHandle.TupleNotEqual(hv_WindowText))) != 0)
                {
                    HDevWindowStack.SetActive(hv_WindowText);
                    hv_WindowHandle.Dispose();
                    hv_WindowHandle = new HTuple(hv_WindowText);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                hv_ChangePlotIntervalSeconds.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "change_plot_interval_seconds",
                    out hv_ChangePlotIntervalSeconds);
                hv_LastChange.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "last_change_plot", out hv_LastChange);
                hv_Seconds.Dispose();
                HOperatorSet.CountSeconds(out hv_Seconds);
                hv_PlotEval.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "plot_eval", out hv_PlotEval);
                if ((int)(new HTuple(((hv_Seconds - hv_LastChange)).TupleGreaterEqual(hv_ChangePlotIntervalSeconds))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PlotEval = (new HTuple(hv_PlotEval.TupleNot()
                                )).TupleAnd(new HTuple((new HTuple(hv_EvalEpochs.TupleLength())).TupleGreaterEqual(
                                2)));
                            hv_PlotEval.Dispose();
                            hv_PlotEval = ExpTmpLocalVar_PlotEval;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", hv_PlotEval);
                    HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Seconds);
                }
                //This procedure can also be called after a training.
                //In such a case the parameter plot_function can be set to determine,
                //which plot shall be displayed.
                hv_PlotFunctionExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayData, "key_exists", "plot_function", out hv_PlotFunctionExists);
                if ((int)(hv_PlotFunctionExists) != 0)
                {
                    hv_PlotFunction.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "plot_function", out hv_PlotFunction);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PlotEval = hv_PlotEval.TupleOr(
                                new HTuple(hv_PlotFunction.TupleEqual("evaluation")));
                            hv_PlotEval.Dispose();
                            hv_PlotEval = ExpTmpLocalVar_PlotEval;
                        }
                    }
                }
                //
                hv_ModelType.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ModelType = ((hv_TrainInfo.TupleGetDictTuple(
                        "model_params"))).TupleGetDictTuple("type");
                }
                if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                {
                    //For models of type 'gc_anomaly_detection'
                    //no evaluation is shown.
                    hv_TextPlot.Dispose();
                    hv_TextPlot = "1/1";
                }
                else
                {
                    if ((int)(hv_PlotEval) != 0)
                    {
                        hv_TextPlot.Dispose();
                        hv_TextPlot = "2/2";
                    }
                    else
                    {
                        hv_TextPlot.Dispose();
                        hv_TextPlot = "1/2";
                        hv_PlotTrainEval.Dispose();
                        hv_PlotTrainEval = 0;
                    }
                }

                hv_HeadlineText.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeadlineText = ("Showing plot " + hv_TextPlot) + ":";
                }
                //
                //Shall the training evaluation be plotted?
                hv_PlotTrainEval.Dispose();
                hv_PlotTrainEval = 0;
                //
                //In case there are missing evaluation values (-1),
                //we just reuse the previous values.
                if ((int)(new HTuple(hv_EvalValuesTrain_COPY_INP_TMP.TupleLength())) != 0)
                {
                    hv_PlotTrainEval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PlotTrainEval = new HTuple(((hv_EvalValuesTrain_COPY_INP_TMP.TupleMax()
                            )).TupleNotEqual(-1));
                    }
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_EvalValuesTrain_COPY_INP_TMP, -1, out hv_Indices);
                        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Indices.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(((hv_Indices.TupleSelect(hv_Index))).TupleEqual(
                                    0))) != 0)
                                {
                                    if (hv_EvalValuesTrain_COPY_INP_TMP == null)
                                        hv_EvalValuesTrain_COPY_INP_TMP = new HTuple();
                                    hv_EvalValuesTrain_COPY_INP_TMP[0] = 0.0;
                                }
                                else
                                {
                                    if (hv_EvalValuesTrain_COPY_INP_TMP == null)
                                        hv_EvalValuesTrain_COPY_INP_TMP = new HTuple();
                                    hv_EvalValuesTrain_COPY_INP_TMP[hv_Indices.TupleSelect(hv_Index)] = hv_EvalValuesTrain_COPY_INP_TMP.TupleSelect(
                                        (hv_Indices.TupleSelect(hv_Index)) - 1);
                                }
                            }
                        }
                    }
                }
                //
                hv_PartRow1.Dispose(); hv_PartColumn1.Dispose(); hv_PartRow2.Dispose(); hv_PartColumn2.Dispose();
                HOperatorSet.GetPart(hv_WindowText, out hv_PartRow1, out hv_PartColumn1, out hv_PartRow2,
                    out hv_PartColumn2);
                hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_Width,
                    out hv_Height);
                //Generate a background rectangle for the plot.
                //For a correct visualization of the rectangle, the region
                //may not be cut off.
                hv_ClipRegionValue.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegionValue);
                HOperatorSet.SetSystem("clip_region", "false");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_PlotBackground.Dispose();
                    HOperatorSet.GenRectangle1(out ho_PlotBackground, 470, 9, hv_PartRow2 - 6, hv_PartColumn2 - 10);
                }
                HOperatorSet.SetSystem("clip_region", hv_ClipRegionValue);
                //
                hv_PlotHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PlotHeight = (((hv_PartRow2 - 30) - 480) * hv_Height) / ((hv_PartRow2 - hv_PartRow1) + 1);
                }
                hv_LegendRow.Dispose();
                hv_LegendRow = 479;
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceLeft = 65;
                hv_LegendDistanceRight.Dispose();
                hv_LegendDistanceRight = 85;
                //
                //Get change strategy parameters and check if a learning rate strategy exits
                hv_PlotLearningRateStrategy.Dispose();
                hv_PlotLearningRateStrategy = 0;
                hv_RightMargin.Dispose();
                hv_RightMargin = 35;
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "change_strategies", out hv_ChangeStrategies);
                if ((int)(new HTuple((new HTuple(hv_ChangeStrategies.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                        )) - 1); hv_Idx = (int)hv_Idx + 1)
                    {
                        hv_ChangeStrategy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                                hv_Idx);
                        }
                        hv_ChangeStrategyName.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ChangeStrategyName);
                        if ((int)(new HTuple(hv_ChangeStrategyName.TupleEqual("learning_rate"))) != 0)
                        {
                            hv_PlotLearningRateStrategy.Dispose();
                            hv_PlotLearningRateStrategy = 1;
                            hv_ChangeStrategiesValues.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_ChangeStrategiesValues);
                            hv_ChangeStrategiesInitial.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_ChangeStrategiesInitial);
                            //
                            //Plot parameters for the learning rate
                            hv_StrategyMin.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StrategyMin = hv_LearningRate.TupleMin()
                                    ;
                            }
                            hv_StrategyMax.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StrategyMax = hv_LearningRate.TupleMax()
                                    ;
                            }
                            hv_LogLRMin.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLRMin = (((new HTuple(1e-8)).TupleMax2(
                                    hv_StrategyMin))).TupleLog10();
                            }
                            hv_LogLRMax.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLRMax = (((new HTuple(1e-8)).TupleMax2(
                                    hv_StrategyMax))).TupleLog10();
                            }
                            //
                            if ((int)(new HTuple(((((hv_LogLRMax - hv_LogLRMin)).TupleFabs())).TupleLess(
                                1e-4))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_LogLRMin = hv_LogLRMin - 5e-5;
                                        hv_LogLRMin.Dispose();
                                        hv_LogLRMin = ExpTmpLocalVar_LogLRMin;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_LogLRMax = hv_LogLRMax + 5e-5;
                                        hv_LogLRMax.Dispose();
                                        hv_LogLRMax = ExpTmpLocalVar_LogLRMax;
                                    }
                                }
                            }
                            //
                            hv_LRScale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LRScale = (hv_LogLRMax - hv_LogLRMin) / hv_PlotHeight;
                            }
                            hv_LROffset.Dispose();
                            hv_LROffset = 15;
                            hv_LogLROffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLROffset = hv_LROffset * hv_LRScale;
                            }
                            //
                            hv_StartYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StartYLearningRate = (new HTuple(10)).TuplePow(
                                    hv_LogLRMin - (1.0 * hv_LogLROffset));
                            }
                            hv_EndYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EndYLearningRate = (new HTuple(10)).TuplePow(
                                    hv_LogLRMax + (1.0 * hv_LogLROffset));
                            }
                            hv_TicksYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TicksYLearningRate = (hv_PlotHeight / 5) * hv_LRScale;
                            }
                            //
                            hv_LogYLearningRate.Dispose();
                            hv_LogYLearningRate = "true";
                            hv_RightMargin.Dispose();
                            hv_RightMargin = 75;
                        }
                    }
                }
                hv_LRColor.Dispose();
                hv_LRColor = "#1332ffdd";
                hv_LRLineWidth.Dispose();
                hv_LRLineWidth = 2;
                hv_LRTextLegend.Dispose();
                hv_LRTextLegend = "'learning_rate'";
                //Space for legends
                hv_TopMarginPlots.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopMarginPlots = 480 + 20;
                }
                //
                //Determine current number of iterations.
                hv_NumIterationsPerEpoch.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_iterations_per_epoch", out hv_NumIterationsPerEpoch);
                hv_Iterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Iterations = ((((hv_Epochs * hv_NumIterationsPerEpoch)).TupleCeil()
                        )).TupleInt();
                }
                hv_NumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
                hv_NumIterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumIterations = ((((hv_NumEpochs * hv_NumIterationsPerEpoch)).TupleCeil()
                        )).TupleInt();
                }
                hv_CurrentIteration.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentIteration = hv_Iterations.TupleSelect(
                        (new HTuple(hv_Iterations.TupleLength())) - 1);
                }
                //
                //Determine x-axis values.
                hv_XAxisLabel.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "x_axis_label", out hv_XAxisLabel);
                if ((int)(new HTuple(hv_XAxisLabel.TupleEqual("epochs"))) != 0)
                {
                    hv_ValuesX.Dispose();
                    hv_ValuesX = new HTuple(hv_Epochs);
                    hv_TicksX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksX = (new HTuple(0.1)).TupleMax2(
                            ((hv_Epochs.TupleMax()) - (hv_Epochs.TupleMin())) * 0.15);
                    }
                    if ((int)(new HTuple(hv_EvalEpochs.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_EvalValuesX.Dispose();
                        hv_EvalValuesX = new HTuple(hv_EvalEpochs);
                        hv_EvalTicksX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalTicksX = (new HTuple(0.1)).TupleMax2(
                                ((hv_EvalEpochs.TupleMax()) - (hv_EvalEpochs.TupleMin())) * 0.15);
                        }
                    }
                    hv_TitleX.Dispose();
                    hv_TitleX = "Epochs";
                }
                else if ((int)(new HTuple(hv_XAxisLabel.TupleEqual("iterations"))) != 0)
                {
                    hv_ValuesX.Dispose();
                    hv_ValuesX = new HTuple(hv_Iterations);
                    hv_TicksX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksX = (((new HTuple(2)).TupleMax2(
                            ((hv_Iterations.TupleMax()) - (hv_Iterations.TupleMin())) * 0.15))).TupleInt()
                            ;
                    }
                    if ((int)(new HTuple(hv_EvalEpochs.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_EvalIterations.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalIterations = ((hv_EvalEpochs * hv_NumIterationsPerEpoch)).TupleCeil()
                                ;
                        }
                        hv_EvalValuesX.Dispose();
                        hv_EvalValuesX = new HTuple(hv_EvalIterations);
                        hv_EvalTicksX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalTicksX = (((new HTuple(2)).TupleMax2(
                                ((hv_EvalIterations.TupleMax()) - (hv_EvalIterations.TupleMin())) * 0.15))).TupleInt()
                                ;
                        }
                    }
                    hv_TitleX.Dispose();
                    hv_TitleX = "Iterations";
                }
                //
                //Determine y-axis values and plot the function as well as its texts.
                if ((int)(hv_PlotEval) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
                    }
                    hv_EvalValuesMin.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvalValuesMin = ((hv_EvalValues.TupleConcat(
                            (new HTuple(0.0)).TupleMax2(hv_EvalValuesTrain_COPY_INP_TMP)))).TupleMin()
                            ;
                    }
                    hv_EvalValuesMax.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvalValuesMax = ((hv_EvalValues.TupleConcat(
                            hv_EvalValuesTrain_COPY_INP_TMP))).TupleMax();
                    }
                    if ((int)(new HTuple(((((hv_EvalValuesMax - hv_EvalValuesMin)).TupleAbs())).TupleLess(
                        1e-3))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvalValuesMin = hv_EvalValuesMin - 5e-4;
                                hv_EvalValuesMin.Dispose();
                                hv_EvalValuesMin = ExpTmpLocalVar_EvalValuesMin;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvalValuesMax = hv_EvalValuesMax + 5e-4;
                                hv_EvalValuesMax.Dispose();
                                hv_EvalValuesMax = ExpTmpLocalVar_EvalValuesMax;
                            }
                        }
                    }
                    hv_TicksY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksY = (hv_EvalValuesMax - hv_EvalValuesMin) * 0.1;
                    }
                    hv_StartY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StartY = hv_EvalValuesMin - ((hv_EvalValuesMax - hv_EvalValuesMin) * 0.1);
                    }
                    hv_EndY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EndY = hv_EvalValuesMax + ((hv_EvalValuesMax - hv_EvalValuesMin) * 0.1);
                    }
                    //
                    hv_YAxisLabel.Dispose();
                    hv_YAxisLabel = "Evaluation value";
                    hv_BestEvaluationData.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
                    if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_BestEvaluationComparisonKeys.Dispose();
                        HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
                        hv_YAxisLabel.Dispose();
                        hv_YAxisLabel = "Evaluation value";
                        if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                            )).TupleGreater(1))) != 0)
                        {
                            hv_YAxisLabel.Dispose();
                            pretty_print_tuple(hv_BestEvaluationComparisonKeys, out hv_YAxisLabel);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisLabel = ("mean(" + hv_YAxisLabel) + ")";
                                    hv_YAxisLabel.Dispose();
                                    hv_YAxisLabel = ExpTmpLocalVar_YAxisLabel;
                                }
                            }
                        }
                        else
                        {
                            hv_YAxisLabel.Dispose();
                            hv_YAxisLabel = new HTuple(hv_BestEvaluationComparisonKeys);
                        }
                    }
                    //Use a smaller, non-bold font for the plot.
                    set_display_font(hv_WindowText, 12, "mono", "false", "false");
                    //Plot learning rate if the corresponding strategy exists.
                    if ((int)(hv_PlotLearningRateStrategy) != 0)
                    {
                        //
                        //Display current values in appropriate colors.
                        hv__.Dispose(); hv__.Dispose(); hv_StringExtendsLegendRight.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowText, hv_LRTextLegend, out hv__,
                            out hv__, out hv_StringExtendsLegendRight, out hv__);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LRTextLegend, "image",
                                    hv_LegendRow, (hv_Width - hv_StringExtendsLegendRight) - hv_LegendDistanceRight,
                                    hv_LRColor, "box", "false");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_LearningRate,
                                "", "", hv_LRColor, ((((((((((((new HTuple("log_y")).TupleConcat("axes_color")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("ticks_y")).TupleConcat(
                                "margin_top")).TupleConcat("margin_bottom")).TupleConcat("margin_left")).TupleConcat(
                                "margin_right")).TupleConcat("line_width")).TupleConcat("axes_color")).TupleConcat(
                                "axis_location_y")).TupleConcat("format_y"), ((((((((((((((((hv_LogYLearningRate.TupleConcat(
                                "black"))).TupleConcat(hv_StartYLearningRate))).TupleConcat(hv_EndYLearningRate))).TupleConcat(
                                hv_TicksYLearningRate))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                hv_LRLineWidth))).TupleConcat(((new HTuple("#898b8f")).TupleConcat(
                                "right")).TupleConcat(".1e")));
                        }
                    }
                    //Plot validation evaluation values.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValues,
                            hv_TitleX, "", "#36a2eb", ((((((((((new HTuple("axes_color")).TupleConcat(
                            "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
                            "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                            "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                            "axes_color"), (((((((((((((((new HTuple("black")).TupleConcat(hv_EvalTicksX))).TupleConcat(
                            hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(
                            hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(65)))).TupleConcat(
                            hv_RightMargin))).TupleConcat((new HTuple(3)).TupleConcat("#898b8f")));
                    }
                    //Plot train evaluation values.
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        hv_Bullet.Dispose();
                        hv_Bullet = "●";
                        hv_Line.Dispose();
                        hv_Line = "―";
                        hv_YAxisTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisTitle = ((((("  '" + hv_YAxisLabel) + "' (") + hv_Line) + new HTuple(" validation, ")) + hv_Bullet) + "-- training)";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValuesTrain_COPY_INP_TMP,
                                hv_TitleX, "", "#36a2eb", (((((((((((new HTuple("style")).TupleConcat(
                                "axes_color")).TupleConcat("ticks_x")).TupleConcat("ticks_y")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("margin_top")).TupleConcat(
                                "margin_bottom")).TupleConcat("margin_left")).TupleConcat("margin_right")).TupleConcat(
                                "line_width")).TupleConcat("axes_color"), ((((((((((((((((new HTuple(20)).TupleConcat(
                                "black")).TupleConcat(hv_EvalTicksX))).TupleConcat(hv_TicksY))).TupleConcat(
                                hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                (new HTuple(3)).TupleConcat("#898b8f")));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValuesTrain_COPY_INP_TMP,
                                hv_TitleX, "", "#36a2eb", (((((((((((new HTuple("style")).TupleConcat(
                                "axes_color")).TupleConcat("ticks_x")).TupleConcat("ticks_y")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("margin_top")).TupleConcat(
                                "margin_bottom")).TupleConcat("margin_left")).TupleConcat("margin_right")).TupleConcat(
                                "line_width")).TupleConcat("axes_color"), ((((((((((((((((new HTuple("circle")).TupleConcat(
                                "black")).TupleConcat(hv_EvalTicksX))).TupleConcat(hv_TicksY))).TupleConcat(
                                hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                (new HTuple(3)).TupleConcat("#898b8f")));
                        }
                    }
                    else
                    {
                        hv_YAxisTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisTitle = ("  '" + hv_YAxisLabel) + "'";
                        }
                    }
                    //Display title of y-axis.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YAxisTitle, "image",
                            hv_LegendRow, hv_LegendDistanceLeft, "#36a2eb", "box", "false");
                    }
                    //Reset font.
                    set_display_font(hv_WindowText, 16, "mono", "true", "false");
                }
                else
                {
                    if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleGreater(3))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
                        }
                        //
                        //Set StartY and EndY, such that there is a margin on top and bottom to
                        //avoid that the plot overlaps with the axis captions. (With respect to
                        //the logarithmic plotting of the Loss function)
                        //Set this offset in window coordinates:
                        hv_Offset.Dispose();
                        hv_Offset = 15;
                        //Calculate min max values to determine the correct offset in log
                        //coordinates.
                        hv_LogMin.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogMin = (((new HTuple(0.00001)).TupleMax2(
                                hv_Loss.TupleMin()))).TupleLog10();
                        }
                        hv_LogMax.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogMax = (((new HTuple(0.00001)).TupleMax2(
                                hv_Loss.TupleMax()))).TupleLog10();
                        }
                        //
                        if ((int)(new HTuple(((((hv_LogMax - hv_LogMin)).TupleFabs())).TupleLess(
                            0.0001))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LogMin = hv_LogMin - 0.00005;
                                    hv_LogMin.Dispose();
                                    hv_LogMin = ExpTmpLocalVar_LogMin;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LogMax = hv_LogMax + 0.00005;
                                    hv_LogMax.Dispose();
                                    hv_LogMax = ExpTmpLocalVar_LogMax;
                                }
                            }
                        }
                        //
                        hv_Scale.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Scale = (hv_LogMax - hv_LogMin) / hv_PlotHeight;
                        }
                        hv_LogOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogOffset = hv_Offset * hv_Scale;
                        }
                        hv_StartY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartY = (new HTuple(10)).TuplePow(
                                hv_LogMin - hv_LogOffset);
                        }
                        hv_EndY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndY = (new HTuple(10)).TuplePow(
                                hv_LogMax + hv_LogOffset);
                        }
                        hv_TicksY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TicksY = (hv_PlotHeight / 10) * hv_Scale;
                        }
                        //
                        //Use a smaller, non-bold font for the plot.
                        set_display_font(hv_WindowText, 12, "mono", "false", "false");
                        hv_LogY.Dispose();
                        hv_LogY = "true";
                        //Plot learning rate if the corresponding strategy exists.
                        if ((int)(hv_PlotLearningRateStrategy) != 0)
                        {
                            //
                            //Display current values in appropriate colors.
                            hv__.Dispose(); hv__.Dispose(); hv_StringExtendsLegendRight.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowText, hv_LRTextLegend, out hv__,
                                out hv__, out hv_StringExtendsLegendRight, out hv__);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LRTextLegend,
                                        "image", hv_LegendRow, (hv_Width - hv_StringExtendsLegendRight) - hv_LegendDistanceRight,
                                        hv_LRColor, "box", "false");
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_LearningRate,
                                    "", "", hv_LRColor, ((((((((((((new HTuple("log_y")).TupleConcat(
                                    "axes_color")).TupleConcat("start_y")).TupleConcat("end_y")).TupleConcat(
                                    "ticks_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                                    "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                                    "axes_color")).TupleConcat("axis_location_y")).TupleConcat("format_y"),
                                    ((((((((((((((((hv_LogY.TupleConcat("black"))).TupleConcat(hv_StartYLearningRate))).TupleConcat(
                                    hv_EndYLearningRate))).TupleConcat(hv_TicksYLearningRate))).TupleConcat(
                                    hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(65)))).TupleConcat(
                                    hv_RightMargin))).TupleConcat(hv_LRLineWidth))).TupleConcat(((new HTuple("#898b8f")).TupleConcat(
                                    "right")).TupleConcat(".1e")));
                            }
                        }
                        hv_YAxisLabel.Dispose();
                        hv_YAxisLabel = "Loss";
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "  " + hv_YAxisLabel,
                                    "image", hv_LegendRow, hv_LegendDistanceLeft, "#ff6384", "box", "false");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_Loss, hv_TitleX,
                                "", "#ff6384", (((((((((((new HTuple("log_y")).TupleConcat("axes_color")).TupleConcat(
                                "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
                                "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                                "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                                "axes_color"), ((((((((((((((((hv_LogY.TupleConcat("black"))).TupleConcat(
                                hv_TicksX))).TupleConcat(hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(
                                hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(
                                65)))).TupleConcat(hv_RightMargin))).TupleConcat((new HTuple(3)).TupleConcat(
                                "#898b8f")));
                        }
                        set_display_font(hv_WindowText, 16, "mono", "true", "false");
                    }
                    else
                    {
                        hv_HeadlineText.Dispose();
                        hv_HeadlineText = "Waiting for data to initialize the plot...";
                    }
                }

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_HeadlineText, "image",
                        445, 9, "black", "box", "false");
                }
                //
                //Model parameter status.
                hv_TextModelParams.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "status_model_params", out hv_TextModelParams);
                hv_ModelParams.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "model_params", out hv_ModelParams);
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsLeft = new HTuple();
                hv_StatusModelParamsRight.Dispose();
                hv_StatusModelParamsRight = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TextModelParams.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ParName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParName = hv_TextModelParams.TupleSelect(
                            hv_Index);
                    }
                    try
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_ModelParams, hv_ParName, out hv_Tuple);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    if ((int)((new HTuple(hv_ParName.TupleEqual("batch_size_multiplier"))).TupleAnd(
                        new HTuple(hv_Tuple.TupleEqual(1)))) != 0)
                    {
                        continue;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsLeft = hv_StatusModelParamsLeft.TupleConcat(
                                ("'" + hv_ParName) + "'");
                            hv_StatusModelParamsLeft.Dispose();
                            hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
                        }
                    }

                    hv_TupleStr.Dispose();
                    pretty_print_tuple(hv_Tuple, out hv_TupleStr);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsRight = hv_StatusModelParamsRight.TupleConcat(
                                hv_TupleStr);
                            hv_StatusModelParamsRight.Dispose();
                            hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_StatusModelParamsLeft.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsLeft = (new HTuple("Model parameters:")).TupleConcat(
                                "  " + hv_StatusModelParamsLeft);
                            hv_StatusModelParamsLeft.Dispose();
                            hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsRight = (new HTuple(" ")).TupleConcat(
                                hv_StatusModelParamsRight);
                            hv_StatusModelParamsRight.Dispose();
                            hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
                        }
                    }
                }
                //
                //Evaluation status.
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationLeft = new HTuple();
                hv_StatusEvaluationRight.Dispose();
                hv_StatusEvaluationRight = new HTuple();
                hv_BestEvaluationData.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
                if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BestEvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
                    hv_BestEvaluationValue.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_value", out hv_BestEvaluationValue);
                    hv_BestEvaluationInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_info", out hv_BestEvaluationInfo);
                    hv_BestEvaluationEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationInfo, "epoch", out hv_BestEvaluationEpoch);
                    hv_BestTrainEvaluationValue.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_value_train", out hv_BestTrainEvaluationValue);
                    hv_BestTrainEvaluationInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_info_train", out hv_BestTrainEvaluationInfo);
                    hv_BestTrainEvaluationEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestTrainEvaluationInfo, "epoch", out hv_BestTrainEvaluationEpoch);
                    if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                        )).TupleGreater(1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Measures");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        hv_BestEvaluationComparisonKeysStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BestEvaluationComparisonKeysStr = new HTuple(new HTuple("multiple (") + (new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                                ))) + ")";
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Measure");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        hv_BestEvaluationComparisonKeysStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BestEvaluationComparisonKeysStr = ("'" + hv_BestEvaluationComparisonKeys) + "'";
                        }
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                hv_BestEvaluationComparisonKeysStr);
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                    //Validation value.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                "Best validation (value / epoch)");
                            hv_StatusEvaluationLeft.Dispose();
                            hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                ((hv_BestEvaluationValue.TupleString("0.3f")) + " / ") + (hv_BestEvaluationEpoch.TupleString(
                                "0.1f")));
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                    //Training value.
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Best training (value / epoch)");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                    ((hv_BestTrainEvaluationValue.TupleString("0.3f")) + " / ") + (hv_BestTrainEvaluationEpoch.TupleString(
                                    "0.1f")));
                                hv_StatusEvaluationRight.Dispose();
                                hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                            }
                        }
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationLeft = (new HTuple("Evaluation:")).TupleConcat(
                                "  " + hv_StatusEvaluationLeft);
                            hv_StatusEvaluationLeft.Dispose();
                            hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = (new HTuple(" ")).TupleConcat(
                                hv_StatusEvaluationRight);
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                }
                //
                //Train status.
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainLeft = new HTuple();
                hv_StatusTrainRight.Dispose();
                hv_StatusTrainRight = new HTuple();
                hv_EpochReal.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochReal);
                hv_NumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Epoch");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            ((hv_EpochReal.TupleString(".1f")) + " of ") + (hv_NumEpochs.TupleString(".1f")));
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Iteration");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            (hv_CurrentIteration + " of ") + hv_NumIterations);
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                hv_MeanLoss.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
                if ((int)(new HTuple((new HTuple(hv_MeanLoss.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_MeanLossStr.Dispose();
                    hv_MeanLossStr = "";
                }
                else
                {
                    hv_MeanLossStr.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanLossStr = hv_MeanLoss.TupleString(
                            "0.4f");
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Loss");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            hv_MeanLossStr);
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                //
                //Elapsed and remaining time.
                hv_TimeElapsedExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayData, "key_exists", "time_elapsed", out hv_TimeElapsedExists);
                if ((int)(hv_TimeElapsedExists.TupleNot()) != 0)
                {
                    //During training the key is not set and the time has to be determined.
                    hv_StartEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_epoch", out hv_StartEpoch);
                    hv_StartTime.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_time", out hv_StartTime);
                    hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                    estimate_progress(hv_StartTime, hv_StartEpoch, hv_EpochReal, hv_NumEpochs,
                        out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent,
                        out hv_ProgressPerSecond);
                    hv_TimeElapsedString.Dispose();
                    timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                    hv_TimeRemainingString.Dispose();
                    timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                                (new HTuple("Time elapsed")).TupleConcat("Time left"));
                            hv_StatusTrainLeft.Dispose();
                            hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusTrainRight = ((hv_StatusTrainRight.TupleConcat(
                                hv_TimeElapsedString))).TupleConcat(hv_TimeRemainingString);
                            hv_StatusTrainRight.Dispose();
                            hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                        }
                    }
                }
                else
                {
                    //For display after the finished training the key may be set.
                    //In case of a given value, display it.
                    hv_TimeElapsedString.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "time_elapsed", out hv_TimeElapsedString);
                    if ((int)(new HTuple(hv_TimeElapsedString.TupleNotEqual(""))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                                    "Time elapsed");
                                hv_StatusTrainLeft.Dispose();
                                hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                                    hv_TimeElapsedString);
                                hv_StatusTrainRight.Dispose();
                                hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                            }
                        }
                    }
                }
                //
                //Check if Device Status is there and combine it all together.
                hv_DeviceNameExists.Dispose();
                HOperatorSet.GetDictParam(hv_ModelParams, "key_exists", "device_name", out hv_DeviceNameExists);
                if ((int)(hv_DeviceNameExists) != 0)
                {
                    hv_DeviceName.Dispose();
                    HOperatorSet.GetDictTuple(hv_ModelParams, "device_name", out hv_DeviceName);
                    //Combine all with device name.
                    hv_StatusLeft.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StatusLeft = new HTuple();
                        hv_StatusLeft[0] = "train_dl_model";
                        hv_StatusLeft[1] = " ";
                        hv_StatusLeft[2] = " ";
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusTrainLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusEvaluationLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusModelParamsLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                    }
                    hv_StatusRight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StatusRight = new HTuple();
                        hv_StatusRight[0] = "Used Device:";
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_DeviceName);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusTrainRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusEvaluationRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusModelParamsRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                    }
                }
                else
                {
                    //Combine all without device name.
                    hv_StatusLeft.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StatusLeft = new HTuple();
                        hv_StatusLeft[0] = "train_dl_model";
                        hv_StatusLeft[1] = " ";
                        hv_StatusLeft[2] = " ";
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusTrainLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusEvaluationLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusModelParamsLeft);
                        hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                    }
                    hv_StatusRight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StatusRight = new HTuple();
                        hv_StatusRight[0] = " ";
                        hv_StatusRight[1] = " ";
                        hv_StatusRight[2] = " ";
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusTrainRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusEvaluationRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                        hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusModelParamsRight);
                        hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                    }
                }
                //
                //Cut strings with too many chars.
                hv_MaxChars.Dispose();
                hv_MaxChars = 20;
                for (hv_Index = 1; (int)hv_Index <= (int)((new HTuple(hv_StatusRight.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Str.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Str = hv_StatusRight.TupleSelect(
                            hv_Index);
                    }
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        hv_Length.Dispose();
                        HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
                        if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
                        {
                            hv_SubStr.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SubStr = (hv_Str.TupleSubstr(
                                    0, hv_MaxChars - 3)) + "...";
                            }
                            if (hv_StatusRight == null)
                                hv_StatusRight = new HTuple();
                            hv_StatusRight[hv_Index] = hv_SubStr;
                        }
                    }
                }
                //
                //Display the text.
                hv_WindowText.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusLeft, "window",
                        "top", "left", "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusRight, "window",
                        "top", "right", "black", "box", "false");
                }
                HOperatorSet.FlushBuffer(hv_WindowText);
                HOperatorSet.SetWindowParam(hv_WindowText, "flush", "true");
                hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                HOperatorSet.GetPart(hv_WindowText, out hv_Row1, out hv_Column1, out hv_Row2,
                    out hv_Column2);
                hv_WindowTextWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_width", out hv_WindowTextWidth);
                hv_WindowTextHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_height", out hv_WindowTextHeight);
                if ((int)((new HTuple(((hv_WindowTextWidth - 1)).TupleNotEqual(hv_Column2 - hv_Column1))).TupleOr(
                    new HTuple(((hv_WindowTextHeight - 1)).TupleNotEqual(hv_Row2 - hv_Row1)))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_Row1, hv_Column1,
                                (hv_Row1 + hv_WindowTextHeight) - 1, (hv_Column1 + hv_WindowTextWidth) - 1);
                        }
                    }
                }
                //
                ho_PlotBackground.Dispose();

                hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayParam.Dispose();
                hv_WindowText.Dispose();
                hv_WindowHandle.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_LastChange.Dispose();
                hv_Seconds.Dispose();
                hv_PlotEval.Dispose();
                hv_PlotFunctionExists.Dispose();
                hv_PlotFunction.Dispose();
                hv_ModelType.Dispose();
                hv_TextPlot.Dispose();
                hv_PlotTrainEval.Dispose();
                hv_HeadlineText.Dispose();
                hv_Indices.Dispose();
                hv_Index.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ClipRegionValue.Dispose();
                hv_PlotHeight.Dispose();
                hv_LegendRow.Dispose();
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceRight.Dispose();
                hv_PlotLearningRateStrategy.Dispose();
                hv_RightMargin.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Idx.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ChangeStrategyName.Dispose();
                hv_ChangeStrategiesValues.Dispose();
                hv_ChangeStrategiesInitial.Dispose();
                hv_StrategyMin.Dispose();
                hv_StrategyMax.Dispose();
                hv_LogLRMin.Dispose();
                hv_LogLRMax.Dispose();
                hv_LRScale.Dispose();
                hv_LROffset.Dispose();
                hv_LogLROffset.Dispose();
                hv_StartYLearningRate.Dispose();
                hv_EndYLearningRate.Dispose();
                hv_TicksYLearningRate.Dispose();
                hv_LogYLearningRate.Dispose();
                hv_LRColor.Dispose();
                hv_LRLineWidth.Dispose();
                hv_LRTextLegend.Dispose();
                hv_TopMarginPlots.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_Iterations.Dispose();
                hv_NumEpochs.Dispose();
                hv_NumIterations.Dispose();
                hv_CurrentIteration.Dispose();
                hv_XAxisLabel.Dispose();
                hv_ValuesX.Dispose();
                hv_TicksX.Dispose();
                hv_EvalValuesX.Dispose();
                hv_EvalTicksX.Dispose();
                hv_TitleX.Dispose();
                hv_EvalIterations.Dispose();
                hv_EvalValuesMin.Dispose();
                hv_EvalValuesMax.Dispose();
                hv_TicksY.Dispose();
                hv_StartY.Dispose();
                hv_EndY.Dispose();
                hv_YAxisLabel.Dispose();
                hv_BestEvaluationData.Dispose();
                hv_BestEvaluationComparisonKeys.Dispose();
                hv_StringExtendsLegendRight.Dispose();
                hv_Bullet.Dispose();
                hv_Line.Dispose();
                hv_YAxisTitle.Dispose();
                hv_Offset.Dispose();
                hv_LogMin.Dispose();
                hv_LogMax.Dispose();
                hv_Scale.Dispose();
                hv_LogOffset.Dispose();
                hv_LogY.Dispose();
                hv_TextModelParams.Dispose();
                hv_ModelParams.Dispose();
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsRight.Dispose();
                hv_ParName.Dispose();
                hv_Tuple.Dispose();
                hv_Exception.Dispose();
                hv_TupleStr.Dispose();
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationRight.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationEpoch.Dispose();
                hv_BestTrainEvaluationValue.Dispose();
                hv_BestTrainEvaluationInfo.Dispose();
                hv_BestTrainEvaluationEpoch.Dispose();
                hv_BestEvaluationComparisonKeysStr.Dispose();
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainRight.Dispose();
                hv_EpochReal.Dispose();
                hv_MeanLoss.Dispose();
                hv_MeanLossStr.Dispose();
                hv_TimeElapsedExists.Dispose();
                hv_StartEpoch.Dispose();
                hv_StartTime.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();
                hv_DeviceNameExists.Dispose();
                hv_DeviceName.Dispose();
                hv_StatusLeft.Dispose();
                hv_StatusRight.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_PlotBackground.Dispose();

                hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayParam.Dispose();
                hv_WindowText.Dispose();
                hv_WindowHandle.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_LastChange.Dispose();
                hv_Seconds.Dispose();
                hv_PlotEval.Dispose();
                hv_PlotFunctionExists.Dispose();
                hv_PlotFunction.Dispose();
                hv_ModelType.Dispose();
                hv_TextPlot.Dispose();
                hv_PlotTrainEval.Dispose();
                hv_HeadlineText.Dispose();
                hv_Indices.Dispose();
                hv_Index.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ClipRegionValue.Dispose();
                hv_PlotHeight.Dispose();
                hv_LegendRow.Dispose();
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceRight.Dispose();
                hv_PlotLearningRateStrategy.Dispose();
                hv_RightMargin.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Idx.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ChangeStrategyName.Dispose();
                hv_ChangeStrategiesValues.Dispose();
                hv_ChangeStrategiesInitial.Dispose();
                hv_StrategyMin.Dispose();
                hv_StrategyMax.Dispose();
                hv_LogLRMin.Dispose();
                hv_LogLRMax.Dispose();
                hv_LRScale.Dispose();
                hv_LROffset.Dispose();
                hv_LogLROffset.Dispose();
                hv_StartYLearningRate.Dispose();
                hv_EndYLearningRate.Dispose();
                hv_TicksYLearningRate.Dispose();
                hv_LogYLearningRate.Dispose();
                hv_LRColor.Dispose();
                hv_LRLineWidth.Dispose();
                hv_LRTextLegend.Dispose();
                hv_TopMarginPlots.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_Iterations.Dispose();
                hv_NumEpochs.Dispose();
                hv_NumIterations.Dispose();
                hv_CurrentIteration.Dispose();
                hv_XAxisLabel.Dispose();
                hv_ValuesX.Dispose();
                hv_TicksX.Dispose();
                hv_EvalValuesX.Dispose();
                hv_EvalTicksX.Dispose();
                hv_TitleX.Dispose();
                hv_EvalIterations.Dispose();
                hv_EvalValuesMin.Dispose();
                hv_EvalValuesMax.Dispose();
                hv_TicksY.Dispose();
                hv_StartY.Dispose();
                hv_EndY.Dispose();
                hv_YAxisLabel.Dispose();
                hv_BestEvaluationData.Dispose();
                hv_BestEvaluationComparisonKeys.Dispose();
                hv_StringExtendsLegendRight.Dispose();
                hv_Bullet.Dispose();
                hv_Line.Dispose();
                hv_YAxisTitle.Dispose();
                hv_Offset.Dispose();
                hv_LogMin.Dispose();
                hv_LogMax.Dispose();
                hv_Scale.Dispose();
                hv_LogOffset.Dispose();
                hv_LogY.Dispose();
                hv_TextModelParams.Dispose();
                hv_ModelParams.Dispose();
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsRight.Dispose();
                hv_ParName.Dispose();
                hv_Tuple.Dispose();
                hv_Exception.Dispose();
                hv_TupleStr.Dispose();
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationRight.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationEpoch.Dispose();
                hv_BestTrainEvaluationValue.Dispose();
                hv_BestTrainEvaluationInfo.Dispose();
                hv_BestTrainEvaluationEpoch.Dispose();
                hv_BestEvaluationComparisonKeysStr.Dispose();
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainRight.Dispose();
                hv_EpochReal.Dispose();
                hv_MeanLoss.Dispose();
                hv_MeanLossStr.Dispose();
                hv_TimeElapsedExists.Dispose();
                hv_StartEpoch.Dispose();
                hv_StartTime.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();
                hv_DeviceNameExists.Dispose();
                hv_DeviceName.Dispose();
                hv_StatusLeft.Dispose();
                hv_StatusRight.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of weights. 
        private void dev_display_weight_regions(HObject ho_ImageWeight, HTuple hv_DrawTransparency,
            HTuple hv_SegMaxWeight, out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Domain, ho_WeightsRegion = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the weights
                //given in ImageWeight as regions.
                //The transparency can be adjusted.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
                    hv_Colors.Dispose();
                    hv_Colors = ExpTmpOutVar_0;
                }
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                //
                //Get gay values of ImageWeight.
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
                hv_GrayVal.Dispose();
                HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
                //
                //Check that the gray values of the image
                //are below the specified maximum.
                if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
                {
                    throw new HalconException(((("The maximum weight (" + (hv_GrayVal.TupleMax()
                        )) + ") in the weight image is greater than the given SegMaxWeight (") + hv_SegMaxWeight) + ").");
                }
                //
                while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Go through all gray value 'groups',
                    //starting from the maximum.
                    hv_GrayValWeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrayValWeight = hv_GrayVal.TupleMax()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
                                hv_GrayVal.TupleFind(hv_GrayValWeight));
                            hv_GrayVal.Dispose();
                            hv_GrayVal = ExpTmpLocalVar_GrayVal;
                        }
                    }
                    ho_WeightsRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight,
                        hv_GrayValWeight);
                    //
                    //Visualize the respective group.
                    hv_ColorIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorIndex = (((((hv_GrayValWeight / hv_SegMaxWeight) * (hv_NumColors - 1))).TupleCeil()
                            )).TupleInt();
                    }
                    hv_ClassColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
                            hv_ColorIndex);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
                    }
                }
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
        public void dev_open_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandle = new HTuple();
            try
            {
                //This procedure open a new graphic window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
                HDevWindowStack.Push(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Resize a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
        public void dev_resize_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure adjusts the size of the current window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column,
                        hv_WindowWidth, hv_WindowHeight);
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Switch dev_update_pc, dev_update_var, and dev_update_window to 'off'. 
        public void dev_update_off()
        {

            // Initialize local and output iconic variables 
            //This procedure sets different update settings to 'off'.
            //This is useful to get the best performance and reduce overhead.
            //
            // dev_update_pc(...); only in hdevelop
            // dev_update_var(...); only in hdevelop
            // dev_update_window(...); only in hdevelop


            return;
        }

        // Chapter: System / Operating System
        // Short Description: Estimate the remaining time for a task given the current progress. 
        public void estimate_progress(HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent,
            HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining,
            out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
            HTuple hv_ProgressRemaining = new HTuple();
            // Initialize local and output iconic variables 
            hv_SecondsElapsed = new HTuple();
            hv_SecondsRemaining = new HTuple();
            hv_ProgressPercent = new HTuple();
            hv_ProgressPerSecond = new HTuple();
            try
            {
                //
                //This procedure estimates the remaining time in seconds,
                //given a start time and a progress value.
                //
                //Get current time.
                hv_SecondsNow.Dispose();
                HOperatorSet.CountSeconds(out hv_SecondsNow);
                //
                //Get elapsed time span.
                hv_SecondsElapsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsElapsed = hv_SecondsNow - hv_SecondsStart;
                }
                //
                //A very small additive constant to avoid division by zero.
                hv_Epsilon.Dispose();
                hv_Epsilon = 1e-6;
                //
                //Estimate remaining time based on elapsed time.
                hv_ProgressRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressRemaining = hv_ProgressMax - hv_ProgressCurrent;
                }
                hv_ProgressPerSecond.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPerSecond = (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        ) / ((hv_SecondsElapsed.TupleReal()) + hv_Epsilon);
                }
                hv_SecondsRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsRemaining = hv_ProgressRemaining / (hv_ProgressPerSecond + hv_Epsilon);
                }
                //
                //Get current progress in percent.
                hv_ProgressPercent.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPercent = (100 * (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        )) / ((((hv_ProgressMax - hv_ProgressMin)).TupleReal()) + hv_Epsilon);
                }

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
        public void evaluate_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod,
            HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_ClassNames = new HTuple(), hv_Alphabet = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_InstanceTypeModel = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_IsInstanceSegmentation = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_ModelIgnoreClassIDs = new HTuple();
            HTuple hv_ShowProgress = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_OptionalKeyNames = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_AnomalyClassificationThresholds = new HTuple();
            HTuple hv_EvaluateMask = new HTuple(), hv_Value = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_ClassInfoExists = new HTuple(), hv_DatasetClassIDs = new HTuple();
            HTuple hv_ClassIDsToClassNames = new HTuple(), hv_EvaluateClassNames = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_NumBatches = new HTuple();
            HTuple hv_RunningMeasures = new HTuple(), hv_Outputs = new HTuple();
            HTuple hv_EvalGCAnomalyNetworks = new HTuple(), hv_ModelGCAnomalyNetworks = new HTuple();
            HTuple hv_DefaultRequested = new HTuple(), hv_EvalAnomalyNetworkIndex = new HTuple();
            HTuple hv_EvalGCAnomalyNetwork = new HTuple(), hv_FindIndex = new HTuple();
            HTuple hv_Progress = new HTuple(), hv_TaskInfo = new HTuple();
            HTuple hv_SecondsStart = new HTuple(), hv_BatchIndex = new HTuple();
            HTuple hv_BatchStart = new HTuple(), hv_BatchEnd = new HTuple();
            HTuple hv_SamplesIndicesBatch = new HTuple(), hv_DLSamplesBatch = new HTuple();
            HTuple hv_DLResultsBatch = new HTuple(), hv_SecondsElapsed = new HTuple();
            HTuple hv_SecondsRemaining = new HTuple(), hv_ProgressPercent = new HTuple();
            HTuple hv_ProgressPerSecond = new HTuple(), hv_TimeElapsedString = new HTuple();
            HTuple hv_TimeRemainingString = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            hv_EvalParams = new HTuple();
            try
            {
                //This procedure applies the model given by DLModelHandle on the selected samples
                //of DLDataset and evaluates the results against the ground truth annotations
                //to calculate evaluation measures.
                //
                //Input:
                // - DLDataset.
                // - DLModelHandle.
                // - SampleSelectMethod: Method by which the samples are selected.
                // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
                //                       for the corresponding selection method.
                // - GenParam: Parameters of the evaluation that should be changed from the default.
                //
                //Output:
                // - EvaluationResult: Dictionary containing the output measures.
                // - EvalParams: Dictionary with the used evaluation parameters.
                //
                //** Initialization: ***
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual(
                    "3d_gripping_point_detection"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "anomaly_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "classification"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("gc_anomaly_detection"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "ocr_recognition"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("segmentation")))) != 0)
                {
                    throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
                }
                //
                //Check if model has been normalized, if required by model type.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                {
                    check_dl_gc_anomaly_scores_normalization(hv_DLModelHandle, new HTuple());
                }
                //
                //Get the class IDs as set in the model.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    //Only the gripping_map class is evaluated.
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassIDs = hv_ClassIDs.TupleSelect(
                                hv_ClassNames.TupleFind("gripping_map"));
                            hv_ClassIDs.Dispose();
                            hv_ClassIDs = ExpTmpLocalVar_ClassIDs;
                        }
                    }
                }
                else if ((int)((new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    //Default for anomaly detection and Global Context Anomaly Detection is 0,1.
                    hv_ClassIDs.Dispose();
                    hv_ClassIDs = new HTuple();
                    hv_ClassIDs[0] = 0;
                    hv_ClassIDs[1] = 1;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    //No Class IDs in case of ocr_recognition models
                    hv_Alphabet.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "alphabet", out hv_Alphabet);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.TupleGenSequence(0, new HTuple(hv_Alphabet.TupleLength()), 1,
                            out hv_ClassIDs);
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    //Default for ocr_detection. Only evaluate word.
                    //0: word, 1: char, 2: ignore
                    hv_ClassIDs.Dispose();
                    hv_ClassIDs = 0;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                }
                //
                //Get the batch size as set in the model.
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                //
                //Generate default parameters.
                hv_EvalParams.Dispose();
                create_evaluation_default_param(hv_ModelType, hv_ClassIDs, out hv_EvalParams);
                //
                //Get model specific information.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    try
                    {
                        hv_InstanceTypeModel.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceTypeModel);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_InstanceTypeModel.Dispose();
                        hv_InstanceTypeModel = "rectangle1";
                    }
                    hv_IsInstanceSegmentation.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_segmentation", out hv_IsInstanceSegmentation);
                    if ((int)(new HTuple(hv_IsInstanceSegmentation.TupleEqual("true"))) != 0)
                    {
                        hv_InstanceType.Dispose();
                        hv_InstanceType = "mask";
                    }
                    else
                    {
                        hv_InstanceType.Dispose();
                        hv_InstanceType = new HTuple(hv_InstanceTypeModel);
                    }
                    //Note, these are the defaults. If the user specifies
                    //'evaluate_mask' as false, the evaluation will use
                    //the instance type of the model (InstanceTypeModel).
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_ModelIgnoreClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
                }
                //
                //By default we do not show the progress of evaluation.
                hv_ShowProgress.Dispose();
                hv_ShowProgress = 0;
                //
                //Set user specified parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                    hv_OptionalKeyNames.Dispose();
                    hv_OptionalKeyNames = new HTuple();
                    hv_OptionalKeyNames[0] = "measures";
                    hv_OptionalKeyNames[1] = "evaluation_type";
                    hv_OptionalKeyNames[2] = "class_ids";
                    hv_OptionalKeyNames[3] = "num_classes";
                    hv_OptionalKeyNames[4] = "evaluate_instances";
                    hv_OptionalKeyNames[5] = "gc_anomaly_networks";
                    hv_OptionalKeyNames[6] = "gripping_point_params";
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "show_progress"))) != 0)
                        {
                            //Show the progress of the evaluation.
                            hv_ShowProgress.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                                        "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
                                    hv_ShowProgress.Dispose();
                                    hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
                                }
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "iou_threshold"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                            new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set IoU threshold.
                            hv_IoUThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "max_num_detections"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                            "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set maximal number detections.
                            hv_MaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "area_ranges"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(
                            new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set area ranges.
                            hv_AreaRanges.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "detailed_evaluation"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                            "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set detailed evaluation.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "allocation_block_length"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                            "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set length of blocks that are allocated during evaluation.
                            hv_AllocationBlockLength.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "interpolate_pr_curves"))).TupleAnd((new HTuple(hv_ModelType.TupleEqual(
                            "detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))))) != 0)
                        {
                            //Set interpolation of precision-recall curves.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "interpolate_pr_curves", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
                        {
                            //Set ignore class IDs.
                            hv_IgnoreClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                            //Merge the specified ignore class IDs with the model ignore class IDs.
                            hv_AllIgnoreClassIDs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
                                    hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
                            }
                            HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
                            //Remove the ignore class IDs from the model class IDs.
                            hv_EvaluateClassIDs.Dispose();
                            HOperatorSet.TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
                                    ));
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_names_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class names to be used in evaluation.
                            //To transform the names to IDs later, one has to remember the class names.
                            hv_ClassesToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names_to_evaluate", hv_ClassesToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_ClassNames);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_ids_to_evaluate");
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class IDs to be used in evaluation.
                            hv_ClassIDsToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_names_to_evaluate");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_classification_thresholds"))) != 0)
                        {
                            //Set anomaly classification threshold for confusion matrices.
                            hv_AnomalyClassificationThresholds.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_classification_thresholds",
                                out hv_AnomalyClassificationThresholds);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                                hv_AnomalyClassificationThresholds);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluate_mask"))) != 0)
                        {
                            hv_EvaluateMask.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluate_mask", out hv_EvaluateMask);
                            if ((int)(hv_EvaluateMask.TupleNot()) != 0)
                            {
                                hv_InstanceType.Dispose();
                                hv_InstanceType = new HTuple(hv_InstanceTypeModel);
                            }
                        }
                        else if ((int)(new HTuple(((hv_OptionalKeyNames.TupleFind(hv_GenParamKeys.TupleSelect(
                            hv_GenParamIndex)))).TupleNotEqual(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Value.Dispose();
                                HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamKeys.TupleSelect(hv_GenParamIndex),
                                    out hv_Value);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, hv_GenParamKeys.TupleSelect(
                                    hv_GenParamIndex), hv_Value);
                            }
                        }
                        else
                        {
                            throw new HalconException(("Unknown parameter : '" + (hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex))) + "'");
                        }
                    }
                }
                //
                //Finally specify the detection evaluation based on all given parameters and defaults.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("mask"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_mask", 1);
                        hv_Measures.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleDifference(
                                "soap"));
                        }
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_mask", 0);
                    }
                    //Overwrite instance_type
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", hv_InstanceType);
                    //For rectangle2 detection with ignore_direction set to false, we also evaluate the
                    //precision of the predicted angle using the Score of Angle Precision (SoAP).
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                        {
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleConcat(
                                    "soap"));
                            }
                        }
                    }
                }
                //
                //Set class names.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", "gripping_map");
                }
                else
                {
                    //Get the class names from the dataset if present.
                    hv_ClassInfoExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
                        "class_ids"), out hv_ClassInfoExists);
                    if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
                        )))) != 0)
                    {
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                        hv_DatasetClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
                        //Set the class names only for the class IDs that are evaluated.
                        hv_EvaluateClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
                        hv_ClassIDsToClassNames.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassIDsToClassNames = HTuple.TupleGenConst(
                                (hv_DatasetClassIDs.TupleMax()) + 1, "");
                        }
                        if (hv_ClassIDsToClassNames == null)
                            hv_ClassIDsToClassNames = new HTuple();
                        hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
                        if ((int)(new HTuple((new HTuple(hv_EvaluateClassIDs.TupleLength())).TupleEqual(
                            new HTuple(hv_ClassNames.TupleLength())))) != 0)
                        {
                            hv_EvaluateClassNames.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
                                    hv_EvaluateClassIDs);
                            }
                            //Set the class names to EvalParams.
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
                        }
                    }
                }
                //
                //Get indices of samples to read from the dataset.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                //
                //Check if there are samples present in the dataset.
                if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
                {
                    throw new HalconException("The provided set of samples in the dataset must be non-empty.");
                }
                //
                //Check for empty SampleSelectValues.
                if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
                    }
                    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
                    }
                    else
                    {
                        throw new HalconException("Provide a name for 'split' selection.");
                    }
                }
                //
                //
                //Get the sample indices according to the sample selection method.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
                {
                    //Get the samples of the split specified.
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                {
                    //Get the samples specified by 'image_ids'.
                    if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
                        new HTuple(hv_DLSamples.TupleLength())))) != 0)
                    {
                        throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                {
                    //Get the samples specified by 'sample_indices'.
                    if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
                        new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
                        )) - 1)))) != 0)
                    {
                        throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = new HTuple(hv_SampleSelectValues);
                }
                else
                {
                    throw new HalconException(("Unknown sample selection method : '" + hv_SampleSelectMethod) + "'");
                }
                //
                //Get the number of batches.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
                        );
                }
                hv_NumBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumBatches = ((((hv_NumSamples / (hv_BatchSize.TupleReal()
                        ))).TupleCeil())).TupleInt();
                }
                //
                //Check for empty samples selected by the selection method.
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException(("No samples present in the dataset that are part of the '" + hv_SampleSelectMethod) + "' selection.");
                }
                //
                //
                //** Running measures are initialized according to evaluation method.
                //
                hv_RunningMeasures.Dispose();
                init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
                //
                //
                //** Apply model to each image and gather evaluation information: ***
                //
                //Use alternative outputs if requested.
                hv_Outputs.Dispose();
                hv_Outputs = new HTuple();
                //
                if ((int)((new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))).TupleAnd(
                    new HTuple(hv_GenParam.TupleNotEqual(new HTuple())))) != 0)
                {
                    //
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "gc_anomaly_networks",
                        out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_EvalGCAnomalyNetworks.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "gc_anomaly_networks", out hv_EvalGCAnomalyNetworks);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvalGCAnomalyNetworks = hv_EvalGCAnomalyNetworks.TupleSort()
                                    ;
                                hv_EvalGCAnomalyNetworks.Dispose();
                                hv_EvalGCAnomalyNetworks = ExpTmpLocalVar_EvalGCAnomalyNetworks;
                            }
                        }
                        hv_ModelGCAnomalyNetworks.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", out hv_ModelGCAnomalyNetworks);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ModelGCAnomalyNetworks = hv_ModelGCAnomalyNetworks.TupleSort()
                                    ;
                                hv_ModelGCAnomalyNetworks.Dispose();
                                hv_ModelGCAnomalyNetworks = ExpTmpLocalVar_ModelGCAnomalyNetworks;
                            }
                        }
                        //
                        hv_DefaultRequested.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DefaultRequested = (new HTuple((new HTuple(hv_EvalGCAnomalyNetworks.TupleLength()
                                )).TupleEqual(0))).TupleOr(new HTuple(hv_EvalGCAnomalyNetworks.TupleEqual(
                                hv_ModelGCAnomalyNetworks)));
                        }
                        for (hv_EvalAnomalyNetworkIndex = 0; (int)hv_EvalAnomalyNetworkIndex <= (int)((new HTuple(hv_EvalGCAnomalyNetworks.TupleLength()
                            )) - 1); hv_EvalAnomalyNetworkIndex = (int)hv_EvalAnomalyNetworkIndex + 1)
                        {
                            hv_EvalGCAnomalyNetwork.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EvalGCAnomalyNetwork = hv_EvalGCAnomalyNetworks.TupleSelect(
                                    hv_EvalAnomalyNetworkIndex);
                            }
                            hv_FindIndex.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FindIndex = hv_ModelGCAnomalyNetworks.TupleFind(
                                    hv_EvalGCAnomalyNetwork);
                            }
                            if ((int)((new HTuple(hv_FindIndex.TupleEqual(new HTuple()))).TupleOr(
                                new HTuple(hv_FindIndex.TupleEqual(-1)))) != 0)
                            {
                                throw new HalconException(("Invalid 'gc_anomaly_networks' requested. Model does not contain a " + hv_EvalGCAnomalyNetwork) + " network.");
                            }
                            if ((int)(hv_DefaultRequested.TupleNot()) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Outputs = hv_Outputs.TupleConcat(
                                            "anomaly_image_" + hv_EvalGCAnomalyNetwork);
                                        hv_Outputs.Dispose();
                                        hv_Outputs = ExpTmpLocalVar_Outputs;
                                    }
                                }
                            }
                        }
                    }
                }
                //
                //Initialize progress variables.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    hv_Progress[3] = "";
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_TaskInfo.Dispose();
                        hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
                                    hv_TaskInfo);
                                hv_Progress.Dispose();
                                hv_Progress = ExpTmpLocalVar_Progress;
                            }
                        }
                    }
                    hv_SecondsStart.Dispose();
                    HOperatorSet.CountSeconds(out hv_SecondsStart);
                    // dev_inspect_ctrl(...); only in hdevelop
                }
                //
                //Loop batchwise over the samples to be evaluated.
                HTuple end_val299 = hv_NumBatches - 1;
                HTuple step_val299 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val299, step_val299); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val299))
                {
                    hv_BatchStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                    }
                    hv_BatchEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                            hv_NumSamples - 1);
                    }
                    hv_SamplesIndicesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
                            hv_BatchStart, hv_BatchEnd);
                    }
                    //
                    //Read samples
                    hv_DLSamplesBatch.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
                    //
                    //Apply the model.
                    hv_DLResultsBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, hv_Outputs,
                        out hv_DLResultsBatch);
                    //
                    //Update the running measures.
                    update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                        hv_EvalParams, hv_RunningMeasures);
                    //
                    //Provide progress information.
                    if ((int)(hv_ShowProgress) != 0)
                    {
                        if ((int)((new HTuple(((hv_BatchIndex % 10)).TupleEqual(1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(
                            hv_NumBatches - 1)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                                estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches - 1,
                                    out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent,
                                    out hv_ProgressPerSecond);
                            }
                            hv_TimeElapsedString.Dispose();
                            timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                            hv_TimeRemainingString.Dispose();
                            timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                        }
                    }
                }
                //
                //Provide progress information.
                if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[1] = "Please wait...";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
                }
                //
                //
                //** Do the actual calculation of measures: ***
                //
                hv_EvaluationResult.Dispose();
                calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                //
                //Close progress inspect.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = "Done.";
                    // dev_close_inspect_ctrl(...); only in hdevelop
                }
                //

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNames.Dispose();
                hv_Alphabet.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceTypeModel.Dispose();
                hv_Exception.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_InstanceType.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_OptionalKeyNames.Dispose();
                hv_GenParamIndex.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyClassificationThresholds.Dispose();
                hv_EvaluateMask.Dispose();
                hv_Value.Dispose();
                hv_Measures.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Outputs.Dispose();
                hv_EvalGCAnomalyNetworks.Dispose();
                hv_ModelGCAnomalyNetworks.Dispose();
                hv_DefaultRequested.Dispose();
                hv_EvalAnomalyNetworkIndex.Dispose();
                hv_EvalGCAnomalyNetwork.Dispose();
                hv_FindIndex.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNames.Dispose();
                hv_Alphabet.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceTypeModel.Dispose();
                hv_Exception.Dispose();
                hv_IsInstanceSegmentation.Dispose();
                hv_InstanceType.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_OptionalKeyNames.Dispose();
                hv_GenParamIndex.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyClassificationThresholds.Dispose();
                hv_EvaluateMask.Dispose();
                hv_Value.Dispose();
                hv_Measures.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Outputs.Dispose();
                hv_EvalGCAnomalyNetworks.Dispose();
                hv_ModelGCAnomalyNetworks.Dispose();
                hv_DefaultRequested.Dispose();
                hv_EvalAnomalyNetworkIndex.Dispose();
                hv_EvalGCAnomalyNetwork.Dispose();
                hv_FindIndex.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Filter the instance segmentation masks of a DL sample based on a given selection. 
        private void filter_dl_sample_instance_segmentation_masks(HTuple hv_DLSample,
            HTuple hv_BBoxSelectionMask)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyMasks = null, ho_Masks = null;

            // Local control variables 

            HTuple hv_MaskKeyExists = new HTuple(), hv_Indices = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyMasks);
            HOperatorSet.GenEmptyObj(out ho_Masks);
            try
            {
                hv_MaskKeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "mask", out hv_MaskKeyExists);
                if ((int)(hv_MaskKeyExists) != 0)
                {
                    //Only if masks exist (-> instance segmentation).
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_BBoxSelectionMask, 1, out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
                    {
                        //We define here that this case will result in an empty object value
                        //for the mask key. Another option would be to remove the
                        //key 'mask'. However, this would be an unwanted big change in the dictionary.
                        ho_EmptyMasks.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_EmptyMasks);
                        HOperatorSet.SetDictObject(ho_EmptyMasks, hv_DLSample, "mask");
                    }
                    else
                    {
                        ho_Masks.Dispose();
                        HOperatorSet.GetDictObject(out ho_Masks, hv_DLSample, "mask");
                        //Remove all unused masks.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.SelectObj(ho_Masks, out ExpTmpOutVar_0, hv_Indices + 1);
                            ho_Masks.Dispose();
                            ho_Masks = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_Masks, hv_DLSample, "mask");
                    }
                }
                ho_EmptyMasks.Dispose();
                ho_Masks.Dispose();

                hv_MaskKeyExists.Dispose();
                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyMasks.Dispose();
                ho_Masks.Dispose();

                hv_MaskKeyExists.Dispose();
                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
        public void find_dl_samples(HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue,
            HTuple hv_Mode, out HTuple hv_SampleIndices)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumKeyValues = new HTuple(), hv_NumFound = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_Hit = new HTuple(), hv_ValueIndex = new HTuple();
            HTuple hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleIndices = new HTuple();
            try
            {
                //
                //This procedure gets the indices of the samples that contain the
                //requested KeyName matching the requested KeyValue according to the Mode.
                //If there is no match, an empty tuple [] will be returned.
                //
                //Check input parameters.
                if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid KeyName size: ") + (new HTuple(hv_KeyName.TupleLength()
                        )));
                }
                if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid Mode size: ") + (new HTuple(hv_Mode.TupleLength()
                        )));
                }
                if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
                    new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
                    "contain")))) != 0)
                {
                    throw new HalconException("Invalid Mode value: " + hv_Mode);
                }
                hv_NumKeyValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
                        );
                }
                if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
                    1)))) != 0)
                {
                    throw new HalconException("Invalid KeyValue size for contain Mode: " + hv_NumKeyValues);
                }
                //
                //Find the indices.
                hv_SampleIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SampleIndices = HTuple.TupleGenConst(
                        new HTuple(hv_Samples.TupleLength()), 0);
                }
                hv_NumFound.Dispose();
                hv_NumFound = 0;
                //
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
                        if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
                        {
                            //Mode 'match': Tuple must be equal KeyValue.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                                    hv_KeyValue));
                            }
                        }
                        else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
                            new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
                        {
                            //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                                    hv_Tuple))).TupleGreaterEqual(0));
                            }
                        }
                        else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
                        {
                            //Mode 'contain': Tuple must contain any of the elements in KeyValue.
                            HTuple end_val37 = hv_NumKeyValues - 1;
                            HTuple step_val37 = 1;
                            for (hv_ValueIndex = 0; hv_ValueIndex.Continue(end_val37, step_val37); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val37))
                            {
                                hv_Value.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value = hv_KeyValue.TupleSelect(
                                        hv_ValueIndex);
                                }
                                hv_Hit.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                                        hv_Value))).TupleGreaterEqual(0));
                                }
                                if ((int)(hv_Hit) != 0)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            //Unsupported configuration.
                            hv_Hit.Dispose();
                            hv_Hit = 0;
                        }
                        if ((int)(hv_Hit) != 0)
                        {
                            if (hv_SampleIndices == null)
                                hv_SampleIndices = new HTuple();
                            hv_SampleIndices[hv_NumFound] = hv_SampleIndex;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_NumFound = hv_NumFound + 1;
                                    hv_NumFound.Dispose();
                                    hv_NumFound = ExpTmpLocalVar_NumFound;
                                }
                            }
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
                            0, hv_NumFound - 1);
                        hv_SampleIndices.Dispose();
                        hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                    }
                }

                hv_NumKeyValues.Dispose();
                hv_NumFound.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumKeyValues.Dispose();
                hv_NumFound.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: XLD / Creation
        // Short Description: Create an arrow shaped XLD contour. 
        public void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
            HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
            HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
            HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
            HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            try
            {
                //This procedure generates arrow shaped XLD contours,
                //pointing from (Row1, Column1) to (Row2, Column2).
                //If starting and end point are identical, a contour consisting
                //of a single point is returned.
                //
                //input parameters:
                //Row1, Column1: Coordinates of the arrows' starting points
                //Row2, Column2: Coordinates of the arrows' end points
                //HeadLength, HeadWidth: Size of the arrow heads in pixels
                //
                //output parameter:
                //Arrow: The resulting XLD contour
                //
                //The input tuples Row1, Column1, Row2, and Column2 have to be of
                //the same length.
                //HeadLength and HeadWidth either have to be of the same length as
                //Row1, Column1, Row2, and Column2 or have to be a single element.
                //If one of the above restrictions is violated, an error will occur.
                //
                //
                //Initialization.
                ho_Arrow.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Arrow);
                //
                //Calculate the arrow length
                hv_Length.Dispose();
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
                //
                //Mark arrows with identical start and end point
                //(set Length to -1 to avoid division-by-zero exception)
                hv_ZeroLengthIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZeroLengthIndices = hv_Length.TupleFind(
                        0);
                }
                if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
                {
                    if (hv_Length == null)
                        hv_Length = new HTuple();
                    hv_Length[hv_ZeroLengthIndices] = -1;
                }
                //
                //Calculate auxiliary variables.
                hv_DR.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
                }
                hv_DC.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
                }
                hv_HalfHeadWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HalfHeadWidth = hv_HeadWidth / 2.0;
                }
                //
                //Calculate end points of the arrow head.
                hv_RowP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
                }
                hv_RowP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
                }
                //
                //Finally create output XLD contour for each input point pair
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                    {
                        //Create_ single points for arrows with identical start and end point
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                                hv_Index), hv_Column1.TupleSelect(hv_Index));
                        }
                    }
                    else
                    {
                        //Create arrow contour
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                                hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                                ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                                hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                        ho_Arrow.Dispose();
                        ho_Arrow = ExpTmpOutVar_0;
                    }
                }
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
        public void gen_confusion_matrix(HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
            HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
            HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
            HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
            HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
            HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
            HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
            HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
            HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
            HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
            HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
            HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_ConfusionMatrix = new HTuple();
            try
            {
                //This procedure computes a confusion matrix.
                //Therefore, it compares the classes
                //assigned in GroundTruthLabels and PredictedClasses.
                //The resulting confusion matrix can be
                //visualized, returned, or both.
                //In each case, the output can be changed
                //via generic parameters using GenParamName and GenParamValue.
                //For the visualization, the graphics window
                //must be specified with WindowHandle.
                //
                if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
                    new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
                {
                    throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
                }
                //
                //Set generic parameter defaults.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = "absolute";
                hv_ReturnMatrix.Dispose();
                hv_ReturnMatrix = "absolute";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = "true";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "minimal";
                //
                //Parse generic parameters.
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_matrix"))) != 0)
                    {
                        //Set 'display_matrix'.
                        hv_DisplayMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "return_matrix"))) != 0)
                    {
                        //Set 'return_matrix'.
                        hv_ReturnMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_color"))) != 0)
                    {
                        //Set 'display_color'.
                        hv_DisplayColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_column_width"))) != 0)
                    {
                        //Set 'display_column_width'.
                        hv_DisplayColumnWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
                    new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
                    "true")))) != 0)
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 1;
                }
                else
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 0;
                }
                //
                //Calculate the confusion matrix with absolute values
                //and the confusion matrix with relative errors.
                //We start with an empty matrix
                //and add the number of matching labels.
                hv_Classes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
                        )).TupleUniq();
                }
                hv_NumClasses.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
                        );
                }
                hv_AbsoluteMatrixID.Dispose();
                HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    hv_RelativeMatrixID.Dispose();
                    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
                }
                HTuple end_val55 = hv_NumClasses - 1;
                HTuple step_val55 = 1;
                for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
                {
                    hv_Class.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Class = hv_Classes.TupleSelect(
                            hv_ColumnMatrix);
                    }
                    hv_ThisLabel.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
                            hv_Class);
                    }
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        //Obtain the number of ground truth labels per class.
                        hv_NumClassGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
                                ;
                        }
                    }
                    HTuple end_val62 = hv_NumClasses - 1;
                    HTuple step_val62 = 1;
                    for (hv_RowMatrix = 0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
                    {
                        //Select classes for this row/column.
                        hv_PredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictedClass = hv_Classes.TupleSelect(
                                hv_RowMatrix);
                        }
                        //Check whether the input data
                        //corresponds to these classes.
                        hv_ThisPredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
                                hv_PredictedClass);
                        }
                        //Count the number of elements where the predicted class
                        //matches the ground truth label.
                        hv_NumMatches.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumMatches = ((((hv_ThisLabel + hv_ThisPredictedClass)).TupleEqualElem(
                                2))).TupleSum();
                        }
                        //Set value in matrix.
                        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                            hv_NumMatches);
                        if ((int)(hv_CalculateRelativeMatrix) != 0)
                        {
                            if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
                            {
                                hv_RelativeError.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_RelativeError = (hv_NumMatches.TupleReal()
                                        ) / hv_NumClassGroundTruth;
                                }
                            }
                            else
                            {
                                hv_RelativeError.Dispose();
                                hv_RelativeError = 0;
                            }
                            HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                                hv_RelativeError);
                        }
                    }
                }
                //
                //Return the result.
                if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
                {
                    //No matrix is returned.
                }
                else
                {
                    throw new HalconException("Unsupported mode for 'return_matrix'");
                }
                //
                //Display the matrix.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Find maximal string width and set display position parameters.
                    hv_StringWidths.Dispose();
                    hv_StringWidths = new HTuple();
                    //Get the string width of each class.
                    for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                    {
                        hv_String.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_String = hv_Classes.TupleSelect(
                                hv_StringIndex);
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                            out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_StringWidths.Dispose();
                                hv_StringWidths = ExpTmpLocalVar_StringWidths;
                            }
                        }
                    }
                    //The columns should have a minimum width for 4 characters.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                        out hv_StringWidth, out hv_StringHeight);
                    hv_MaxStringWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
                            )).TupleMax2(hv_StringWidth);
                    }
                    //Get the maximum string width
                    //and resize the window accordingly.
                    hv_RowStart.Dispose();
                    hv_RowStart = 80;
                    hv_RowDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowDistance = hv_StringHeight + 10;
                    }
                    hv_RowEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowEnd = hv_StringHeight * 7;
                    }
                    hv_ColumnStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnStart = 50 + hv_MaxStringWidth;
                    }
                    hv_ColumnOffset.Dispose();
                    hv_ColumnOffset = 20;
                    hv_ColumnEnd.Dispose();
                    hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                    //
                    //Adapt the window size to fit the confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                    {
                        //Every column of the confusion matrix is as narrow as possible
                        //based to the respective string widths.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_StringWidths.TupleSum()
                                ) + (hv_ColumnOffset * hv_NumClasses)) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                    {
                        //Every column of the confusion matrix should have the same width.
                        //based on the maximum string width.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumClasses) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else
                    {
                        throw new HalconException("");
                    }
                    hv_Height.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Height = ((hv_RowDistance * hv_NumClasses) + hv_RowStart) + hv_RowEnd;
                    }
                    HDevWindowStack.SetActive(hv_WindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //
                    //Set reasonable limits for graphics window (adapt if necessary).
                    hv_WidthLimit.Dispose();
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit[1] = 1920;
                    hv_HeightLimit.Dispose();
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit[1] = 1080;
                    if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
                        new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
                    {
                        throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
                    }
                    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                    //
                    //Get display coordinates.
                    //Get row coordinates for display.
                    hv_TextRow.Dispose();
                    hv_TextRow = new HTuple();
                    HTuple end_val145 = hv_NumClasses - 1;
                    HTuple step_val145 = 1;
                    for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                    HTuple.TupleGenSequence(0, (hv_NumClasses - 1) * hv_RowDistance, hv_RowDistance));
                                hv_TextRow.Dispose();
                                hv_TextRow = ExpTmpLocalVar_TextRow;
                            }
                        }
                    }
                    //Get column coordinates for display.
                    hv_TextColumn.Dispose();
                    hv_TextColumn = new HTuple();
                    HTuple end_val150 = hv_NumClasses - 1;
                    HTuple step_val150 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                    HTuple.TupleGenConst(hv_NumClasses, hv_ColumnStart));
                                hv_TextColumn.Dispose();
                                hv_TextColumn = ExpTmpLocalVar_TextColumn;
                            }
                        }
                        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + (hv_StringWidths.TupleSelect(
                                        hv_Index))) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
                            "equal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + hv_MaxStringWidth) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                    }
                    //Display the confusion matrix with a margin from the top.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    //Display axis titles.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels",
                            "window", "top", "right", "white", "box", "false");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes",
                            "window", "bottom", "left", "white", "box", "false");
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_Classes.TupleSelect(
                                hv_Index);
                        }
                        //Display predicted class names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = hv_TextRow.TupleSelect(
                                hv_Index);
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                        //Display ground truth label names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = (hv_TextRow.TupleSelect(
                                0)) - hv_RowDistance;
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = hv_TextColumn.TupleSelect(
                                hv_Index * hv_NumClasses);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                    }
                    //
                    //Get the confusion matrix values for display.
                    if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_AbsoluteTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
                        //Align the numbers right.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        HOperatorSet.ClearMatrix(hv_MatrixMaxID);
                        hv_StringConversion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StringConversion = (((((hv_MaxValue.TupleLog10()
                                )).TupleCeil())).TupleInt()) + ".0f";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    hv_StringConversion);
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    else
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    ".2f");
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    //Set color for displayed confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666",
                                out hv_TextColor);
                        }
                        //Use the relative values to adapt the color of the text.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_RelativeValues.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        //Set the colors and respective thresholds for the off-diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = 0.0;
                        hv_Thresholds[1] = 0.05;
                        hv_Thresholds[2] = 0.1;
                        hv_Thresholds[3] = 0.2;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#8C4D4D";
                        hv_Colors[1] = "#B33333";
                        hv_Colors[2] = "#D91A1A";
                        hv_Colors[3] = "#FF0000";
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Greater.Dispose();
                                HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                                    hv_Index), out hv_Greater);
                            }
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
                            if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                                        hv_Index), out ExpTmpOutVar_0);
                                    hv_TextColor.Dispose();
                                    hv_TextColor = ExpTmpOutVar_0;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        //Set the colors and respective thresholds for the diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = -0.01;
                        hv_Thresholds[1] = 0.60;
                        hv_Thresholds[2] = 0.80;
                        hv_Thresholds[3] = 0.90;
                        hv_Thresholds[4] = 0.95;
                        hv_Thresholds[5] = 0.98;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#666666";
                        hv_Colors[1] = "#508650";
                        hv_Colors[2] = "#419C41";
                        hv_Colors[3] = "#2BBD2B";
                        hv_Colors[4] = "#15DE15";
                        hv_Colors[5] = "#00FF00";
                        HTuple end_val216 = hv_NumClasses - 1;
                        HTuple step_val216 = 1;
                        for (hv_DiagonalIndex = 0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex,
                                out hv_Value);
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                                    hv_Index)))) != 0)
                                {
                                    if (hv_TextColor == null)
                                        hv_TextColor = new HTuple();
                                    hv_TextColor[hv_DiagonalIndex * (hv_NumClasses + 1)] = hv_Colors.TupleSelect(
                                        hv_Index);
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        //Default value for the text color.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white",
                                out hv_TextColor);
                        }
                    }
                    //
                    //Display confusion matrix.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window",
                            hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
                    }
                    //
                    //Clean up.
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
                    }
                    HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
                }

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Generate gripping points for connected regions of high gripping confidence. 
        private void gen_dl_3d_gripping_point_image_coord(HObject ho_GrippingMap, out HObject ho_Regions,
            HTuple hv_MinAreaSize, out HTuple hv_Rows, out HTuple hv_Columns)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TmpRegions, ho_FilteredRegions;
            HObject ho_ConnectedRegions, ho_SelectedRegions, ho_Skeletons;
            HObject ho_OrigRegion = null, ho_Skeleton = null, ho_SkeletonIntersection = null;
            HObject ho_Contours = null, ho_ContourRegions = null, ho_ContourSelected = null;
            HObject ho_RegionSelected = null, ho_CenterRegion = null;

            // Local control variables 

            HTuple hv_GapClosingRadius = new HTuple();
            HTuple hv_NumDilationRuns = new HTuple(), hv_NumRegions = new HTuple();
            HTuple hv_RegionIdx = new HTuple(), hv_Area = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Radius = new HTuple(), hv_RadiusIndex = new HTuple();
            HTuple hv_Dilation = new HTuple(), hv_Rows1 = new HTuple();
            HTuple hv_Columns1 = new HTuple(), hv_RowOut = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_SelectedColumns = new HTuple();
            HTuple hv_ColumnOut = new HTuple(), hv_NumContours = new HTuple();
            HTuple hv_CandidateRows = new HTuple(), hv_CandidateCols = new HTuple();
            HTuple hv_ContourIdx = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_MinDistance = new HTuple();
            HTuple hv_RowCandidate = new HTuple(), hv_ColumnCandidate = new HTuple();
            HTuple hv_RowUnused = new HTuple(), hv_ColumnUnused = new HTuple();
            HTuple hv_MinDist = new HTuple(), hv_MaxDist = new HTuple();
            HTuple hv_Indices1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_TmpRegions);
            HOperatorSet.GenEmptyObj(out ho_FilteredRegions);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_Skeletons);
            HOperatorSet.GenEmptyObj(out ho_OrigRegion);
            HOperatorSet.GenEmptyObj(out ho_Skeleton);
            HOperatorSet.GenEmptyObj(out ho_SkeletonIntersection);
            HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out ho_ContourRegions);
            HOperatorSet.GenEmptyObj(out ho_ContourSelected);
            HOperatorSet.GenEmptyObj(out ho_RegionSelected);
            HOperatorSet.GenEmptyObj(out ho_CenterRegion);
            hv_Rows = new HTuple();
            hv_Columns = new HTuple();
            try
            {
                //
                //This procedure extracts connected regions from the gripping
                //map and generates a single gripping point near the center
                //of each of those regions.
                //
                hv_GapClosingRadius.Dispose();
                hv_GapClosingRadius = 3.5;
                hv_NumDilationRuns.Dispose();
                hv_NumDilationRuns = 5;
                //
                //Compute regions (connected components).
                ho_TmpRegions.Dispose();
                HOperatorSet.Threshold(ho_GrippingMap, out ho_TmpRegions, 0.5, 1);
                //
                //Close small gaps inside regions to get a nicer skeleton.
                ho_FilteredRegions.Dispose();
                HOperatorSet.ClosingCircle(ho_TmpRegions, out ho_FilteredRegions, hv_GapClosingRadius);
                //
                ho_ConnectedRegions.Dispose();
                HOperatorSet.Connection(ho_FilteredRegions, out ho_ConnectedRegions);
                //
                //Filter for regions smaller than RegionThreshold.
                ho_SelectedRegions.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area",
                    "and", hv_MinAreaSize, "max");
                hv_NumRegions.Dispose();
                HOperatorSet.CountObj(ho_SelectedRegions, out hv_NumRegions);
                if ((int)(new HTuple(hv_NumRegions.TupleLess(1))) != 0)
                {
                    ho_Regions.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_Regions);
                    hv_Rows.Dispose();
                    hv_Rows = new HTuple();
                    hv_Columns.Dispose();
                    hv_Columns = new HTuple();
                    ho_TmpRegions.Dispose();
                    ho_FilteredRegions.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho_SelectedRegions.Dispose();
                    ho_Skeletons.Dispose();
                    ho_OrigRegion.Dispose();
                    ho_Skeleton.Dispose();
                    ho_SkeletonIntersection.Dispose();
                    ho_Contours.Dispose();
                    ho_ContourRegions.Dispose();
                    ho_ContourSelected.Dispose();
                    ho_RegionSelected.Dispose();
                    ho_CenterRegion.Dispose();

                    hv_GapClosingRadius.Dispose();
                    hv_NumDilationRuns.Dispose();
                    hv_NumRegions.Dispose();
                    hv_RegionIdx.Dispose();
                    hv_Area.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Radius.Dispose();
                    hv_RadiusIndex.Dispose();
                    hv_Dilation.Dispose();
                    hv_Rows1.Dispose();
                    hv_Columns1.Dispose();
                    hv_RowOut.Dispose();
                    hv_Indices.Dispose();
                    hv_SelectedColumns.Dispose();
                    hv_ColumnOut.Dispose();
                    hv_NumContours.Dispose();
                    hv_CandidateRows.Dispose();
                    hv_CandidateCols.Dispose();
                    hv_ContourIdx.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_MinDistance.Dispose();
                    hv_RowCandidate.Dispose();
                    hv_ColumnCandidate.Dispose();
                    hv_RowUnused.Dispose();
                    hv_ColumnUnused.Dispose();
                    hv_MinDist.Dispose();
                    hv_MaxDist.Dispose();
                    hv_Indices1.Dispose();

                    return;
                }
                //
                //Determine gripping point based on skeleton per region.
                ho_Skeletons.Dispose();
                HOperatorSet.Skeleton(ho_SelectedRegions, out ho_Skeletons);
                hv_Rows.Dispose();
                HOperatorSet.TupleGenConst(hv_NumRegions, 0, out hv_Rows);
                hv_Columns.Dispose();
                HOperatorSet.TupleGenConst(hv_NumRegions, 0, out hv_Columns);
                ho_Regions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Regions);
                HTuple end_val31 = hv_NumRegions;
                HTuple step_val31 = 1;
                for (hv_RegionIdx = 1; hv_RegionIdx.Continue(end_val31, step_val31); hv_RegionIdx = hv_RegionIdx.TupleAdd(step_val31))
                {
                    ho_OrigRegion.Dispose();
                    HOperatorSet.SelectObj(ho_SelectedRegions, out ho_OrigRegion, hv_RegionIdx);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Intersection(ho_OrigRegion, ho_TmpRegions, out ExpTmpOutVar_0
                            );
                        ho_OrigRegion.Dispose();
                        ho_OrigRegion = ExpTmpOutVar_0;
                    }
                    ho_Skeleton.Dispose();
                    HOperatorSet.SelectObj(ho_Skeletons, out ho_Skeleton, hv_RegionIdx);
                    //
                    //Reduce skeleton and region produced by contours by original
                    //region (if skeleton used pixels added by closing circle).
                    ho_SkeletonIntersection.Dispose();
                    HOperatorSet.Intersection(ho_Skeleton, ho_OrigRegion, out ho_SkeletonIntersection
                        );
                    //
                    //Check if skeleton lies outside valid region
                    hv_Area.Dispose(); hv_Row1.Dispose(); hv_Column1.Dispose();
                    HOperatorSet.AreaCenter(ho_SkeletonIntersection, out hv_Area, out hv_Row1,
                        out hv_Column1);
                    if ((int)(new HTuple(hv_Area.TupleEqual(0))) != 0)
                    {
                        //Skeleton outside valid region -> use simple median row pixel and
                        //fixing this row, the median column pixel. This case should be
                        //extremely rare.
                        hv_Radius.Dispose();
                        HOperatorSet.RegionFeatures(ho_OrigRegion, "outer_radius", out hv_Radius);
                        HTuple end_val47 = hv_NumDilationRuns - 1;
                        HTuple step_val47 = 1;
                        for (hv_RadiusIndex = 0; hv_RadiusIndex.Continue(end_val47, step_val47); hv_RadiusIndex = hv_RadiusIndex.TupleAdd(step_val47))
                        {
                            hv_Dilation.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Dilation = ((hv_Radius / hv_NumDilationRuns)).TupleMax2(
                                    1.5);
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.DilationCircle(ho_Skeleton, out ExpTmpOutVar_0, hv_Dilation);
                                ho_Skeleton.Dispose();
                                ho_Skeleton = ExpTmpOutVar_0;
                            }
                            ho_SkeletonIntersection.Dispose();
                            HOperatorSet.Intersection(ho_Skeleton, ho_OrigRegion, out ho_SkeletonIntersection
                                );
                            hv_Area.Dispose(); hv_Row1.Dispose(); hv_Column1.Dispose();
                            HOperatorSet.AreaCenter(ho_SkeletonIntersection, out hv_Area, out hv_Row1,
                                out hv_Column1);
                            if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                            {
                                break;
                            }
                        }
                        hv_Rows1.Dispose(); hv_Columns1.Dispose();
                        HOperatorSet.GetRegionPoints(ho_SkeletonIntersection, out hv_Rows1, out hv_Columns1);
                        hv_RowOut.Dispose();
                        HOperatorSet.TupleMedian(hv_Rows1, out hv_RowOut);
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_Rows1, hv_RowOut, out hv_Indices);
                        hv_SelectedColumns.Dispose();
                        HOperatorSet.TupleSelect(hv_Columns1, hv_Indices, out hv_SelectedColumns);
                        hv_ColumnOut.Dispose();
                        HOperatorSet.TupleMedian(hv_SelectedColumns, out hv_ColumnOut);
                    }
                    else
                    {
                        //Skeleton inside valid region -> use skeleton
                        ho_Contours.Dispose();
                        HOperatorSet.GenContoursSkeletonXld(ho_SkeletonIntersection, out ho_Contours,
                            1, "filter");
                        ho_ContourRegions.Dispose();
                        HOperatorSet.GenRegionContourXld(ho_Contours, out ho_ContourRegions, "margin");
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Intersection(ho_ContourRegions, ho_SkeletonIntersection, out ExpTmpOutVar_0
                                );
                            ho_ContourRegions.Dispose();
                            ho_ContourRegions = ExpTmpOutVar_0;
                        }
                        //
                        //From every contour select middle point as candidate.
                        hv_NumContours.Dispose();
                        HOperatorSet.CountObj(ho_Contours, out hv_NumContours);
                        hv_CandidateRows.Dispose();
                        HOperatorSet.TupleGenConst(hv_NumContours, 0, out hv_CandidateRows);
                        hv_CandidateCols.Dispose();
                        HOperatorSet.TupleGenConst(hv_NumContours, 0, out hv_CandidateCols);
                        HTuple end_val71 = hv_NumContours;
                        HTuple step_val71 = 1;
                        for (hv_ContourIdx = 1; hv_ContourIdx.Continue(end_val71, step_val71); hv_ContourIdx = hv_ContourIdx.TupleAdd(step_val71))
                        {
                            ho_ContourSelected.Dispose();
                            HOperatorSet.SelectObj(ho_Contours, out ho_ContourSelected, hv_ContourIdx);
                            ho_RegionSelected.Dispose();
                            HOperatorSet.SelectObj(ho_ContourRegions, out ho_RegionSelected, hv_ContourIdx);
                            //
                            //Select point in RegionSelected closest to middle
                            //of the contour.
                            hv_Row.Dispose(); hv_Column.Dispose();
                            HOperatorSet.GetContourXld(ho_ContourSelected, out hv_Row, out hv_Column);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_CenterRegion.Dispose();
                                HOperatorSet.GenRegionRuns(out ho_CenterRegion, hv_Row.TupleSelect((new HTuple(hv_Row.TupleLength()
                                    )) / 2), hv_Column.TupleSelect((new HTuple(hv_Column.TupleLength())) / 2),
                                    hv_Column.TupleSelect((new HTuple(hv_Column.TupleLength())) / 2));
                            }
                            //
                            //Make sure the selected point is always inside
                            //the region.
                            hv_MinDistance.Dispose(); hv_RowCandidate.Dispose(); hv_ColumnCandidate.Dispose(); hv_RowUnused.Dispose(); hv_ColumnUnused.Dispose();
                            HOperatorSet.DistanceRrMin(ho_RegionSelected, ho_CenterRegion, out hv_MinDistance,
                                out hv_RowCandidate, out hv_ColumnCandidate, out hv_RowUnused, out hv_ColumnUnused);
                            //
                            if (hv_CandidateRows == null)
                                hv_CandidateRows = new HTuple();
                            hv_CandidateRows[hv_ContourIdx - 1] = hv_RowCandidate;
                            if (hv_CandidateCols == null)
                                hv_CandidateCols = new HTuple();
                            hv_CandidateCols[hv_ContourIdx - 1] = hv_ColumnCandidate;
                        }
                        //
                        //Find candidate with minimum maximum distance to any
                        //point in SkeletonIntersection.
                        hv_MinDist.Dispose(); hv_MaxDist.Dispose();
                        HOperatorSet.DistancePr(ho_SkeletonIntersection, hv_CandidateRows, hv_CandidateCols,
                            out hv_MinDist, out hv_MaxDist);
                        hv_Indices1.Dispose();
                        HOperatorSet.TupleSortIndex(hv_MaxDist, out hv_Indices1);
                        hv_RowOut.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RowOut = hv_CandidateRows.TupleSelect(
                                hv_Indices1.TupleSelect(0));
                        }
                        hv_ColumnOut.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColumnOut = hv_CandidateCols.TupleSelect(
                                hv_Indices1.TupleSelect(0));
                        }
                    }
                    //
                    //Collect output.
                    if (hv_Rows == null)
                        hv_Rows = new HTuple();
                    hv_Rows[hv_RegionIdx - 1] = hv_RowOut;
                    if (hv_Columns == null)
                        hv_Columns = new HTuple();
                    hv_Columns[hv_RegionIdx - 1] = hv_ColumnOut;
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_OrigRegion, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }
                ho_TmpRegions.Dispose();
                ho_FilteredRegions.Dispose();
                ho_ConnectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
                ho_Skeletons.Dispose();
                ho_OrigRegion.Dispose();
                ho_Skeleton.Dispose();
                ho_SkeletonIntersection.Dispose();
                ho_Contours.Dispose();
                ho_ContourRegions.Dispose();
                ho_ContourSelected.Dispose();
                ho_RegionSelected.Dispose();
                ho_CenterRegion.Dispose();

                hv_GapClosingRadius.Dispose();
                hv_NumDilationRuns.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIdx.Dispose();
                hv_Area.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Radius.Dispose();
                hv_RadiusIndex.Dispose();
                hv_Dilation.Dispose();
                hv_Rows1.Dispose();
                hv_Columns1.Dispose();
                hv_RowOut.Dispose();
                hv_Indices.Dispose();
                hv_SelectedColumns.Dispose();
                hv_ColumnOut.Dispose();
                hv_NumContours.Dispose();
                hv_CandidateRows.Dispose();
                hv_CandidateCols.Dispose();
                hv_ContourIdx.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_MinDistance.Dispose();
                hv_RowCandidate.Dispose();
                hv_ColumnCandidate.Dispose();
                hv_RowUnused.Dispose();
                hv_ColumnUnused.Dispose();
                hv_MinDist.Dispose();
                hv_MaxDist.Dispose();
                hv_Indices1.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TmpRegions.Dispose();
                ho_FilteredRegions.Dispose();
                ho_ConnectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
                ho_Skeletons.Dispose();
                ho_OrigRegion.Dispose();
                ho_Skeleton.Dispose();
                ho_SkeletonIntersection.Dispose();
                ho_Contours.Dispose();
                ho_ContourRegions.Dispose();
                ho_ContourSelected.Dispose();
                ho_RegionSelected.Dispose();
                ho_CenterRegion.Dispose();

                hv_GapClosingRadius.Dispose();
                hv_NumDilationRuns.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIdx.Dispose();
                hv_Area.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Radius.Dispose();
                hv_RadiusIndex.Dispose();
                hv_Dilation.Dispose();
                hv_Rows1.Dispose();
                hv_Columns1.Dispose();
                hv_RowOut.Dispose();
                hv_Indices.Dispose();
                hv_SelectedColumns.Dispose();
                hv_ColumnOut.Dispose();
                hv_NumContours.Dispose();
                hv_CandidateRows.Dispose();
                hv_CandidateCols.Dispose();
                hv_ContourIdx.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_MinDistance.Dispose();
                hv_RowCandidate.Dispose();
                hv_ColumnCandidate.Dispose();
                hv_RowUnused.Dispose();
                hv_ColumnUnused.Dispose();
                hv_MinDist.Dispose();
                hv_MaxDist.Dispose();
                hv_Indices1.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Extract gripping points based on a 3D gripping point detection model output. 
        public void gen_dl_3d_gripping_points_and_poses(HTuple hv_DLSampleBatch, HTuple hv_DLGrippingPointParams,
            HTuple hv_DLResultBatch)
        {



            // Local iconic variables 

            HObject ho_Regions = null, ho___Tmp_Obj_0 = null;

            // Local control variables 

            HTuple hv_MinAreaSize = new HTuple(), hv_SortingDirection = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_DLResult = new HTuple(), hv_Rows = new HTuple();
            HTuple hv_Columns = new HTuple(), hv_HasXYZ = new HTuple();
            HTuple hv_X = new HTuple(), hv_Y = new HTuple(), hv_Z = new HTuple();
            HTuple hv_NormalsXYZ = new HTuple(), hv_NX = new HTuple();
            HTuple hv_NY = new HTuple(), hv_NZ = new HTuple(), hv_DLResultUnsorted = new HTuple();
            HTuple hv_Index = new HTuple(), hv_GrippingPoint = new HTuple();
            HTuple hv_Depths = new HTuple(), hv_AscendingIndices = new HTuple();
            HTuple hv___Tmp_Ctrl_0 = new HTuple();
            HTuple hv_DLGrippingPointParams_COPY_INP_TMP = new HTuple(hv_DLGrippingPointParams);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
            try
            {
                //Extracts gripping points from connected regions in the
                //'gripping_map' image of the items in DLResultBatch.
                //Stores gripping points in a dict containing
                //row, column, region and pose.
                //
                if ((int)(new HTuple((new HTuple(hv_DLGrippingPointParams_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(0))) != 0)
                {
                    hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
                    HOperatorSet.CreateDict(out hv_DLGrippingPointParams_COPY_INP_TMP);
                }
                //
                check_dl_3d_gripping_points_and_poses_params(hv_DLGrippingPointParams_COPY_INP_TMP);
                //
                hv_MinAreaSize.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinAreaSize = hv_DLGrippingPointParams_COPY_INP_TMP.TupleGetDictTuple(
                        "min_area_size");
                }
                hv_SortingDirection.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SortingDirection = hv_DLGrippingPointParams_COPY_INP_TMP.TupleGetDictTuple(
                        "sorting_direction");
                }
                //
                //Preprocess the sample entries.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_DLSampleBatch.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSampleBatch.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_DLResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLResult = hv_DLResultBatch.TupleSelect(
                            hv_SampleIndex);
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Regions.Dispose(); hv_Rows.Dispose(); hv_Columns.Dispose();
                        gen_dl_3d_gripping_point_image_coord(hv_DLResult.TupleGetDictObject("gripping_map"),
                            out ho_Regions, hv_MinAreaSize, out hv_Rows, out hv_Columns);
                    }
                    if ((int)(new HTuple((new HTuple(hv_Rows.TupleLength())).TupleLess(1))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", new HTuple());
                        continue;
                    }
                    //
                    //Convert to output.
                    hv_HasXYZ.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", ((new HTuple("x")).TupleConcat(
                        "y")).TupleConcat("z"), out hv_HasXYZ);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleMin(hv_HasXYZ, out ExpTmpOutVar_0);
                        hv_HasXYZ.Dispose();
                        hv_HasXYZ = ExpTmpOutVar_0;
                    }
                    if ((int)(hv_HasXYZ) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_X.Dispose();
                            HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("x"), hv_Rows, hv_Columns,
                                out hv_X);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Y.Dispose();
                            HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("y"), hv_Rows, hv_Columns,
                                out hv_Y);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Z.Dispose();
                            HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns,
                                out hv_Z);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NormalsXYZ.Dispose();
                            HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("normals"), hv_Rows,
                                hv_Columns, out hv_NormalsXYZ);
                        }
                        hv_NX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NX = hv_NormalsXYZ.TupleSelect(
                                HTuple.TupleGenSequence(0, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                                3));
                        }
                        hv_NY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NY = hv_NormalsXYZ.TupleSelect(
                                HTuple.TupleGenSequence(1, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                                3));
                        }
                        hv_NZ.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NZ = hv_NormalsXYZ.TupleSelect(
                                HTuple.TupleGenSequence(2, (new HTuple(hv_NormalsXYZ.TupleLength())) - 1,
                                3));
                        }
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLResultUnsorted.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_Rows.TupleLength()), HTuple.TupleConstant(
                            "HNULL"), out hv_DLResultUnsorted);
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Rows.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_GrippingPoint.Dispose();
                        HOperatorSet.CreateDict(out hv_GrippingPoint);
                        if (hv_DLResultUnsorted == null)
                            hv_DLResultUnsorted = new HTuple();
                        hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_GrippingPoint, "row", hv_Rows.TupleSelect(
                                hv_Index));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_GrippingPoint, "column", hv_Columns.TupleSelect(
                                hv_Index));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho___Tmp_Obj_0.Dispose();
                            HOperatorSet.SelectObj(ho_Regions, out ho___Tmp_Obj_0, hv_Index + 1);
                        }
                        HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_GrippingPoint, "region");
                        if ((int)(hv_HasXYZ) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_0.Dispose();
                                convert_dl_3d_gripping_point_to_pose(hv_X.TupleSelect(hv_Index), hv_Y.TupleSelect(
                                    hv_Index), hv_Z.TupleSelect(hv_Index), hv_NX.TupleSelect(hv_Index),
                                    hv_NY.TupleSelect(hv_Index), hv_NZ.TupleSelect(hv_Index), out hv___Tmp_Ctrl_0);
                            }
                            HOperatorSet.SetDictTuple(hv_GrippingPoint, "pose", hv___Tmp_Ctrl_0);
                        }
                        if (hv_DLResultUnsorted == null)
                            hv_DLResultUnsorted = new HTuple();
                        hv_DLResultUnsorted[hv_Index] = hv_GrippingPoint;
                    }
                    //
                    //Sort by ascending depth (closer objects first).
                    if ((int)(hv_HasXYZ) != 0)
                    {
                        hv_Depths.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Depths = ((hv_X * (hv_SortingDirection.TupleSelect(
                                0))) + (hv_Y * (hv_SortingDirection.TupleSelect(1)))) + (hv_Z * (hv_SortingDirection.TupleSelect(
                                2)));
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Depths.Dispose();
                            HOperatorSet.GetGrayval(hv_DLSample.TupleGetDictObject("z"), hv_Rows, hv_Columns,
                                out hv_Depths);
                        }
                    }
                    hv_AscendingIndices.Dispose();
                    HOperatorSet.TupleSortIndex(hv_Depths, out hv_AscendingIndices);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_0.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_Rows.TupleLength()), HTuple.TupleConstant(
                            "HNULL"), out hv___Tmp_Ctrl_0);
                    }
                    HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", hv___Tmp_Ctrl_0);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DLResult, "gripping_points", hv_DLResultUnsorted.TupleSelect(
                            hv_AscendingIndices));
                    }
                }
                ho_Regions.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
                hv_MinAreaSize.Dispose();
                hv_SortingDirection.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HasXYZ.Dispose();
                hv_X.Dispose();
                hv_Y.Dispose();
                hv_Z.Dispose();
                hv_NormalsXYZ.Dispose();
                hv_NX.Dispose();
                hv_NY.Dispose();
                hv_NZ.Dispose();
                hv_DLResultUnsorted.Dispose();
                hv_Index.Dispose();
                hv_GrippingPoint.Dispose();
                hv_Depths.Dispose();
                hv_AscendingIndices.Dispose();
                hv___Tmp_Ctrl_0.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_DLGrippingPointParams_COPY_INP_TMP.Dispose();
                hv_MinAreaSize.Dispose();
                hv_SortingDirection.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HasXYZ.Dispose();
                hv_X.Dispose();
                hv_Y.Dispose();
                hv_Z.Dispose();
                hv_NormalsXYZ.Dispose();
                hv_NX.Dispose();
                hv_NY.Dispose();
                hv_NZ.Dispose();
                hv_DLResultUnsorted.Dispose();
                hv_Index.Dispose();
                hv_GrippingPoint.Dispose();
                hv_Depths.Dispose();
                hv_AscendingIndices.Dispose();
                hv___Tmp_Ctrl_0.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate ground truth characters if they don't exist and words to characters mapping. 
        private void gen_dl_ocr_detection_gt_chars(HTuple hv_DLSampleTargets, HTuple hv_DLSample,
            HTuple hv_ScaleWidth, HTuple hv_ScaleHeight, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordsCharsMapping)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CharBoxIndex = new HTuple(), hv_WordLengths = new HTuple();
            HTuple hv_J = new HTuple(), hv_Start = new HTuple(), hv_End = new HTuple();
            HTuple hv_SplitRow = new HTuple(), hv_SplitColumn = new HTuple();
            HTuple hv_SplitPhi = new HTuple(), hv_SplitLength1 = new HTuple();
            HTuple hv_SplitLength2 = new HTuple(), hv_CharsIds = new HTuple();
            HTuple hv_EmptyWordStrings = new HTuple();
            // Initialize local and output iconic variables 
            hvec_WordsCharsMapping = new HTupleVector(1);
            try
            {
                hvec_WordsCharsMapping[0] = new HTupleVector(new HTuple());
                if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    //Check if chars GT exist otherwise generate them.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CharBoxIndex.Dispose();
                        HOperatorSet.TupleFindFirst(hv_DLSample.TupleGetDictTuple("bbox_label_id"),
                            1, out hv_CharBoxIndex);
                    }
                    if ((int)(new HTuple(hv_CharBoxIndex.TupleEqual(-1))) != 0)
                    {
                        hv_WordLengths.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WordLengths = ((hv_DLSample.TupleGetDictTuple(
                                "word"))).TupleStrlen();
                        }
                        hvec_WordsCharsMapping[(new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                            )) - 1] = new HTupleVector(new HTuple());
                        for (hv_J = 0; (int)hv_J <= (int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
                            "bbox_label_id"))).TupleLength())) - 1); hv_J = (int)hv_J + 1)
                        {
                            //For each word box
                            if ((int)(new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
                                hv_J))).TupleEqual(0))) != 0)
                            {
                                if ((int)(new HTuple(((hv_WordLengths.TupleSelect(hv_J))).TupleNotEqual(
                                    0))) != 0)
                                {
                                    hv_Start.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Start = new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_label_id"))).TupleLength());
                                    }
                                    hv_End.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_End = ((new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_label_id"))).TupleLength())) - 1) + (hv_WordLengths.TupleSelect(
                                            hv_J));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hvec_WordsCharsMapping[hv_J] = dh.Add(new HTupleVector(HTuple.TupleGenSequence(
                                            hv_Start, hv_End, 1)));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SplitRow.Dispose(); hv_SplitColumn.Dispose(); hv_SplitPhi.Dispose(); hv_SplitLength1.Dispose(); hv_SplitLength2.Dispose();
                                        split_rectangle2(((hv_DLSample.TupleGetDictTuple("bbox_row"))).TupleSelect(
                                            hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(
                                            hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                                            hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_length1"))).TupleSelect(
                                            hv_J), ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(
                                            hv_J), hv_WordLengths.TupleSelect(hv_J), out hv_SplitRow, out hv_SplitColumn,
                                            out hv_SplitPhi, out hv_SplitLength1, out hv_SplitLength2);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CharsIds.Dispose();
                                        HOperatorSet.TupleGenConst(hv_WordLengths.TupleSelect(hv_J), 1, out hv_CharsIds);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_EmptyWordStrings.Dispose();
                                        HOperatorSet.TupleGenConst(hv_WordLengths.TupleSelect(hv_J), "",
                                            out hv_EmptyWordStrings);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_label_id", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_label_id"))).TupleConcat(hv_CharsIds));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_row", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_row"))).TupleConcat(hv_SplitRow));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_col", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_col"))).TupleConcat(hv_SplitColumn));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_phi", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_phi"))).TupleConcat(hv_SplitPhi));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_length1", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_length1"))).TupleConcat(hv_SplitLength1 * hv_ScaleWidth));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "bbox_length2", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "bbox_length2"))).TupleConcat(hv_SplitLength2 * hv_ScaleHeight));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSampleTargets, "word", ((hv_DLSampleTargets.TupleGetDictTuple(
                                            "word"))).TupleConcat(hv_EmptyWordStrings));
                                    }
                                }
                                else
                                {
                                    throw new HalconException(((("Sample with image id " + (hv_DLSample.TupleGetDictTuple(
                                        "image_id"))) + " is not valid. The word bounding box at index ") + hv_J) + " has an empty string as the ground truth. This is not allowed. Please assign a word label to every word bounding box.");
                                }
                            }
                        }
                    }
                    else
                    {
                        hvec_WordsCharsMapping.Dispose();
                        gen_words_chars_mapping(hv_DLSample, out hvec_WordsCharsMapping);
                    }
                }

                hv_CharBoxIndex.Dispose();
                hv_WordLengths.Dispose();
                hv_J.Dispose();
                hv_Start.Dispose();
                hv_End.Dispose();
                hv_SplitRow.Dispose();
                hv_SplitColumn.Dispose();
                hv_SplitPhi.Dispose();
                hv_SplitLength1.Dispose();
                hv_SplitLength2.Dispose();
                hv_CharsIds.Dispose();
                hv_EmptyWordStrings.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CharBoxIndex.Dispose();
                hv_WordLengths.Dispose();
                hv_J.Dispose();
                hv_Start.Dispose();
                hv_End.Dispose();
                hv_SplitRow.Dispose();
                hv_SplitColumn.Dispose();
                hv_SplitPhi.Dispose();
                hv_SplitLength1.Dispose();
                hv_SplitLength2.Dispose();
                hv_CharsIds.Dispose();
                hv_EmptyWordStrings.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate target link score map for ocr detection training. 
        private void gen_dl_ocr_detection_gt_link_map(out HObject ho_GtLinkMap, HTuple hv_ImageWidth,
            HTuple hv_ImageHeight, HTuple hv_DLSampleTargets, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordToCharVec,
            HTuple hv_Alpha)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Lines = null, ho_Line = null, ho_LineDilated = null;

            // Local control variables 

            HTuple hv_InitImage = new HTuple(), hv_CRow = new HTuple();
            HTuple hv_CCol = new HTuple(), hv_DiameterC = new HTuple();
            HTuple hv_IndexW = new HTuple(), hv_CharBoxIndices = new HTuple();
            HTuple hv_CharCRows = new HTuple(), hv_CharCCols = new HTuple();
            HTuple hv_CharDistToWordCenter = new HTuple(), hv_ExtremeCharIndex = new HTuple();
            HTuple hv_DistToExtreme = new HTuple(), hv_CharIndexSorted = new HTuple();
            HTuple hv_Box1Idx = new HTuple(), hv_Box2Idx = new HTuple();
            HTuple hv_Diameter1 = new HTuple(), hv_Diameter2 = new HTuple();
            HTuple hv_DilationRadius = new HTuple(), hv_NumLines = new HTuple();
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_GtLinkMap);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_LineDilated);
            try
            {
                ho_GtLinkMap.Dispose();
                HOperatorSet.GenImageConst(out ho_GtLinkMap, "real", hv_ImageWidth, hv_ImageHeight);
                hv_InitImage.Dispose();
                HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
                if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
                {
                    HOperatorSet.OverpaintRegion(ho_GtLinkMap, ho_GtLinkMap, 0.0, "fill");
                }
                //Compute box centers.
                hv_CRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CRow = hv_DLSampleTargets.TupleGetDictTuple(
                        "bbox_row");
                }
                hv_CCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CCol = hv_DLSampleTargets.TupleGetDictTuple(
                        "bbox_col");
                }
                hv_DiameterC.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DiameterC = 2 * (((hv_DLSampleTargets.TupleGetDictTuple(
                        "bbox_length1"))).TupleHypot(hv_DLSampleTargets.TupleGetDictTuple("bbox_length2")));
                }
                //Loop over word boxes.
                for (hv_IndexW = 0; (int)hv_IndexW <= (int)((new HTuple(((hv_DLSampleTargets.TupleGetDictTuple(
                    "bbox_label_id"))).TupleLength())) - 1); hv_IndexW = (int)hv_IndexW + 1)
                {
                    //For each word box
                    if ((int)(new HTuple(((((hv_DLSampleTargets.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
                        hv_IndexW))).TupleEqual(0))) != 0)
                    {
                        hv_CharBoxIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CharBoxIndices = new HTuple(hvec_WordToCharVec[hv_IndexW].T);
                        }
                        if ((int)(new HTuple((new HTuple(hv_CharBoxIndices.TupleLength())).TupleEqual(
                            0))) != 0)
                        {
                            continue;
                        }
                        else if ((int)(new HTuple((new HTuple(hv_CharBoxIndices.TupleLength()
                            )).TupleEqual(1))) != 0)
                        {
                            //Generate a dot in the char center.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_Lines.Dispose();
                                HOperatorSet.GenCircle(out ho_Lines, hv_CRow.TupleSelect(hv_CharBoxIndices),
                                    hv_CCol.TupleSelect(hv_CharBoxIndices), ((((0.5 * hv_Alpha) * (hv_DiameterC.TupleSelect(
                                    hv_CharBoxIndices)))).TupleRound()) + 0.5);
                            }
                        }
                        else
                        {
                            //Generate link lines between chars.
                            hv_CharCRows.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CharCRows = hv_CRow.TupleSelect(
                                    hv_CharBoxIndices);
                            }
                            hv_CharCCols.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CharCCols = hv_CCol.TupleSelect(
                                    hv_CharBoxIndices);
                            }
                            //Sort the char boxes within the word.
                            hv_CharDistToWordCenter.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CharDistToWordCenter = ((hv_CharCRows - (hv_CRow.TupleSelect(
                                    hv_IndexW)))).TupleHypot(hv_CharCCols - (hv_CCol.TupleSelect(hv_IndexW)));
                            }
                            hv_ExtremeCharIndex.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ExtremeCharIndex = (new HTuple(hv_CharDistToWordCenter.TupleSortIndex()
                                    )).TupleSelect((new HTuple(hv_CharDistToWordCenter.TupleLength())) - 1);
                            }
                            hv_DistToExtreme.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DistToExtreme = ((hv_CharCRows - (hv_CharCRows.TupleSelect(
                                    hv_ExtremeCharIndex)))).TupleHypot(hv_CharCCols - (hv_CharCCols.TupleSelect(
                                    hv_ExtremeCharIndex)));
                            }
                            hv_CharIndexSorted.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CharIndexSorted = hv_DistToExtreme.TupleSortIndex()
                                    ;
                            }
                            //Get the indices of adjacent characters.
                            hv_Box1Idx.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Box1Idx = hv_CharIndexSorted.TupleSelectRange(
                                    0, (new HTuple(hv_CharIndexSorted.TupleLength())) - 2);
                            }
                            hv_Box2Idx.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Box2Idx = hv_CharIndexSorted.TupleSelectRange(
                                    1, (new HTuple(hv_CharIndexSorted.TupleLength())) - 1);
                            }
                            //Generate link lines between each pair of adjacent characters.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_Lines.Dispose();
                                HOperatorSet.GenRegionLine(out ho_Lines, hv_CharCRows.TupleSelect(hv_Box1Idx),
                                    hv_CharCCols.TupleSelect(hv_Box1Idx), hv_CharCRows.TupleSelect(hv_Box2Idx),
                                    hv_CharCCols.TupleSelect(hv_Box2Idx));
                            }
                            //Dilate the lines by 0.5/1.5/2.5/... pixels, such that the line thickness is approximately Alpha*mean(D1, D2)
                            hv_Diameter1.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Diameter1 = hv_DiameterC.TupleSelect(
                                    hv_CharBoxIndices.TupleSelect(hv_Box1Idx));
                            }
                            hv_Diameter2.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Diameter2 = hv_DiameterC.TupleSelect(
                                    hv_CharBoxIndices.TupleSelect(hv_Box2Idx));
                            }
                            hv_DilationRadius.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DilationRadius = ((((0.25 * hv_Alpha) * (hv_Diameter1 + hv_Diameter2))).TupleRound()
                                    ) + 0.5;
                            }
                            //dilation_circle only accepts a single radius, so we need to loop over the lines.
                            hv_NumLines.Dispose();
                            HOperatorSet.CountObj(ho_Lines, out hv_NumLines);
                            HTuple end_val39 = hv_NumLines;
                            HTuple step_val39 = 1;
                            for (hv_Index = 1; hv_Index.Continue(end_val39, step_val39); hv_Index = hv_Index.TupleAdd(step_val39))
                            {
                                ho_Line.Dispose();
                                HOperatorSet.SelectObj(ho_Lines, out ho_Line, hv_Index);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_LineDilated.Dispose();
                                    HOperatorSet.DilationCircle(ho_Line, out ho_LineDilated, hv_DilationRadius.TupleSelect(
                                        hv_Index - 1));
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ReplaceObj(ho_Lines, ho_LineDilated, out ExpTmpOutVar_0,
                                        hv_Index);
                                    ho_Lines.Dispose();
                                    ho_Lines = ExpTmpOutVar_0;
                                }
                            }
                        }
                        HOperatorSet.OverpaintRegion(ho_GtLinkMap, ho_Lines, 1.0, "fill");
                    }
                }
                ho_Lines.Dispose();
                ho_Line.Dispose();
                ho_LineDilated.Dispose();

                hv_InitImage.Dispose();
                hv_CRow.Dispose();
                hv_CCol.Dispose();
                hv_DiameterC.Dispose();
                hv_IndexW.Dispose();
                hv_CharBoxIndices.Dispose();
                hv_CharCRows.Dispose();
                hv_CharCCols.Dispose();
                hv_CharDistToWordCenter.Dispose();
                hv_ExtremeCharIndex.Dispose();
                hv_DistToExtreme.Dispose();
                hv_CharIndexSorted.Dispose();
                hv_Box1Idx.Dispose();
                hv_Box2Idx.Dispose();
                hv_Diameter1.Dispose();
                hv_Diameter2.Dispose();
                hv_DilationRadius.Dispose();
                hv_NumLines.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Lines.Dispose();
                ho_Line.Dispose();
                ho_LineDilated.Dispose();

                hv_InitImage.Dispose();
                hv_CRow.Dispose();
                hv_CCol.Dispose();
                hv_DiameterC.Dispose();
                hv_IndexW.Dispose();
                hv_CharBoxIndices.Dispose();
                hv_CharCRows.Dispose();
                hv_CharCCols.Dispose();
                hv_CharDistToWordCenter.Dispose();
                hv_ExtremeCharIndex.Dispose();
                hv_DistToExtreme.Dispose();
                hv_CharIndexSorted.Dispose();
                hv_Box1Idx.Dispose();
                hv_Box2Idx.Dispose();
                hv_Diameter1.Dispose();
                hv_Diameter2.Dispose();
                hv_DilationRadius.Dispose();
                hv_NumLines.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate target orientation score maps for ocr detection training. 
        private void gen_dl_ocr_detection_gt_orientation_map(out HObject ho_GtOrientationMaps,
            HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_DLSample)
        {



            // Local iconic variables 

            HObject ho_GtOrientationSin, ho_GtOrientationCos;
            HObject ho_Region = null;

            // Local control variables 

            HTuple hv_InitImage = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_Phi = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_GtOrientationMaps);
            HOperatorSet.GenEmptyObj(out ho_GtOrientationSin);
            HOperatorSet.GenEmptyObj(out ho_GtOrientationCos);
            HOperatorSet.GenEmptyObj(out ho_Region);
            try
            {
                ho_GtOrientationSin.Dispose();
                HOperatorSet.GenImageConst(out ho_GtOrientationSin, "real", hv_ImageWidth,
                    hv_ImageHeight);
                ho_GtOrientationCos.Dispose();
                HOperatorSet.GenImageConst(out ho_GtOrientationCos, "real", hv_ImageWidth,
                    hv_ImageHeight);
                hv_InitImage.Dispose();
                HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
                if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
                {
                    HOperatorSet.OverpaintRegion(ho_GtOrientationSin, ho_GtOrientationSin, 0.0,
                        "fill");
                    HOperatorSet.OverpaintRegion(ho_GtOrientationCos, ho_GtOrientationCos, 0.0,
                        "fill");
                }
                if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    //Process char boxes
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1,
                            out hv_Indices);
                    }
                    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                    {
                        hv_Phi.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Phi = hv_DLSample.TupleGetDictTuple(
                                "bbox_phi");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Region.Dispose();
                            HOperatorSet.GenRectangle2(out ho_Region, ((hv_DLSample.TupleGetDictTuple(
                                "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_Indices));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.OverpaintRegion(ho_GtOrientationSin, ho_Region, ((hv_Phi.TupleSelect(
                                hv_Indices))).TupleSin(), "fill");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.OverpaintRegion(ho_GtOrientationCos, ho_Region, ((hv_Phi.TupleSelect(
                                hv_Indices))).TupleCos(), "fill");
                        }
                    }
                }
                ho_GtOrientationMaps.Dispose();
                HOperatorSet.Compose2(ho_GtOrientationSin, ho_GtOrientationCos, out ho_GtOrientationMaps
                    );
                ho_GtOrientationSin.Dispose();
                ho_GtOrientationCos.Dispose();
                ho_Region.Dispose();

                hv_InitImage.Dispose();
                hv_Indices.Dispose();
                hv_Phi.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GtOrientationSin.Dispose();
                ho_GtOrientationCos.Dispose();
                ho_Region.Dispose();

                hv_InitImage.Dispose();
                hv_Indices.Dispose();
                hv_Phi.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate target text score map for ocr detection training. 
        private void gen_dl_ocr_detection_gt_score_map(out HObject ho_TargetText, HTuple hv_DLSample,
            HTuple hv_BoxCutoff, HTuple hv_RenderCutoff, HTuple hv_ImageWidth, HTuple hv_ImageHeight)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ExtendedRectangle = null;

            // Local control variables 

            HTuple hv_InitImage = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Sigma1 = new HTuple(), hv_Sigma2 = new HTuple();
            HTuple hv_ExtendedLength1 = new HTuple(), hv_ExtendedLength2 = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_HomMat2D = new HTuple(), hv_DistRow = new HTuple();
            HTuple hv_DistCol = new HTuple(), hv_ScaledGaussian = new HTuple();
            HTuple hv_Grayval = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TargetText);
            HOperatorSet.GenEmptyObj(out ho_ExtendedRectangle);
            try
            {
                ho_TargetText.Dispose();
                HOperatorSet.GenImageConst(out ho_TargetText, "real", hv_ImageWidth, hv_ImageHeight);
                hv_InitImage.Dispose();
                HOperatorSet.GetSystem("init_new_image", out hv_InitImage);
                if ((int)(new HTuple(hv_InitImage.TupleEqual("false"))) != 0)
                {
                    HOperatorSet.OverpaintRegion(ho_TargetText, ho_TargetText, 0.0, "fill");
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
                    "bbox_label_id"))).TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //For each char box
                    if ((int)((new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
                        hv_Index))).TupleEqual(1))).TupleAnd(new HTuple(hv_BoxCutoff.TupleNotEqual(
                        0)))) != 0)
                    {
                        //Compute the sigma of an unnormalized normal distribution, such that
                        //a certain threshold value is reached at the interval of a certain size.
                        hv_Sigma1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Sigma1 = (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_Index)) * (((-0.5 / (hv_BoxCutoff.TupleLog()
                                ))).TupleSqrt());
                        }
                        hv_Sigma2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Sigma2 = (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_Index)) * (((-0.5 / (hv_BoxCutoff.TupleLog()
                                ))).TupleSqrt());
                        }
                        if ((int)((new HTuple((new HTuple(hv_Sigma1.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_Sigma2.TupleNotEqual(0))))).TupleAnd(new HTuple(hv_RenderCutoff.TupleNotEqual(
                            0)))) != 0)
                        {
                            //Compute the radius of an unnormalized normal distribution,
                            //where a certain threshold value is reached at the end.
                            hv_ExtendedLength1.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ExtendedLength1 = hv_Sigma1 * (((-2 * (hv_RenderCutoff.TupleLog()
                                    ))).TupleSqrt());
                            }
                            hv_ExtendedLength2.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ExtendedLength2 = hv_Sigma2 * (((-2 * (hv_RenderCutoff.TupleLog()
                                    ))).TupleSqrt());
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ExtendedRectangle.Dispose();
                                HOperatorSet.GenRectangle2(out ho_ExtendedRectangle, ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_row"))).TupleSelect(hv_Index), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_col"))).TupleSelect(hv_Index), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_phi"))).TupleSelect(hv_Index), hv_ExtendedLength1, hv_ExtendedLength2);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ClipRegion(ho_ExtendedRectangle, out ExpTmpOutVar_0, 0,
                                    0, hv_ImageHeight - 1, hv_ImageWidth - 1);
                                ho_ExtendedRectangle.Dispose();
                                ho_ExtendedRectangle = ExpTmpOutVar_0;
                            }
                            hv_Rows.Dispose(); hv_Columns.Dispose();
                            HOperatorSet.GetRegionPoints(ho_ExtendedRectangle, out hv_Rows, out hv_Columns);
                            //Verify that the bounding box has an area to plot a gaussian
                            hv_Area.Dispose(); hv_Row.Dispose(); hv_Column.Dispose();
                            HOperatorSet.AreaCenter(ho_ExtendedRectangle, out hv_Area, out hv_Row,
                                out hv_Column);
                            if ((int)(new HTuple(hv_Area.TupleGreater(1))) != 0)
                            {
                                hv_HomMat2D.Dispose();
                                HOperatorSet.HomMat2dIdentity(out hv_HomMat2D);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.HomMat2dTranslate(hv_HomMat2D, -(((hv_DLSample.TupleGetDictTuple(
                                        "bbox_row"))).TupleSelect(hv_Index)), -(((hv_DLSample.TupleGetDictTuple(
                                        "bbox_col"))).TupleSelect(hv_Index)), out ExpTmpOutVar_0);
                                    hv_HomMat2D.Dispose();
                                    hv_HomMat2D = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.HomMat2dRotate(hv_HomMat2D, -(((hv_DLSample.TupleGetDictTuple(
                                        "bbox_phi"))).TupleSelect(hv_Index)), 0, 0, out ExpTmpOutVar_0);
                                    hv_HomMat2D.Dispose();
                                    hv_HomMat2D = ExpTmpOutVar_0;
                                }
                                hv_DistRow.Dispose(); hv_DistCol.Dispose();
                                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_Rows, hv_Columns, out hv_DistRow,
                                    out hv_DistCol);
                                hv_ScaledGaussian.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ScaledGaussian = ((-0.5 * (((hv_DistCol * hv_DistCol) / (hv_Sigma1 * hv_Sigma1)) + ((hv_DistRow * hv_DistRow) / (hv_Sigma2 * hv_Sigma2))))).TupleExp()
                                        ;
                                }
                                hv_Grayval.Dispose();
                                HOperatorSet.GetGrayval(ho_TargetText, hv_Rows, hv_Columns, out hv_Grayval);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetGrayval(ho_TargetText, hv_Rows, hv_Columns, hv_ScaledGaussian.TupleMax2(
                                        hv_Grayval));
                                }
                            }
                        }
                    }
                }
                ho_ExtendedRectangle.Dispose();

                hv_InitImage.Dispose();
                hv_Index.Dispose();
                hv_Sigma1.Dispose();
                hv_Sigma2.Dispose();
                hv_ExtendedLength1.Dispose();
                hv_ExtendedLength2.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Area.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_HomMat2D.Dispose();
                hv_DistRow.Dispose();
                hv_DistCol.Dispose();
                hv_ScaledGaussian.Dispose();
                hv_Grayval.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ExtendedRectangle.Dispose();

                hv_InitImage.Dispose();
                hv_Index.Dispose();
                hv_Sigma1.Dispose();
                hv_Sigma2.Dispose();
                hv_ExtendedLength1.Dispose();
                hv_ExtendedLength2.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Area.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_HomMat2D.Dispose();
                hv_DistRow.Dispose();
                hv_DistCol.Dispose();
                hv_ScaledGaussian.Dispose();
                hv_Grayval.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Preprocess dl samples and generate targets and weights for ocr detection training. 
        private void gen_dl_ocr_detection_targets(HTuple hv_DLSampleOriginal, HTuple hv_DLPreprocessParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TargetText, ho_TargetLink, ho_TargetOrientation;
            HObject ho_TargetWeightText, ho_TargetWeightLink, ho_WeightedCharScore;
            HObject ho_TargetWeightOrientation, ho_OriginalDomain, ho_Image = null;
            HObject ho_DomainWeight = null, ho_Domain = null, ho_TargetOrientationOut = null;
            HObject ho_TargetWeightOrientationOut = null, ho_TargetOrientationChannel = null;
            HObject ho_TargetWeightOrientationChannel = null;

            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_Stride = new HTuple(), hv_ScaleHeight = new HTuple();
            HTuple hv_ScaleWidth = new HTuple(), hv_BoxCutoff = new HTuple();
            HTuple hv_RenderCutoff = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_WSWeightRenderThreshold = new HTuple(), hv_LinkZeroWeightRadius = new HTuple();
            HTuple hv_Confidence = new HTuple(), hv_ScoreMapsWidth = new HTuple();
            HTuple hv_ScoreMapsHeight = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DScale = new HTuple();
            HTuple hv_DLSampleTargets = new HTuple(), hv_OriginalDomainArea = new HTuple();
            HTuple hv__ = new HTuple(), hv_OriginalWidth = new HTuple();
            HTuple hv_OriginalHeight = new HTuple(), hv_IsOriginalDomainFull = new HTuple();
            HTuple hv_ChannelIdx = new HTuple(), hv___Tmp_Ctrl_0 = new HTuple();
            HTuple hv___Tmp_Ctrl_1 = new HTuple();

            HTupleVector hvec_WordsCharsMapping = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TargetText);
            HOperatorSet.GenEmptyObj(out ho_TargetLink);
            HOperatorSet.GenEmptyObj(out ho_TargetOrientation);
            HOperatorSet.GenEmptyObj(out ho_TargetWeightText);
            HOperatorSet.GenEmptyObj(out ho_TargetWeightLink);
            HOperatorSet.GenEmptyObj(out ho_WeightedCharScore);
            HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientation);
            HOperatorSet.GenEmptyObj(out ho_OriginalDomain);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_DomainWeight);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_TargetOrientationOut);
            HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationOut);
            HOperatorSet.GenEmptyObj(out ho_TargetOrientationChannel);
            HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationChannel);
            try
            {
                check_dl_preprocess_param(hv_DLPreprocessParam);
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_Stride.Dispose();
                hv_Stride = 2;
                //Parameters used in the fallback weak supervision case.
                //They make the the uniformly sized char boxes a bit smaller, as we can expect a spacing between the characters.
                hv_ScaleHeight.Dispose();
                hv_ScaleHeight = 0.9;
                hv_ScaleWidth.Dispose();
                hv_ScaleWidth = 0.8;
                //Parameters relevant to plot the gaussian blobs in the score map.
                hv_BoxCutoff.Dispose();
                hv_BoxCutoff = 0.3;
                hv_RenderCutoff.Dispose();
                hv_RenderCutoff = 0.01;
                //Parameter used to determine the dilation of lines in link map.
                hv_Alpha.Dispose();
                hv_Alpha = 0.1;
                //Parameter used to determine the dilation radius of word boxes in the weight score map.
                hv_WSWeightRenderThreshold.Dispose();
                hv_WSWeightRenderThreshold = 0.05;
                //Parameter represents the dilation radius of word lines in the weight link map.
                hv_LinkZeroWeightRadius.Dispose();
                hv_LinkZeroWeightRadius = 2.5;
                //Confidence is here only a place holder for the fallback weak supervision case.
                hv_Confidence.Dispose();
                hv_Confidence = 1.0;
                if ((int)(new HTuple(hv_Stride.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Stride must be greater than 0.");
                }
                //Calculate the size of score maps.
                hv_ScoreMapsWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScoreMapsWidth = hv_ImageWidth / hv_Stride;
                }
                hv_ScoreMapsHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScoreMapsHeight = hv_ImageHeight / hv_Stride;
                }
                //Copy DLSample to maintain the original bounding boxes dimensions.
                hv_DLSample.Dispose();
                HOperatorSet.CopyDict(hv_DLSampleOriginal, new HTuple(), new HTuple(), out hv_DLSample);
                //Preprocess bounding boxes to match targets dimensions.
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DScale.Dispose();
                    HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, 1.0 / hv_Stride, 1.0 / hv_Stride,
                        0, 0, out hv_HomMat2DScale);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_0.Dispose(); hv___Tmp_Ctrl_1.Dispose();
                    HOperatorSet.AffineTransPoint2d(hv_HomMat2DScale, hv_DLSample.TupleGetDictTuple(
                        "bbox_col"), hv_DLSample.TupleGetDictTuple("bbox_row"), out hv___Tmp_Ctrl_0,
                        out hv___Tmp_Ctrl_1);
                }
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv___Tmp_Ctrl_1);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv___Tmp_Ctrl_0);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", (hv_DLSample.TupleGetDictTuple(
                        "bbox_length1")) / hv_Stride);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", (hv_DLSample.TupleGetDictTuple(
                        "bbox_length2")) / hv_Stride);
                }
                hv_DLSampleTargets.Dispose();
                HOperatorSet.CopyDict(hv_DLSample, new HTuple(), new HTuple(), out hv_DLSampleTargets);
                hvec_WordsCharsMapping.Dispose();
                gen_dl_ocr_detection_gt_chars(hv_DLSampleTargets, hv_DLSample, hv_ScaleWidth,
                    hv_ScaleHeight, out hvec_WordsCharsMapping);
                //Generate target maps from WordRegions and CharBoxes.
                ho_TargetText.Dispose();
                gen_dl_ocr_detection_gt_score_map(out ho_TargetText, hv_DLSampleTargets, hv_BoxCutoff,
                    hv_RenderCutoff, hv_ScoreMapsWidth, hv_ScoreMapsHeight);
                ho_TargetLink.Dispose();
                gen_dl_ocr_detection_gt_link_map(out ho_TargetLink, hv_ScoreMapsWidth, hv_ScoreMapsHeight,
                    hv_DLSampleTargets, hvec_WordsCharsMapping, hv_Alpha);
                ho_TargetOrientation.Dispose();
                gen_dl_ocr_detection_gt_orientation_map(out ho_TargetOrientation, hv_ScoreMapsWidth,
                    hv_ScoreMapsHeight, hv_DLSampleTargets);
                //Generate weight maps from WordRegions and CharBoxes.
                ho_TargetWeightText.Dispose();
                gen_dl_ocr_detection_weight_score_map(out ho_TargetWeightText, hv_ScoreMapsWidth,
                    hv_ScoreMapsHeight, hv_DLSampleTargets, hv_BoxCutoff, hv_WSWeightRenderThreshold,
                    hv_Confidence);
                ho_TargetWeightLink.Dispose();
                gen_dl_ocr_detection_weight_link_map(ho_TargetLink, ho_TargetWeightText, out ho_TargetWeightLink,
                    hv_LinkZeroWeightRadius);
                ho_WeightedCharScore.Dispose();
                HOperatorSet.MultImage(ho_TargetText, ho_TargetWeightText, out ho_WeightedCharScore,
                    1, 0);
                ho_TargetWeightOrientation.Dispose();
                gen_dl_ocr_detection_weight_orientation_map(ho_WeightedCharScore, out ho_TargetWeightOrientation,
                    hv_DLSampleTargets);
                //Take account of the image domain in DLSampleOriginal.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_OriginalDomain.Dispose();
                    HOperatorSet.GetDomain(hv_DLSampleOriginal.TupleGetDictObject("image"), out ho_OriginalDomain
                        );
                }
                hv_OriginalDomainArea.Dispose(); hv__.Dispose(); hv__.Dispose();
                HOperatorSet.AreaCenter(ho_OriginalDomain, out hv_OriginalDomainArea, out hv__,
                    out hv__);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OriginalWidth.Dispose(); hv_OriginalHeight.Dispose();
                    HOperatorSet.GetImageSize(hv_DLSampleOriginal.TupleGetDictObject("image"),
                        out hv_OriginalWidth, out hv_OriginalHeight);
                }
                hv_IsOriginalDomainFull.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsOriginalDomainFull = new HTuple(hv_OriginalDomainArea.TupleEqual(
                        hv_OriginalWidth * hv_OriginalHeight));
                }
                if ((int)(hv_IsOriginalDomainFull.TupleNot()) != 0)
                {
                    //Calculate the domain weight.
                    ho_Image.Dispose();
                    HOperatorSet.GenImageConst(out ho_Image, "real", hv_OriginalWidth, hv_OriginalHeight);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ChangeDomain(ho_Image, ho_OriginalDomain, out ExpTmpOutVar_0
                            );
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    ho_DomainWeight.Dispose();
                    HOperatorSet.ZoomImageSize(ho_Image, out ho_DomainWeight, hv_ScoreMapsWidth,
                        hv_ScoreMapsHeight, "constant");
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_DomainWeight, out ho_Domain);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_DomainWeight, out ExpTmpOutVar_0);
                        ho_DomainWeight.Dispose();
                        ho_DomainWeight = ExpTmpOutVar_0;
                    }
                    HOperatorSet.OverpaintRegion(ho_DomainWeight, ho_DomainWeight, 0.0, "fill");
                    HOperatorSet.OverpaintRegion(ho_DomainWeight, ho_Domain, 1.0, "fill");
                    //Apply the domain weight.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetText, out ExpTmpOutVar_0,
                            1, 0);
                        ho_TargetText.Dispose();
                        ho_TargetText = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetLink, out ExpTmpOutVar_0,
                            1, 0);
                        ho_TargetLink.Dispose();
                        ho_TargetLink = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightText, out ExpTmpOutVar_0,
                            1, 0);
                        ho_TargetWeightText.Dispose();
                        ho_TargetWeightText = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightLink, out ExpTmpOutVar_0,
                            1, 0);
                        ho_TargetWeightLink.Dispose();
                        ho_TargetWeightLink = ExpTmpOutVar_0;
                    }
                    ho_TargetOrientationOut.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_TargetOrientationOut);
                    ho_TargetWeightOrientationOut.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_TargetWeightOrientationOut);
                    for (hv_ChannelIdx = 1; (int)hv_ChannelIdx <= 2; hv_ChannelIdx = (int)hv_ChannelIdx + 1)
                    {
                        ho_TargetOrientationChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_TargetOrientation, out ho_TargetOrientationChannel,
                            hv_ChannelIdx);
                        ho_TargetWeightOrientationChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_TargetWeightOrientation, out ho_TargetWeightOrientationChannel,
                            hv_ChannelIdx);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MultImage(ho_DomainWeight, ho_TargetOrientationChannel, out ExpTmpOutVar_0,
                                1, 0);
                            ho_TargetOrientationChannel.Dispose();
                            ho_TargetOrientationChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.MultImage(ho_DomainWeight, ho_TargetWeightOrientationChannel,
                                out ExpTmpOutVar_0, 1, 0);
                            ho_TargetWeightOrientationChannel.Dispose();
                            ho_TargetWeightOrientationChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AppendChannel(ho_TargetOrientationOut, ho_TargetOrientationChannel,
                                out ExpTmpOutVar_0);
                            ho_TargetOrientationOut.Dispose();
                            ho_TargetOrientationOut = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AppendChannel(ho_TargetWeightOrientationOut, ho_TargetWeightOrientationChannel,
                                out ExpTmpOutVar_0);
                            ho_TargetWeightOrientationOut.Dispose();
                            ho_TargetWeightOrientationOut = ExpTmpOutVar_0;
                        }
                    }
                    ho_TargetOrientation.Dispose();
                    ho_TargetOrientation = new HObject(ho_TargetOrientationOut);
                    ho_TargetWeightOrientation.Dispose();
                    ho_TargetWeightOrientation = new HObject(ho_TargetWeightOrientationOut);
                }
                //Set targets in output sample.
                HOperatorSet.SetDictObject(ho_TargetText, hv_DLSampleOriginal, "target_text");
                HOperatorSet.SetDictObject(ho_TargetLink, hv_DLSampleOriginal, "target_link");
                HOperatorSet.SetDictObject(ho_TargetOrientation, hv_DLSampleOriginal, "target_orientation");
                HOperatorSet.SetDictObject(ho_TargetWeightText, hv_DLSampleOriginal, "target_weight_text");
                HOperatorSet.SetDictObject(ho_TargetWeightLink, hv_DLSampleOriginal, "target_weight_link");
                HOperatorSet.SetDictObject(ho_TargetWeightOrientation, hv_DLSampleOriginal,
                    "target_weight_orientation");
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TargetText.Dispose();
                ho_TargetLink.Dispose();
                ho_TargetOrientation.Dispose();
                ho_TargetWeightText.Dispose();
                ho_TargetWeightLink.Dispose();
                ho_WeightedCharScore.Dispose();
                ho_TargetWeightOrientation.Dispose();
                ho_OriginalDomain.Dispose();
                ho_Image.Dispose();
                ho_DomainWeight.Dispose();
                ho_Domain.Dispose();
                ho_TargetOrientationOut.Dispose();
                ho_TargetWeightOrientationOut.Dispose();
                ho_TargetOrientationChannel.Dispose();
                ho_TargetWeightOrientationChannel.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Stride.Dispose();
                hv_ScaleHeight.Dispose();
                hv_ScaleWidth.Dispose();
                hv_BoxCutoff.Dispose();
                hv_RenderCutoff.Dispose();
                hv_Alpha.Dispose();
                hv_WSWeightRenderThreshold.Dispose();
                hv_LinkZeroWeightRadius.Dispose();
                hv_Confidence.Dispose();
                hv_ScoreMapsWidth.Dispose();
                hv_ScoreMapsHeight.Dispose();
                hv_DLSample.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DScale.Dispose();
                hv_DLSampleTargets.Dispose();
                hv_OriginalDomainArea.Dispose();
                hv__.Dispose();
                hv_OriginalWidth.Dispose();
                hv_OriginalHeight.Dispose();
                hv_IsOriginalDomainFull.Dispose();
                hv_ChannelIdx.Dispose();
                hv___Tmp_Ctrl_0.Dispose();
                hv___Tmp_Ctrl_1.Dispose();
                hvec_WordsCharsMapping.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate link score map weight for ocr detection training. 
        private void gen_dl_ocr_detection_weight_link_map(HObject ho_LinkMap, HObject ho_TargetWeight,
            out HObject ho_TargetWeightLink, HTuple hv_LinkZeroWeightRadius)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_LinkRegion = null, ho_RegionDilation = null;
            HObject ho_RegionComplement = null, ho_RegionUnion = null, ho_RegionBorder = null;

            // Local control variables 

            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TargetWeightLink);
            HOperatorSet.GenEmptyObj(out ho_LinkRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho_RegionComplement);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_RegionBorder);
            try
            {
                if ((int)(new HTuple(hv_LinkZeroWeightRadius.TupleGreater(0))) != 0)
                {
                    //Set zero weight around the link regions.
                    ho_LinkRegion.Dispose();
                    HOperatorSet.Threshold(ho_LinkMap, out ho_LinkRegion, 0.01, "max");
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho_LinkRegion, out ho_RegionDilation, hv_LinkZeroWeightRadius);
                    ho_RegionComplement.Dispose();
                    HOperatorSet.Complement(ho_RegionDilation, out ho_RegionComplement);
                    hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetImageSize(ho_TargetWeight, out hv_Width, out hv_Height);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ClipRegion(ho_RegionComplement, out ExpTmpOutVar_0, 0, 0, hv_Height - 1,
                            hv_Width - 1);
                        ho_RegionComplement.Dispose();
                        ho_RegionComplement = ExpTmpOutVar_0;
                    }
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union2(ho_LinkRegion, ho_RegionComplement, out ho_RegionUnion
                        );
                    ho_RegionBorder.Dispose();
                    HOperatorSet.Complement(ho_RegionUnion, out ho_RegionBorder);
                    ho_TargetWeightLink.Dispose();
                    HOperatorSet.PaintRegion(ho_RegionBorder, ho_TargetWeight, out ho_TargetWeightLink,
                        0, "fill");
                }
                else
                {
                    //Just copy the original weight map.
                    ho_TargetWeightLink.Dispose();
                    HOperatorSet.CopyObj(ho_TargetWeight, out ho_TargetWeightLink, 1, 1);
                }
                ho_LinkRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_RegionComplement.Dispose();
                ho_RegionUnion.Dispose();
                ho_RegionBorder.Dispose();

                hv_Width.Dispose();
                hv_Height.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_LinkRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_RegionComplement.Dispose();
                ho_RegionUnion.Dispose();
                ho_RegionBorder.Dispose();

                hv_Width.Dispose();
                hv_Height.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate orientation score map weight for ocr detection training. 
        private void gen_dl_ocr_detection_weight_orientation_map(HObject ho_InitialWeight,
            out HObject ho_OrientationTargetWeight, HTuple hv_DLSample)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_CharRegions = null, ho_CharRegion = null;
            HObject ho_BackgroundRegion = null;

            // Local control variables 

            HTuple hv_Indices = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_OrientationTargetWeight);
            HOperatorSet.GenEmptyObj(out ho_CharRegions);
            HOperatorSet.GenEmptyObj(out ho_CharRegion);
            HOperatorSet.GenEmptyObj(out ho_BackgroundRegion);
            try
            {
                //Inside the valid regions, the inital weight is set to the initial weight.
                ho_OrientationTargetWeight.Dispose();
                HOperatorSet.CopyImage(ho_InitialWeight, out ho_OrientationTargetWeight);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.FullDomain(ho_OrientationTargetWeight, out ExpTmpOutVar_0);
                    ho_OrientationTargetWeight.Dispose();
                    ho_OrientationTargetWeight = ExpTmpOutVar_0;
                }
                //Set orientation weight to 0 outside the valid regions.
                if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    //Process char boxes
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1,
                            out hv_Indices);
                    }
                    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_CharRegions.Dispose();
                            HOperatorSet.GenRectangle2(out ho_CharRegions, ((hv_DLSample.TupleGetDictTuple(
                                "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_Indices));
                        }
                        ho_CharRegion.Dispose();
                        HOperatorSet.Union1(ho_CharRegions, out ho_CharRegion);
                        ho_BackgroundRegion.Dispose();
                        HOperatorSet.Complement(ho_CharRegion, out ho_BackgroundRegion);
                        HOperatorSet.OverpaintRegion(ho_OrientationTargetWeight, ho_BackgroundRegion,
                            0, "fill");
                    }
                }
                //We need two channels: for Sin and Cos
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Compose2(ho_OrientationTargetWeight, ho_OrientationTargetWeight,
                        out ExpTmpOutVar_0);
                    ho_OrientationTargetWeight.Dispose();
                    ho_OrientationTargetWeight = ExpTmpOutVar_0;
                }
                ho_CharRegions.Dispose();
                ho_CharRegion.Dispose();
                ho_BackgroundRegion.Dispose();

                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_CharRegions.Dispose();
                ho_CharRegion.Dispose();
                ho_BackgroundRegion.Dispose();

                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate text score map weight for ocr detection training. 
        private void gen_dl_ocr_detection_weight_score_map(out HObject ho_TargetWeightText,
            HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_DLSample, HTuple hv_BoxCutoff,
            HTuple hv_WSWeightRenderThreshold, HTuple hv_Confidence)
        {



            // Local iconic variables 

            HObject ho_IgnoreRegion = null, ho_WordRegion = null;
            HObject ho_WordRegionDilated = null;

            // Local control variables 

            HTuple hv_Indices = new HTuple(), hv_WordIndex = new HTuple();
            HTuple hv_SigmaL2 = new HTuple(), hv_WordLength2Ext = new HTuple();
            HTuple hv_DilationRadius = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TargetWeightText);
            HOperatorSet.GenEmptyObj(out ho_IgnoreRegion);
            HOperatorSet.GenEmptyObj(out ho_WordRegion);
            HOperatorSet.GenEmptyObj(out ho_WordRegionDilated);
            try
            {
                ho_TargetWeightText.Dispose();
                HOperatorSet.GenImageConst(out ho_TargetWeightText, "real", hv_ImageWidth,
                    hv_ImageHeight);
                HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_TargetWeightText, 1.0,
                    "fill");
                if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    //Process ignore boxes
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 2,
                            out hv_Indices);
                    }
                    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_IgnoreRegion.Dispose();
                            HOperatorSet.GenRectangle2(out ho_IgnoreRegion, ((hv_DLSample.TupleGetDictTuple(
                                "bbox_row"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_col"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_phi"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_Indices), ((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_Indices));
                        }
                        HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_IgnoreRegion, 0.0,
                            "fill");
                    }
                    for (hv_WordIndex = 0; (int)hv_WordIndex <= (int)((new HTuple(((hv_DLSample.TupleGetDictTuple(
                        "bbox_label_id"))).TupleLength())) - 1); hv_WordIndex = (int)hv_WordIndex + 1)
                    {
                        //For each word box
                        if ((int)(new HTuple(((((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleSelect(
                            hv_WordIndex))).TupleEqual(0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_BoxCutoff.TupleEqual(0))).TupleOr(
                                new HTuple(hv_WSWeightRenderThreshold.TupleEqual(0))))).TupleNot()
                                ) != 0)
                            {
                                hv_SigmaL2.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SigmaL2 = (((hv_DLSample.TupleGetDictTuple(
                                        "bbox_length2"))).TupleSelect(hv_WordIndex)) * (((-0.5 / (hv_BoxCutoff.TupleLog()
                                        ))).TupleSqrt());
                                }
                                hv_WordLength2Ext.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_WordLength2Ext = hv_SigmaL2 * (((-2 * (hv_WSWeightRenderThreshold.TupleLog()
                                        ))).TupleSqrt());
                                }
                                hv_DilationRadius.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DilationRadius = hv_WordLength2Ext - (((hv_DLSample.TupleGetDictTuple(
                                        "bbox_length2"))).TupleSelect(hv_WordIndex));
                                }
                            }
                            else
                            {
                                hv_DilationRadius.Dispose();
                                hv_DilationRadius = 0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_WordRegion.Dispose();
                                HOperatorSet.GenRectangle2(out ho_WordRegion, ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_row"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_col"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_phi"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_length1"))).TupleSelect(hv_WordIndex), ((hv_DLSample.TupleGetDictTuple(
                                    "bbox_length2"))).TupleSelect(hv_WordIndex));
                            }
                            //Slightly enlarge the weight region to suppress halos at the box borders.
                            if ((int)(new HTuple(hv_DilationRadius.TupleGreaterEqual(0.5))) != 0)
                            {
                                ho_WordRegionDilated.Dispose();
                                HOperatorSet.DilationCircle(ho_WordRegion, out ho_WordRegionDilated,
                                    hv_DilationRadius);
                            }
                            else
                            {
                                ho_WordRegionDilated.Dispose();
                                ho_WordRegionDilated = new HObject(ho_WordRegion);
                            }
                            //Set the confidence as weight for the word region.
                            HOperatorSet.OverpaintRegion(ho_TargetWeightText, ho_WordRegionDilated,
                                hv_Confidence, "fill");
                        }
                    }
                }
                ho_IgnoreRegion.Dispose();
                ho_WordRegion.Dispose();
                ho_WordRegionDilated.Dispose();

                hv_Indices.Dispose();
                hv_WordIndex.Dispose();
                hv_SigmaL2.Dispose();
                hv_WordLength2Ext.Dispose();
                hv_DilationRadius.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_IgnoreRegion.Dispose();
                ho_WordRegion.Dispose();
                ho_WordRegionDilated.Dispose();

                hv_Indices.Dispose();
                hv_WordIndex.Dispose();
                hv_SigmaL2.Dispose();
                hv_WordLength2Ext.Dispose();
                hv_DilationRadius.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Store the given images in a tuple of dictionaries DLSamples. 
        public void gen_dl_samples_from_images(HObject ho_Images, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            HObject ho_Image = null;

            // Local control variables 

            HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
            HTuple hv_DLSample = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure creates DLSampleBatch, a tuple
                //containing a dictionary DLSample
                //for every image given in Images.
                //
                //Initialize output tuple.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images, out hv_NumImages);
                hv_DLSampleBatch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSampleBatch = HTuple.TupleGenConst(
                        hv_NumImages, -1);
                }
                //
                //Loop through all given images.
                HTuple end_val10 = hv_NumImages - 1;
                HTuple step_val10 = 1;
                for (hv_ImageIndex = 0; hv_ImageIndex.Continue(end_val10, step_val10); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val10))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_Images, out ho_Image, hv_ImageIndex + 1);
                    }
                    //Create DLSample from image.
                    hv_DLSample.Dispose();
                    HOperatorSet.CreateDict(out hv_DLSample);
                    HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                    //
                    //Collect the DLSamples.
                    if (hv_DLSampleBatch == null)
                        hv_DLSampleBatch = new HTuple();
                    hv_DLSampleBatch[hv_ImageIndex] = hv_DLSample;
                }
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Generate a tiled image for the classified DLSamples and add indications whether the predictions are true or not. 
        private void gen_tiled_classification_image_result(out HObject ho_TiledImageRow,
            HTuple hv_DLSamples, HTuple hv_SpacingCol, HTuple hv_PredictionsCorrect, HTuple hv_ResClasses,
            out HTuple hv_TextImageRows, out HTuple hv_TextImageColumns, out HTuple hv_TextImageWidth,
            out HTuple hv_TextImageHeight)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_GTImagesRaw, ho_GTImage = null, ho_Channel = null;
            HObject ho_RegionContourCheck, ho_Rectangle1, ho_Rectangle2;
            HObject ho_RegionContourCross, ho_TopContour, ho_LeftContour;
            HObject ho_RightContour, ho_BottomContour, ho_Frame, ho_TextImageOneChannel;
            HObject ho_TextImageOneChannels, ho_TextImage, ho_SeparateImageOneChannel;
            HObject ho_SeparateImageOneChannels, ho_SeparateImage, ho_GTImages;
            HObject ho_GTImageChannelsScaled = null, ho_GTImageChannel = null;
            HObject ho_GTImageChannelScaled = null, ho_GTImageR = null;
            HObject ho_GTImageG = null, ho_GTImageB = null, ho_RegionContour = null;

            // Local control variables 

            HTuple hv_NumSamples = new HTuple(), hv_NumRows = new HTuple();
            HTuple hv_NumColumns = new HTuple(), hv_Index = new HTuple();
            HTuple hv_NumChannels = new HTuple(), hv_GrayMin = new HTuple();
            HTuple hv_GrayMax = new HTuple(), hv_IndexChannel = new HTuple();
            HTuple hv_GrayMinTmp = new HTuple(), hv_GrayMaxTmp = new HTuple();
            HTuple hv__ = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DCompose = new HTuple();
            HTuple hv_FrameSize = new HTuple(), hv_SeparateImageHeight = new HTuple();
            HTuple hv_SeparateImageWidth = new HTuple(), hv_ScaleMax = new HTuple();
            HTuple hv_ScaleMin = new HTuple(), hv_Color = new HTuple();
            HTuple hv_Number = new HTuple(), hv_TiledRows = new HTuple();
            HTuple hv_TiledColumns = new HTuple(), hv_TiledHeights = new HTuple();
            HTuple hv_TiledWidths = new HTuple(), hv_MinusOnes = new HTuple();

            HTupleVector hvec_GrayMins = new HTupleVector(1);
            HTupleVector hvec_GrayMaxs = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_GTImagesRaw);
            HOperatorSet.GenEmptyObj(out ho_GTImage);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_RegionContourCheck);
            HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_Rectangle2);
            HOperatorSet.GenEmptyObj(out ho_RegionContourCross);
            HOperatorSet.GenEmptyObj(out ho_TopContour);
            HOperatorSet.GenEmptyObj(out ho_LeftContour);
            HOperatorSet.GenEmptyObj(out ho_RightContour);
            HOperatorSet.GenEmptyObj(out ho_BottomContour);
            HOperatorSet.GenEmptyObj(out ho_Frame);
            HOperatorSet.GenEmptyObj(out ho_TextImageOneChannel);
            HOperatorSet.GenEmptyObj(out ho_TextImageOneChannels);
            HOperatorSet.GenEmptyObj(out ho_TextImage);
            HOperatorSet.GenEmptyObj(out ho_SeparateImageOneChannel);
            HOperatorSet.GenEmptyObj(out ho_SeparateImageOneChannels);
            HOperatorSet.GenEmptyObj(out ho_SeparateImage);
            HOperatorSet.GenEmptyObj(out ho_GTImages);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannel);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_GTImageR);
            HOperatorSet.GenEmptyObj(out ho_GTImageG);
            HOperatorSet.GenEmptyObj(out ho_GTImageB);
            HOperatorSet.GenEmptyObj(out ho_RegionContour);
            hv_TextImageRows = new HTuple();
            hv_TextImageColumns = new HTuple();
            hv_TextImageWidth = new HTuple();
            hv_TextImageHeight = new HTuple();
            try
            {
                //
                //This procedure generates a tiled image for the classified DLSamples.
                //In the process it adds indications if the prediction was
                //correct (green frame and checkmark) or wrong (red frame and cross).
                //
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
                        );
                }
                //
                //Get number of rows/columns of tiled image.
                if ((int)(new HTuple(hv_NumSamples.TupleGreater(9))) != 0)
                {
                    throw new HalconException("More than 9 images cannot be shown in the training progress.");
                }
                if ((int)((new HTuple((new HTuple(hv_NumSamples.TupleEqual(1))).TupleOr(new HTuple(hv_NumSamples.TupleEqual(
                    4))))).TupleOr(new HTuple(hv_NumSamples.TupleEqual(9)))) != 0)
                {
                    hv_NumRows.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRows = ((hv_NumSamples.TupleSqrt()
                            )).TupleInt();
                    }
                    hv_NumColumns.Dispose();
                    hv_NumColumns = new HTuple(hv_NumRows);
                }
                else
                {
                    hv_NumRows.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRows = hv_NumSamples.TupleMin2(
                            3);
                    }
                    hv_NumColumns.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumColumns = ((hv_NumSamples - 1) / hv_NumRows) + 1;
                    }
                }
                //
                //Get images and minimal/maximal gray values.
                ho_GTImagesRaw.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImagesRaw);
                HTuple end_val21 = hv_NumSamples - 1;
                HTuple step_val21 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_GTImage, hv_DLSamples.TupleSelect(hv_Index),
                            "image");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImagesRaw, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImagesRaw.Dispose();
                        ho_GTImagesRaw = ExpTmpOutVar_0;
                    }
                    hv_NumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_GTImage, out hv_NumChannels);
                    hv_GrayMin.Dispose();
                    hv_GrayMin = new HTuple();
                    hv_GrayMax.Dispose();
                    hv_GrayMax = new HTuple();
                    HTuple end_val27 = hv_NumChannels - 1;
                    HTuple step_val27 = 1;
                    for (hv_IndexChannel = 0; hv_IndexChannel.Continue(end_val27, step_val27); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val27))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Channel.Dispose();
                            HOperatorSet.AccessChannel(ho_GTImage, out ho_Channel, hv_IndexChannel + 1);
                        }
                        hv_GrayMinTmp.Dispose(); hv_GrayMaxTmp.Dispose(); hv__.Dispose();
                        HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_GrayMinTmp, out hv_GrayMaxTmp,
                            out hv__);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_GrayMin = hv_GrayMin.TupleConcat(
                                    hv_GrayMinTmp);
                                hv_GrayMin.Dispose();
                                hv_GrayMin = ExpTmpLocalVar_GrayMin;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_GrayMax = hv_GrayMax.TupleConcat(
                                    hv_GrayMaxTmp);
                                hv_GrayMax.Dispose();
                                hv_GrayMax = ExpTmpLocalVar_GrayMax;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_GrayMins[hv_Index] = dh.Add(new HTupleVector(hv_GrayMin));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_GrayMaxs[hv_Index] = dh.Add(new HTupleVector(hv_GrayMax));
                    }
                }
                //
                //Create a checkmark, a cross, and a frame.
                //Note: It is assumed that all images have the same size.
                //Set parameters for displaying crosses/hooks at the bottom-right corner.
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_GTImage, out hv_ImageWidth, out hv_ImageHeight);
                hv_Length1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length1 = (hv_ImageWidth.TupleMin2(
                        hv_ImageHeight)) / 5;
                }
                hv_Length2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length2 = (hv_ImageWidth.TupleMin2(
                        hv_ImageHeight)) / 25;
                }
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, (new HTuple(45)).TupleRad()
                        , 0, 0, out hv_HomMat2DRotate);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DCompose.Dispose();
                    HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_ImageHeight - (0.75 * hv_Length1),
                        hv_ImageWidth - (0.75 * hv_Length1), out hv_HomMat2DCompose);
                }
                //Generate checkmark.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RegionContourCheck.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_RegionContourCheck, ((((((((((-hv_Length2)).TupleConcat(
                        hv_Length2))).TupleConcat(hv_Length2))).TupleConcat((new HTuple(0)).TupleConcat(
                        0)))).TupleConcat(-hv_Length2))).TupleConcat(-hv_Length2), (((((((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_Length1))).TupleConcat(hv_Length1))).TupleConcat(hv_Length2))).TupleConcat(
                        hv_Length2))).TupleConcat(0)) - (hv_Length1 / 2));
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_RegionContourCheck, out ExpTmpOutVar_0,
                        hv_HomMat2DCompose);
                    ho_RegionContourCheck.Dispose();
                    ho_RegionContourCheck = ExpTmpOutVar_0;
                }
                //Generate cross.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Rectangle1.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, 0, 0, 0, hv_Length1 / 2,
                        hv_Length2 / 2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Rectangle2.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2, 0, 0, 0, hv_Length2 / 2,
                        hv_Length1 / 2);
                }
                ho_RegionContourCross.Dispose();
                HOperatorSet.ConcatObj(ho_Rectangle1, ho_Rectangle2, out ho_RegionContourCross
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_RegionContourCross, out ExpTmpOutVar_0,
                        hv_HomMat2DCompose);
                    ho_RegionContourCross.Dispose();
                    ho_RegionContourCross = ExpTmpOutVar_0;
                }
                //Generate the color frame.
                hv_FrameSize.Dispose();
                hv_FrameSize = 7;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_TopContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TopContour, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_FrameSize))).TupleConcat(hv_FrameSize))).TupleConcat(
                        0)) - 0.5, ((((((new HTuple(0)).TupleConcat(hv_ImageWidth))).TupleConcat(
                        hv_ImageWidth))).TupleConcat((new HTuple(0)).TupleConcat(0))) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_LeftContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_LeftContour, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_ImageHeight))).TupleConcat(hv_ImageHeight))).TupleConcat(
                        0)) - 0.5, ((((((new HTuple(0)).TupleConcat(hv_FrameSize))).TupleConcat(hv_FrameSize))).TupleConcat(
                        (new HTuple(0)).TupleConcat(0))) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RightContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_RightContour, ((((((new HTuple(0)).TupleConcat(
                        hv_ImageHeight))).TupleConcat(hv_ImageHeight))).TupleConcat((new HTuple(0)).TupleConcat(
                        0))) - 0.5, (((((((hv_ImageWidth.TupleConcat(hv_ImageWidth))).TupleConcat(
                        hv_ImageWidth - hv_FrameSize))).TupleConcat(hv_ImageWidth - hv_FrameSize))).TupleConcat(
                        hv_ImageWidth)) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_BottomContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_BottomContour, (((((((hv_ImageHeight.TupleConcat(
                        hv_ImageHeight - hv_FrameSize))).TupleConcat(hv_ImageHeight - hv_FrameSize))).TupleConcat(
                        hv_ImageHeight))).TupleConcat(hv_ImageHeight)) - 0.5, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_ImageWidth))).TupleConcat(hv_ImageWidth))).TupleConcat(
                        0)) - 0.5);
                }
                ho_Frame.Dispose();
                HOperatorSet.ConcatObj(ho_TopContour, ho_RightContour, out ho_Frame);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Frame, ho_BottomContour, out ExpTmpOutVar_0);
                    ho_Frame.Dispose();
                    ho_Frame = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Frame, ho_LeftContour, out ExpTmpOutVar_0);
                    ho_Frame.Dispose();
                    ho_Frame = ExpTmpOutVar_0;
                }
                //
                //Create black image to print in text later.
                hv_TextImageHeight.Dispose();
                hv_TextImageHeight = 40;
                hv_TextImageWidth.Dispose();
                hv_TextImageWidth = new HTuple(hv_ImageWidth);
                ho_TextImageOneChannel.Dispose();
                HOperatorSet.GenImageConst(out ho_TextImageOneChannel, "real", hv_TextImageWidth,
                    hv_TextImageHeight);
                ho_TextImageOneChannels.Dispose();
                HOperatorSet.ConcatObj(ho_TextImageOneChannel, ho_TextImageOneChannel, out ho_TextImageOneChannels
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_TextImageOneChannels, ho_TextImageOneChannel, out ExpTmpOutVar_0
                        );
                    ho_TextImageOneChannels.Dispose();
                    ho_TextImageOneChannels = ExpTmpOutVar_0;
                }
                ho_TextImage.Dispose();
                HOperatorSet.ChannelsToImage(ho_TextImageOneChannels, out ho_TextImage);
                //
                //Create black image to separate columns.
                hv_SeparateImageHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SeparateImageHeight = hv_NumRows * (hv_ImageHeight + hv_TextImageHeight);
                }
                hv_SeparateImageWidth.Dispose();
                hv_SeparateImageWidth = 4;
                ho_SeparateImageOneChannel.Dispose();
                HOperatorSet.GenImageConst(out ho_SeparateImageOneChannel, "real", hv_SeparateImageWidth,
                    hv_SeparateImageHeight);
                ho_SeparateImageOneChannels.Dispose();
                HOperatorSet.ConcatObj(ho_SeparateImageOneChannel, ho_SeparateImageOneChannel,
                    out ho_SeparateImageOneChannels);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_SeparateImageOneChannels, ho_SeparateImageOneChannel,
                        out ExpTmpOutVar_0);
                    ho_SeparateImageOneChannels.Dispose();
                    ho_SeparateImageOneChannels = ExpTmpOutVar_0;
                }
                ho_SeparateImage.Dispose();
                HOperatorSet.ChannelsToImage(ho_SeparateImageOneChannels, out ho_SeparateImage
                    );
                //
                //Adapt images with frame and checkmark/cross.
                ho_GTImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImages);
                HTuple end_val82 = hv_NumSamples - 1;
                HTuple step_val82 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val82, step_val82); hv_Index = hv_Index.TupleAdd(step_val82))
                {
                    //Scale images to [0,1] to have identical color ranges.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.SelectObj(ho_GTImagesRaw, out ho_GTImage, hv_Index + 1);
                    }
                    hv_NumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_GTImage, out hv_NumChannels);
                    ho_GTImageChannelsScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_GTImageChannelsScaled);
                    HTuple end_val87 = hv_NumChannels - 1;
                    HTuple step_val87 = 1;
                    for (hv_IndexChannel = 0; hv_IndexChannel.Continue(end_val87, step_val87); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val87))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_GTImageChannel.Dispose();
                            HOperatorSet.AccessChannel(ho_GTImage, out ho_GTImageChannel, hv_IndexChannel + 1);
                        }
                        hv_ScaleMax.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleMax = (hvec_GrayMaxs[hv_Index].T).TupleSelect(
                                hv_IndexChannel);
                        }
                        hv_ScaleMin.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleMin = (hvec_GrayMins[hv_Index].T).TupleSelect(
                                hv_IndexChannel);
                        }
                        if ((int)(new HTuple(((hv_ScaleMax - hv_ScaleMin)).TupleGreater(1e-5))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_GTImageChannelScaled.Dispose();
                                HOperatorSet.ScaleImage(ho_GTImageChannel, out ho_GTImageChannelScaled,
                                    1.0 / (hv_ScaleMax - hv_ScaleMin), (-hv_ScaleMin) / (hv_ScaleMax - hv_ScaleMin));
                            }
                        }
                        else
                        {
                            ho_GTImageChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_GTImageChannel, out ho_GTImageChannelScaled,
                                0, 0);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_GTImageChannelsScaled, ho_GTImageChannelScaled,
                                out ExpTmpOutVar_0);
                            ho_GTImageChannelsScaled.Dispose();
                            ho_GTImageChannelsScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_GTImage.Dispose();
                    HOperatorSet.ChannelsToImage(ho_GTImageChannelsScaled, out ho_GTImage);
                    //The frame has 3 channels, hence ensure that GTImage
                    //has equal number of channels for display.
                    if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                    {
                        //Just take the first channel and use this to generate
                        //an image with 3 channels for visualization.
                        ho_GTImageR.Dispose();
                        HOperatorSet.AccessChannel(ho_GTImage, out ho_GTImageR, 1);
                        ho_GTImageG.Dispose();
                        HOperatorSet.CopyImage(ho_GTImageR, out ho_GTImageG);
                        ho_GTImageB.Dispose();
                        HOperatorSet.CopyImage(ho_GTImageR, out ho_GTImageB);
                        ho_GTImage.Dispose();
                        HOperatorSet.Compose3(ho_GTImageR, ho_GTImageG, ho_GTImageB, out ho_GTImage
                            );
                    }
                    //
                    if ((int)(new HTuple(((hv_PredictionsCorrect.TupleSelect(hv_Index))).TupleEqual(
                        1))) != 0)
                    {
                        //If the actual image is predicted correctly, plot a green frame and
                        //a green checkmark.
                        ho_RegionContour.Dispose();
                        ho_RegionContour = new HObject(ho_RegionContourCheck);
                        hv_Color.Dispose();
                        hv_Color = new HTuple();
                        hv_Color[0] = 0;
                        hv_Color[1] = 1;
                        hv_Color[2] = 0;
                    }
                    else
                    {
                        //Same as for the correct predictions, plot red frame and
                        //a red cross for incorrect predictions.
                        ho_RegionContour.Dispose();
                        ho_RegionContour = new HObject(ho_RegionContourCross);
                        hv_Color.Dispose();
                        hv_Color = new HTuple();
                        hv_Color[0] = 1;
                        hv_Color[1] = 0;
                        hv_Color[2] = 0;
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintXld(ho_Frame, ho_GTImage, out ExpTmpOutVar_0, hv_Color);
                        ho_GTImage.Dispose();
                        ho_GTImage = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintXld(ho_RegionContour, ho_GTImage, out ExpTmpOutVar_0, hv_Color);
                        ho_GTImage.Dispose();
                        ho_GTImage = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                    //Add TextImage.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_TextImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                }
                //
                //Tile the images. The maximum is 3x3=9 samples.
                //Set row/column positions of upper-left corners of images and text images.
                hv_Number.Dispose();
                HOperatorSet.CountObj(ho_GTImages, out hv_Number);
                hv_TiledRows.Dispose();
                HOperatorSet.TupleGenConst(hv_Number, 0, out hv_TiledRows);
                hv_TiledColumns.Dispose();
                HOperatorSet.TupleGenConst(hv_Number, 0, out hv_TiledColumns);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageRows.Dispose();
                    HOperatorSet.TupleGenConst(hv_Number / 2, 0, out hv_TextImageRows);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageColumns.Dispose();
                    HOperatorSet.TupleGenConst(hv_Number / 2, 0, out hv_TextImageColumns);
                }
                HTuple end_val136 = (hv_Number / 2) - 1;
                HTuple step_val136 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val136, step_val136); hv_Index = hv_Index.TupleAdd(step_val136))
                {
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[2 * hv_Index] = (hv_TextImageHeight + hv_ImageHeight) * (hv_Index % hv_NumRows);
                    if (hv_TextImageRows == null)
                        hv_TextImageRows = new HTuple();
                    hv_TextImageRows[hv_Index] = ((hv_TextImageHeight + hv_ImageHeight) * (hv_Index % hv_NumRows)) + hv_ImageHeight;
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[(2 * hv_Index) + 1] = hv_TextImageRows.TupleSelect(hv_Index);
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[2 * hv_Index] = (hv_ImageWidth + hv_SeparateImageWidth) * (hv_Index / hv_NumRows);
                    if (hv_TextImageColumns == null)
                        hv_TextImageColumns = new HTuple();
                    hv_TextImageColumns[hv_Index] = hv_TiledColumns.TupleSelect(2 * hv_Index);
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[(2 * hv_Index) + 1] = hv_TextImageColumns.TupleSelect(hv_Index);
                }
                //Add images and row/column positions of upper-left corners of SeparateImages.
                HTuple end_val145 = hv_NumColumns - 2;
                HTuple step_val145 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val145, step_val145); hv_Index = hv_Index.TupleAdd(step_val145))
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_SeparateImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[new HTuple(hv_TiledRows.TupleLength())] = 0;
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[new HTuple(hv_TiledColumns.TupleLength())] = (hv_Index + 1) * hv_ImageWidth;
                }
                //
                hv_TiledHeights.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledHeights = hv_NumRows * (hv_TextImageHeight + hv_ImageHeight);
                }
                hv_TiledWidths.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledWidths = (hv_NumColumns * hv_ImageWidth) + ((hv_NumColumns - 1) * hv_SeparateImageWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinusOnes.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_TiledRows.TupleLength()), -1, out hv_MinusOnes);
                }
                ho_TiledImageRow.Dispose();
                HOperatorSet.TileImagesOffset(ho_GTImages, out ho_TiledImageRow, hv_TiledRows,
                    hv_TiledColumns, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes,
                    hv_TiledWidths, hv_TiledHeights);
                //
                ho_GTImagesRaw.Dispose();
                ho_GTImage.Dispose();
                ho_Channel.Dispose();
                ho_RegionContourCheck.Dispose();
                ho_Rectangle1.Dispose();
                ho_Rectangle2.Dispose();
                ho_RegionContourCross.Dispose();
                ho_TopContour.Dispose();
                ho_LeftContour.Dispose();
                ho_RightContour.Dispose();
                ho_BottomContour.Dispose();
                ho_Frame.Dispose();
                ho_TextImageOneChannel.Dispose();
                ho_TextImageOneChannels.Dispose();
                ho_TextImage.Dispose();
                ho_SeparateImageOneChannel.Dispose();
                ho_SeparateImageOneChannels.Dispose();
                ho_SeparateImage.Dispose();
                ho_GTImages.Dispose();
                ho_GTImageChannelsScaled.Dispose();
                ho_GTImageChannel.Dispose();
                ho_GTImageChannelScaled.Dispose();
                ho_GTImageR.Dispose();
                ho_GTImageG.Dispose();
                ho_GTImageB.Dispose();
                ho_RegionContour.Dispose();

                hv_NumSamples.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_NumChannels.Dispose();
                hv_GrayMin.Dispose();
                hv_GrayMax.Dispose();
                hv_IndexChannel.Dispose();
                hv_GrayMinTmp.Dispose();
                hv_GrayMaxTmp.Dispose();
                hv__.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_FrameSize.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_Color.Dispose();
                hv_Number.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();
                hvec_GrayMins.Dispose();
                hvec_GrayMaxs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GTImagesRaw.Dispose();
                ho_GTImage.Dispose();
                ho_Channel.Dispose();
                ho_RegionContourCheck.Dispose();
                ho_Rectangle1.Dispose();
                ho_Rectangle2.Dispose();
                ho_RegionContourCross.Dispose();
                ho_TopContour.Dispose();
                ho_LeftContour.Dispose();
                ho_RightContour.Dispose();
                ho_BottomContour.Dispose();
                ho_Frame.Dispose();
                ho_TextImageOneChannel.Dispose();
                ho_TextImageOneChannels.Dispose();
                ho_TextImage.Dispose();
                ho_SeparateImageOneChannel.Dispose();
                ho_SeparateImageOneChannels.Dispose();
                ho_SeparateImage.Dispose();
                ho_GTImages.Dispose();
                ho_GTImageChannelsScaled.Dispose();
                ho_GTImageChannel.Dispose();
                ho_GTImageChannelScaled.Dispose();
                ho_GTImageR.Dispose();
                ho_GTImageG.Dispose();
                ho_GTImageB.Dispose();
                ho_RegionContour.Dispose();

                hv_NumSamples.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_NumChannels.Dispose();
                hv_GrayMin.Dispose();
                hv_GrayMax.Dispose();
                hv_IndexChannel.Dispose();
                hv_GrayMinTmp.Dispose();
                hv_GrayMaxTmp.Dispose();
                hv__.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_FrameSize.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_Color.Dispose();
                hv_Number.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();
                hvec_GrayMins.Dispose();
                hvec_GrayMaxs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Generate a tiled image for the Deep OCR DLSamples and add indications whether the predictions are true or not. 
        private void gen_tiled_ocr_recognition_image_result(out HObject ho_TiledImage,
            HTuple hv_DLSamples, HTuple hv_PredictionsCorrect, out HTuple hv_TextImageRows,
            out HTuple hv_TextImageColumns, out HTuple hv_TextImageWidth, out HTuple hv_TextImageHeight)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_SampleImagesRaw, ho_Image = null;
            HObject ho_ChannelR, ho_ChannelG, ho_ChannelB, ho_TextImageRaw;
            HObject ho_SeparateImage, ho_Checkmark, ho_Cross, ho_ImagesToTile;
            HObject ho_SampleImage = null, ho_ImageChannelsScaled = null;
            HObject ho_ImageChannel = null, ho_ImageChannelScaled = null;
            HObject ho_ImageR = null, ho_ImageG = null, ho_ImageB = null;
            HObject ho_PredictionSymbol = null, ho_TextImage = null;

            // Local control variables 

            HTuple hv_NumSamples = new HTuple(), hv_NumColumnsTiled = new HTuple();
            HTuple hv_NumRowsTiled = new HTuple(), hv_MaxNumSamplesSupported = new HTuple();
            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_Index = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_SeparateImageWidth = new HTuple();
            HTuple hv_SeparateImageHeight = new HTuple(), hv_SymbolLineWidth = new HTuple();
            HTuple hv_SymbolSize = new HTuple(), hv_SymbolRow = new HTuple();
            HTuple hv_SymbolColumn = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DCompose = new HTuple();
            HTuple hv_S = new HTuple(), hv_W = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_IndexChannel = new HTuple(), hv_ScaleMax = new HTuple();
            HTuple hv_ScaleMin = new HTuple(), hv_PredictionForegroundColor = new HTuple();
            HTuple hv_PredictionBackgroundColor = new HTuple(), hv_TiledRows = new HTuple();
            HTuple hv_TiledColumns = new HTuple(), hv_TiledHeights = new HTuple();
            HTuple hv_TiledWidths = new HTuple(), hv_MinusOnes = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImage);
            HOperatorSet.GenEmptyObj(out ho_SampleImagesRaw);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ChannelR);
            HOperatorSet.GenEmptyObj(out ho_ChannelG);
            HOperatorSet.GenEmptyObj(out ho_ChannelB);
            HOperatorSet.GenEmptyObj(out ho_TextImageRaw);
            HOperatorSet.GenEmptyObj(out ho_SeparateImage);
            HOperatorSet.GenEmptyObj(out ho_Checkmark);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_ImagesToTile);
            HOperatorSet.GenEmptyObj(out ho_SampleImage);
            HOperatorSet.GenEmptyObj(out ho_ImageChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageChannel);
            HOperatorSet.GenEmptyObj(out ho_ImageChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_PredictionSymbol);
            HOperatorSet.GenEmptyObj(out ho_TextImage);
            hv_TextImageRows = new HTuple();
            hv_TextImageColumns = new HTuple();
            hv_TextImageWidth = new HTuple();
            hv_TextImageHeight = new HTuple();
            try
            {
                //
                //This procedure generates a tiled image for the Deep OCR Recognition samples.
                //It adds indications if the prediction was correct (green bar with checkmark)
                //or wrong (red bar with cross).
                //
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
                        );
                }
                //
                //Maximum number of samples supported: 16 (grid 4 x 4).
                hv_NumColumnsTiled.Dispose();
                hv_NumColumnsTiled = new HTuple();
                hv_NumColumnsTiled[0] = 1;
                hv_NumColumnsTiled[1] = 1;
                hv_NumColumnsTiled[2] = 1;
                hv_NumColumnsTiled[3] = 1;
                hv_NumColumnsTiled[4] = 2;
                hv_NumColumnsTiled[5] = 2;
                hv_NumColumnsTiled[6] = 2;
                hv_NumColumnsTiled[7] = 2;
                hv_NumColumnsTiled[8] = 3;
                hv_NumColumnsTiled[9] = 3;
                hv_NumColumnsTiled[10] = 3;
                hv_NumColumnsTiled[11] = 3;
                hv_NumColumnsTiled[12] = 4;
                hv_NumColumnsTiled[13] = 4;
                hv_NumColumnsTiled[14] = 4;
                hv_NumColumnsTiled[15] = 4;
                hv_NumRowsTiled.Dispose();
                hv_NumRowsTiled = new HTuple();
                hv_NumRowsTiled[0] = 1;
                hv_NumRowsTiled[1] = 2;
                hv_NumRowsTiled[2] = 3;
                hv_NumRowsTiled[3] = 4;
                hv_NumRowsTiled[4] = 4;
                hv_NumRowsTiled[5] = 4;
                hv_NumRowsTiled[6] = 4;
                hv_NumRowsTiled[7] = 4;
                hv_NumRowsTiled[8] = 4;
                hv_NumRowsTiled[9] = 4;
                hv_NumRowsTiled[10] = 4;
                hv_NumRowsTiled[11] = 4;
                hv_NumRowsTiled[12] = 4;
                hv_NumRowsTiled[13] = 4;
                hv_NumRowsTiled[14] = 4;
                hv_NumRowsTiled[15] = 4;
                hv_MaxNumSamplesSupported.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxNumSamplesSupported = new HTuple(hv_NumRowsTiled.TupleLength()
                        );
                }
                //
                //Get number of rows/columns of tiled image.
                if ((int)(new HTuple(hv_NumSamples.TupleGreater(hv_MaxNumSamplesSupported))) != 0)
                {
                    throw new HalconException(("More than " + hv_MaxNumSamplesSupported) + " images cannot be shown in the training progress.");
                }
                hv_NumRows.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumRows = hv_NumRowsTiled.TupleSelect(
                        hv_NumSamples - 1);
                }
                hv_NumColumns.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColumns = hv_NumColumnsTiled.TupleSelect(
                        hv_NumSamples - 1);
                }
                //
                //Get images and minimal/maximal gray values.
                ho_SampleImagesRaw.Dispose();
                HOperatorSet.GenEmptyObj(out ho_SampleImagesRaw);
                HTuple end_val21 = hv_NumSamples - 1;
                HTuple step_val21 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.GetDictObject(out ho_Image, hv_DLSamples.TupleSelect(hv_Index),
                            "image");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_SampleImagesRaw, ho_Image, out ExpTmpOutVar_0);
                        ho_SampleImagesRaw.Dispose();
                        ho_SampleImagesRaw = ExpTmpOutVar_0;
                    }
                }
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //
                //Create text image to print in text later.
                hv_TextImageHeight.Dispose();
                hv_TextImageHeight = 24;
                hv_TextImageWidth.Dispose();
                hv_TextImageWidth = new HTuple(hv_ImageWidth);
                ho_ChannelR.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelR, "real", hv_TextImageWidth, hv_TextImageHeight);
                ho_ChannelG.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelG, "real", hv_TextImageWidth, hv_TextImageHeight);
                ho_ChannelB.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelB, "real", hv_TextImageWidth, hv_TextImageHeight);
                ho_TextImageRaw.Dispose();
                HOperatorSet.Compose3(ho_ChannelR, ho_ChannelG, ho_ChannelB, out ho_TextImageRaw
                    );
                //
                //Create black image to separate columns.
                hv_SeparateImageWidth.Dispose();
                hv_SeparateImageWidth = 4;
                hv_SeparateImageHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SeparateImageHeight = hv_NumRows * (hv_ImageHeight + hv_TextImageHeight);
                }
                ho_ChannelR.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelR, "real", hv_SeparateImageWidth,
                    hv_SeparateImageHeight);
                ho_ChannelG.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelG, "real", hv_SeparateImageWidth,
                    hv_SeparateImageHeight);
                ho_ChannelB.Dispose();
                HOperatorSet.GenImageConst(out ho_ChannelB, "real", hv_SeparateImageWidth,
                    hv_SeparateImageHeight);
                ho_SeparateImage.Dispose();
                HOperatorSet.Compose3(ho_ChannelR, ho_ChannelG, ho_ChannelB, out ho_SeparateImage
                    );
                //
                //Create prediction symbols: checkmark/cross for correct/incorrect.
                hv_SymbolLineWidth.Dispose();
                hv_SymbolLineWidth = 3.6;
                hv_SymbolSize.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SymbolSize = 0.5 * hv_TextImageHeight;
                }
                hv_SymbolRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SymbolRow = 0.5 * hv_TextImageHeight;
                }
                hv_SymbolColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SymbolColumn = hv_ImageWidth - hv_SymbolSize;
                }
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, (new HTuple(45)).TupleRad()
                        , 0, 0, out hv_HomMat2DRotate);
                }
                hv_HomMat2DCompose.Dispose();
                HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_SymbolRow, hv_SymbolColumn,
                    out hv_HomMat2DCompose);
                hv_S.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_S = 0.5 * hv_SymbolSize;
                }
                hv_W.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_W = 0.5 * hv_SymbolLineWidth;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Checkmark.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Checkmark, ((((((((((hv_W.TupleConcat(
                        -0.75 * hv_S))).TupleConcat(-0.75 * hv_S))).TupleConcat(-hv_W))).TupleConcat(
                        -hv_W))).TupleConcat(hv_W))).TupleConcat(hv_W), (((((((((((((-hv_S) - hv_W)).TupleConcat(
                        (-hv_S) - hv_W))).TupleConcat((-hv_S) + hv_W))).TupleConcat((-hv_S) + hv_W))).TupleConcat(
                        hv_S))).TupleConcat(hv_S))).TupleConcat((-hv_S) - hv_W));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Cross, ((((((((((((((((((((((((-hv_W)).TupleConcat(
                        -hv_W))).TupleConcat(-hv_S))).TupleConcat(-hv_S))).TupleConcat(-hv_W))).TupleConcat(
                        -hv_W))).TupleConcat(hv_W))).TupleConcat(hv_W))).TupleConcat(hv_S))).TupleConcat(
                        hv_S))).TupleConcat(hv_W))).TupleConcat(hv_W))).TupleConcat(-hv_W), ((((((((((((((((((((((((-hv_S)).TupleConcat(
                        -hv_W))).TupleConcat(-hv_W))).TupleConcat(hv_W))).TupleConcat(hv_W))).TupleConcat(
                        hv_S))).TupleConcat(hv_S))).TupleConcat(hv_W))).TupleConcat(hv_W))).TupleConcat(
                        -hv_W))).TupleConcat(-hv_W))).TupleConcat(-hv_S))).TupleConcat(-hv_S));
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_Checkmark, out ExpTmpOutVar_0, hv_HomMat2DCompose);
                    ho_Checkmark.Dispose();
                    ho_Checkmark = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_Cross, out ExpTmpOutVar_0, hv_HomMat2DCompose);
                    ho_Cross.Dispose();
                    ho_Cross = ExpTmpOutVar_0;
                }
                //
                //Adapt images with prediction results.
                ho_ImagesToTile.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ImagesToTile);
                HTuple end_val60 = hv_NumSamples - 1;
                HTuple step_val60 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val60, step_val60); hv_Index = hv_Index.TupleAdd(step_val60))
                {
                    //Scale images to [0,1] to have identical color ranges.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_SampleImage.Dispose();
                        HOperatorSet.SelectObj(ho_SampleImagesRaw, out ho_SampleImage, hv_Index + 1);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_SampleImage, out ExpTmpOutVar_0);
                        ho_SampleImage.Dispose();
                        ho_SampleImage = ExpTmpOutVar_0;
                    }
                    hv_NumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_SampleImage, out hv_NumChannels);
                    ho_ImageChannelsScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImageChannelsScaled);
                    HTuple end_val66 = hv_NumChannels - 1;
                    HTuple step_val66 = 1;
                    for (hv_IndexChannel = 0; hv_IndexChannel.Continue(end_val66, step_val66); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val66))
                    {
                        //ocr_recognition image range is [-1,1]
                        hv_ScaleMax.Dispose();
                        hv_ScaleMax = 1.0;
                        hv_ScaleMin.Dispose();
                        hv_ScaleMin = -1.0;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ImageChannel.Dispose();
                            HOperatorSet.AccessChannel(ho_SampleImage, out ho_ImageChannel, hv_IndexChannel + 1);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ImageChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_ImageChannel, out ho_ImageChannelScaled, 1.0 / (hv_ScaleMax - hv_ScaleMin),
                                (-(hv_ScaleMin.TupleReal())) / (hv_ScaleMax - hv_ScaleMin));
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_ImageChannelsScaled, ho_ImageChannelScaled, out ExpTmpOutVar_0
                                );
                            ho_ImageChannelsScaled.Dispose();
                            ho_ImageChannelsScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_SampleImage.Dispose();
                    HOperatorSet.ChannelsToImage(ho_ImageChannelsScaled, out ho_SampleImage);
                    //Ensure that all images in Image has equal number of channels for display.
                    if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                    {
                        ho_ImageR.Dispose();
                        HOperatorSet.AccessChannel(ho_SampleImage, out ho_ImageR, 1);
                        ho_ImageG.Dispose();
                        HOperatorSet.CopyImage(ho_ImageR, out ho_ImageG);
                        ho_ImageB.Dispose();
                        HOperatorSet.CopyImage(ho_ImageR, out ho_ImageB);
                        ho_SampleImage.Dispose();
                        HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_SampleImage
                            );
                    }
                    //Set prediction parameters.
                    if ((int)(hv_PredictionsCorrect.TupleSelect(hv_Index)) != 0)
                    {
                        hv_PredictionForegroundColor.Dispose();
                        hv_PredictionForegroundColor = new HTuple();
                        hv_PredictionForegroundColor[0] = 0;
                        hv_PredictionForegroundColor[1] = 1;
                        hv_PredictionForegroundColor[2] = 0;
                        hv_PredictionBackgroundColor.Dispose();
                        hv_PredictionBackgroundColor = new HTuple();
                        hv_PredictionBackgroundColor[0] = 0;
                        hv_PredictionBackgroundColor[1] = 0.5;
                        hv_PredictionBackgroundColor[2] = 0;
                        ho_PredictionSymbol.Dispose();
                        ho_PredictionSymbol = new HObject(ho_Checkmark);
                    }
                    else
                    {
                        hv_PredictionForegroundColor.Dispose();
                        hv_PredictionForegroundColor = new HTuple();
                        hv_PredictionForegroundColor[0] = 1;
                        hv_PredictionForegroundColor[1] = 0;
                        hv_PredictionForegroundColor[2] = 0;
                        hv_PredictionBackgroundColor.Dispose();
                        hv_PredictionBackgroundColor = new HTuple();
                        hv_PredictionBackgroundColor[0] = 0.5;
                        hv_PredictionBackgroundColor[1] = 0;
                        hv_PredictionBackgroundColor[2] = 0;
                        ho_PredictionSymbol.Dispose();
                        ho_PredictionSymbol = new HObject(ho_Cross);
                    }
                    //Add sample image.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImagesToTile, ho_SampleImage, out ExpTmpOutVar_0
                            );
                        ho_ImagesToTile.Dispose();
                        ho_ImagesToTile = ExpTmpOutVar_0;
                    }
                    //Add text image.
                    ho_TextImage.Dispose();
                    HOperatorSet.CopyImage(ho_TextImageRaw, out ho_TextImage);
                    HOperatorSet.OverpaintRegion(ho_TextImage, ho_TextImage, hv_PredictionBackgroundColor,
                        "fill");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintXld(ho_PredictionSymbol, ho_TextImage, out ExpTmpOutVar_0,
                            hv_PredictionForegroundColor);
                        ho_TextImage.Dispose();
                        ho_TextImage = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImagesToTile, ho_TextImage, out ExpTmpOutVar_0);
                        ho_ImagesToTile.Dispose();
                        ho_ImagesToTile = ExpTmpOutVar_0;
                    }
                }
                //
                //Set row/column positions of upper-left corners for the images to tile,
                //and for the text images.
                hv_TiledRows.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledRows = HTuple.TupleGenConst(
                        2 * hv_NumSamples, 0);
                }
                hv_TiledColumns.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledColumns = HTuple.TupleGenConst(
                        2 * hv_NumSamples, 0);
                }
                hv_TextImageRows.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageRows = HTuple.TupleGenConst(
                        hv_NumSamples, 0);
                }
                hv_TextImageColumns.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageColumns = HTuple.TupleGenConst(
                        hv_NumSamples, 0);
                }
                HTuple end_val107 = hv_NumSamples - 1;
                HTuple step_val107 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val107, step_val107); hv_Index = hv_Index.TupleAdd(step_val107))
                {
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[2 * hv_Index] = (hv_Index % hv_NumRows) * (hv_TextImageHeight + hv_ImageHeight);
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[(2 * hv_Index) + 1] = (hv_TiledRows.TupleSelect(2 * hv_Index)) + hv_ImageHeight;
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[2 * hv_Index] = (hv_Index / hv_NumRows) * (hv_ImageWidth + hv_SeparateImageWidth);
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[(2 * hv_Index) + 1] = hv_TiledColumns.TupleSelect(2 * hv_Index);
                    if (hv_TextImageRows == null)
                        hv_TextImageRows = new HTuple();
                    hv_TextImageRows[hv_Index] = hv_TiledRows.TupleSelect((2 * hv_Index) + 1);
                    if (hv_TextImageColumns == null)
                        hv_TextImageColumns = new HTuple();
                    hv_TextImageColumns[hv_Index] = hv_TiledColumns.TupleSelect((2 * hv_Index) + 1);
                }
                //
                //Add vertical separator images to the images to tile, and
                //set the row/column positions of their upper-left corners.
                HTuple end_val118 = hv_NumColumns - 1;
                HTuple step_val118 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val118, step_val118); hv_Index = hv_Index.TupleAdd(step_val118))
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImagesToTile, ho_SeparateImage, out ExpTmpOutVar_0
                            );
                        ho_ImagesToTile.Dispose();
                        ho_ImagesToTile = ExpTmpOutVar_0;
                    }
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[new HTuple(hv_TiledRows.TupleLength())] = 0;
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[new HTuple(hv_TiledColumns.TupleLength())] = (hv_Index * (hv_ImageWidth + hv_SeparateImageWidth)) + hv_ImageWidth;
                }
                //
                hv_TiledHeights.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledHeights = hv_NumRows * (hv_TextImageHeight + hv_ImageHeight);
                }
                hv_TiledWidths.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledWidths = (hv_NumColumns * hv_ImageWidth) + ((hv_NumColumns - 1) * hv_SeparateImageWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinusOnes.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_TiledRows.TupleLength()), -1, out hv_MinusOnes);
                }
                ho_TiledImage.Dispose();
                HOperatorSet.TileImagesOffset(ho_ImagesToTile, out ho_TiledImage, hv_TiledRows,
                    hv_TiledColumns, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes,
                    hv_TiledWidths, hv_TiledHeights);
                //
                ho_SampleImagesRaw.Dispose();
                ho_Image.Dispose();
                ho_ChannelR.Dispose();
                ho_ChannelG.Dispose();
                ho_ChannelB.Dispose();
                ho_TextImageRaw.Dispose();
                ho_SeparateImage.Dispose();
                ho_Checkmark.Dispose();
                ho_Cross.Dispose();
                ho_ImagesToTile.Dispose();
                ho_SampleImage.Dispose();
                ho_ImageChannelsScaled.Dispose();
                ho_ImageChannel.Dispose();
                ho_ImageChannelScaled.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();
                ho_PredictionSymbol.Dispose();
                ho_TextImage.Dispose();

                hv_NumSamples.Dispose();
                hv_NumColumnsTiled.Dispose();
                hv_NumRowsTiled.Dispose();
                hv_MaxNumSamplesSupported.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SymbolLineWidth.Dispose();
                hv_SymbolSize.Dispose();
                hv_SymbolRow.Dispose();
                hv_SymbolColumn.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_S.Dispose();
                hv_W.Dispose();
                hv_NumChannels.Dispose();
                hv_IndexChannel.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_PredictionForegroundColor.Dispose();
                hv_PredictionBackgroundColor.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_SampleImagesRaw.Dispose();
                ho_Image.Dispose();
                ho_ChannelR.Dispose();
                ho_ChannelG.Dispose();
                ho_ChannelB.Dispose();
                ho_TextImageRaw.Dispose();
                ho_SeparateImage.Dispose();
                ho_Checkmark.Dispose();
                ho_Cross.Dispose();
                ho_ImagesToTile.Dispose();
                ho_SampleImage.Dispose();
                ho_ImageChannelsScaled.Dispose();
                ho_ImageChannel.Dispose();
                ho_ImageChannelScaled.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();
                ho_PredictionSymbol.Dispose();
                ho_TextImage.Dispose();

                hv_NumSamples.Dispose();
                hv_NumColumnsTiled.Dispose();
                hv_NumRowsTiled.Dispose();
                hv_MaxNumSamplesSupported.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SymbolLineWidth.Dispose();
                hv_SymbolSize.Dispose();
                hv_SymbolRow.Dispose();
                hv_SymbolColumn.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_S.Dispose();
                hv_W.Dispose();
                hv_NumChannels.Dispose();
                hv_IndexChannel.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_PredictionForegroundColor.Dispose();
                hv_PredictionBackgroundColor.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Generate a tiled image for segmentation and 3D Gripping Point Detection DLSamples. 
        private void gen_tiled_segmentation_image(out HObject ho_TiledImageRow, HTuple hv_DLSamples,
            HTuple hv_SpacingCol, HTuple hv_Width, HTuple hv_Height)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_GTImages, ho_GTImage = null;

            // Local control variables 

            HTuple hv_SegmentationImageExist = new HTuple();
            HTuple hv_GrippingMapExist = new HTuple(), hv_ImageNameKey = new HTuple();
            HTuple hv_Crop = new HTuple(), hv_OffsetRow = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_GTImages);
            HOperatorSet.GenEmptyObj(out ho_GTImage);
            try
            {
                //
                //This procedure tiles the existing segmentation or gripping map images in given samples in a row.
                //
                //Check the required image for tiling.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationImageExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "segmentation_image",
                        out hv_SegmentationImageExist);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GrippingMapExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "gripping_map",
                        out hv_GrippingMapExist);
                }
                if ((int)(hv_SegmentationImageExist) != 0)
                {
                    hv_ImageNameKey.Dispose();
                    hv_ImageNameKey = "segmentation_image";
                }
                else if ((int)(hv_GrippingMapExist) != 0)
                {
                    hv_ImageNameKey.Dispose();
                    hv_ImageNameKey = "gripping_map";
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Crop.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OffsetRow.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
                }
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
                        );
                }
                ho_GTImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImages);
                HTuple end_val16 = hv_NumSamples - 1;
                HTuple step_val16 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val16, step_val16); hv_Index = hv_Index.TupleAdd(step_val16))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_GTImage, hv_DLSamples.TupleSelect(hv_Index),
                            hv_ImageNameKey);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_TiledImageRow.Dispose();
                    HOperatorSet.TileImagesOffset(ho_GTImages, out ho_TiledImageRow, hv_OffsetRow,
                        (((new HTuple(0)).TupleConcat(((hv_Width + hv_SpacingCol)).TupleCumul()))).TupleSelectRange(
                        0, (new HTuple(hv_Width.TupleLength())) - 1), hv_Crop, hv_Crop, hv_Crop, hv_Crop,
                        (((((hv_Width + hv_SpacingCol)).TupleCumul())).TupleSelect((new HTuple(hv_Width.TupleLength()
                        )) - 1)) - hv_SpacingCol, hv_Height.TupleMax());
                }
                ho_GTImages.Dispose();
                ho_GTImage.Dispose();

                hv_SegmentationImageExist.Dispose();
                hv_GrippingMapExist.Dispose();
                hv_ImageNameKey.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_NumSamples.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GTImages.Dispose();
                ho_GTImage.Dispose();

                hv_SegmentationImageExist.Dispose();
                hv_GrippingMapExist.Dispose();
                hv_ImageNameKey.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_NumSamples.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Generate a word to characters mapping. 
        private void gen_words_chars_mapping(HTuple hv_DLSample, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_WordsCharsMapping)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WordsIndices = new HTuple(), hv_CharsIndices = new HTuple();
            HTuple hv_WordLengths = new HTuple(), hv_WordArea = new HTuple();
            HTuple hv_CharArea = new HTuple(), hv_CharAreaThreshold = new HTuple();
            HTuple hv_WordIndex = new HTuple(), hv_AreaIntersection = new HTuple();
            HTuple hv_CIsInsideW = new HTuple(), hv_CIndex = new HTuple();
            // Initialize local and output iconic variables 
            hvec_WordsCharsMapping = new HTupleVector(1);
            try
            {
                //Procedure to generate the mapping: gen_words_chars_mapping
                if ((int)(new HTuple((new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WordsIndices.Dispose();
                        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 0,
                            out hv_WordsIndices);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CharsIndices.Dispose();
                        HOperatorSet.TupleFind(hv_DLSample.TupleGetDictTuple("bbox_label_id"), 1,
                            out hv_CharsIndices);
                    }
                    if ((int)((new HTuple(hv_CharsIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_WordsIndices.TupleNotEqual(
                        -1)))) != 0)
                    {
                        hv_WordLengths.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WordLengths = ((((hv_DLSample.TupleGetDictTuple(
                                "word"))).TupleSelect(hv_WordsIndices))).TupleStrlen();
                        }
                        //Init vector.
                        hvec_WordsCharsMapping[(new HTuple(((hv_DLSample.TupleGetDictTuple("bbox_label_id"))).TupleLength()
                            )) - 1] = new HTupleVector(new HTuple());
                        hv_WordArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WordArea = (4 * (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_WordsIndices))) * (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_WordsIndices));
                        }
                        hv_CharArea.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CharArea = (4 * (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length1"))).TupleSelect(hv_CharsIndices))) * (((hv_DLSample.TupleGetDictTuple(
                                "bbox_length2"))).TupleSelect(hv_CharsIndices));
                        }
                        //TODO: This threshold is quite arbitrary and not stable.
                        hv_CharAreaThreshold.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CharAreaThreshold = hv_CharArea * 0.8;
                        }
                        for (hv_WordIndex = 0; (int)hv_WordIndex <= (int)((new HTuple(hv_WordsIndices.TupleLength()
                            )) - 1); hv_WordIndex = (int)hv_WordIndex + 1)
                        {
                            if ((int)(new HTuple(((hv_WordLengths.TupleSelect(hv_WordIndex))).TupleNotEqual(
                                0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_AreaIntersection.Dispose();
                                    HOperatorSet.AreaIntersectionRectangle2(((hv_DLSample.TupleGetDictTuple(
                                        "bbox_row"))).TupleSelect(hv_WordsIndices.TupleSelect(hv_WordIndex)),
                                        ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(hv_WordsIndices.TupleSelect(
                                        hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                                        hv_WordsIndices.TupleSelect(hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple(
                                        "bbox_length1"))).TupleSelect(hv_WordsIndices.TupleSelect(hv_WordIndex)),
                                        ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(hv_WordsIndices.TupleSelect(
                                        hv_WordIndex)), ((hv_DLSample.TupleGetDictTuple("bbox_row"))).TupleSelect(
                                        hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_col"))).TupleSelect(
                                        hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_phi"))).TupleSelect(
                                        hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_length1"))).TupleSelect(
                                        hv_CharsIndices), ((hv_DLSample.TupleGetDictTuple("bbox_length2"))).TupleSelect(
                                        hv_CharsIndices), out hv_AreaIntersection);
                                }
                                hv_CIsInsideW.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CIsInsideW = hv_AreaIntersection.TupleGreaterElem(
                                        hv_CharAreaThreshold);
                                }
                                hv_CIndex.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CIndex = hv_CIsInsideW.TupleFind(
                                        1);
                                }
                                if ((int)(new HTuple(hv_CIndex.TupleNotEqual(-1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hvec_WordsCharsMapping[hv_WordsIndices.TupleSelect(
                                            hv_WordIndex)] = dh.Add(new HTupleVector(hv_CharsIndices.TupleSelect(
                                            hv_CIndex)));
                                    }
                                }
                            }
                            else
                            {
                                throw new HalconException(((("Sample with image id " + (hv_DLSample.TupleGetDictTuple(
                                    "image_id"))) + " is not valid. The word bounding box at index ") + hv_WordIndex) + " has an empty string as the ground truth. This is not allowed. Please assign a word label to every word bounding box.");
                            }
                        }
                    }
                }

                hv_WordsIndices.Dispose();
                hv_CharsIndices.Dispose();
                hv_WordLengths.Dispose();
                hv_WordArea.Dispose();
                hv_CharArea.Dispose();
                hv_CharAreaThreshold.Dispose();
                hv_WordIndex.Dispose();
                hv_AreaIntersection.Dispose();
                hv_CIsInsideW.Dispose();
                hv_CIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WordsIndices.Dispose();
                hv_CharsIndices.Dispose();
                hv_WordLengths.Dispose();
                hv_WordArea.Dispose();
                hv_CharArea.Dispose();
                hv_CharAreaThreshold.Dispose();
                hv_WordIndex.Dispose();
                hv_AreaIntersection.Dispose();
                hv_CIsInsideW.Dispose();
                hv_CIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Get the ground truth anomaly label and label ID. 
        private void get_anomaly_ground_truth_label(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_AnomalyLabelGroundTruth = new HTuple();
            hv_AnomalyLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the anomaly ground truth label.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label id cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). 
        private void get_anomaly_result(out HObject ho_AnomalyImage, out HObject ho_AnomalyRegion,
            HTuple hv_DLResult, HTuple hv_AnomalyClassThreshold, HTuple hv_AnomalyRegionThreshold,
            HTuple hv_AnomalyResultPostfix, out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID,
            out HTuple hv_AnomalyClassThresholdDisplay, out HTuple hv_AnomalyRegionThresholdDisplay)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AnomalyImageKey = new HTuple(), hv_AnomalyScoreKey = new HTuple();
            HTuple hv_AnomalyRegionKey = new HTuple(), hv_AnomalyClassIdKey = new HTuple();
            HTuple hv_ErrorMsgPostfix = new HTuple(), hv_ResultKeys = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyScore = new HTuple();
            hv_AnomalyClassID = new HTuple();
            hv_AnomalyClassThresholdDisplay = new HTuple();
            hv_AnomalyRegionThresholdDisplay = new HTuple();
            try
            {
                //
                //This procedure returns the inference results in DLResult which are
                //the anomaly image and the anomaly score. It also returns the
                //classification of the anomaly score and segmentation of anomalous
                //pixels in the anomaly image by applying the specified thresholds if
                //given. Otherwise the results from DLResult are used.
                //
                //
                hv_AnomalyImageKey.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyImageKey = "anomaly_image" + hv_AnomalyResultPostfix;
                }
                hv_AnomalyScoreKey.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyScoreKey = "anomaly_score" + hv_AnomalyResultPostfix;
                }
                hv_AnomalyRegionKey.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyRegionKey = "anomaly_region" + hv_AnomalyResultPostfix;
                }
                hv_AnomalyClassIdKey.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyClassIdKey = "anomaly_class_id" + hv_AnomalyResultPostfix;
                }
                //
                hv_ErrorMsgPostfix.Dispose();
                HOperatorSet.TupleRegexpReplace(hv_AnomalyResultPostfix, "_", " ", out hv_ErrorMsgPostfix);
                //
                hv_ResultKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
                if ((int)(new HTuple(hv_ResultKeys.TupleEqual(new HTuple()))) != 0)
                {
                    throw new HalconException(("Result anomaly image" + hv_ErrorMsgPostfix) + " could not be found in DLResult.");
                }
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyImageKey))).TupleNotEqual(
                    -1))) != 0)
                {
                    ho_AnomalyImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, hv_AnomalyImageKey);
                }
                else
                {
                    throw new HalconException(("Result anomaly image" + hv_ErrorMsgPostfix) + " could not be found in DLResult.");
                }
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyScoreKey))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, hv_AnomalyScoreKey, out hv_AnomalyScore);
                }
                else
                {
                    throw new HalconException(("Result anomaly score" + hv_ErrorMsgPostfix) + " could not be found in DLResult.");
                }
                //
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay = -1;
                if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                {
                    //Apply threshold for segmentation result.
                    if ((int)(new HTuple((new HTuple(hv_AnomalyRegionThreshold.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_region_threshold' must be specified by exactly one value.");
                    }
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold,
                        "max");
                    hv_AnomalyRegionThresholdDisplay.Dispose();
                    hv_AnomalyRegionThresholdDisplay = new HTuple(hv_AnomalyRegionThreshold);
                }
                else
                {
                    //If no threshold is given, use the threshold and resulting anomaly region out of DLResult.
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyRegionKey))).TupleNotEqual(
                        -1))) != 0)
                    {
                        ho_AnomalyRegion.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyRegion, hv_DLResult, hv_AnomalyRegionKey);
                    }
                    else
                    {
                        ho_AnomalyRegion.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
                    }
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_segmentation_threshold"))).TupleNotEqual(
                        -1))) != 0)
                    {
                        hv_AnomalyRegionThresholdDisplay.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_segmentation_threshold",
                            out hv_AnomalyRegionThresholdDisplay);
                    }
                }
                //
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyClassThresholdDisplay = -1;
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassID = -1;
                if ((int)(new HTuple(hv_AnomalyClassThreshold.TupleNotEqual(-1))) != 0)
                {
                    //Apply threshold for classification result.
                    if ((int)(new HTuple((new HTuple(hv_AnomalyClassThreshold.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_classification_threshold' must be specified by exactly one value.");
                    }
                    if ((int)(new HTuple(hv_AnomalyScore.TupleLess(hv_AnomalyClassThreshold))) != 0)
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = 0;
                    }
                    else
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = 1;
                    }
                    hv_AnomalyClassThresholdDisplay.Dispose();
                    hv_AnomalyClassThresholdDisplay = new HTuple(hv_AnomalyClassThreshold);
                }
                else
                {
                    //If no threshold is given, use the threshold and resulting class id out of DLResult.
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFindFirst(hv_AnomalyClassIdKey))).TupleNotEqual(
                        -1))) != 0)
                    {
                        hv_AnomalyClassID.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, hv_AnomalyClassIdKey, out hv_AnomalyClassID);
                    }
                    else
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = -1;
                    }
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_classification_threshold"))).TupleNotEqual(
                        -1))) != 0)
                    {
                        hv_AnomalyClassThresholdDisplay.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_classification_threshold",
                            out hv_AnomalyClassThresholdDisplay);
                    }
                }
                //

                hv_AnomalyImageKey.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyRegionKey.Dispose();
                hv_AnomalyClassIdKey.Dispose();
                hv_ErrorMsgPostfix.Dispose();
                hv_ResultKeys.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AnomalyImageKey.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyRegionKey.Dispose();
                hv_AnomalyClassIdKey.Dispose();
                hv_ErrorMsgPostfix.Dispose();
                hv_ResultKeys.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next child window that can be used for visualization. 
        private void get_child_window(HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatio = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next child window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_ParentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    hv_ChildWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
                            1);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //Since there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next child window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_ChildWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    //
                    //Get previous window coordinates.
                    hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                    HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn,
                        out hv_WindowWidth, out hv_WindowHeight);
                    hv_WindowImageRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                    }
                    //
                    try
                    {
                        //
                        //Get WindowImageRatio from parent window.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                                out hv_WindowImageRatio);
                        }
                        //
                        //Get previous window coordinates.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PrevWindowCoordinatesOut.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                                out hv_PrevWindowCoordinatesOut);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        //
                        //Set WindowImageRatio from parent window.
                        hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow,
                            out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
                        hv_WindowImageRatio.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                        }
                        //
                        //Set previous window coordinates.
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
                    }
                }
                else
                {
                    //
                    //Open a new child window.
                    hv_ChildWindowHandle.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                        hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
                            hv_ChildWindowHandle));
                    }
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the ground truth classification label id. 
        private void get_classification_ground_truth(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_ClassificationLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_ClassificationLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the classification ground truth label ID.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the predicted classification class ID. 
        private void get_classification_result(HTuple hv_ResultKeys, HTuple hv_DLResult,
            out HTuple hv_ClassificationClassID)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_ClassificationClassID = new HTuple();
            //
            //This procedure returns the predicted classification class ID.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationClassID.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
                if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
                                0);
                            hv_ClassificationClassID.Dispose();
                            hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
                        }
                    }
                }
            }
            else
            {
                throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Get the confidences of the segmentation result. 
        private void get_confidence_image(out HObject ho_ImageConfidence, HTuple hv_ResultKeys,
            HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            //
            //This procedure returns confidences of the segmentation result.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
            }
            else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
            }
            else
            {
                throw new HalconException("Confidence image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        private void get_distinct_colors(HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor,
            HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        private void get_distinct_colors_dev_display_pie_chart(HTuple hv_NumColors, HTuple hv_Random,
            HTuple hv_StartColor, HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate certain colors for different ClassNames 
        private void get_dl_class_colors(HTuple hv_ClassNames, HTuple hv_AdditionalGreenClassNames,
            out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
            HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
            HTuple hv_GreenIdx = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure returns for each class a certain color.
                //
                //Define distinct colors for the classes.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
                        );
                }
                //Get distinct colors without randomness makes neighboring colors look very similar.
                //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
                hv_ColorsRainbow.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
                    hv_ColorsRainbow.Dispose();
                    hv_ColorsRainbow = ExpTmpOutVar_0;
                }
                hv_Colors.Dispose();
                make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
                //If a class 'OK','ok', 'good' or 'GOOD' or a class specified in AdditionalGreenClassNames is present set this class to green.
                //Only the first occurrence found is set to a green shade.
                hv_ClassNamesGood.Dispose();
                HOperatorSet.TupleUnion((((new HTuple("good")).TupleConcat("GOOD")).TupleConcat(
                    "ok")).TupleConcat("OK"), hv_AdditionalGreenClassNames, out hv_ClassNamesGood);
                for (hv_IndexFind = 0; (int)hv_IndexFind <= (int)((new HTuple(hv_ClassNamesGood.TupleLength()
                    )) - 1); hv_IndexFind = (int)hv_IndexFind + 1)
                {
                    hv_GoodIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
                            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
                    }
                    if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
                        )).TupleLessEqual(8)))) != 0)
                    {
                        //If number of classes is <= 8, swap color with a green color.
                        hv_CurrentColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentColor = hv_Colors.TupleSelect(
                                hv_GoodIdx);
                        }
                        hv_GreenIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
                                )) / 2.0)).TupleFloor();
                        }
                        //Set to pure green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        //Write original color to a green entry.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GreenIdx] = hv_CurrentColor;
                        break;
                    }
                    else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
                        new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
                    {
                        //If number of classes is larger than 8, set the respective color to green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        break;
                    }
                }

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Return the intended optimization method based on given evaluation key(s). 
        public void get_dl_evaluation_optimization_method(HTuple hv_EvaluationKeys, out HTuple hv_OptimizationMethod)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Matches = new HTuple(), hv_Length = new HTuple();
            HTuple hv_ErrorKeys = new HTuple(), hv_Sum = new HTuple();
            // Initialize local and output iconic variables 
            hv_OptimizationMethod = new HTuple();
            try
            {
                //Only evaluation keys which contain the name 'error' are minimization problems.
                hv_Matches.Dispose();
                HOperatorSet.TupleRegexpMatch(hv_EvaluationKeys, "error", out hv_Matches);
                hv_Length.Dispose();
                HOperatorSet.TupleStrlen(hv_Matches, out hv_Length);
                hv_ErrorKeys.Dispose();
                HOperatorSet.TupleGreaterElem(hv_Length, 0, out hv_ErrorKeys);
                hv_Sum.Dispose();
                HOperatorSet.TupleSum(hv_ErrorKeys, out hv_Sum);
                if ((int)(new HTuple(hv_Sum.TupleEqual(new HTuple(hv_ErrorKeys.TupleLength()
                    )))) != 0)
                {
                    hv_OptimizationMethod.Dispose();
                    hv_OptimizationMethod = "min";
                }
                else if ((int)(new HTuple(hv_Sum.TupleEqual(0))) != 0)
                {
                    hv_OptimizationMethod.Dispose();
                    hv_OptimizationMethod = "max";
                }
                else
                {
                    hv_OptimizationMethod.Dispose();
                    hv_OptimizationMethod = "mixed";
                }

                hv_Matches.Dispose();
                hv_Length.Dispose();
                hv_ErrorKeys.Dispose();
                hv_Sum.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Matches.Dispose();
                hv_Length.Dispose();
                hv_ErrorKeys.Dispose();
                hv_Sum.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get an image of a sample with a certain key. 
        public void get_dl_sample_image(out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample,
            HTuple hv_Key)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            //This procedure returns an image with key Key of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind(hv_Key))).TupleNotEqual(-1))) != 0)
            {
                ho_Image.Dispose();
                HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, hv_Key);
            }
            else
            {
                throw new HalconException(("Image with key '" + hv_Key) + "' could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / OCR
        // Short Description: Determine the ocr type of the sample based on the sample structure. 
        private void get_dl_sample_ocr_type(HTuple hv_DLSample, out HTuple hv_OCRType)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WordExists = new HTuple(), hv_BoundingBoxExists = new HTuple();
            // Initialize local and output iconic variables 
            hv_OCRType = new HTuple();
            try
            {
                hv_OCRType.Dispose();
                hv_OCRType = "non_ocr";
                hv_WordExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "word", out hv_WordExists);
                if ((int)(hv_WordExists) != 0)
                {
                    hv_BoundingBoxExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_label_id", out hv_BoundingBoxExists);
                    if ((int)(hv_BoundingBoxExists) != 0)
                    {
                        hv_OCRType.Dispose();
                        hv_OCRType = "ocr_detection";
                    }
                    else
                    {
                        hv_OCRType.Dispose();
                        hv_OCRType = "ocr_recognition";
                    }
                }

                hv_WordExists.Dispose();
                hv_BoundingBoxExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WordExists.Dispose();
                hv_BoundingBoxExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get a parameter value from GenParamValue with the name RequestedGenParamName. 
        private void get_genparam_single_value(HTuple hv_GenParamName, HTuple hv_GenParamValue,
            HTuple hv_RequestedGenParamName, out HTuple hv_FoundGenParamValue)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Indices = new HTuple();
            // Initialize local and output iconic variables 
            hv_FoundGenParamValue = new HTuple();
            try
            {
                //
                //Get a parameter value from GenParamValue with the name RequestedGenParamName,
                //which is allowed to appear only once in GenParamName.
                //
                //Set a default in case no value is provided.
                hv_FoundGenParamValue.Dispose();
                hv_FoundGenParamValue = new HTuple();
                //Set user provided values, if provided.
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_GenParamName.TupleFind(
                        hv_RequestedGenParamName);
                }
                if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(1))).TupleAnd(
                    new HTuple(hv_Indices.TupleNotEqual(-1)))) != 0)
                {
                    hv_FoundGenParamValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FoundGenParamValue = hv_GenParamValue.TupleSelect(
                            hv_Indices);
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    //Throw an error if more than one value was provided for RequestedGenParamName.
                    throw new HalconException(("Only a single parameter dictionary or none is allowed for '" + hv_RequestedGenParamName) + "'.");
                }

                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Extract gripping points from a dictionary. 
        private void get_gripping_points_from_dict(HTuple hv_DLResult, out HTuple hv_Rows,
            out HTuple hv_Columns)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_KeyExists = new HTuple(), hv_GrippingPoints = new HTuple();
            HTuple hv_NumberOfResults = new HTuple(), hv_IndexGrippingPointsPoint = new HTuple();
            HTuple hv_GrippingPointCoordDict = new HTuple();
            // Initialize local and output iconic variables 
            hv_Rows = new HTuple();
            hv_Columns = new HTuple();
            try
            {
                if ((int)(new HTuple(hv_DLResult.TupleEqual(new HTuple()))) != 0)
                {
                    throw new HalconException("DLResult dict is empty.");
                }
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "gripping_points", out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_GrippingPoints.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "gripping_points", out hv_GrippingPoints);
                }
                else
                {
                    throw new HalconException("Result data could not be found in DLResult.");
                }
                hv_NumberOfResults.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumberOfResults = new HTuple(hv_GrippingPoints.TupleLength()
                        );
                }
                hv_Rows.Dispose();
                HOperatorSet.TupleGenConst(hv_NumberOfResults, 0, out hv_Rows);
                hv_Columns.Dispose();
                HOperatorSet.TupleGenConst(hv_NumberOfResults, 0, out hv_Columns);
                for (hv_IndexGrippingPointsPoint = 0; (int)hv_IndexGrippingPointsPoint <= (int)((new HTuple(hv_GrippingPoints.TupleLength()
                    )) - 1); hv_IndexGrippingPointsPoint = (int)hv_IndexGrippingPointsPoint + 1)
                {
                    hv_GrippingPointCoordDict.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrippingPointCoordDict = hv_GrippingPoints.TupleSelect(
                            hv_IndexGrippingPointsPoint);
                    }
                    if (hv_Rows == null)
                        hv_Rows = new HTuple();
                    hv_Rows[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple(
                        "row");
                    if (hv_Columns == null)
                        hv_Columns = new HTuple();
                    hv_Columns[hv_IndexGrippingPointsPoint] = hv_GrippingPointCoordDict.TupleGetDictTuple(
                        "column");
                }

                hv_KeyExists.Dispose();
                hv_GrippingPoints.Dispose();
                hv_NumberOfResults.Dispose();
                hv_IndexGrippingPointsPoint.Dispose();
                hv_GrippingPointCoordDict.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_KeyExists.Dispose();
                hv_GrippingPoints.Dispose();
                hv_NumberOfResults.Dispose();
                hv_IndexGrippingPointsPoint.Dispose();
                hv_GrippingPointCoordDict.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next window that can be used for visualization. 
        private void get_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_NumLines = new HTuple();
            HTuple hv_MarginBottom = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_SetPartRow2 = new HTuple(), hv_SetPartColumn2 = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_CurrentWindowHandle = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_CurrentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        hv_Value.Dispose();
                        HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //If there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                        HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_CurrentWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    //Calculate MarginBottom.
                    if ((int)(hv_ShowBottomDesc) != 0)
                    {
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_NumLines.Dispose();
                        hv_NumLines = new HTuple(hv_ShowBottomDesc);
                        hv_MarginBottom.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MarginBottom = (hv_NumLines * (hv_Ascent + hv_Descent)) + (2 * 12);
                        }
                    }
                    else
                    {
                        hv_MarginBottom.Dispose();
                        hv_MarginBottom = 0;
                    }
                    //
                    //Get and set meta information for current window.
                    hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage,
                        0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                        out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                        out hv_PrevWindowCoordinatesOut);
                    //
                    //Update meta information.
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                            hv_WindowImageRatioHeight);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                            hv_WindowImageRatioWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                            hv_SetPartRow2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                            hv_SetPartColumn2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                            hv_MarginBottom);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                            hv_MapColorBarWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                            hv_PrevWindowCoordinatesOut);
                    }
                }
                else
                {
                    //
                    //Open a new window.
                    hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatioHeight.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                        hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle,
                        out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_NumLines.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_NumLines.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Return all pixel measures from a specified list of measures. 
        private void get_requested_pixel_measures(HTuple hv_Measures, HTuple hv_EvaluationType,
            out HTuple hv_PixelMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ValidMeasures = new HTuple(), hv_M = new HTuple();
            // Initialize local and output iconic variables 
            hv_PixelMeasures = new HTuple();
            try
            {
                //
                //This helper procedure returns for a given list of
                //requested measures all pixel measures for the specified
                //evaluation type.
                //
                hv_PixelMeasures.Dispose();
                hv_PixelMeasures = new HTuple();
                hv_ValidMeasures.Dispose();
                get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
                //
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("all"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_PixelMeasures = hv_PixelMeasures.TupleConcat(
                                    hv_ValidMeasures);
                                hv_PixelMeasures.Dispose();
                                hv_PixelMeasures = ExpTmpLocalVar_PixelMeasures;
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_ValidMeasures.TupleFind(hv_Measures.TupleSelect(
                        hv_M)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_PixelMeasures = hv_PixelMeasures.TupleConcat(
                                    hv_Measures.TupleSelect(hv_M));
                                hv_PixelMeasures.Dispose();
                                hv_PixelMeasures = ExpTmpLocalVar_PixelMeasures;
                            }
                        }
                    }
                }
                //

                hv_ValidMeasures.Dispose();
                hv_M.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ValidMeasures.Dispose();
                hv_M.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Get the ground truth segmentation image. 
        private void get_segmentation_image_ground_truth(out HObject ho_SegmentationImagGroundTruth,
            HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            //
            //This procedure returns the ground truth segmentation image.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImagGroundTruth.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample,
                    "segmentation_image");
            }
            else
            {
                throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Get the predicted segmentation result image. 
        private void get_segmentation_image_result(out HObject ho_SegmentationImageResult,
            HTuple hv_ResultKeys, HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            //
            //This procedure returns the predicted segmentation result image.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImageResult.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
            }
            else
            {
                throw new HalconException("Result segmentation data could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Returns the list of available pixel evaluation measures for the specified type. 
        private void get_valid_pixel_measures(HTuple hv_EvaluationType, out HTuple hv_EvaluationMeasures)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_EvaluationMeasures = new HTuple();
            //
            //This helper procedure returns for the given evaluation type
            //all pixel measures available for this type.
            //
            hv_EvaluationMeasures.Dispose();
            hv_EvaluationMeasures = new HTuple();
            if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
            {
                hv_EvaluationMeasures.Dispose();
                hv_EvaluationMeasures = new HTuple();
                hv_EvaluationMeasures[0] = "pixel_accuracy";
                hv_EvaluationMeasures[1] = "mean_accuracy";
                hv_EvaluationMeasures[2] = "mean_iou";
                hv_EvaluationMeasures[3] = "class_iou";
                hv_EvaluationMeasures[4] = "class_pixel_accuracy";
                hv_EvaluationMeasures[5] = "pixel_confusion_matrix";
                hv_EvaluationMeasures[6] = "frequency_weighted_iou";
            }
            else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
            {
                hv_EvaluationMeasures.Dispose();
                hv_EvaluationMeasures = new HTuple();
                hv_EvaluationMeasures[0] = "mean_precision";
                hv_EvaluationMeasures[1] = "mean_iou";
            }
            //


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Get the weight image of a sample. 
        private void get_weight_image(out HObject ho_ImageWeight, HTuple hv_SampleKeys,
            HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            //
            //This procedure returns the segmentation weight image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageWeight.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
            }
            else
            {
                throw new HalconException("Weight image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
        public void init_running_evaluation_measures(HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_PixelMeasures = new HTuple(), hv_CalcRegionMeasures = new HTuple();
            HTuple hv_CalcGrippingPointMeasures = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_EvalOrientation = new HTuple(), hv_AllocationBlockLength = new HTuple();
            HTuple hv_IoUThreshs = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_MaxNumIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_CurrentRunningMeasure = new HTuple();
            HTuple hv_AreaIdx = new HTuple(), hv_AreaRunningMeasure = new HTuple();
            HTuple hv_I = new HTuple(), hv_IoURunningMeasure = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_ClassRunningMeasures = new HTuple();
            HTuple hv_Confidence = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_CalcConfMatrix = new HTuple(), hv_MatrixSize = new HTuple();
            HTuple hv_PixelConfusionMatrix = new HTuple(), hv_MaxId = new HTuple();
            HTuple hv_ClsIDToClsIdx = new HTuple(), hv_TP = new HTuple();
            HTuple hv_FP = new HTuple(), hv_FN = new HTuple();
            // Initialize local and output iconic variables 
            hv_RunningMeasures = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary RunningMeasures for evaluation.
                //It uses the evaluation parameters to initialize the running measures accordingly.
                //
                //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
                //
                //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
                //
                hv_RunningMeasures.Dispose();
                HOperatorSet.CreateDict(out hv_RunningMeasures);
                //Check that the necessary evaluation parameters exist.
                hv_Valid.Dispose(); hv_Exception.Dispose();
                validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
                if ((int)(hv_Valid.TupleNot()) != 0)
                {
                    throw new HalconException(new HTuple("Invalid EvalParams, ") + hv_Exception);
                }
                //
                //Get general evaluation parameters.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //if pixel measures:
                    //- tp/fp/fn (pixel numbers for the gripping_map class)
                    //if region measures:
                    //- gt_overlap (accumulated overlap of groundtruth regions with the prediction)
                    //- num_gt_regions (overall number of groundtruth regions)
                    //if gripping point measures:
                    //- gp_tp/gp_fp/gp_fn (gripping point true positives, false positives, and
                    //  false negatives w.r.t. ground truth gripping point region).
                    hv_PixelMeasures.Dispose();
                    get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
                    if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", 0);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", 0);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", 0);
                    }
                    hv_CalcRegionMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcRegionMeasures = (new HTuple(((hv_Measures.TupleFind(
                            "mean_pro"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                            "all"))).TupleGreater(-1)));
                    }
                    if ((int)(hv_CalcRegionMeasures) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "gt_overlap", 0);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "num_gt_regions", 0);
                    }
                    hv_CalcGrippingPointMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcGrippingPointMeasures = new HTuple((new HTuple((new HTuple(hv_Measures.TupleRegexpSelect(
                            "gripping_point_.*|all"))).TupleLength())).TupleGreater(0));
                    }
                    if ((int)(hv_CalcGrippingPointMeasures) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_tp", 0);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", 0);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fn", 0);
                    }
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- anomaly_label_ids:  Class IDs of ground truth labels.
                    //- anomaly_scores:     Predicted image level anomaly scores.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- image_label_ids:    Class IDs of ground truth labels.
                    //- top1_predictions:   Class IDs of the top predicted class.
                    //- topk_predictions:   Class IDs of top-K predicted classes.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", new HTuple());
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
                {
                    //RunningMeasures contains:
                    //For each maximal number of regions (MaxNumDetections):
                    // - For each area range (AreaRanges):
                    //   -- confidence:     Confidence (score) of each result.
                    //   -- num_gt:         Total number of ground truth instances per class.
                    //   -- num_pred:       Total number of predictions per class.
                    //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
                    //   -- for each IoU-threshold:
                    //      --- For each class:
                    //          ---- is_tp:                  TP/FP assignment of result.
                    //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
                    //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
                    //                                       Absolute orientation difference of the result.
                    //
                    //Check if the orientation difference is to be evaluated.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                    hv_EvalOrientation.Dispose();
                    hv_EvalOrientation = 0;
                    if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                        (new HTuple(((hv_Measures.TupleFind("soap"))).TupleNotEqual(-1))).TupleOr(
                        new HTuple(((hv_Measures.TupleFind("all"))).TupleNotEqual(-1))))) != 0)
                    {
                        hv_EvalOrientation.Dispose();
                        hv_EvalOrientation = 1;
                    }
                    //
                    //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
                    //arrays are allocated with -1 in blocks of AllocationBlockLength
                    //(thus, if a block is filled, the next block is allocated).
                    //Otherwise the arrays have to be concatenated which is rather slow.
                    //The actual length of the array is garnered in num_pred.
                    hv_AllocationBlockLength.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                    hv_IoUThreshs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
                    hv_MaxNumDetections.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                    hv_AreaRanges.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                    //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
                    hv_AreaNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                    hv_MinAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                    hv_MaxAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                    //Check if a detailed evaluation will be performed.
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                    //Set a result dictionary for each maximal number of detections and IoU-threshold.
                    for (hv_MaxNumIdx = 0; (int)hv_MaxNumIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MaxNumIdx);
                        }
                        hv_CurrentRunningMeasure.Dispose();
                        HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            hv_AreaRunningMeasure.Dispose();
                            HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
                            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IoUThreshs.TupleLength()
                                )) - 1); hv_I = (int)hv_I + 1)
                            {
                                hv_IoURunningMeasure.Dispose();
                                HOperatorSet.CreateDict(out hv_IoURunningMeasure);
                                HTuple end_val111 = hv_NumClasses - 1;
                                HTuple step_val111 = 1;
                                for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val111, step_val111); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val111))
                                {
                                    hv_ClassRunningMeasures.Dispose();
                                    HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    if ((int)(hv_EvalOrientation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                    }
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        if ((int)(hv_EvalOrientation) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives",
                                            0);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassRunningMeasures);
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_" + ((("" + (hv_IoUThreshs.TupleSelect(
                                        hv_I)))).TupleRegexpReplace("\\.", "")), hv_IoURunningMeasure);
                                }
                            }
                            hv_Confidence.Dispose();
                            HOperatorSet.CreateDict(out hv_Confidence);
                            HTuple end_val140 = hv_NumClasses - 1;
                            HTuple step_val140 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val140, step_val140); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val140))
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Confidence, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength, -1.0));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_" + (hv_AreaNames.TupleSelect(
                                    hv_AreaIdx)), hv_AreaRunningMeasure);
                            }
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNum.Dispose();
                            hv_MaxNum = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNum,
                                hv_CurrentRunningMeasure);
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //RunningMeasures contains:
                    //if confusion matrix in Measures (slower but more information).
                    // - confusion matrix per pixel.
                    //else:
                    // - TP/FP/FN (pixel numbers per class).
                    //
                    //Incorporate ignore class IDs.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    //
                    //Check if we need to compute/update the confusion matrix.
                    hv_CalcConfMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                            "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                            "all"))).TupleGreater(-1)));
                    }
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Define the size of the confusion matrix.
                        hv_MatrixSize.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MatrixSize = hv_NumClasses + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                                )).TupleGreater(0)));
                        }
                        hv_PixelConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix",
                            hv_PixelConfusionMatrix);
                        //
                        //If the class IDs are not running indices from 0 to NumClasses we
                        //define a mapping from class IDs to class indices.
                        if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(
                            0, (new HTuple(hv_ClassIDs.TupleLength())) - 1, 1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //Get the max ID that can occur.
                            hv_MaxId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxId = (hv_ClassIDs.TupleMax()
                                    ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                                    0)));
                            }
                            //Define the basic mapping.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsIDToClsIdx.Dispose();
                                HOperatorSet.TupleGenConst(hv_MaxId + 1, -1, out hv_ClsIDToClsIdx);
                            }
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                                )) - 1, 1);
                            //Map ignore IDs to the next higher one.
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax()) + 1;
                            //Set the mapping to the evaluation parameters.
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
                        }
                    }
                    else
                    {
                        hv_TP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FN.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FN = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
                {
                    //RunningMeasures for OCR recognition models.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_ground_truth", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_prediction", new HTuple());
                }
                //

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_PixelMeasures.Dispose();
                hv_CalcRegionMeasures.Dispose();
                hv_CalcGrippingPointMeasures.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_PixelMeasures.Dispose();
                hv_CalcRegionMeasures.Dispose();
                hv_CalcGrippingPointMeasures.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize change strategies data. 
        private void init_train_dl_model_change_strategies(HTuple hv_TrainParam, out HTuple hv_ChangeStrategyData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ChangeStrategies = new HTuple();
            HTuple hv_Enabled = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ChangeStrategy = new HTuple(), hv_ModelParam = new HTuple();
            HTuple hv_Epochs = new HTuple(), hv_Values = new HTuple();
            HTuple hv_Initial = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_ScaleThresholdExists = new HTuple();
            // Initialize local and output iconic variables 
            hv_ChangeStrategyData = new HTuple();
            try
            {
                //
                //Initialize a dictionary with the change strategies data.
                hv_ChangeStrategyData.Dispose();
                HOperatorSet.CreateDict(out hv_ChangeStrategyData);
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "change_strategies", out hv_ChangeStrategies);
                hv_Enabled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Enabled = new HTuple((new HTuple(hv_ChangeStrategies.TupleLength()
                        )).TupleGreater(0));
                }
                HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "enabled", hv_Enabled);
                if ((int)(hv_Enabled.TupleNot()) != 0)
                {

                    hv_ChangeStrategies.Dispose();
                    hv_Enabled.Dispose();
                    hv_Index.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ModelParam.Dispose();
                    hv_Epochs.Dispose();
                    hv_Values.Dispose();
                    hv_Initial.Dispose();
                    hv_Indices.Dispose();
                    hv_ScaleThresholdExists.Dispose();

                    return;
                }
                //
                //Sort all epochs in all change strategies.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ChangeStrategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_ModelParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
                    hv_Values.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
                    hv_Initial.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
                    //Check that the length are equal.
                    if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleNotEqual(
                        new HTuple(hv_Values.TupleLength())))) != 0)
                    {
                        throw new HalconException("ChangeStrategy parameter error: 'epochs' and 'values' need to have same length.");
                    }
                    //We need sorted arrays for faster access.
                    hv_Indices.Dispose();
                    HOperatorSet.TupleSortIndex(hv_Epochs, out hv_Indices);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ChangeStrategy, "epochs", hv_Epochs.TupleSelect(
                            hv_Indices));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ChangeStrategy, "values", hv_Values.TupleSelect(
                            hv_Indices));
                    }
                    //
                    //For the learning rate, there can be an additional parameter
                    //indicating if the momentum should be scaled as well.
                    if ((int)(new HTuple(hv_ModelParam.TupleEqual("learning_rate"))) != 0)
                    {
                        hv_ScaleThresholdExists.Dispose();
                        HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "scale_momentum_threshold",
                            out hv_ScaleThresholdExists);
                        if ((int)(hv_ScaleThresholdExists.TupleNot()) != 0)
                        {
                            //If not given, the threshold is set to an empty tuple such that no scaling is performed.
                            HOperatorSet.SetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                                new HTuple());
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "strategies", hv_ChangeStrategies);

                hv_ChangeStrategies.Dispose();
                hv_Enabled.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Indices.Dispose();
                hv_ScaleThresholdExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ChangeStrategies.Dispose();
                hv_Enabled.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Indices.Dispose();
                hv_ScaleThresholdExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize the dictionary setting for serialization strategies. 
        private void init_train_dl_model_serialization_strategies(HTuple hv_TrainParam,
            out HTuple hv_SerializationData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SerializationStrategies = new HTuple();
            HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
            HTuple hv_SerializeFinal = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_Type = new HTuple();
            HTuple hv_Data = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_NumEpochs = new HTuple();
            // Initialize local and output iconic variables 
            hv_SerializationData = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary setting the serialization strategies.
                //
                //Initialize each serialization strategy.
                hv_SerializationStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "serialization_strategies", out hv_SerializationStrategies);
                hv_SerializationData.Dispose();
                HOperatorSet.CreateDict(out hv_SerializationData);
                HOperatorSet.SetDictTuple(hv_SerializationData, "strategies", hv_SerializationStrategies);
                hv_RawData.Dispose();
                hv_RawData = new HTuple();
                hv_Types.Dispose();
                hv_Types = new HTuple();
                hv_SerializeFinal.Dispose();
                hv_SerializeFinal = 0;
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_SerializationStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_SerializationStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_Type.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);
                    hv_Data.Dispose();
                    HOperatorSet.CreateDict(out hv_Data);
                    if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_Data, "best_value", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                    {
                        hv_Epochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_Strategy, "epochs", out hv_Epochs);
                        //Store sorted values in order to search faster during updates.
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleSort(hv_Epochs, out ExpTmpOutVar_0);
                            hv_Epochs.Dispose();
                            hv_Epochs = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictTuple(hv_Data, "epochs", hv_Epochs);
                        HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("current"))) != 0)
                    {
                        hv_NumEpochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_Data, "epochs", HTuple.TupleGenSequence(1,
                                hv_NumEpochs, 1));
                        }
                        HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_Data, "serialize_final", 1);
                    }
                    else
                    {
                        throw new HalconException(("Unknown serialization strategy type: '" + hv_Type) + "'");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Types = hv_Types.TupleConcat(
                                hv_Type);
                            hv_Types.Dispose();
                            hv_Types = ExpTmpLocalVar_Types;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RawData = hv_RawData.TupleConcat(
                                hv_Data);
                            hv_RawData.Dispose();
                            hv_RawData = ExpTmpLocalVar_RawData;
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_SerializationData, "raw_data", hv_RawData);
                HOperatorSet.SetDictTuple(hv_SerializationData, "types", hv_Types);

                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_SerializeFinal.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Epochs.Dispose();
                hv_NumEpochs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_SerializeFinal.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Epochs.Dispose();
                hv_NumEpochs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: File / Misc
        // Short Description: Get all image files under the given path 
        public void list_image_files(HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options,
            out HTuple hv_ImageFiles)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageDirectoryIndex = new HTuple();
            HTuple hv_ImageFilesTmp = new HTuple(), hv_CurrentImageDirectory = new HTuple();
            HTuple hv_HalconImages = new HTuple(), hv_OS = new HTuple();
            HTuple hv_Directories = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Length = new HTuple(), hv_NetworkDrive = new HTuple();
            HTuple hv_Substring = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_AllFiles = new HTuple(), hv_i = new HTuple();
            HTuple hv_Selection = new HTuple();
            HTuple hv_Extensions_COPY_INP_TMP = new HTuple(hv_Extensions);

            // Initialize local and output iconic variables 
            hv_ImageFiles = new HTuple();
            try
            {
                //This procedure returns all files in a given directory
                //with one of the suffixes specified in Extensions.
                //
                //Input parameters:
                //ImageDirectory: Directory or a tuple of directories with images.
                //   If a directory is not found locally, the respective directory
                //   is searched under %HALCONIMAGES%/ImageDirectory.
                //   See the Installation Guide for further information
                //   in case %HALCONIMAGES% is not set.
                //Extensions: A string tuple containing the extensions to be found
                //   e.g. ['png','tif',jpg'] or others
                //If Extensions is set to 'default' or the empty string '',
                //   all image suffixes supported by HALCON are used.
                //Options: as in the operator list_files, except that the 'files'
                //   option is always used. Note that the 'directories' option
                //   has no effect but increases runtime, because only files are
                //   returned.
                //
                //Output parameter:
                //ImageFiles: A tuple of all found image file names
                //
                if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
                    "default")))) != 0)
                {
                    hv_Extensions_COPY_INP_TMP.Dispose();
                    hv_Extensions_COPY_INP_TMP = new HTuple();
                    hv_Extensions_COPY_INP_TMP[0] = "ima";
                    hv_Extensions_COPY_INP_TMP[1] = "tif";
                    hv_Extensions_COPY_INP_TMP[2] = "tiff";
                    hv_Extensions_COPY_INP_TMP[3] = "gif";
                    hv_Extensions_COPY_INP_TMP[4] = "bmp";
                    hv_Extensions_COPY_INP_TMP[5] = "jpg";
                    hv_Extensions_COPY_INP_TMP[6] = "jpeg";
                    hv_Extensions_COPY_INP_TMP[7] = "jp2";
                    hv_Extensions_COPY_INP_TMP[8] = "jxr";
                    hv_Extensions_COPY_INP_TMP[9] = "png";
                    hv_Extensions_COPY_INP_TMP[10] = "pcx";
                    hv_Extensions_COPY_INP_TMP[11] = "ras";
                    hv_Extensions_COPY_INP_TMP[12] = "xwd";
                    hv_Extensions_COPY_INP_TMP[13] = "pbm";
                    hv_Extensions_COPY_INP_TMP[14] = "pnm";
                    hv_Extensions_COPY_INP_TMP[15] = "pgm";
                    hv_Extensions_COPY_INP_TMP[16] = "ppm";
                    //
                }
                hv_ImageFiles.Dispose();
                hv_ImageFiles = new HTuple();
                //Loop through all given image directories.
                for (hv_ImageDirectoryIndex = 0; (int)hv_ImageDirectoryIndex <= (int)((new HTuple(hv_ImageDirectory.TupleLength()
                    )) - 1); hv_ImageDirectoryIndex = (int)hv_ImageDirectoryIndex + 1)
                {
                    hv_ImageFilesTmp.Dispose();
                    hv_ImageFilesTmp = new HTuple();
                    hv_CurrentImageDirectory.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentImageDirectory = hv_ImageDirectory.TupleSelect(
                            hv_ImageDirectoryIndex);
                    }
                    if ((int)(new HTuple(hv_CurrentImageDirectory.TupleEqual(""))) != 0)
                    {
                        hv_CurrentImageDirectory.Dispose();
                        hv_CurrentImageDirectory = ".";
                    }
                    hv_HalconImages.Dispose();
                    HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
                    hv_OS.Dispose();
                    HOperatorSet.GetSystem("operating_system", out hv_OS);
                    if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_HalconImages = hv_HalconImages.TupleSplit(
                                    ";");
                                hv_HalconImages.Dispose();
                                hv_HalconImages = ExpTmpLocalVar_HalconImages;
                            }
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_HalconImages = hv_HalconImages.TupleSplit(
                                    ":");
                                hv_HalconImages.Dispose();
                                hv_HalconImages = ExpTmpLocalVar_HalconImages;
                            }
                        }
                    }
                    hv_Directories.Dispose();
                    hv_Directories = new HTuple(hv_CurrentImageDirectory);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_HalconImages.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Directories = hv_Directories.TupleConcat(
                                    ((hv_HalconImages.TupleSelect(hv_Index)) + "/") + hv_CurrentImageDirectory);
                                hv_Directories.Dispose();
                                hv_Directories = ExpTmpLocalVar_Directories;
                            }
                        }
                    }
                    hv_Length.Dispose();
                    HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NetworkDrive.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_NetworkDrive);
                    }
                    if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                    {
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen()
                                )).TupleGreater(1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Substring.Dispose();
                                    HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1,
                                        out hv_Substring);
                                }
                                if ((int)((new HTuple(hv_Substring.TupleEqual("//"))).TupleOr(new HTuple(hv_Substring.TupleEqual(
                                    "\\\\")))) != 0)
                                {
                                    if (hv_NetworkDrive == null)
                                        hv_NetworkDrive = new HTuple();
                                    hv_NetworkDrive[hv_Index] = 1;
                                }
                            }
                        }
                    }
                    hv_ImageFilesTmp.Dispose();
                    hv_ImageFilesTmp = new HTuple();
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Directories.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FileExists.Dispose();
                            HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
                        }
                        if ((int)(hv_FileExists) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AllFiles.Dispose();
                                HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
                                    hv_Options), out hv_AllFiles);
                            }
                            hv_ImageFilesTmp.Dispose();
                            hv_ImageFilesTmp = new HTuple();
                            for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength()
                                )) - 1); hv_i = (int)hv_i + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Selection.Dispose();
                                    HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*" + (hv_Extensions_COPY_INP_TMP.TupleSelect(
                                        hv_i))) + "$")).TupleConcat("ignore_case"), out hv_Selection);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ImageFilesTmp = hv_ImageFilesTmp.TupleConcat(
                                            hv_Selection);
                                        hv_ImageFilesTmp.Dispose();
                                        hv_ImageFilesTmp = ExpTmpLocalVar_ImageFilesTmp;
                                    }
                                }
                            }
                            {
                                HTuple ExpTmpOutVar_0;
                                HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("\\\\")).TupleConcat(
                                    "replace_all"), "/", out ExpTmpOutVar_0);
                                hv_ImageFilesTmp.Dispose();
                                hv_ImageFilesTmp = ExpTmpOutVar_0;
                            }
                            if ((int)(hv_NetworkDrive.TupleSelect(hv_Index)) != 0)
                            {
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                                        "replace_all"), "/", out ExpTmpOutVar_0);
                                    hv_ImageFilesTmp.Dispose();
                                    hv_ImageFilesTmp = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ImageFilesTmp = "/" + hv_ImageFilesTmp;
                                        hv_ImageFilesTmp.Dispose();
                                        hv_ImageFilesTmp = ExpTmpLocalVar_ImageFilesTmp;
                                    }
                                }
                            }
                            else
                            {
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                                        "replace_all"), "/", out ExpTmpOutVar_0);
                                    hv_ImageFilesTmp.Dispose();
                                    hv_ImageFilesTmp = ExpTmpOutVar_0;
                                }
                            }
                            break;
                        }
                    }
                    //Concatenate the output image paths.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageFiles = hv_ImageFiles.TupleConcat(
                                hv_ImageFilesTmp);
                            hv_ImageFiles.Dispose();
                            hv_ImageFiles = ExpTmpLocalVar_ImageFiles;
                        }
                    }
                }

                hv_Extensions_COPY_INP_TMP.Dispose();
                hv_ImageDirectoryIndex.Dispose();
                hv_ImageFilesTmp.Dispose();
                hv_CurrentImageDirectory.Dispose();
                hv_HalconImages.Dispose();
                hv_OS.Dispose();
                hv_Directories.Dispose();
                hv_Index.Dispose();
                hv_Length.Dispose();
                hv_NetworkDrive.Dispose();
                hv_Substring.Dispose();
                hv_FileExists.Dispose();
                hv_AllFiles.Dispose();
                hv_i.Dispose();
                hv_Selection.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Extensions_COPY_INP_TMP.Dispose();
                hv_ImageDirectoryIndex.Dispose();
                hv_ImageFilesTmp.Dispose();
                hv_CurrentImageDirectory.Dispose();
                hv_HalconImages.Dispose();
                hv_OS.Dispose();
                hv_Directories.Dispose();
                hv_Index.Dispose();
                hv_Length.Dispose();
                hv_NetworkDrive.Dispose();
                hv_Substring.Dispose();
                hv_FileExists.Dispose();
                hv_AllFiles.Dispose();
                hv_i.Dispose();
                hv_Selection.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Shuffle the input colors in a deterministic way 
        private void make_neighboring_colors_distinguishable(HTuple hv_ColorsRainbow,
            out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
            HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
            HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
            HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
            HTuple hv_IdxsRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //Shuffle the input colors in a deterministic way
                //to make adjacent colors more distinguishable.
                //Neighboring colors from the input are distributed to every NumChunks
                //position in the output.
                //Depending on the number of colors, increase NumChunks.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
                {
                    hv_NumChunks.Dispose();
                    hv_NumChunks = 3;
                    if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 6;
                    }
                    else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 4;
                    }
                    hv_Colors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors = HTuple.TupleGenConst(
                            hv_NumColors, -1);
                    }
                    //Check if the Number of Colors is dividable by NumChunks.
                    hv_NumLeftOver.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumLeftOver = hv_NumColors % hv_NumChunks;
                    }
                    hv_ColorsPerChunk.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorsPerChunk = ((hv_NumColors / hv_NumChunks)).TupleInt()
                            ;
                    }
                    hv_StartIdx.Dispose();
                    hv_StartIdx = 0;
                    HTuple end_val19 = hv_NumChunks - 1;
                    HTuple step_val19 = 1;
                    for (hv_S = 0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
                    {
                        hv_EndIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndIdx = (hv_StartIdx + hv_ColorsPerChunk) - 1;
                        }
                        if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_EndIdx = hv_EndIdx + 1;
                                    hv_EndIdx.Dispose();
                                    hv_EndIdx = ExpTmpLocalVar_EndIdx;
                                }
                            }
                        }
                        hv_IdxsLeft.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsLeft = HTuple.TupleGenSequence(
                                hv_S, hv_NumColors - 1, hv_NumChunks);
                        }
                        hv_IdxsRight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsRight = HTuple.TupleGenSequence(
                                hv_StartIdx, hv_EndIdx, 1);
                        }
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[HTuple.TupleGenSequence(hv_S, hv_NumColors - 1, hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
                            hv_StartIdx, hv_EndIdx);
                        hv_StartIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartIdx = hv_EndIdx + 1;
                        }
                    }
                }
                else
                {
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple(hv_ColorsRainbow);
                }

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Normalize the output features of the Global Context Anomaly Detection model before training. 
        public void normalize_dl_gc_anomaly_features(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DLSamples = new HTuple(), hv_TrainSampleIndices = new HTuple();
            HTuple hv_OriginalSeed = new HTuple(), hv_ShuffledIndices = new HTuple();
            HTuple hv_NumNormalizationIndices = new HTuple(), hv_NormalizationIndices = new HTuple();
            HTuple hv_DLSamplesNormalization = new HTuple(), hv_NormalizationLayerNames = new HTuple();
            HTuple hv_ModelLayerNames = new HTuple(), hv_Index = new HTuple();
            HTuple hv_LayerName = new HTuple(), hv_Mean = new HTuple();
            HTuple hv_StdDev = new HTuple(), hv_Normalizer = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //To normalize the output of the feature extractor E_loc its
                //output channels are normalized to have zero mean and a
                //standard deviation of 1.0 on the training samples.
                //
                //Make sure GenParam is an empty tuple.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    throw new HalconException("The parameter GenParam must be an empty tuple.");
                }
                //
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_TrainSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_TrainSampleIndices);
                //Make sure we use the same samples given the same dataset,
                //so that repeatedly calling this procedure with the same dataset does not
                //update the normalization of E_loc.
                hv_OriginalSeed.Dispose();
                HOperatorSet.GetSystem("seed_rand", out hv_OriginalSeed);
                HOperatorSet.SetSystem("seed_rand", 0);
                hv_ShuffledIndices.Dispose();
                tuple_shuffle(hv_TrainSampleIndices, out hv_ShuffledIndices);
                HOperatorSet.SetSystem("seed_rand", hv_OriginalSeed);
                hv_NumNormalizationIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumNormalizationIndices = (new HTuple(100)).TupleMin2(
                        new HTuple(hv_ShuffledIndices.TupleLength()));
                }
                hv_NormalizationIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NormalizationIndices = hv_ShuffledIndices.TupleSelectRange(
                        0, hv_NumNormalizationIndices - 1);
                }
                hv_DLSamplesNormalization.Dispose();
                read_dl_samples(hv_DLDataset, hv_NormalizationIndices, out hv_DLSamplesNormalization);

                hv_NormalizationLayerNames.Dispose();
                hv_NormalizationLayerNames = new HTuple();
                hv_NormalizationLayerNames[0] = "eloc_output";
                hv_NormalizationLayerNames[1] = "tglo_output";
                hv_ModelLayerNames.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "layer_names", out hv_ModelLayerNames);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NormalizationLayerNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_LayerName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LayerName = hv_NormalizationLayerNames.TupleSelect(
                            hv_Index);
                    }
                    if ((int)(new HTuple(((hv_ModelLayerNames.TupleFindFirst(hv_LayerName))).TupleNotEqual(
                        -1))) != 0)
                    {
                        hv_Mean.Dispose(); hv_StdDev.Dispose();
                        calculate_dl_model_layer_mean_stddev(hv_DLModelHandle, hv_LayerName, hv_DLSamplesNormalization,
                            out hv_Mean, out hv_StdDev);
                        //Clip the standard deviation to avoid numerical issues.
                        hv_Normalizer.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Normalizer = hv_StdDev.TupleMax2(
                                0.001);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            scale_and_shift_dl_model_layer(hv_DLModelHandle, hv_LayerName, 1.0 / (hv_Normalizer.TupleReal()
                                ), (-hv_Mean) / (hv_Normalizer.TupleReal()));
                        }
                    }
                }

                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_OriginalSeed.Dispose();
                hv_ShuffledIndices.Dispose();
                hv_NumNormalizationIndices.Dispose();
                hv_NormalizationIndices.Dispose();
                hv_DLSamplesNormalization.Dispose();
                hv_NormalizationLayerNames.Dispose();
                hv_ModelLayerNames.Dispose();
                hv_Index.Dispose();
                hv_LayerName.Dispose();
                hv_Mean.Dispose();
                hv_StdDev.Dispose();
                hv_Normalizer.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_OriginalSeed.Dispose();
                hv_ShuffledIndices.Dispose();
                hv_NumNormalizationIndices.Dispose();
                hv_NormalizationIndices.Dispose();
                hv_DLSamplesNormalization.Dispose();
                hv_NormalizationLayerNames.Dispose();
                hv_ModelLayerNames.Dispose();
                hv_Index.Dispose();
                hv_LayerName.Dispose();
                hv_Mean.Dispose();
                hv_StdDev.Dispose();
                hv_Normalizer.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Normalize the anomaly scores on the validation set. 
        public void normalize_dl_gc_anomaly_scores(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DLSamples = new HTuple(), hv_ValidationSampleIndices = new HTuple();
            HTuple hv_OKSampleIndices = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_DLSamplesValidation = new HTuple(), hv_LowerQuantileP = new HTuple();
            HTuple hv_UpperQuantileP = new HTuple(), hv_LowerQuantileLocation = new HTuple();
            HTuple hv_UpperQuantileLocation = new HTuple(), hv_Networks = new HTuple();
            HTuple hv_HasLocalNetwork = new HTuple(), hv_HasGlobalNetwork = new HTuple();
            HTuple hv_NormalizationLayers = new HTuple(), hv_Index = new HTuple();
            HTuple hv_NormalizationLayer = new HTuple(), hv_Quantiles = new HTuple();
            HTuple hv_Scale = new HTuple(), hv_LowerQuantileScaled = new HTuple();
            HTuple hv_Shift = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure normalizes the anomaly scores of the local and the global network of
                //a gc_anomaly_detection model to the same scale.
                //It is crucial to perform this step after the actual training of the model DLDataset.
                //
                //Make sure GenParam is an empty tuple.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    throw new HalconException("The parameter GenParam must be an empty tuple.");
                }
                //
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_ValidationSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "validation", "match", out hv_ValidationSampleIndices);
                hv_OKSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "anomaly_label", "ok", "match", out hv_OKSampleIndices);
                hv_SampleIndices.Dispose();
                HOperatorSet.TupleIntersection(hv_ValidationSampleIndices, hv_OKSampleIndices,
                    out hv_SampleIndices);
                hv_DLSamplesValidation.Dispose();
                read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamplesValidation);
                //
                //Based on the 'good'/'ok' samples, select normalization scale such that 99.5%
                //of the anomaly image pixel values are smaller or equal to 0.1.
                hv_LowerQuantileP.Dispose();
                hv_LowerQuantileP = 0.9;
                hv_UpperQuantileP.Dispose();
                hv_UpperQuantileP = 0.995;
                hv_LowerQuantileLocation.Dispose();
                hv_LowerQuantileLocation = 0;
                hv_UpperQuantileLocation.Dispose();
                hv_UpperQuantileLocation = 0.1;
                //
                //Find networks to be normalized.
                hv_Networks.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "gc_anomaly_networks", out hv_Networks);
                hv_HasLocalNetwork.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasLocalNetwork = new HTuple(((hv_Networks.TupleFind(
                        "local"))).TupleNotEqual(-1));
                }
                hv_HasGlobalNetwork.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasGlobalNetwork = new HTuple(((hv_Networks.TupleFind(
                        "global"))).TupleNotEqual(-1));
                }
                hv_NormalizationLayers.Dispose();
                hv_NormalizationLayers = new HTuple();
                if ((int)(hv_HasLocalNetwork) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                                "local_normalization");
                            hv_NormalizationLayers.Dispose();
                            hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                        }
                    }
                }
                if ((int)(hv_HasGlobalNetwork) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_NormalizationLayers = hv_NormalizationLayers.TupleConcat(
                                "global_normalization");
                            hv_NormalizationLayers.Dispose();
                            hv_NormalizationLayers = ExpTmpLocalVar_NormalizationLayers;
                        }
                    }
                }
                //
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NormalizationLayers.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Calculate quantiles for requested normalization layer.
                    hv_NormalizationLayer.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NormalizationLayer = hv_NormalizationLayers.TupleSelect(
                            hv_Index);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Quantiles.Dispose();
                        calculate_dl_anomaly_quantiles(hv_DLModelHandle, hv_NormalizationLayer, hv_DLSamplesValidation,
                            hv_LowerQuantileP.TupleConcat(hv_UpperQuantileP), out hv_Quantiles);
                    }
                    hv_Scale.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Scale = (hv_UpperQuantileLocation - hv_LowerQuantileLocation) / ((hv_Quantiles.TupleSelect(
                            1)) - (hv_Quantiles.TupleSelect(0)));
                    }
                    //Scale the lower quantile.
                    hv_LowerQuantileScaled.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LowerQuantileScaled = (hv_Quantiles.TupleSelect(
                            0)) * hv_Scale;
                    }
                    //Compute the shift required to map it to LowerQuantileLocation.
                    hv_Shift.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Shift = hv_LowerQuantileLocation - hv_LowerQuantileScaled;
                    }
                    scale_and_shift_dl_model_layer(hv_DLModelHandle, hv_NormalizationLayer, hv_Scale,
                        hv_Shift);
                }
                //

                hv_DLSamples.Dispose();
                hv_ValidationSampleIndices.Dispose();
                hv_OKSampleIndices.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLSamplesValidation.Dispose();
                hv_LowerQuantileP.Dispose();
                hv_UpperQuantileP.Dispose();
                hv_LowerQuantileLocation.Dispose();
                hv_UpperQuantileLocation.Dispose();
                hv_Networks.Dispose();
                hv_HasLocalNetwork.Dispose();
                hv_HasGlobalNetwork.Dispose();
                hv_NormalizationLayers.Dispose();
                hv_Index.Dispose();
                hv_NormalizationLayer.Dispose();
                hv_Quantiles.Dispose();
                hv_Scale.Dispose();
                hv_LowerQuantileScaled.Dispose();
                hv_Shift.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLSamples.Dispose();
                hv_ValidationSampleIndices.Dispose();
                hv_OKSampleIndices.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLSamplesValidation.Dispose();
                hv_LowerQuantileP.Dispose();
                hv_UpperQuantileP.Dispose();
                hv_LowerQuantileLocation.Dispose();
                hv_UpperQuantileLocation.Dispose();
                hv_Networks.Dispose();
                hv_HasLocalNetwork.Dispose();
                hv_HasGlobalNetwork.Dispose();
                hv_NormalizationLayers.Dispose();
                hv_Index.Dispose();
                hv_NormalizationLayer.Dispose();
                hv_Quantiles.Dispose();
                hv_Scale.Dispose();
                hv_LowerQuantileScaled.Dispose();
                hv_Shift.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a window next to the given WindowHandleFather.  
        private void open_child_window(HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleChild = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a window next to the given WindowHandleFather.
                //
                //Get the maximum width of the text to be displayed.
                //The width should be at least 200.
                hv_StringWidth.Dispose();
                hv_StringWidth = 150;
                for (hv_IndexText = 0; (int)hv_IndexText <= (int)((new HTuple(hv_Text.TupleLength()
                    )) - 1); hv_IndexText = (int)hv_IndexText + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_TextWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
                            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
                                hv_TextWidth);
                            hv_StringWidth.Dispose();
                            hv_StringWidth = ExpTmpLocalVar_StringWidth;
                        }
                    }
                }
                //
                //Define window coordinates.
                hv_WindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_WindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
                        1)) + (hv_PrevWindowCoordinates.TupleSelect(2))) + 5;
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_StringWidth + (2 * 12.0);
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleChild);
                HDevWindowStack.Push(hv_WindowHandleChild);
                set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
                }
                //
                //Set some meta information about the new child window handle.
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a new window, either next to the last ones, or in a new row. 
        private void open_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
            HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_NumLines = new HTuple();
            HTuple hv_MarginBottom = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_SetPartRow2 = new HTuple(), hv_SetPartColumn2 = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleNew = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a new window, either next to
                //the last ones, or in a new row.
                //
                //Get coordinates of previous window.
                hv_PrevWindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_PrevWindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
                        1);
                }
                hv_PrevWindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
                        2);
                }
                hv_PrevWindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                if ((int)(new HTuple(((hv_PrevWindowColumn + hv_PrevWindowWidth)).TupleGreater(
                    hv_ThresholdWidth))) != 0)
                {
                    //Open window in new row.
                    hv_WindowRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowRow = (hv_PrevWindowRow + hv_PrevWindowHeight) + 55;
                    }
                    hv_WindowColumn.Dispose();
                    hv_WindowColumn = 0;
                }
                else
                {
                    //Open window in same row.
                    hv_WindowRow.Dispose();
                    hv_WindowRow = new HTuple(hv_PrevWindowRow);
                    hv_WindowColumn.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowColumn = hv_PrevWindowColumn + hv_PrevWindowWidth;
                    }
                    if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowColumn = hv_WindowColumn + 5;
                                hv_WindowColumn.Dispose();
                                hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                            }
                        }
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHandleNew.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage,
                        (new HTuple(500)).TupleConcat(800) * hv_ScaleWindows, (new HTuple(400)).TupleConcat(
                        600) * hv_ScaleWindows, out hv_WindowHandleNew);
                }
                set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
                //
                //Add MarginBottom and MapColorBarWidth to window.
                if ((int)(hv_ShowBottomDesc) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent,
                        out hv_Descent, out hv__, out hv__);
                    hv_NumLines.Dispose();
                    hv_NumLines = new HTuple(hv_ShowBottomDesc);
                    hv_MarginBottom.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MarginBottom = (hv_NumLines * (hv_Ascent + hv_Descent)) + (2 * 12);
                    }
                }
                else
                {
                    hv_MarginBottom.Dispose();
                    hv_MarginBottom = 0;
                }
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_WindowWidth + hv_MapColorBarWidth, hv_WindowHeight + hv_MarginBottom);
                    }
                }
                //
                //Get and set meta information of new window handle.
                hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage,
                    hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                    out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                    out hv_PrevWindowCoordinatesOut);
                //
                //Set window handle and some meta information about the new window handle.
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                        hv_WindowImageRatioHeight);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                        hv_WindowImageRatioWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                        hv_SetPartRow2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                        hv_SetPartColumn2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                        hv_MarginBottom);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                        hv_MapColorBarWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_NumLines.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_NumLines.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Plot tuples representing functions or curves in a coordinate system. 
        public void plot_tuple(HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues,
            HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName,
            HTuple hv_GenParamValue)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContourXGrid = null, ho_ContourYGrid = null;
            HObject ho_XArrow = null, ho_YArrow = null, ho_ContourXTick = null;
            HObject ho_ContourYTick = null, ho_Contour = null, ho_Cross = null;
            HObject ho_Filled = null, ho_Stair = null, ho_StairTmp = null;

            // Local control variables 

            HTuple hv_PreviousWindowHandle = new HTuple();
            HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
            HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
            HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
            HTuple hv_XAxisEndValue = new HTuple(), hv_YAxisEndValue = new HTuple();
            HTuple hv_XAxisStartValue = new HTuple(), hv_YAxisStartValue = new HTuple();
            HTuple hv_XValuesAreStrings = new HTuple(), hv_XTickValues = new HTuple();
            HTuple hv_XTicks = new HTuple(), hv_YAxisPosition = new HTuple();
            HTuple hv_XAxisPosition = new HTuple(), hv_LeftBorder = new HTuple();
            HTuple hv_RightBorder = new HTuple(), hv_UpperBorder = new HTuple();
            HTuple hv_LowerBorder = new HTuple(), hv_AxesColor = new HTuple();
            HTuple hv_Style = new HTuple(), hv_Clip = new HTuple();
            HTuple hv_YTicks = new HTuple(), hv_XGrid = new HTuple();
            HTuple hv_YGrid = new HTuple(), hv_GridColor = new HTuple();
            HTuple hv_YPosition = new HTuple(), hv_FormatX = new HTuple();
            HTuple hv_FormatY = new HTuple(), hv_NumGenParamNames = new HTuple();
            HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
            HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
            HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
            HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
            HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
            HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
            HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
            HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
            HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
            HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
            HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
            HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
            HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
            HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
            HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
            HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
            HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
            HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
            HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_Col2 = new HTuple();
            HTuple hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
            HTuple hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
            HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
            HOperatorSet.GenEmptyObj(out ho_XArrow);
            HOperatorSet.GenEmptyObj(out ho_YArrow);
            HOperatorSet.GenEmptyObj(out ho_ContourXTick);
            HOperatorSet.GenEmptyObj(out ho_ContourYTick);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Filled);
            HOperatorSet.GenEmptyObj(out ho_Stair);
            HOperatorSet.GenEmptyObj(out ho_StairTmp);
            try
            {
                //This procedure plots tuples representing functions
                //or curves in a coordinate system.
                //
                //Input parameters:
                //
                //XValues: X values of the function to be plotted
                //         If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.
                //         If XValues is a tuple of strings, the values are taken as categories.
                //
                //YValues: Y values of the function(s) to be plotted
                //         If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.
                //         The number of y values must be equal to the number of x values
                //         or an integral multiple. In the latter case,
                //         multiple functions are plotted, that share the same x values.
                //
                //XLabel: X-axis label
                //
                //YLabel: Y-axis label
                //
                //Color: Color of the plotted function
                //       If [] is given, the currently set display color is used.
                //       If 'none is given, the function is not plotted, but only
                //       the coordinate axes as specified.
                //       If more than one color is given, multiple functions
                //       can be displayed in different colors.
                //
                //GenParamName:  Generic parameters to control the presentation
                //               Possible Values:
                //   'axes_color': coordinate system color
                //                 Default: 'white'
                //                 If 'none' is given, no coordinate system is shown.
                //   'style': Graph style
                //            Possible values: 'line' (default), 'cross', 'step', 'filled'
                //   'clip': Clip graph to coordinate system area
                //           Possible values: 'yes', 'no' (default)
                //   'ticks': Control display of ticks on the axes
                //            If 'min_max_origin' is given (default), ticks are shown
                //            at the minimum and maximum values of the axes and at the
                //            intercept point of x- and y-axis.
                //            If 'none' is given, no ticks are shown.
                //            If any number != 0 is given, it is interpreted as distance
                //            between the ticks.
                //   'ticks_x': Control display of ticks on x-axis only
                //   'ticks_y': Control display of ticks on y-axis only
                //   'format_x': Format of the values next to the ticks of the x-axis
                //               (see tuple_string for more details).
                //   'format_y': Format of the values next to the ticks of the y-axis
                //               (see tuple_string for more details).
                //   'grid': Control display of grid lines within the coordinate system
                //           If 'min_max_origin' is given (default), grid lines are shown
                //           at the minimum and maximum values of the axes.
                //           If 'none' is given, no grid lines are shown.
                //           If any number != 0 is given, it is interpreted as distance
                //           between the grid lines.
                //   'grid_x': Control display of grid lines for the x-axis only
                //   'grid_y': Control display of grid lines for the y-axis only
                //   'grid_color': Color of the grid (default: 'dim gray')
                //   'margin': The distance in pixels of the coordinate system area
                //             to all four window borders.
                //   'margin_left': The distance in pixels of the coordinate system area
                //                  to the left window border.
                //   'margin_right': The distance in pixels of the coordinate system area
                //                   to the right window border.
                //   'margin_top': The distance in pixels of the coordinate system area
                //                 to the upper window border.
                //   'margin_bottom': The distance in pixels of the coordinate system area
                //                    to the lower window border.
                //   'start_x': Lowest x value of the x-axis
                //              Default: min(XValues)
                //   'end_x': Highest x value of the x-axis
                //            Default: max(XValues)
                //   'start_y': Lowest y value of the y-axis
                //              Default: min(YValues)
                //   'end_y': Highest y value of the y-axis
                //            Default: max(YValues)
                //   'axis_location_x': Either 'bottom', 'origin', or 'top'
                //               to position the x-axis conveniently,
                //               or the Y coordinate of the intercept point of x- and y-axis.
                //               Default: 'bottom'
                //               (Used to be called 'origin_y')
                //   'axis_location_y': Either 'left', 'origin', or 'right'
                //               to position the y-axis conveniently,
                //               or the X coordinate of the intercept point of x- and y-axis.
                //               Default: 'left'
                //               (Used to be called 'origin_x')
                //
                //GenParamValue: Values of the generic parameters of GenericParamName
                //
                //
                //Store current display settings
                if (HDevWindowStack.IsOpen())
                {
                    hv_PreviousWindowHandle = HDevWindowStack.GetActive();
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                hv_Row.Dispose(); hv_Column.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width,
                    out hv_Height);
                hv_PartRow1.Dispose(); hv_PartColumn1.Dispose(); hv_PartRow2.Dispose(); hv_PartColumn2.Dispose();
                HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1,
                    out hv_PartRow2, out hv_PartColumn2);
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose();
                HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                hv_OriginStyle.Dispose();
                HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
                //
                //Set display parameters
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                HOperatorSet.SetSystem("clip_region", "false");
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }
                //
                //Check input coordinates
                //
                if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
                    new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
                {
                    //Neither XValues nor YValues are given:
                    //Set axes to interval [0,1]
                    hv_XAxisEndValue.Dispose();
                    hv_XAxisEndValue = 1;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                    hv_XAxisStartValue.Dispose();
                    hv_XAxisStartValue = 0;
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_XValuesAreStrings.Dispose();
                    hv_XValuesAreStrings = 0;
                }
                else
                {
                    if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //XValues are omitted:
                        //Set equidistant XValues
                        hv_XValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                        hv_XValuesAreStrings.Dispose();
                        hv_XValuesAreStrings = 0;
                    }
                    else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //YValues are omitted:
                        //Set equidistant YValues
                        hv_YValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                        )) % (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
                        0))) != 0)
                    {
                        //Number of YValues does not match number of XValues
                        throw new HalconException("Number of YValues is no multiple of the number of XValues!");
                        ho_ContourXGrid.Dispose();
                        ho_ContourYGrid.Dispose();
                        ho_XArrow.Dispose();
                        ho_YArrow.Dispose();
                        ho_ContourXTick.Dispose();
                        ho_ContourYTick.Dispose();
                        ho_Contour.Dispose();
                        ho_Cross.Dispose();
                        ho_Filled.Dispose();
                        ho_Stair.Dispose();
                        ho_StairTmp.Dispose();

                        hv_XValues_COPY_INP_TMP.Dispose();
                        hv_YValues_COPY_INP_TMP.Dispose();
                        hv_PreviousWindowHandle.Dispose();
                        hv_ClipRegion.Dispose();
                        hv_Row.Dispose();
                        hv_Column.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_PartRow1.Dispose();
                        hv_PartColumn1.Dispose();
                        hv_PartRow2.Dispose();
                        hv_PartColumn2.Dispose();
                        hv_Red.Dispose();
                        hv_Green.Dispose();
                        hv_Blue.Dispose();
                        hv_DrawMode.Dispose();
                        hv_OriginStyle.Dispose();
                        hv_XAxisEndValue.Dispose();
                        hv_YAxisEndValue.Dispose();
                        hv_XAxisStartValue.Dispose();
                        hv_YAxisStartValue.Dispose();
                        hv_XValuesAreStrings.Dispose();
                        hv_XTickValues.Dispose();
                        hv_XTicks.Dispose();
                        hv_YAxisPosition.Dispose();
                        hv_XAxisPosition.Dispose();
                        hv_LeftBorder.Dispose();
                        hv_RightBorder.Dispose();
                        hv_UpperBorder.Dispose();
                        hv_LowerBorder.Dispose();
                        hv_AxesColor.Dispose();
                        hv_Style.Dispose();
                        hv_Clip.Dispose();
                        hv_YTicks.Dispose();
                        hv_XGrid.Dispose();
                        hv_YGrid.Dispose();
                        hv_GridColor.Dispose();
                        hv_YPosition.Dispose();
                        hv_FormatX.Dispose();
                        hv_FormatY.Dispose();
                        hv_NumGenParamNames.Dispose();
                        hv_NumGenParamValues.Dispose();
                        hv_GenParamIndex.Dispose();
                        hv_XGridTicks.Dispose();
                        hv_YTickDirection.Dispose();
                        hv_XTickDirection.Dispose();
                        hv_XAxisWidthPx.Dispose();
                        hv_XAxisWidth.Dispose();
                        hv_XScaleFactor.Dispose();
                        hv_YAxisHeightPx.Dispose();
                        hv_YAxisHeight.Dispose();
                        hv_YScaleFactor.Dispose();
                        hv_YAxisOffsetPx.Dispose();
                        hv_XAxisOffsetPx.Dispose();
                        hv_DotStyle.Dispose();
                        hv_XGridValues.Dispose();
                        hv_XGridStart.Dispose();
                        hv_XCoord.Dispose();
                        hv_IndexGrid.Dispose();
                        hv_YGridValues.Dispose();
                        hv_YGridStart.Dispose();
                        hv_YCoord.Dispose();
                        hv_Ascent.Dispose();
                        hv_Descent.Dispose();
                        hv_TextWidthXLabel.Dispose();
                        hv_TextHeightXLabel.Dispose();
                        hv_TextWidthYLabel.Dispose();
                        hv_TextHeightYLabel.Dispose();
                        hv_XTickStart.Dispose();
                        hv_Indices.Dispose();
                        hv_TypeTicks.Dispose();
                        hv_IndexTicks.Dispose();
                        hv_Ascent1.Dispose();
                        hv_Descent1.Dispose();
                        hv_TextWidthXTicks.Dispose();
                        hv_TextHeightXTicks.Dispose();
                        hv_YTickValues.Dispose();
                        hv_YTickStart.Dispose();
                        hv_TextWidthYTicks.Dispose();
                        hv_TextHeightYTicks.Dispose();
                        hv_Num.Dispose();
                        hv_I.Dispose();
                        hv_YSelected.Dispose();
                        hv_Y1Selected.Dispose();
                        hv_X1Selected.Dispose();
                        hv_Index.Dispose();
                        hv_Row1.Dispose();
                        hv_Row2.Dispose();
                        hv_Col1.Dispose();
                        hv_Col2.Dispose();

                        return;
                    }
                    hv_XValuesAreStrings.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
                                )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
                            hv_XValuesAreStrings.Dispose();
                            hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
                        }
                    }
                    if ((int)(hv_XValuesAreStrings) != 0)
                    {
                        //XValues are given as strings:
                        //Show XValues as ticks
                        hv_XTickValues.Dispose();
                        hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
                        hv_XTicks.Dispose();
                        hv_XTicks = 1;
                        //Set x-axis dimensions
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
                                    1, new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()), 1);
                                hv_XValues_COPY_INP_TMP.Dispose();
                                hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
                            }
                        }
                    }
                    //Set default x-axis dimensions
                    if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
                                ;
                        }
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
                                ;
                        }
                    }
                    else
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) + 0.5;
                        }
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) - 0.5;
                        }
                    }
                }
                //Set default y-axis dimensions
                if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
                            ;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
                            ;
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) - 0.5;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) + 0.5;
                    }
                }
                else
                {
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                }
                //Set default interception point of x- and y- axis
                hv_YAxisPosition.Dispose();
                hv_YAxisPosition = "default";
                hv_XAxisPosition.Dispose();
                hv_XAxisPosition = "default";
                //
                //Set more defaults
                hv_LeftBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LeftBorder = hv_Width * 0.1;
                }
                hv_RightBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RightBorder = hv_Width * 0.1;
                }
                hv_UpperBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_UpperBorder = hv_Height * 0.1;
                }
                hv_LowerBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LowerBorder = hv_Height * 0.1;
                }
                hv_AxesColor.Dispose();
                hv_AxesColor = "white";
                hv_Style.Dispose();
                hv_Style = "line";
                hv_Clip.Dispose();
                hv_Clip = "no";
                hv_XTicks.Dispose();
                hv_XTicks = "min_max_origin";
                hv_YTicks.Dispose();
                hv_YTicks = "min_max_origin";
                hv_XGrid.Dispose();
                hv_XGrid = "none";
                hv_YGrid.Dispose();
                hv_YGrid = "none";
                hv_GridColor.Dispose();
                hv_GridColor = "dim gray";
                hv_YPosition.Dispose();
                hv_YPosition = "left";
                hv_FormatX.Dispose();
                hv_FormatX = "default";
                hv_FormatY.Dispose();
                hv_FormatY = "default";
                //
                //Parse generic parameters
                //
                hv_NumGenParamNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
                        );
                }
                hv_NumGenParamValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
                {
                    throw new HalconException("Number of generic parameter names does not match generic parameter values!");
                    ho_ContourXGrid.Dispose();
                    ho_ContourYGrid.Dispose();
                    ho_XArrow.Dispose();
                    ho_YArrow.Dispose();
                    ho_ContourXTick.Dispose();
                    ho_ContourYTick.Dispose();
                    ho_Contour.Dispose();
                    ho_Cross.Dispose();
                    ho_Filled.Dispose();
                    ho_Stair.Dispose();
                    ho_StairTmp.Dispose();

                    hv_XValues_COPY_INP_TMP.Dispose();
                    hv_YValues_COPY_INP_TMP.Dispose();
                    hv_PreviousWindowHandle.Dispose();
                    hv_ClipRegion.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_PartRow1.Dispose();
                    hv_PartColumn1.Dispose();
                    hv_PartRow2.Dispose();
                    hv_PartColumn2.Dispose();
                    hv_Red.Dispose();
                    hv_Green.Dispose();
                    hv_Blue.Dispose();
                    hv_DrawMode.Dispose();
                    hv_OriginStyle.Dispose();
                    hv_XAxisEndValue.Dispose();
                    hv_YAxisEndValue.Dispose();
                    hv_XAxisStartValue.Dispose();
                    hv_YAxisStartValue.Dispose();
                    hv_XValuesAreStrings.Dispose();
                    hv_XTickValues.Dispose();
                    hv_XTicks.Dispose();
                    hv_YAxisPosition.Dispose();
                    hv_XAxisPosition.Dispose();
                    hv_LeftBorder.Dispose();
                    hv_RightBorder.Dispose();
                    hv_UpperBorder.Dispose();
                    hv_LowerBorder.Dispose();
                    hv_AxesColor.Dispose();
                    hv_Style.Dispose();
                    hv_Clip.Dispose();
                    hv_YTicks.Dispose();
                    hv_XGrid.Dispose();
                    hv_YGrid.Dispose();
                    hv_GridColor.Dispose();
                    hv_YPosition.Dispose();
                    hv_FormatX.Dispose();
                    hv_FormatY.Dispose();
                    hv_NumGenParamNames.Dispose();
                    hv_NumGenParamValues.Dispose();
                    hv_GenParamIndex.Dispose();
                    hv_XGridTicks.Dispose();
                    hv_YTickDirection.Dispose();
                    hv_XTickDirection.Dispose();
                    hv_XAxisWidthPx.Dispose();
                    hv_XAxisWidth.Dispose();
                    hv_XScaleFactor.Dispose();
                    hv_YAxisHeightPx.Dispose();
                    hv_YAxisHeight.Dispose();
                    hv_YScaleFactor.Dispose();
                    hv_YAxisOffsetPx.Dispose();
                    hv_XAxisOffsetPx.Dispose();
                    hv_DotStyle.Dispose();
                    hv_XGridValues.Dispose();
                    hv_XGridStart.Dispose();
                    hv_XCoord.Dispose();
                    hv_IndexGrid.Dispose();
                    hv_YGridValues.Dispose();
                    hv_YGridStart.Dispose();
                    hv_YCoord.Dispose();
                    hv_Ascent.Dispose();
                    hv_Descent.Dispose();
                    hv_TextWidthXLabel.Dispose();
                    hv_TextHeightXLabel.Dispose();
                    hv_TextWidthYLabel.Dispose();
                    hv_TextHeightYLabel.Dispose();
                    hv_XTickStart.Dispose();
                    hv_Indices.Dispose();
                    hv_TypeTicks.Dispose();
                    hv_IndexTicks.Dispose();
                    hv_Ascent1.Dispose();
                    hv_Descent1.Dispose();
                    hv_TextWidthXTicks.Dispose();
                    hv_TextHeightXTicks.Dispose();
                    hv_YTickValues.Dispose();
                    hv_YTickStart.Dispose();
                    hv_TextWidthYTicks.Dispose();
                    hv_TextHeightYTicks.Dispose();
                    hv_Num.Dispose();
                    hv_I.Dispose();
                    hv_YSelected.Dispose();
                    hv_Y1Selected.Dispose();
                    hv_X1Selected.Dispose();
                    hv_Index.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Col1.Dispose();
                    hv_Col2.Dispose();

                    return;
                }
                //
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    //
                    //Set 'axes_color'
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axes_color"))) != 0)
                    {
                        hv_AxesColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxesColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'style'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "style"))) != 0)
                    {
                        hv_Style.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Style = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'clip'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "clip"))) != 0)
                    {
                        hv_Clip.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Clip = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
                            "no")))) != 0)
                        {
                            throw new HalconException(("Unsupported clipping option: '" + hv_Clip) + "'");
                        }
                        //
                        //Set 'ticks'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_x"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_y'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_y"))) != 0)
                    {
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_XGridTicks.Dispose();
                        hv_XGridTicks = new HTuple(hv_XTicks);
                        //
                        //Set 'grid_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_x"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_y'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_y"))) != 0)
                    {
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_color'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_color"))) != 0)
                    {
                        hv_GridColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GridColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_x"))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'end_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_x"))) != 0)
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_y'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_y"))) != 0)
                    {
                        hv_YAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'end_y'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_y"))) != 0)
                    {
                        hv_YAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'axis_location_y' (old name 'origin_x')
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_x")))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'axis_location_x' (old name: 'origin_y')
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_y")))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_left'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_left"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_right'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_right"))) != 0)
                    {
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_top'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_top"))) != 0)
                    {
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_bottom'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_bottom"))) != 0)
                    {
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_x"))) != 0)
                    {
                        hv_FormatX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatX = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_y"))) != 0)
                    {
                        hv_FormatY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatY = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                //Check consistency of start and end values
                //of the axes.
                if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
                }
                if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
                }
                //
                //Set the position of the y-axis.
                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_YAxisPosition.Dispose();
                    hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                }
                if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_y: '" + hv_YAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_YAxisPosition))) != 0)
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "right";
                }
                else
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "left";
                }
                //
                //Set the position of the x-axis.
                if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_XAxisPosition.Dispose();
                    hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                }
                if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_x: '" + hv_XAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_XAxisPosition))) != 0)
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "up";
                }
                else
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "down";
                }
                //
                //Calculate basic pixel coordinates and scale factors
                //
                hv_XAxisWidthPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidthPx = (hv_Width - hv_LeftBorder) - hv_RightBorder;
                }
                hv_XAxisWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidth = hv_XAxisEndValue - hv_XAxisStartValue;
                }
                if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue - 0.5;
                            hv_XAxisStartValue.Dispose();
                            hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue + 0.5;
                            hv_XAxisEndValue.Dispose();
                            hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
                        }
                    }
                    hv_XAxisWidth.Dispose();
                    hv_XAxisWidth = 1;
                }
                hv_XScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XScaleFactor = hv_XAxisWidthPx / (hv_XAxisWidth.TupleReal()
                        );
                }
                hv_YAxisHeightPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeightPx = (hv_Height - hv_LowerBorder) - hv_UpperBorder;
                }
                hv_YAxisHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeight = hv_YAxisEndValue - hv_YAxisStartValue;
                }
                if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue - 0.5;
                            hv_YAxisStartValue.Dispose();
                            hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue + 0.5;
                            hv_YAxisEndValue.Dispose();
                            hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
                        }
                    }
                    hv_YAxisHeight.Dispose();
                    hv_YAxisHeight = 1;
                }
                hv_YScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YScaleFactor = hv_YAxisHeightPx / (hv_YAxisHeight.TupleReal()
                        );
                }
                hv_YAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisOffsetPx = (hv_YAxisPosition - hv_XAxisStartValue) * hv_XScaleFactor;
                }
                hv_XAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisOffsetPx = (hv_XAxisPosition - hv_YAxisStartValue) * hv_YScaleFactor;
                }
                //
                //Display grid lines
                //
                if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
                {
                    hv_DotStyle.Dispose();
                    hv_DotStyle = new HTuple();
                    hv_DotStyle[0] = 5;
                    hv_DotStyle[1] = 7;
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
                    }
                    //
                    //Display x grid lines
                    if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates
                            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates
                            hv_XGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridStart = (((hv_XAxisStartValue / hv_XGrid)).TupleCeil()
                                    ) * hv_XGrid;
                            }
                            hv_XGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridValues = HTuple.TupleGenSequence(
                                    hv_XGridStart, hv_XAxisEndValue, hv_XGrid);
                            }
                        }
                        hv_XCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XCoord = (hv_XGridValues - hv_XAxisStartValue) * hv_XScaleFactor;
                        }
                        //Generate and display grid lines
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_XGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourXGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height - hv_LowerBorder)).TupleConcat(
                                    hv_UpperBorder), ((hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
                                    hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid))));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Display y grid lines
                    if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates
                            hv_YGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridStart = (((hv_YAxisStartValue / hv_YGrid)).TupleCeil()
                                    ) * hv_YGrid;
                            }
                            hv_YGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridValues = HTuple.TupleGenSequence(
                                    hv_YGridStart, hv_YAxisEndValue, hv_YGrid);
                            }
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YGridValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        //Generate and display grid lines
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_YGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourYGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width - hv_RightBorder));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                //
                //
                //Display the coordinate system axes
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    //Display axes
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_XArrow.Dispose();
                        gen_arrow_contour_xld(out ho_XArrow, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx,
                            hv_LeftBorder, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx, hv_Width - hv_RightBorder,
                            0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_YArrow.Dispose();
                        gen_arrow_contour_xld(out ho_YArrow, hv_Height - hv_LowerBorder, hv_LeftBorder + hv_YAxisOffsetPx,
                            hv_UpperBorder, hv_LeftBorder + hv_YAxisOffsetPx, 0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
                    }
                    //Display labels
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthXLabel.Dispose(); hv_TextHeightXLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthXLabel, out hv_TextHeightXLabel);
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthYLabel.Dispose(); hv_TextHeightYLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthYLabel, out hv_TextHeightYLabel);
                    if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, (hv_LeftBorder + 3) + hv_YAxisOffsetPx, hv_AxesColor,
                                        "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, (hv_LeftBorder + 3) + hv_YAxisOffsetPx,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXLabel)) + 3, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, ((hv_Width - hv_RightBorder) - hv_TextWidthYLabel) - 13,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - (2 * hv_TextWidthYLabel)) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                }
                //
                //Display ticks
                //
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display x ticks
                        if ((int)(hv_XValuesAreStrings) != 0)
                        {
                            //Display string XValues as categories
                            hv_XTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) / (new HTuple(hv_XTickValues.TupleLength()));
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XValues_COPY_INP_TMP - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                        }
                        else
                        {
                            //Display tick values
                            if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
                            {
                                //Calculate 'min_max_origin' tick coordinates
                                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                    }
                                }
                                else
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                    }
                                }
                            }
                            else
                            {
                                //Calculate equidistant tick coordinates
                                hv_XTickStart.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickStart = (((hv_XAxisStartValue / hv_XTicks)).TupleCeil()
                                        ) * hv_XTicks;
                                }
                                hv_XTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickValues = HTuple.TupleGenSequence(
                                        hv_XTickStart, hv_XAxisEndValue, hv_XTicks);
                                }
                            }
                            //Remove ticks that are smaller than the x-axis start.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = ((hv_XTickValues.TupleLessElem(
                                    hv_XAxisStartValue))).TupleFind(1);
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XTickValues - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
                                        hv_Indices);
                                    hv_XCoord.Dispose();
                                    hv_XCoord = ExpTmpLocalVar_XCoord;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
                                        hv_Indices);
                                    hv_XTickValues.Dispose();
                                    hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                }
                            }
                            //
                            if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
                            {
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_XTicks.TupleType()
                                        ;
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                                {
                                    //String ('min_max_origin')
                                    //Format depends on actual values
                                    hv_TypeTicks.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_TypeTicks = hv_XTickValues.TupleType()
                                            ;
                                    }
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                                {
                                    //Round to integer
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                                                ;
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                                else
                                {
                                    //Use floating point numbers
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                                ".2f");
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                            hv_FormatX);
                                        hv_XTickValues.Dispose();
                                        hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                    }
                                }
                            }
                        }
                        //Generate and display ticks
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_XTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthXTicks.Dispose(); hv_TextHeightXTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks,
                                    out hv_TextHeightXTicks);
                            }
                            if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx)).TupleConcat(
                                        ((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) - 5), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) + 2) - hv_XAxisOffsetPx,
                                            hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor,
                                            "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) + 5)).TupleConcat(
                                        (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXTicks)) - hv_XAxisOffsetPx,
                                            hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor,
                                            "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display y ticks
                        if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' tick coordinates
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant tick coordinates
                            hv_YTickStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickStart = (((hv_YAxisStartValue / hv_YTicks)).TupleCeil()
                                    ) * hv_YTicks;
                            }
                            hv_YTickValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickValues = HTuple.TupleGenSequence(
                                    hv_YTickStart, hv_YAxisEndValue, hv_YTicks);
                            }
                        }
                        //Remove ticks that are smaller than the y-axis start.
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = ((hv_YTickValues.TupleLessElem(
                                hv_YAxisStartValue))).TupleFind(1);
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YTickValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
                                    hv_Indices);
                                hv_YCoord.Dispose();
                                hv_YCoord = ExpTmpLocalVar_YCoord;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
                                    hv_Indices);
                                hv_YTickValues.Dispose();
                                hv_YTickValues = ExpTmpLocalVar_YTickValues;
                            }
                        }
                        //
                        if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
                        {
                            hv_TypeTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TypeTicks = hv_YTicks.TupleType()
                                    ;
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                            {
                                //String ('min_max_origin')
                                //Format depends on actual values
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_YTickValues.TupleType()
                                        ;
                                }
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                            {
                                //Round to integer
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                                            ;
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                            else
                            {
                                //Use floating point numbers
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                            ".2f");
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                        hv_FormatY);
                                    hv_YTickValues.Dispose();
                                    hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                }
                            }
                        }
                        //Generate and display ticks
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_YTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthYTicks.Dispose(); hv_TextHeightYTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks,
                                    out hv_TextHeightYTicks);
                            }
                            if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), ((hv_LeftBorder + hv_YAxisOffsetPx)).TupleConcat(
                                        (hv_LeftBorder + hv_YAxisOffsetPx) + 5));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), ((hv_LeftBorder - hv_TextWidthYTicks) - 2) + hv_YAxisOffsetPx,
                                            hv_AxesColor, "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), (((hv_LeftBorder + hv_YAxisOffsetPx) - 5)).TupleConcat(
                                        hv_LeftBorder + hv_YAxisOffsetPx));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), (hv_LeftBorder + 2) + hv_YAxisOffsetPx, hv_AxesColor,
                                            "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                //
                //Display function plot
                //
                if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
                {
                    if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
                    {
                        hv_Num.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                                )) / (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
                        }
                        //
                        //Iterate over all functions to be displayed
                        HTuple end_val576 = hv_Num - 1;
                        HTuple step_val576 = 1;
                        for (hv_I = 0; hv_I.Continue(end_val576, step_val576); hv_I = hv_I.TupleAdd(step_val576))
                        {
                            //Select y values for current function
                            hv_YSelected.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
                                    hv_I * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())), ((hv_I + 1) * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    ))) - 1);
                            }
                            //Set color
                            if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
                            {
                                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                                            hv_I % (new HTuple(hv_Color.TupleLength()))));
                                    }
                                }
                            }
                            //
                            //Display in different styles
                            //
                            if ((int)((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(new HTuple(hv_Style.TupleEqual(
                                new HTuple())))) != 0)
                            {
                                //Line
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Contour.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Contour.Dispose();
                                        ho_Contour = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
                            {
                                //Cross
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Cross.Dispose();
                                    HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                        6, 0.785398);
                                }
                                //Clip, if necessary
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Cross.Dispose();
                                        ho_Cross = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
                            {
                                //Filled
                                hv_Y1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Y1Selected = new HTuple();
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                }
                                hv_X1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_X1Selected = new HTuple();
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                                        );
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                                        );
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Filled.Dispose();
                                    HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height - hv_LowerBorder) - (hv_Y1Selected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_X1Selected * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Filled.Dispose();
                                        ho_Filled = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
                            {
                                ho_Stair.Dispose();
                                HOperatorSet.GenEmptyObj(out ho_Stair);
                                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) - 2); hv_Index = (int)hv_Index + 1)
                                {
                                    hv_Row1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row1 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Row2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row2 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index + 1)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Col1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    hv_Col2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index + 1)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_StairTmp.Dispose();
                                        HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                                            hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                                            hv_Col2));
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0,
                                        0.1, 0.1, "attr_keep");
                                    ho_Stair.Dispose();
                                    ho_Stair = ExpTmpOutVar_0;
                                }
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
                                }
                            }
                            else
                            {
                                throw new HalconException("Unsupported style: " + hv_Style);
                            }
                        }
                    }
                }
                //
                //
                //Reset original display settings
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_PartRow1, hv_PartColumn1,
                        hv_PartRow2, hv_PartColumn2);
                }
                HDevWindowStack.SetActive(hv_PreviousWindowHandle);
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_PreviousWindowHandle.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_PreviousWindowHandle.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Plot tuples representing functions or curves in a coordinate system. 
        private void plot_tuple_no_window_handling(HTuple hv_WindowHandle, HTuple hv_XValues,
            HTuple hv_YValues, HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName,
            HTuple hv_GenParamValue)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContourXGrid = null, ho_ContourYGrid = null;
            HObject ho_XArrow = null, ho_YArrow = null, ho_ContourXTick = null;
            HObject ho_ContourYTick = null, ho_Contour = null, ho_Cross = null;
            HObject ho_Circle = null, ho_Filled = null, ho_Stair = null, ho_StairTmp = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
            HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
            HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
            HTuple hv_PartDiffers = new HTuple(), hv_PlotYLog = new HTuple();
            HTuple hv_YLogIndices = new HTuple(), hv_PlotYLogUser = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_YInd = new HTuple();
            HTuple hv_Indices1 = new HTuple(), hv_XAxisEndValue = new HTuple();
            HTuple hv_YAxisEndValue = new HTuple(), hv_XAxisStartValue = new HTuple();
            HTuple hv_YAxisStartValue = new HTuple(), hv_XValuesAreStrings = new HTuple();
            HTuple hv_XTickValues = new HTuple(), hv_XTicks = new HTuple();
            HTuple hv_YAxisPosition = new HTuple(), hv_XAxisPosition = new HTuple();
            HTuple hv_LeftBorder = new HTuple(), hv_RightBorder = new HTuple();
            HTuple hv_UpperBorder = new HTuple(), hv_LowerBorder = new HTuple();
            HTuple hv_AxesColor = new HTuple(), hv_Style = new HTuple();
            HTuple hv_Clip = new HTuple(), hv_YTicks = new HTuple();
            HTuple hv_XGrid = new HTuple(), hv_YGrid = new HTuple();
            HTuple hv_GridColor = new HTuple(), hv_YPosition = new HTuple();
            HTuple hv_FormatX = new HTuple(), hv_FormatY = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_NumGenParamNames = new HTuple();
            HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
            HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
            HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
            HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
            HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
            HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
            HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
            HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
            HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
            HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
            HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
            HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
            HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
            HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
            HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
            HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
            HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
            HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
            HTuple hv_StyleOriginal = new HTuple(), hv_OldLineWidth = new HTuple();
            HTuple hv_Radii = new HTuple(), hv_OldContourStyle = new HTuple();
            HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_Col2 = new HTuple();
            HTuple hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
            HTuple hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
            HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
            HOperatorSet.GenEmptyObj(out ho_XArrow);
            HOperatorSet.GenEmptyObj(out ho_YArrow);
            HOperatorSet.GenEmptyObj(out ho_ContourXTick);
            HOperatorSet.GenEmptyObj(out ho_ContourYTick);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Filled);
            HOperatorSet.GenEmptyObj(out ho_Stair);
            HOperatorSet.GenEmptyObj(out ho_StairTmp);
            try
            {
                //
                //This procedure plots tuples representing functions
                //or curves in a coordinate system.

                //In the following, the possible values are listed for the parameters:
                //
                //- XValues: X values of the function to be plotted. Thereby you have the following options:
                //  -- []: XValues are internally set to 0,1,2,...,|YValues|-1.
                //  -- a tuple of strings: These values are taken as categories.
                //
                //- YValues: Y values of the function(s) to be plotted. Thereby you have the following options:
                //  -- []: YValues are internally set to 0,1,2,...,|XValues|-1.
                //  -- a tuple of values: The number of y values must be equal to the number of x values or an integral multiple.
                //     In the latter case, multiple functions are plotted, that share the same x values.
                //
                //- XLabel: X-axis label.
                //
                //- YLabel: Y-axis label.
                //
                //- Color: Color of the plotted function. Thereby you have the following options:
                //  -- []: The currently set display color is used.
                //  -- 'none': The function is not plotted, but only the coordinate axes as specified.
                //  -- string: Defining the color of the plotted function.
                //  -- tuple of strings: -multiple functions can be displayed in different colors.
                //
                //- GenParamName: Generic parameter names to control the presentation.
                // The corresponding values are taken from GenParamValue. Possible Values string/value pairs:
                //  -- 'axes_color': Color of the coordinate axes. The default value is 'white'.
                //     If 'none' is given, no coordinate axes are shown.
                //  -- 'style': Graph style. Possible values:
                //     --- 'line' (default)
                //     --- 'cross'
                //     --- 'circle'
                //     --- 'step'
                //     --- 'filled'
                //  -- 'clip': Clip graph to coordinate system area. Possible values:
                //     --- 'no' (default)
                //     --- 'yes''
                //  -- 'ticks': Control display of ticks on the axes. Thereby you have the following options:
                //     --- 'min_max_origin' (default): Ticks are shown at the minimum and maximum values
                //         of the axes and at the intercept point of x- and y-axis.
                //     --- 'none': No ticks are shown.
                //     --- any number != 0: This number specifies the distance between the ticks.
                //  -- 'ticks_x': Control display of ticks on x-axis only. You have the same options as for 'ticks'.
                //  -- 'ticks_y': Control display of ticks on y-axis only. You have the same options as for 'ticks'.
                //  -- 'format_x': Format of the values next to the ticks of the x-axis (see tuple_string for more details).
                //  -- 'format_y': Format of the values next to the ticks of the y-axis (see tuple_string for more details).
                //  -- 'grid': Control display of grid lines within the coordinate system.
                //     Thereby you have the following options:
                //    --- 'min_max_origin' (default): Grid lines are shown at the minimum and maximum values of the axes.
                //    --- 'none': No grid lines are shown.
                //    --- If any number != 0: This number specifies the distance between the grid lines.
                //  -- 'grid_x': Control display of grid lines for the x-axis only.
                //  -- 'grid_y': Control display of grid lines for the y-axis only.
                //  -- 'grid_color': Color of the grid (default: 'dim gray').
                //  -- 'margin': The distance in pixels of the plot area to all four window borders.
                //  -- 'margin_left': The distance in pixels of the plot area to the left window border.
                //  -- 'margin_right': The distance in pixels of the plot area to the right window border.
                //  -- 'margin_top': The distance in pixels of the plot area to the upper window border.
                //  -- 'margin_bottom'': The distance in pixels of the plot area to the lower window border.
                //  -- 'start_x': Lowest x value of the x-axis. The default value is min(XValues).
                //  -- 'end_x': Highest x value of the x-axis. The default value is max(XValues).
                //  -- 'start_y': Lowest y value of the y-axis. The default value is min(YValues).
                //  -- 'end_y': Highest y value of the y-axis. The default value is max(YValues).
                //  -- 'axis_location_x': Position of the x-axis (Used to be called 'origin_y').
                //     Thereby you have the following options:
                //     --- 'bottom' (default)
                //     --- 'origin'
                //     --- 'top'
                //     --- Y coordinate of the intercept point of x- and y-axis.
                //  -- 'axis_location_y': Position of the y-axis (Used to be called 'origin_x').
                //     Thereby you have the following options:
                //     --- 'left' (default)
                //     --- 'right'
                //     --- 'origin'
                //     --- X coordinate of the intercept point of x- and y-axis.
                //  -- 'line_width': Line width of the plot.
                //  -- 'log_y': If 'true', plot the YValue in logarithmic scale. Default is 'false'.
                //
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                hv_Row.Dispose(); hv_Column.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width,
                    out hv_Height);
                hv_PartRow1.Dispose(); hv_PartColumn1.Dispose(); hv_PartRow2.Dispose(); hv_PartColumn2.Dispose();
                HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1,
                    out hv_PartRow2, out hv_PartColumn2);
                hv_Width.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Width = (hv_PartColumn2 - hv_PartColumn1) + 1;
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = (hv_PartRow2 - hv_PartRow1) + 1;
                }
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose();
                HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                hv_OriginStyle.Dispose();
                HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
                //
                //Set the display parameters.
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                HOperatorSet.SetSystem("clip_region", "false");

                hv_PartDiffers.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PartDiffers = (new HTuple((new HTuple((new HTuple((new HTuple(0)).TupleNotEqual(
                        hv_PartRow1))).TupleOr(new HTuple((new HTuple(0)).TupleNotEqual(hv_Column))))).TupleOr(
                        new HTuple(((hv_Width - 1)).TupleNotEqual(hv_PartColumn2))))).TupleOr(new HTuple(((hv_Height - 1)).TupleNotEqual(
                        hv_PartRow2)));
                }
                //Only use set part if it differs.
                if ((int)(hv_PartDiffers) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                        }
                    }
                }
                //
                //Check if we need to plot y-values logarithmically.
                //It is checked here because we want to convert the YValues tuple
                //immediately so that derived values will be correct.
                hv_PlotYLog.Dispose();
                hv_PlotYLog = 0;
                if ((int)((new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
                    0))).TupleAnd(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleEqual(
                    new HTuple(hv_GenParamValue.TupleLength()))))) != 0)
                {
                    hv_YLogIndices.Dispose();
                    HOperatorSet.TupleFind(hv_GenParamName, "log_y", out hv_YLogIndices);
                    if ((int)(new HTuple(hv_YLogIndices.TupleGreaterEqual(0))) != 0)
                    {
                        hv_PlotYLogUser.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PlotYLogUser = hv_GenParamValue.TupleSelect(
                                hv_YLogIndices.TupleSelect(0));
                        }
                        hv_IsString.Dispose();
                        HOperatorSet.TupleIsString(hv_PlotYLogUser, out hv_IsString);
                        if ((int)(hv_IsString) != 0)
                        {
                            if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("true"))) != 0)
                            {
                                hv_PlotYLog.Dispose();
                                hv_PlotYLog = 1;
                            }
                            else if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("false"))) != 0)
                            {
                                hv_PlotYLog.Dispose();
                                hv_PlotYLog = 0;
                            }
                            else
                            {
                                throw new HalconException(("Unknown generic parameter value: '" + hv_PlotYLogUser) + "' for value: 'log_y'");
                            }
                            hv_PlotYLog.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
                                    "true"));
                            }
                        }
                        else
                        {
                            hv_PlotYLog.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
                                    1));
                            }
                        }
                    }
                }
                if ((int)(hv_PlotYLog) != 0)
                {
                    //Clamp values to be >= 0.00001.
                    hv_YInd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YInd = hv_YValues_COPY_INP_TMP.TupleLessEqualElem(
                            0);
                    }
                    hv_Indices1.Dispose();
                    HOperatorSet.TupleFind(hv_YInd, 1, out hv_Indices1);
                    if ((int)(new HTuple(hv_Indices1.TupleGreaterEqual(0))) != 0)
                    {
                        if (hv_YValues_COPY_INP_TMP == null)
                            hv_YValues_COPY_INP_TMP = new HTuple();
                        hv_YValues_COPY_INP_TMP[hv_Indices1] = 0.00001;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YValues = hv_YValues_COPY_INP_TMP.TupleLog10()
                                ;
                            hv_YValues_COPY_INP_TMP.Dispose();
                            hv_YValues_COPY_INP_TMP = ExpTmpLocalVar_YValues;
                        }
                    }
                }
                //
                //Check input coordinate values.
                //
                if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
                    new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
                {
                    //Neither XValues nor YValues are given:
                    //Set axes to interval [0,1]
                    hv_XAxisEndValue.Dispose();
                    hv_XAxisEndValue = 1;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                    hv_XAxisStartValue.Dispose();
                    hv_XAxisStartValue = 0;
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_XValuesAreStrings.Dispose();
                    hv_XValuesAreStrings = 0;
                }
                else
                {
                    if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //XValues are omitted: Set equidistant XValues.
                        hv_XValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                        hv_XValuesAreStrings.Dispose();
                        hv_XValuesAreStrings = 0;
                    }
                    else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //YValues are omitted: Set equidistant YValues.
                        hv_YValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                        )) % (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
                        0))) != 0)
                    {
                        //Number of YValues does not match number of XValues.
                        throw new HalconException("Number of YValues is no multiple of the number of XValues.");
                        ho_ContourXGrid.Dispose();
                        ho_ContourYGrid.Dispose();
                        ho_XArrow.Dispose();
                        ho_YArrow.Dispose();
                        ho_ContourXTick.Dispose();
                        ho_ContourYTick.Dispose();
                        ho_Contour.Dispose();
                        ho_Cross.Dispose();
                        ho_Circle.Dispose();
                        ho_Filled.Dispose();
                        ho_Stair.Dispose();
                        ho_StairTmp.Dispose();

                        hv_XValues_COPY_INP_TMP.Dispose();
                        hv_YValues_COPY_INP_TMP.Dispose();
                        hv_ClipRegion.Dispose();
                        hv_Row.Dispose();
                        hv_Column.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_PartRow1.Dispose();
                        hv_PartColumn1.Dispose();
                        hv_PartRow2.Dispose();
                        hv_PartColumn2.Dispose();
                        hv_Red.Dispose();
                        hv_Green.Dispose();
                        hv_Blue.Dispose();
                        hv_DrawMode.Dispose();
                        hv_OriginStyle.Dispose();
                        hv_PartDiffers.Dispose();
                        hv_PlotYLog.Dispose();
                        hv_YLogIndices.Dispose();
                        hv_PlotYLogUser.Dispose();
                        hv_IsString.Dispose();
                        hv_YInd.Dispose();
                        hv_Indices1.Dispose();
                        hv_XAxisEndValue.Dispose();
                        hv_YAxisEndValue.Dispose();
                        hv_XAxisStartValue.Dispose();
                        hv_YAxisStartValue.Dispose();
                        hv_XValuesAreStrings.Dispose();
                        hv_XTickValues.Dispose();
                        hv_XTicks.Dispose();
                        hv_YAxisPosition.Dispose();
                        hv_XAxisPosition.Dispose();
                        hv_LeftBorder.Dispose();
                        hv_RightBorder.Dispose();
                        hv_UpperBorder.Dispose();
                        hv_LowerBorder.Dispose();
                        hv_AxesColor.Dispose();
                        hv_Style.Dispose();
                        hv_Clip.Dispose();
                        hv_YTicks.Dispose();
                        hv_XGrid.Dispose();
                        hv_YGrid.Dispose();
                        hv_GridColor.Dispose();
                        hv_YPosition.Dispose();
                        hv_FormatX.Dispose();
                        hv_FormatY.Dispose();
                        hv_LineWidth.Dispose();
                        hv_NumGenParamNames.Dispose();
                        hv_NumGenParamValues.Dispose();
                        hv_GenParamIndex.Dispose();
                        hv_XGridTicks.Dispose();
                        hv_YTickDirection.Dispose();
                        hv_XTickDirection.Dispose();
                        hv_XAxisWidthPx.Dispose();
                        hv_XAxisWidth.Dispose();
                        hv_XScaleFactor.Dispose();
                        hv_YAxisHeightPx.Dispose();
                        hv_YAxisHeight.Dispose();
                        hv_YScaleFactor.Dispose();
                        hv_YAxisOffsetPx.Dispose();
                        hv_XAxisOffsetPx.Dispose();
                        hv_DotStyle.Dispose();
                        hv_XGridValues.Dispose();
                        hv_XGridStart.Dispose();
                        hv_XCoord.Dispose();
                        hv_IndexGrid.Dispose();
                        hv_YGridValues.Dispose();
                        hv_YGridStart.Dispose();
                        hv_YCoord.Dispose();
                        hv_Ascent.Dispose();
                        hv_Descent.Dispose();
                        hv_TextWidthXLabel.Dispose();
                        hv_TextHeightXLabel.Dispose();
                        hv_TextWidthYLabel.Dispose();
                        hv_TextHeightYLabel.Dispose();
                        hv_XTickStart.Dispose();
                        hv_Indices.Dispose();
                        hv_TypeTicks.Dispose();
                        hv_IndexTicks.Dispose();
                        hv_Ascent1.Dispose();
                        hv_Descent1.Dispose();
                        hv_TextWidthXTicks.Dispose();
                        hv_TextHeightXTicks.Dispose();
                        hv_YTickValues.Dispose();
                        hv_YTickStart.Dispose();
                        hv_TextWidthYTicks.Dispose();
                        hv_TextHeightYTicks.Dispose();
                        hv_Num.Dispose();
                        hv_I.Dispose();
                        hv_YSelected.Dispose();
                        hv_StyleOriginal.Dispose();
                        hv_OldLineWidth.Dispose();
                        hv_Radii.Dispose();
                        hv_OldContourStyle.Dispose();
                        hv_Y1Selected.Dispose();
                        hv_X1Selected.Dispose();
                        hv_Index.Dispose();
                        hv_Row1.Dispose();
                        hv_Row2.Dispose();
                        hv_Col1.Dispose();
                        hv_Col2.Dispose();

                        return;
                    }

                    hv_XValuesAreStrings.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
                                )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
                            hv_XValuesAreStrings.Dispose();
                            hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
                        }
                    }
                    if ((int)(hv_XValuesAreStrings) != 0)
                    {
                        //XValues are given as strings: Show XValues as ticks.
                        hv_XTickValues.Dispose();
                        hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
                        hv_XTicks.Dispose();
                        hv_XTicks = 1;
                        //Set x-axis dimensions.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
                                    1, new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()), 1);
                                hv_XValues_COPY_INP_TMP.Dispose();
                                hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
                            }
                        }
                    }
                    //Set default x-axis dimensions.
                    if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
                                ;
                        }
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
                                ;
                        }
                    }
                    else
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) + 0.5;
                        }
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) - 0.5;
                        }
                    }
                }
                //Set default y-axis dimensions.
                if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
                            ;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
                            ;
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) - 0.5;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) + 0.5;
                    }
                }
                else
                {
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                }
                //Set default interception point of x- and y- axis.
                hv_YAxisPosition.Dispose();
                hv_YAxisPosition = "default";
                hv_XAxisPosition.Dispose();
                hv_XAxisPosition = "default";
                //
                //Set further default values:
                hv_LeftBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LeftBorder = hv_Width * 0.1;
                }
                hv_RightBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RightBorder = hv_Width * 0.1;
                }
                hv_UpperBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_UpperBorder = hv_Height * 0.1;
                }
                hv_LowerBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LowerBorder = hv_Height * 0.1;
                }
                hv_AxesColor.Dispose();
                hv_AxesColor = "white";
                hv_Style.Dispose();
                hv_Style = "line";
                hv_Clip.Dispose();
                hv_Clip = "no";
                hv_XTicks.Dispose();
                hv_XTicks = "min_max_origin";
                hv_YTicks.Dispose();
                hv_YTicks = "min_max_origin";
                hv_XGrid.Dispose();
                hv_XGrid = "none";
                hv_YGrid.Dispose();
                hv_YGrid = "none";
                hv_GridColor.Dispose();
                hv_GridColor = "dim gray";
                hv_YPosition.Dispose();
                hv_YPosition = "left";
                hv_FormatX.Dispose();
                hv_FormatX = "default";
                hv_FormatY.Dispose();
                hv_FormatY = "default";
                hv_LineWidth.Dispose();
                hv_LineWidth = 1;
                //
                //Parse generic parameters.
                //
                hv_NumGenParamNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
                        );
                }
                hv_NumGenParamValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
                {
                    throw new HalconException("Number of generic parameter names does not match generic parameter values.");
                    ho_ContourXGrid.Dispose();
                    ho_ContourYGrid.Dispose();
                    ho_XArrow.Dispose();
                    ho_YArrow.Dispose();
                    ho_ContourXTick.Dispose();
                    ho_ContourYTick.Dispose();
                    ho_Contour.Dispose();
                    ho_Cross.Dispose();
                    ho_Circle.Dispose();
                    ho_Filled.Dispose();
                    ho_Stair.Dispose();
                    ho_StairTmp.Dispose();

                    hv_XValues_COPY_INP_TMP.Dispose();
                    hv_YValues_COPY_INP_TMP.Dispose();
                    hv_ClipRegion.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_PartRow1.Dispose();
                    hv_PartColumn1.Dispose();
                    hv_PartRow2.Dispose();
                    hv_PartColumn2.Dispose();
                    hv_Red.Dispose();
                    hv_Green.Dispose();
                    hv_Blue.Dispose();
                    hv_DrawMode.Dispose();
                    hv_OriginStyle.Dispose();
                    hv_PartDiffers.Dispose();
                    hv_PlotYLog.Dispose();
                    hv_YLogIndices.Dispose();
                    hv_PlotYLogUser.Dispose();
                    hv_IsString.Dispose();
                    hv_YInd.Dispose();
                    hv_Indices1.Dispose();
                    hv_XAxisEndValue.Dispose();
                    hv_YAxisEndValue.Dispose();
                    hv_XAxisStartValue.Dispose();
                    hv_YAxisStartValue.Dispose();
                    hv_XValuesAreStrings.Dispose();
                    hv_XTickValues.Dispose();
                    hv_XTicks.Dispose();
                    hv_YAxisPosition.Dispose();
                    hv_XAxisPosition.Dispose();
                    hv_LeftBorder.Dispose();
                    hv_RightBorder.Dispose();
                    hv_UpperBorder.Dispose();
                    hv_LowerBorder.Dispose();
                    hv_AxesColor.Dispose();
                    hv_Style.Dispose();
                    hv_Clip.Dispose();
                    hv_YTicks.Dispose();
                    hv_XGrid.Dispose();
                    hv_YGrid.Dispose();
                    hv_GridColor.Dispose();
                    hv_YPosition.Dispose();
                    hv_FormatX.Dispose();
                    hv_FormatY.Dispose();
                    hv_LineWidth.Dispose();
                    hv_NumGenParamNames.Dispose();
                    hv_NumGenParamValues.Dispose();
                    hv_GenParamIndex.Dispose();
                    hv_XGridTicks.Dispose();
                    hv_YTickDirection.Dispose();
                    hv_XTickDirection.Dispose();
                    hv_XAxisWidthPx.Dispose();
                    hv_XAxisWidth.Dispose();
                    hv_XScaleFactor.Dispose();
                    hv_YAxisHeightPx.Dispose();
                    hv_YAxisHeight.Dispose();
                    hv_YScaleFactor.Dispose();
                    hv_YAxisOffsetPx.Dispose();
                    hv_XAxisOffsetPx.Dispose();
                    hv_DotStyle.Dispose();
                    hv_XGridValues.Dispose();
                    hv_XGridStart.Dispose();
                    hv_XCoord.Dispose();
                    hv_IndexGrid.Dispose();
                    hv_YGridValues.Dispose();
                    hv_YGridStart.Dispose();
                    hv_YCoord.Dispose();
                    hv_Ascent.Dispose();
                    hv_Descent.Dispose();
                    hv_TextWidthXLabel.Dispose();
                    hv_TextHeightXLabel.Dispose();
                    hv_TextWidthYLabel.Dispose();
                    hv_TextHeightYLabel.Dispose();
                    hv_XTickStart.Dispose();
                    hv_Indices.Dispose();
                    hv_TypeTicks.Dispose();
                    hv_IndexTicks.Dispose();
                    hv_Ascent1.Dispose();
                    hv_Descent1.Dispose();
                    hv_TextWidthXTicks.Dispose();
                    hv_TextHeightXTicks.Dispose();
                    hv_YTickValues.Dispose();
                    hv_YTickStart.Dispose();
                    hv_TextWidthYTicks.Dispose();
                    hv_TextHeightYTicks.Dispose();
                    hv_Num.Dispose();
                    hv_I.Dispose();
                    hv_YSelected.Dispose();
                    hv_StyleOriginal.Dispose();
                    hv_OldLineWidth.Dispose();
                    hv_Radii.Dispose();
                    hv_OldContourStyle.Dispose();
                    hv_Y1Selected.Dispose();
                    hv_X1Selected.Dispose();
                    hv_Index.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Col1.Dispose();
                    hv_Col2.Dispose();

                    return;
                }
                //
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    //
                    //Set 'axes_color'.
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axes_color"))) != 0)
                    {
                        hv_AxesColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxesColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'style'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "style"))) != 0)
                    {
                        hv_Style.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Style = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'clip'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "clip"))) != 0)
                    {
                        hv_Clip.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Clip = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
                            "no")))) != 0)
                        {
                            throw new HalconException(("Unsupported clipping option: '" + hv_Clip) + "'");
                        }
                        //
                        //Set 'ticks'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_x"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_y"))) != 0)
                    {
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_XGridTicks.Dispose();
                        hv_XGridTicks = new HTuple(hv_XTicks);
                        //
                        //Set 'grid_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_x"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_y"))) != 0)
                    {
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_color'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_color"))) != 0)
                    {
                        hv_GridColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GridColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_x"))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'end_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_x"))) != 0)
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_y"))) != 0)
                    {
                        hv_YAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisStartValue = (((new HTuple(0.00000001)).TupleMax2(
                                        hv_YAxisStartValue))).TupleLog10();
                                    hv_YAxisStartValue.Dispose();
                                    hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
                                }
                            }
                        }
                        //
                        //Set 'end_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_y"))) != 0)
                    {
                        hv_YAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisEndValue = (((new HTuple(0.00000001)).TupleMax2(
                                        hv_YAxisEndValue))).TupleLog10();
                                    hv_YAxisEndValue.Dispose();
                                    hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
                                }
                            }
                        }
                        //
                        //Set 'axis_location_y' (old name 'origin_x').
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_x")))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'axis_location_x' (old name: 'origin_y').
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_y")))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_left'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_left"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_right'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_right"))) != 0)
                    {
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_top'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_top"))) != 0)
                    {
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_bottom'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_bottom"))) != 0)
                    {
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_x"))) != 0)
                    {
                        hv_FormatX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatX = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_y"))) != 0)
                    {
                        hv_FormatY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatY = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "line_width"))) != 0)
                    {
                        hv_LineWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LineWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "log_y"))) != 0)
                    {
                        //log_y already checked before because some other values depend on it.
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                //Check consistency of start and end values of the axes.
                if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
                }
                if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
                }
                //
                //Set the position of the y-axis.
                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_YAxisPosition.Dispose();
                    hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                }
                if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_y: '" + hv_YAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_YAxisPosition))) != 0)
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "right";
                }
                else
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "left";
                }
                //
                //Set the position of the x-axis.
                if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_XAxisPosition.Dispose();
                    hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                }
                if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_x: '" + hv_XAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_XAxisPosition))) != 0)
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "up";
                }
                else
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "down";
                }
                //
                //Calculate basic pixel coordinates and scale factors.
                //
                hv_XAxisWidthPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidthPx = (hv_Width - hv_LeftBorder) - hv_RightBorder;
                }
                hv_XAxisWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidth = hv_XAxisEndValue - hv_XAxisStartValue;
                }
                if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue - 0.5;
                            hv_XAxisStartValue.Dispose();
                            hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue + 0.5;
                            hv_XAxisEndValue.Dispose();
                            hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
                        }
                    }
                    hv_XAxisWidth.Dispose();
                    hv_XAxisWidth = 1;
                }
                hv_XScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XScaleFactor = hv_XAxisWidthPx / (hv_XAxisWidth.TupleReal()
                        );
                }
                hv_YAxisHeightPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeightPx = (hv_Height - hv_LowerBorder) - hv_UpperBorder;
                }
                hv_YAxisHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeight = hv_YAxisEndValue - hv_YAxisStartValue;
                }
                if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue - 0.5;
                            hv_YAxisStartValue.Dispose();
                            hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue + 0.5;
                            hv_YAxisEndValue.Dispose();
                            hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
                        }
                    }
                    hv_YAxisHeight.Dispose();
                    hv_YAxisHeight = 1;
                }
                hv_YScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YScaleFactor = hv_YAxisHeightPx / (hv_YAxisHeight.TupleReal()
                        );
                }
                hv_YAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisOffsetPx = (hv_YAxisPosition - hv_XAxisStartValue) * hv_XScaleFactor;
                }
                hv_XAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisOffsetPx = (hv_XAxisPosition - hv_YAxisStartValue) * hv_YScaleFactor;
                }
                //
                //Display grid lines.
                //
                if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
                {
                    hv_DotStyle.Dispose();
                    hv_DotStyle = new HTuple();
                    hv_DotStyle[0] = 5;
                    hv_DotStyle[1] = 7;
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
                    }
                    //
                    //Display x grid lines.
                    if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates.
                            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates.
                            hv_XGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridStart = (((hv_XAxisStartValue / hv_XGrid)).TupleCeil()
                                    ) * hv_XGrid;
                            }
                            hv_XGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridValues = HTuple.TupleGenSequence(
                                    hv_XGridStart, hv_XAxisEndValue, hv_XGrid);
                            }
                        }
                        hv_XCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XCoord = (hv_XGridValues - hv_XAxisStartValue) * hv_XScaleFactor;
                        }
                        //Generate and display grid lines.
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_XGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourXGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height - hv_LowerBorder)).TupleConcat(
                                    hv_UpperBorder), ((hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
                                    hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid))));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Display y grid lines.
                    if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates.
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates.
                            hv_YGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridStart = (((hv_YAxisStartValue / hv_YGrid)).TupleCeil()
                                    ) * hv_YGrid;
                            }
                            hv_YGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridValues = HTuple.TupleGenSequence(
                                    hv_YGridStart, hv_YAxisEndValue, hv_YGrid);
                            }
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YGridValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        //Generate and display grid lines.
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_YGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourYGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width - hv_RightBorder));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                //
                //
                //Display the coordinate system axes.
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    //Display axes.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_XArrow.Dispose();
                        gen_arrow_contour_xld(out ho_XArrow, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx,
                            hv_LeftBorder, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx, hv_Width - hv_RightBorder,
                            0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_YArrow.Dispose();
                        gen_arrow_contour_xld(out ho_YArrow, hv_Height - hv_LowerBorder, hv_LeftBorder + hv_YAxisOffsetPx,
                            hv_UpperBorder, hv_LeftBorder + hv_YAxisOffsetPx, 0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
                    }
                    //Display labels.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthXLabel.Dispose(); hv_TextHeightXLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthXLabel, out hv_TextHeightXLabel);
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthYLabel.Dispose(); hv_TextHeightYLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthYLabel, out hv_TextHeightYLabel);
                    if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, (hv_LeftBorder + 3) + hv_YAxisOffsetPx, hv_AxesColor,
                                        "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, (hv_LeftBorder + 3) + hv_YAxisOffsetPx,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXLabel)) + 3, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, ((hv_Width - hv_RightBorder) - hv_TextWidthYLabel) - 13,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - (2 * hv_TextWidthYLabel)) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                }
                //
                //Display ticks.
                //
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display x ticks.
                        if ((int)(hv_XValuesAreStrings) != 0)
                        {
                            //Display string XValues as categories.
                            hv_XTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) / (new HTuple(hv_XTickValues.TupleLength()));
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XValues_COPY_INP_TMP - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                        }
                        else
                        {
                            //Display tick values.
                            if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
                            {
                                //Calculate 'min_max_origin' tick coordinates.
                                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                    }
                                }
                                else
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                    }
                                }
                            }
                            else
                            {
                                //Calculate equidistant tick coordinates.
                                hv_XTickStart.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickStart = (((hv_XAxisStartValue / hv_XTicks)).TupleCeil()
                                        ) * hv_XTicks;
                                }
                                hv_XTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickValues = HTuple.TupleGenSequence(
                                        hv_XTickStart, hv_XAxisEndValue, hv_XTicks);
                                }
                            }
                            //Remove ticks that are smaller than the x-axis start.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = ((hv_XTickValues.TupleLessElem(
                                    hv_XAxisStartValue))).TupleFind(1);
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XTickValues - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
                                        hv_Indices);
                                    hv_XCoord.Dispose();
                                    hv_XCoord = ExpTmpLocalVar_XCoord;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
                                        hv_Indices);
                                    hv_XTickValues.Dispose();
                                    hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                }
                            }
                            //
                            if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
                            {
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_XTicks.TupleType()
                                        ;
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                                {
                                    //String ('min_max_origin').
                                    //Format depends on actual values.
                                    hv_TypeTicks.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_TypeTicks = hv_XTickValues.TupleType()
                                            ;
                                    }
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                                {
                                    //Round to integer.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                                                ;
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                                else
                                {
                                    //Use floating point numbers.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                                ".2f");
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                            hv_FormatX);
                                        hv_XTickValues.Dispose();
                                        hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                    }
                                }
                            }
                        }
                        //Generate and display ticks.
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_XTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthXTicks.Dispose(); hv_TextHeightXTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks,
                                    out hv_TextHeightXTicks);
                            }
                            if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx)).TupleConcat(
                                        ((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) - 5), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) + 2) - hv_XAxisOffsetPx,
                                            (hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks))) - (0.5 * hv_TextWidthXTicks),
                                            hv_AxesColor, "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) + 5)).TupleConcat(
                                        (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXTicks)) - hv_XAxisOffsetPx,
                                            (hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks))) - (0.5 * hv_TextWidthXTicks),
                                            hv_AxesColor, "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display y ticks.

                        if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' tick coordinates.
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant tick coordinates.
                            hv_YTickStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickStart = (((hv_YAxisStartValue / hv_YTicks)).TupleCeil()
                                    ) * hv_YTicks;
                            }
                            hv_YTickValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickValues = HTuple.TupleGenSequence(
                                    hv_YTickStart, hv_YAxisEndValue, hv_YTicks);
                            }
                        }

                        //Remove ticks that are smaller than the y-axis start.
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = ((hv_YTickValues.TupleLessElem(
                                hv_YAxisStartValue))).TupleFind(1);
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YTickValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
                                    hv_Indices);
                                hv_YCoord.Dispose();
                                hv_YCoord = ExpTmpLocalVar_YCoord;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
                                    hv_Indices);
                                hv_YTickValues.Dispose();
                                hv_YTickValues = ExpTmpLocalVar_YTickValues;
                            }
                        }
                        //
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YTickValues = (new HTuple(10)).TuplePow(
                                        hv_YTickValues);
                                    hv_YTickValues.Dispose();
                                    hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
                        {
                            hv_TypeTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TypeTicks = hv_YTicks.TupleType()
                                    ;
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                            {
                                //String ('min_max_origin').
                                //Format depends on actual values.
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_YTickValues.TupleType()
                                        ;
                                }
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                            {
                                //Round to integer.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                                            ;
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                            else
                            {
                                //Use floating point numbers.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                            ".2f");
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                        hv_FormatY);
                                    hv_YTickValues.Dispose();
                                    hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                }
                            }
                        }
                        //Generate and display ticks.
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_YTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthYTicks.Dispose(); hv_TextHeightYTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks,
                                    out hv_TextHeightYTicks);
                            }
                            //Since we only deal with numbers, use the Ascent as text height.
                            hv_TextHeightYTicks.Dispose();
                            hv_TextHeightYTicks = new HTuple(hv_Ascent);
                            if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), ((hv_LeftBorder + hv_YAxisOffsetPx)).TupleConcat(
                                        (hv_LeftBorder + hv_YAxisOffsetPx) + 5));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), ((hv_LeftBorder - hv_TextWidthYTicks) - 4) + hv_YAxisOffsetPx,
                                            hv_Color, "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), (((hv_LeftBorder + hv_YAxisOffsetPx) - 5)).TupleConcat(
                                        hv_LeftBorder + hv_YAxisOffsetPx));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), (hv_LeftBorder + 4) + hv_YAxisOffsetPx, hv_Color,
                                            "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                //
                //Display function plot.
                //
                if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
                {
                    if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
                    {
                        hv_Num.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                                )) / (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
                        }
                        //
                        //Iterate over all functions to be displayed.
                        HTuple end_val619 = hv_Num - 1;
                        HTuple step_val619 = 1;
                        for (hv_I = 0; hv_I.Continue(end_val619, step_val619); hv_I = hv_I.TupleAdd(step_val619))
                        {
                            //Select y values for current function.
                            hv_YSelected.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
                                    hv_I * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())), ((hv_I + 1) * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    ))) - 1);
                            }
                            //Set color
                            if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
                            {
                                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                                            hv_I % (new HTuple(hv_Color.TupleLength()))));
                                    }
                                }
                            }
                            //
                            //Display in different styles.
                            //
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(
                                new HTuple(hv_Style.TupleEqual(new HTuple()))))).TupleOr(hv_Style.TupleIsReal()
                                ))).TupleOr(hv_Style.TupleIsInt())) != 0)
                            {
                                //Style = Line. For real value, the line is plotted dashed.
                                if ((int)(((hv_Style.TupleIsReal())).TupleOr(hv_Style.TupleIsInt())) != 0)
                                {
                                    hv_StyleOriginal.Dispose();
                                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_StyleOriginal);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style.TupleConcat(hv_Style / 2.0));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Contour.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Contour.Dispose();
                                        ho_Contour = ExpTmpOutVar_0;
                                    }
                                }
                                hv_OldLineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_OldLineWidth);
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                                            );
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_OldLineWidth.TupleInt()
                                            );
                                    }
                                }
                                if ((int)(((hv_Style.TupleIsReal())).TupleOr(hv_Style.TupleIsInt())) != 0)
                                {
                                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_StyleOriginal);
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
                            {
                                //Style = Cross.
                                hv_LineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Cross.Dispose();
                                    HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                        6, 0.785398);
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Cross.Dispose();
                                        ho_Cross = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("circle"))) != 0)
                            {
                                //Style = Circle.
                                hv_LineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Radii.Dispose();
                                    HOperatorSet.TupleGenConst(new HTuple(hv_YSelected.TupleLength()),
                                        3 * hv_LineWidth, out hv_Radii);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Circle.Dispose();
                                    HOperatorSet.GenCircleContourXld(out ho_Circle, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                        hv_Radii, 0, 6.28318, "positive", 1);
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Circle, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Circle.Dispose();
                                        ho_Circle = ExpTmpOutVar_0;
                                    }
                                }
                                hv_OldContourStyle.Dispose();
                                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_OldContourStyle);
                                HOperatorSet.SetContourStyle(hv_WindowHandle, "stroke_and_fill");
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Circle, HDevWindowStack.GetActive());
                                }
                                HOperatorSet.SetContourStyle(hv_WindowHandle, hv_OldContourStyle);
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
                            {
                                //Style = Filled.
                                hv_Y1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Y1Selected = new HTuple();
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                }
                                hv_X1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_X1Selected = new HTuple();
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                                        );
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                                        );
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Filled.Dispose();
                                    HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height - hv_LowerBorder) - (hv_Y1Selected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_X1Selected * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Filled.Dispose();
                                        ho_Filled = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
                            {
                                ho_Stair.Dispose();
                                HOperatorSet.GenEmptyObj(out ho_Stair);
                                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) - 2); hv_Index = (int)hv_Index + 1)
                                {
                                    hv_Row1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row1 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Row2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row2 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index + 1)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Col1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    hv_Col2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index + 1)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_StairTmp.Dispose();
                                        HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                                            hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                                            hv_Col2));
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0,
                                        0.1, 0.1, "attr_keep");
                                    ho_Stair.Dispose();
                                    ho_Stair = ExpTmpOutVar_0;
                                }
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipRegion(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
                                }
                            }
                            else
                            {
                                throw new HalconException("Unsupported style: " + hv_Style);
                            }
                        }
                    }
                }
                //
                //
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Circle.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_PartDiffers.Dispose();
                hv_PlotYLog.Dispose();
                hv_YLogIndices.Dispose();
                hv_PlotYLogUser.Dispose();
                hv_IsString.Dispose();
                hv_YInd.Dispose();
                hv_Indices1.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_LineWidth.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_StyleOriginal.Dispose();
                hv_OldLineWidth.Dispose();
                hv_Radii.Dispose();
                hv_OldContourStyle.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Circle.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_PartDiffers.Dispose();
                hv_PlotYLog.Dispose();
                hv_YLogIndices.Dispose();
                hv_PlotYLogUser.Dispose();
                hv_IsString.Dispose();
                hv_YInd.Dispose();
                hv_Indices1.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_LineWidth.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_StyleOriginal.Dispose();
                hv_OldLineWidth.Dispose();
                hv_Radii.Dispose();
                hv_OldContourStyle.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Preprocess 3D data for deep-learning-based training and inference. 
        public void preprocess_dl_model_3d_data(HTuple hv_DLSample, HTuple hv_DLPreprocessParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageZ = null, ho_Domain, ho_Region = null;
            HObject ho_ImageReduced = null, ho_DomainComplement, ho_ImageX = null;
            HObject ho_ImageY = null, ho_ImageXYZ = null, ho_NXImage = null;
            HObject ho_NYImage = null, ho_NZImage = null, ho_MultiChannelImage;
            HObject ho___Tmp_Obj_0;

            // Local control variables 

            HTuple hv_HasNormals = new HTuple(), hv_XYZKeys = new HTuple();
            HTuple hv_HasXYZ = new HTuple(), hv_HasX = new HTuple();
            HTuple hv_HasY = new HTuple(), hv_HasZ = new HTuple();
            HTuple hv_HasFullXYZ = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_Type = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Key = new HTuple(), hv_ZMinMaxExist = new HTuple();
            HTuple hv_GrayvalOutsideInit = new HTuple(), hv_NormalSizeExists = new HTuple();
            HTuple hv_NormalWidth = new HTuple(), hv_NormalHeight = new HTuple();
            HTuple hv_WidthZ = new HTuple(), hv_HeightZ = new HTuple();
            HTuple hv_ZoomNormals = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_ScaleWidth = new HTuple();
            HTuple hv_ScaleHeight = new HTuple(), hv_XIndex = new HTuple();
            HTuple hv_YIndex = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageZ);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_DomainComplement);
            HOperatorSet.GenEmptyObj(out ho_ImageX);
            HOperatorSet.GenEmptyObj(out ho_ImageY);
            HOperatorSet.GenEmptyObj(out ho_ImageXYZ);
            HOperatorSet.GenEmptyObj(out ho_NXImage);
            HOperatorSet.GenEmptyObj(out ho_NYImage);
            HOperatorSet.GenEmptyObj(out ho_NZImage);
            HOperatorSet.GenEmptyObj(out ho_MultiChannelImage);
            HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
            try
            {
                //
                //This procedure preprocesses 3D data of a DLSample.
                //
                //Check presence of inputs in DLSample.
                //
                hv_HasNormals.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "normals", out hv_HasNormals);
                hv_XYZKeys.Dispose();
                hv_XYZKeys = new HTuple();
                hv_XYZKeys[0] = "x";
                hv_XYZKeys[1] = "y";
                hv_XYZKeys[2] = "z";
                hv_HasXYZ.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", hv_XYZKeys, out hv_HasXYZ);
                hv_HasX.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasX = hv_HasXYZ.TupleSelect(
                        0);
                }
                hv_HasY.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasY = hv_HasXYZ.TupleSelect(
                        1);
                }
                hv_HasZ.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HasZ = hv_HasXYZ.TupleSelect(
                        2);
                }
                hv_HasFullXYZ.Dispose();
                HOperatorSet.TupleMin(hv_HasXYZ, out hv_HasFullXYZ);
                if ((int)(hv_HasNormals.TupleNot()) != 0)
                {
                    //XYZ are required because normals would need to be computed.
                    if ((int)(hv_HasFullXYZ.TupleNot()) != 0)
                    {
                        throw new HalconException(new HTuple("The given input DLSample does not contain necessary images 'x','y' and 'z'. This is required if no normals are provided."));
                    }
                }
                else
                {
                    //At least Z is required if normals are given.
                    if ((int)(hv_HasZ.TupleNot()) != 0)
                    {
                        throw new HalconException(new HTuple("The given input DLSample does not contain at least the depth image 'z'. This is required because normals are provided. Optionally, 'x' and 'y' images might be provided additionally."));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumChannels.Dispose();
                        HOperatorSet.CountChannels(hv_DLSample.TupleGetDictObject("normals"), out hv_NumChannels);
                    }
                    if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                    {
                        throw new HalconException("The given input DLSample.normals has to have three channels.");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Type.Dispose();
                        HOperatorSet.GetImageType(hv_DLSample.TupleGetDictObject("normals"), out hv_Type);
                    }
                    if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
                    {
                        throw new HalconException("The given input DLSample.normals is not a real image.");
                    }
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_HasXYZ.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(hv_HasXYZ.TupleSelect(hv_Index)) != 0)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_XYZKeys.TupleSelect(
                                hv_Index);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumChannels.Dispose();
                            HOperatorSet.CountChannels(hv_DLSample.TupleGetDictObject(hv_Key), out hv_NumChannels);
                        }
                        if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(1))) != 0)
                        {
                            throw new HalconException(("The given input DLSample." + hv_Key) + " needs to have a single channel.");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Type.Dispose();
                            HOperatorSet.GetImageType(hv_DLSample.TupleGetDictObject(hv_Key), out hv_Type);
                        }
                        if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
                        {
                            throw new HalconException(("The given input DLSample." + hv_Key) + " is not a real image.");
                        }
                    }
                }
                //
                ho_ImageZ.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ImageZ = hv_DLSample.TupleGetDictObject(
                        "z");
                }
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_ImageZ, out ho_Domain);
                //Reduce Z domain to user-defined min/max values for Z.
                hv_ZMinMaxExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("min_z")).TupleConcat(
                    "max_z"), out hv_ZMinMaxExist);
                if ((int)(hv_ZMinMaxExist.TupleSelect(0)) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageZ, out ho_Region, "min", hv_DLPreprocessParam.TupleGetDictTuple(
                            "min_z"));
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Difference(ho_Domain, ho_Region, out ExpTmpOutVar_0);
                        ho_Domain.Dispose();
                        ho_Domain = ExpTmpOutVar_0;
                    }
                }
                if ((int)(hv_ZMinMaxExist.TupleSelect(1)) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageZ, out ho_Region, hv_DLPreprocessParam.TupleGetDictTuple(
                            "max_z"), "max");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Difference(ho_Domain, ho_Region, out ExpTmpOutVar_0);
                        ho_Domain.Dispose();
                        ho_Domain = ExpTmpOutVar_0;
                    }
                }
                //Reduce domain because it might have changed
                if ((int)(hv_ZMinMaxExist.TupleMax()) != 0)
                {
                    ho_ImageReduced.Dispose();
                    HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ho_ImageReduced);
                }
                ho_DomainComplement.Dispose();
                HOperatorSet.Complement(ho_Domain, out ho_DomainComplement);
                //
                //Before we zoom any 3D images we want to set all pixels outside of the domain to
                //an invalid value.
                hv_GrayvalOutsideInit.Dispose();
                hv_GrayvalOutsideInit = 0;

                if ((int)(hv_HasFullXYZ) != 0)
                {
                    ho_ImageX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_ImageX = hv_DLSample.TupleGetDictObject(
                            "x");
                    }
                    ho_ImageY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_ImageY = hv_DLSample.TupleGetDictObject(
                            "y");
                    }
                    ho_ImageZ.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_ImageZ = hv_DLSample.TupleGetDictObject(
                            "z");
                    }

                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_ImageX, out ExpTmpOutVar_0);
                        ho_ImageX.Dispose();
                        ho_ImageX = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_ImageY, out ExpTmpOutVar_0);
                        ho_ImageY.Dispose();
                        ho_ImageY = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_ImageZ, out ExpTmpOutVar_0);
                        ho_ImageZ.Dispose();
                        ho_ImageZ = ExpTmpOutVar_0;
                    }

                    HOperatorSet.OverpaintRegion(ho_ImageX, ho_DomainComplement, hv_GrayvalOutsideInit,
                        "fill");
                    HOperatorSet.OverpaintRegion(ho_ImageY, ho_DomainComplement, hv_GrayvalOutsideInit,
                        "fill");
                    HOperatorSet.OverpaintRegion(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit,
                        "fill");

                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReduceDomain(ho_ImageX, ho_Domain, out ExpTmpOutVar_0);
                        ho_ImageX.Dispose();
                        ho_ImageX = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReduceDomain(ho_ImageY, ho_Domain, out ExpTmpOutVar_0);
                        ho_ImageY.Dispose();
                        ho_ImageY = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ExpTmpOutVar_0);
                        ho_ImageZ.Dispose();
                        ho_ImageZ = ExpTmpOutVar_0;
                    }

                    if ((int)(hv_HasNormals.TupleNot()) != 0)
                    {
                        //Get optional user-defined resolution of normal computation.
                        hv_NormalSizeExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("normal_image_width")).TupleConcat(
                            "normal_image_height"), out hv_NormalSizeExists);
                        if ((int)(((hv_NormalSizeExists.TupleSelect(0))).TupleNot()) != 0)
                        {
                            hv_NormalWidth.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NormalWidth = (((hv_DLPreprocessParam.TupleGetDictTuple(
                                    "image_width")) * 1.5)).TupleInt();
                            }
                        }
                        else
                        {
                            hv_NormalWidth.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NormalWidth = hv_DLPreprocessParam.TupleGetDictTuple(
                                    "normal_image_width");
                            }
                        }
                        if ((int)(((hv_NormalSizeExists.TupleSelect(1))).TupleNot()) != 0)
                        {
                            hv_NormalHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NormalHeight = (((hv_DLPreprocessParam.TupleGetDictTuple(
                                    "image_height")) * 1.5)).TupleInt();
                            }
                        }
                        else
                        {
                            hv_NormalHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NormalHeight = hv_DLPreprocessParam.TupleGetDictTuple(
                                    "normal_image_height");
                            }
                        }

                        hv_WidthZ.Dispose(); hv_HeightZ.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageZ, out hv_WidthZ, out hv_HeightZ);
                        hv_ZoomNormals.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ZoomNormals = (new HTuple(hv_NormalWidth.TupleNotEqual(
                                hv_WidthZ))).TupleOr(new HTuple(hv_NormalHeight.TupleNotEqual(hv_HeightZ)));
                        }

                        if ((int)(hv_ZoomNormals) != 0)
                        {
                            ho_ImageXYZ.Dispose();
                            HOperatorSet.Compose3(ho_ImageX, ho_ImageY, ho_ImageZ, out ho_ImageXYZ
                                );
                            hv_Width.Dispose(); hv_Height.Dispose();
                            HOperatorSet.GetImageSize(ho_ImageXYZ, out hv_Width, out hv_Height);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ZoomImageSize(ho_ImageXYZ, out ExpTmpOutVar_0, hv_NormalWidth,
                                    hv_NormalHeight, "nearest_neighbor");
                                ho_ImageXYZ.Dispose();
                                ho_ImageXYZ = ExpTmpOutVar_0;
                            }
                            ho_ImageX.Dispose();
                            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageX, 1);
                            ho_ImageY.Dispose();
                            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageY, 2);
                            ho_ImageZ.Dispose();
                            HOperatorSet.AccessChannel(ho_ImageXYZ, out ho_ImageZ, 3);
                            hv_ScaleWidth.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ScaleWidth = hv_NormalWidth / (hv_Width.TupleReal()
                                    );
                            }
                            hv_ScaleHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ScaleHeight = hv_NormalHeight / (hv_Height.TupleReal()
                                    );
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ZoomRegion(ho_Domain, out ExpTmpOutVar_0, hv_ScaleWidth,
                                    hv_ScaleHeight);
                                ho_Domain.Dispose();
                                ho_Domain = ExpTmpOutVar_0;
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                remove_invalid_3d_pixels(ho_ImageX, ho_ImageY, ho_ImageZ, ho_Domain,
                                    out ExpTmpOutVar_0, hv_GrayvalOutsideInit);
                                ho_Domain.Dispose();
                                ho_Domain = ExpTmpOutVar_0;
                            }
                            ho_DomainComplement.Dispose();
                            HOperatorSet.Complement(ho_Domain, out ho_DomainComplement);
                        }

                        ho_NXImage.Dispose(); ho_NYImage.Dispose(); ho_NZImage.Dispose();
                        compute_normals_xyz(ho_ImageX, ho_ImageY, ho_ImageZ, out ho_NXImage, out ho_NYImage,
                            out ho_NZImage, 1);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_NXImage.Dispose();
                            HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NXImage,
                                1);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_NYImage.Dispose();
                            HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NYImage,
                                2);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_NZImage.Dispose();
                            HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NZImage,
                                3);
                        }
                    }
                }
                else
                {
                    ho_ImageX.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImageX);
                    ho_ImageY.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImageY);

                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_NXImage.Dispose();
                        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NXImage,
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_NYImage.Dispose();
                        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NYImage,
                            2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_NZImage.Dispose();
                        HOperatorSet.AccessChannel(hv_DLSample.TupleGetDictObject("normals"), out ho_NZImage,
                            3);
                    }
                }

                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.FullDomain(ho_ImageZ, out ExpTmpOutVar_0);
                    ho_ImageZ.Dispose();
                    ho_ImageZ = ExpTmpOutVar_0;
                }

                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.FullDomain(ho_NXImage, out ExpTmpOutVar_0);
                    ho_NXImage.Dispose();
                    ho_NXImage = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.FullDomain(ho_NYImage, out ExpTmpOutVar_0);
                    ho_NYImage.Dispose();
                    ho_NYImage = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.FullDomain(ho_NZImage, out ExpTmpOutVar_0);
                    ho_NZImage.Dispose();
                    ho_NZImage = ExpTmpOutVar_0;
                }

                //full_domain does not change the pixels outside of the existing domain.
                //Hence we have to set a specific value
                HOperatorSet.OverpaintRegion(ho_NXImage, ho_DomainComplement, hv_GrayvalOutsideInit,
                    "fill");
                HOperatorSet.OverpaintRegion(ho_NYImage, ho_DomainComplement, hv_GrayvalOutsideInit,
                    "fill");
                HOperatorSet.OverpaintRegion(ho_NZImage, ho_DomainComplement, hv_GrayvalOutsideInit,
                    "fill");
                HOperatorSet.OverpaintRegion(ho_ImageZ, ho_DomainComplement, hv_GrayvalOutsideInit,
                    "fill");

                ho_MultiChannelImage.Dispose();
                HOperatorSet.Compose4(ho_NXImage, ho_NYImage, ho_NZImage, ho_ImageZ, out ho_MultiChannelImage
                    );

                hv_HasX.Dispose();
                HOperatorSet.CountObj(ho_ImageX, out hv_HasX);
                if ((int)(hv_HasX) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_ImageX, out ExpTmpOutVar_0);
                        ho_ImageX.Dispose();
                        ho_ImageX = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AppendChannel(ho_MultiChannelImage, ho_ImageX, out ExpTmpOutVar_0
                            );
                        ho_MultiChannelImage.Dispose();
                        ho_MultiChannelImage = ExpTmpOutVar_0;
                    }
                    hv_XIndex.Dispose();
                    HOperatorSet.CountChannels(ho_MultiChannelImage, out hv_XIndex);
                }
                hv_HasY.Dispose();
                HOperatorSet.CountObj(ho_ImageY, out hv_HasY);
                if ((int)(hv_HasY) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_ImageY, out ExpTmpOutVar_0);
                        ho_ImageY.Dispose();
                        ho_ImageY = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AppendChannel(ho_MultiChannelImage, ho_ImageY, out ExpTmpOutVar_0
                            );
                        ho_MultiChannelImage.Dispose();
                        ho_MultiChannelImage = ExpTmpOutVar_0;
                    }
                    hv_YIndex.Dispose();
                    HOperatorSet.CountChannels(ho_MultiChannelImage, out hv_YIndex);
                }
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_MultiChannelImage, out hv_Width, out hv_Height);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ZoomImageSize(ho_MultiChannelImage, out ExpTmpOutVar_0, hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_width"), hv_DLPreprocessParam.TupleGetDictTuple("image_height"),
                        "nearest_neighbor");
                    ho_MultiChannelImage.Dispose();
                    ho_MultiChannelImage = ExpTmpOutVar_0;
                }

                ho_NXImage.Dispose(); ho_NYImage.Dispose(); ho_NZImage.Dispose(); ho_ImageZ.Dispose();
                HOperatorSet.Decompose4(ho_MultiChannelImage, out ho_NXImage, out ho_NYImage,
                    out ho_NZImage, out ho_ImageZ);
                if ((int)(hv_HasX) != 0)
                {
                    ho_ImageX.Dispose();
                    HOperatorSet.AccessChannel(ho_MultiChannelImage, out ho_ImageX, hv_XIndex);
                }
                if ((int)(hv_HasY) != 0)
                {
                    ho_ImageY.Dispose();
                    HOperatorSet.AccessChannel(ho_MultiChannelImage, out ho_ImageY, hv_YIndex);
                }


                //Zoom the domain
                hv_ScaleWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScaleWidth = (hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_width")) / (hv_Width.TupleReal());
                }
                hv_ScaleHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ScaleHeight = (hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_height")) / (hv_Height.TupleReal());
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ZoomRegion(ho_Domain, out ExpTmpOutVar_0, hv_ScaleWidth, hv_ScaleHeight);
                    ho_Domain.Dispose();
                    ho_Domain = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    remove_invalid_3d_pixels(ho_NXImage, ho_NYImage, ho_NZImage, ho_Domain, out ExpTmpOutVar_0,
                        hv_GrayvalOutsideInit);
                    ho_Domain.Dispose();
                    ho_Domain = ExpTmpOutVar_0;
                }

                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageX, ho_Domain, out ExpTmpOutVar_0);
                    ho_ImageX.Dispose();
                    ho_ImageX = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageY, ho_Domain, out ExpTmpOutVar_0);
                    ho_ImageY.Dispose();
                    ho_ImageY = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageZ, ho_Domain, out ExpTmpOutVar_0);
                    ho_ImageZ.Dispose();
                    ho_ImageZ = ExpTmpOutVar_0;
                }
                ho___Tmp_Obj_0.Dispose();
                HOperatorSet.Compose3(ho_NXImage, ho_NYImage, ho_NZImage, out ho___Tmp_Obj_0
                    );
                HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, "normals");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho___Tmp_Obj_0.Dispose();
                    HOperatorSet.ReduceDomain(hv_DLSample.TupleGetDictObject("normals"), ho_Domain,
                        out ho___Tmp_Obj_0);
                }
                HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, "normals");

                //Overwrite preprocessed 3D data
                if ((int)(hv_HasX) != 0)
                {
                    HOperatorSet.SetDictObject(ho_ImageX, hv_DLSample, "x");
                }
                if ((int)(hv_HasY) != 0)
                {
                    HOperatorSet.SetDictObject(ho_ImageY, hv_DLSample, "y");
                }
                if ((int)(hv_HasZ) != 0)
                {
                    HOperatorSet.SetDictObject(ho_ImageZ, hv_DLSample, "z");
                }

                ho_ImageZ.Dispose();
                ho_Domain.Dispose();
                ho_Region.Dispose();
                ho_ImageReduced.Dispose();
                ho_DomainComplement.Dispose();
                ho_ImageX.Dispose();
                ho_ImageY.Dispose();
                ho_ImageXYZ.Dispose();
                ho_NXImage.Dispose();
                ho_NYImage.Dispose();
                ho_NZImage.Dispose();
                ho_MultiChannelImage.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_HasNormals.Dispose();
                hv_XYZKeys.Dispose();
                hv_HasXYZ.Dispose();
                hv_HasX.Dispose();
                hv_HasY.Dispose();
                hv_HasZ.Dispose();
                hv_HasFullXYZ.Dispose();
                hv_NumChannels.Dispose();
                hv_Type.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_ZMinMaxExist.Dispose();
                hv_GrayvalOutsideInit.Dispose();
                hv_NormalSizeExists.Dispose();
                hv_NormalWidth.Dispose();
                hv_NormalHeight.Dispose();
                hv_WidthZ.Dispose();
                hv_HeightZ.Dispose();
                hv_ZoomNormals.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ScaleWidth.Dispose();
                hv_ScaleHeight.Dispose();
                hv_XIndex.Dispose();
                hv_YIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageZ.Dispose();
                ho_Domain.Dispose();
                ho_Region.Dispose();
                ho_ImageReduced.Dispose();
                ho_DomainComplement.Dispose();
                ho_ImageX.Dispose();
                ho_ImageY.Dispose();
                ho_ImageXYZ.Dispose();
                ho_NXImage.Dispose();
                ho_NYImage.Dispose();
                ho_NZImage.Dispose();
                ho_MultiChannelImage.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_HasNormals.Dispose();
                hv_XYZKeys.Dispose();
                hv_HasXYZ.Dispose();
                hv_HasX.Dispose();
                hv_HasY.Dispose();
                hv_HasZ.Dispose();
                hv_HasFullXYZ.Dispose();
                hv_NumChannels.Dispose();
                hv_Type.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_ZMinMaxExist.Dispose();
                hv_GrayvalOutsideInit.Dispose();
                hv_NormalSizeExists.Dispose();
                hv_NormalWidth.Dispose();
                hv_NormalHeight.Dispose();
                hv_WidthZ.Dispose();
                hv_HeightZ.Dispose();
                hv_ZoomNormals.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ScaleWidth.Dispose();
                hv_ScaleHeight.Dispose();
                hv_XIndex.Dispose();
                hv_YIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Preprocess anomaly images for evaluation and visualization of deep-learning-based anomaly detection or Global Context Anomaly Detection. 
        public void preprocess_dl_model_anomaly(HObject ho_AnomalyImages, out HObject ho_AnomalyImagesPreprocessed,
            HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            // Local copy input parameter variables 
            HObject ho_AnomalyImages_COPY_INP_TMP;
            ho_AnomalyImages_COPY_INP_TMP = new HObject(ho_AnomalyImages);



            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_DomainHandling = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_ImageNumChannels = new HTuple(), hv_Min = new HTuple();
            HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_ImageWidthInput = new HTuple(), hv_ImageHeightInput = new HTuple();
            HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
            HTuple hv_Type = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_EqualByte = new HTuple();
            HTuple hv_NumChannelsAllImages = new HTuple(), hv_ImageNumChannelsTuple = new HTuple();
            HTuple hv_IndicesWrongChannels = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImagesPreprocessed);
            try
            {
                //
                //This procedure preprocesses the anomaly images given by AnomalyImages
                //according to the parameters in the dictionary DLPreprocessParam.
                //Note that depending on the images,
                //additional preprocessing steps might be beneficial.
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the preprocessing parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                hv_ModelType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
                //
                hv_ImageNumChannels.Dispose();
                hv_ImageNumChannels = 1;
                //
                //Preprocess the images.
                //
                if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
                            );
                        ho_AnomalyImages_COPY_INP_TMP.Dispose();
                        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.CropDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
                            );
                        ho_AnomalyImages_COPY_INP_TMP.Dispose();
                        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleEqual("anomaly_detection")))) != 0)
                {
                    //The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection'
                }
                else
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'");
                }
                //
                hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                HOperatorSet.MinMaxGray(ho_AnomalyImages_COPY_INP_TMP, ho_AnomalyImages_COPY_INP_TMP,
                    0, out hv_Min, out hv_Max, out hv_Range);
                if ((int)(new HTuple(hv_Min.TupleLess(0.0))) != 0)
                {
                    throw new HalconException("Values of anomaly image must not be smaller than 0.0.");
                }
                //
                //Zoom images only if they have a different size than the specified size.
                hv_ImageWidthInput.Dispose(); hv_ImageHeightInput.Dispose();
                HOperatorSet.GetImageSize(ho_AnomalyImages_COPY_INP_TMP, out hv_ImageWidthInput,
                    out hv_ImageHeightInput);
                hv_EqualWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
                        hv_ImageWidthInput);
                }
                hv_EqualHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
                        hv_ImageHeightInput);
                }
                if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
                    new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0,
                            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
                        ho_AnomalyImages_COPY_INP_TMP.Dispose();
                        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Check the type of the input images.
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_AnomalyImages_COPY_INP_TMP, out hv_Type);
                hv_NumMatches.Dispose();
                HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
                if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
                {
                    throw new HalconException("Please provide only images of type 'byte' or 'real'.");
                }
                //
                //If the type is 'byte', convert it to 'real' and scale it.
                //The gray value scaling does not work on 'byte' images.
                //For 'real' images it is assumed that the range is already correct.
                hv_EqualByte.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualByte = hv_Type.TupleEqualElem(
                        "byte");
                }
                if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
                    {
                        throw new HalconException("Passing mixed type images is not supported.");
                    }
                    //Convert the image type from 'byte' to 'real',
                    //because the model expects 'real' images.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "real");
                        ho_AnomalyImages_COPY_INP_TMP.Dispose();
                        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Check the number of channels.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
                //Check all images for number of channels.
                hv_NumChannelsAllImages.Dispose();
                HOperatorSet.CountChannels(ho_AnomalyImages_COPY_INP_TMP, out hv_NumChannelsAllImages);
                hv_ImageNumChannelsTuple.Dispose();
                HOperatorSet.TupleGenConst(hv_NumImages, hv_ImageNumChannels, out hv_ImageNumChannelsTuple);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IndicesWrongChannels.Dispose();
                    HOperatorSet.TupleFind(hv_NumChannelsAllImages.TupleNotEqualElem(hv_ImageNumChannelsTuple),
                        1, out hv_IndicesWrongChannels);
                }
                //
                //Check for anomaly image channels.
                //Only single channel images are accepted.
                if ((int)(new HTuple(hv_IndicesWrongChannels.TupleNotEqual(-1))) != 0)
                {
                    throw new HalconException("Number of channels in anomaly image is not supported. Please check for anomaly images with a number of channels different from 1.");
                }
                //
                //Write preprocessed image to output variable.
                ho_AnomalyImagesPreprocessed.Dispose();
                ho_AnomalyImagesPreprocessed = new HObject(ho_AnomalyImages_COPY_INP_TMP);
                //
                ho_AnomalyImages_COPY_INP_TMP.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_ModelType.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_ImageWidthInput.Dispose();
                hv_ImageHeightInput.Dispose();
                hv_EqualWidth.Dispose();
                hv_EqualHeight.Dispose();
                hv_Type.Dispose();
                hv_NumMatches.Dispose();
                hv_NumImages.Dispose();
                hv_EqualByte.Dispose();
                hv_NumChannelsAllImages.Dispose();
                hv_ImageNumChannelsTuple.Dispose();
                hv_IndicesWrongChannels.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImages_COPY_INP_TMP.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_ModelType.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_ImageWidthInput.Dispose();
                hv_ImageHeightInput.Dispose();
                hv_EqualWidth.Dispose();
                hv_EqualHeight.Dispose();
                hv_Type.Dispose();
                hv_NumMatches.Dispose();
                hv_NumImages.Dispose();
                hv_EqualByte.Dispose();
                hv_NumChannelsAllImages.Dispose();
                hv_ImageNumChannelsTuple.Dispose();
                hv_IndicesWrongChannels.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Preprocess the provided DLSample image for augmentation purposes. 
        public void preprocess_dl_model_augmentation_data(HTuple hv_DLSample, HTuple hv_DLPreprocessParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_InputImage = null, ho_ImageHighRes = null;

            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_ImageNumChannels = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_AugmentationKeyExists = new HTuple(), hv_ImageKeyExists = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ImageType = new HTuple(), hv_InputImageWidth = new HTuple();
            HTuple hv_InputImageHeight = new HTuple(), hv_InputImageWidthHeightRatio = new HTuple();
            HTuple hv_ZoomHeight = new HTuple(), hv_ZoomWidth = new HTuple();
            HTuple hv_HasPadding = new HTuple(), hv_ZoomFactorWidth = new HTuple();
            HTuple hv_ZoomFactorHeight = new HTuple(), hv_UseZoomImage = new HTuple();
            HTuple hv_DLSampleHighRes = new HTuple(), hv_DLPreprocessParamHighRes = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_InputImage);
            HOperatorSet.GenEmptyObj(out ho_ImageHighRes);
            try
            {
                //This procedure preprocesses the provided DLSample image for augmentation purposes.
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the required preprocessing parameters.
                hv_ImageWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageWidth = hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_width");
                }
                hv_ImageHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageHeight = hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_height");
                }
                hv_ImageNumChannels.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageNumChannels = hv_DLPreprocessParam.TupleGetDictTuple(
                        "image_num_channels");
                }
                hv_ModelType.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ModelType = hv_DLPreprocessParam.TupleGetDictTuple(
                        "model_type");
                }
                //
                //Determine whether the preprocessing is required or not.
                hv_AugmentationKeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "augmentation",
                    out hv_AugmentationKeyExists);
                if ((int)(hv_AugmentationKeyExists.TupleNot()) != 0)
                {
                    ho_InputImage.Dispose();
                    ho_ImageHighRes.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_ImageNumChannels.Dispose();
                    hv_ModelType.Dispose();
                    hv_AugmentationKeyExists.Dispose();
                    hv_ImageKeyExists.Dispose();
                    hv_NumImages.Dispose();
                    hv_NumChannels.Dispose();
                    hv_ImageType.Dispose();
                    hv_InputImageWidth.Dispose();
                    hv_InputImageHeight.Dispose();
                    hv_InputImageWidthHeightRatio.Dispose();
                    hv_ZoomHeight.Dispose();
                    hv_ZoomWidth.Dispose();
                    hv_HasPadding.Dispose();
                    hv_ZoomFactorWidth.Dispose();
                    hv_ZoomFactorHeight.Dispose();
                    hv_UseZoomImage.Dispose();
                    hv_DLSampleHighRes.Dispose();
                    hv_DLPreprocessParamHighRes.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_2.Dispose();

                    return;
                }
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "true");
                if ((int)(((((hv_DLPreprocessParam.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                    "augmentation", "comp"))).TupleNot()) != 0)
                {
                    ho_InputImage.Dispose();
                    ho_ImageHighRes.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_ImageNumChannels.Dispose();
                    hv_ModelType.Dispose();
                    hv_AugmentationKeyExists.Dispose();
                    hv_ImageKeyExists.Dispose();
                    hv_NumImages.Dispose();
                    hv_NumChannels.Dispose();
                    hv_ImageType.Dispose();
                    hv_InputImageWidth.Dispose();
                    hv_InputImageHeight.Dispose();
                    hv_InputImageWidthHeightRatio.Dispose();
                    hv_ZoomHeight.Dispose();
                    hv_ZoomWidth.Dispose();
                    hv_HasPadding.Dispose();
                    hv_ZoomFactorWidth.Dispose();
                    hv_ZoomFactorHeight.Dispose();
                    hv_UseZoomImage.Dispose();
                    hv_DLSampleHighRes.Dispose();
                    hv_DLPreprocessParamHighRes.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_2.Dispose();

                    return;
                }
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                        "HNULL");
                }
                if ((int)((new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition")))) != 0)
                {
                    ho_InputImage.Dispose();
                    ho_ImageHighRes.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_ImageNumChannels.Dispose();
                    hv_ModelType.Dispose();
                    hv_AugmentationKeyExists.Dispose();
                    hv_ImageKeyExists.Dispose();
                    hv_NumImages.Dispose();
                    hv_NumChannels.Dispose();
                    hv_ImageType.Dispose();
                    hv_InputImageWidth.Dispose();
                    hv_InputImageHeight.Dispose();
                    hv_InputImageWidthHeightRatio.Dispose();
                    hv_ZoomHeight.Dispose();
                    hv_ZoomWidth.Dispose();
                    hv_HasPadding.Dispose();
                    hv_ZoomFactorWidth.Dispose();
                    hv_ZoomFactorHeight.Dispose();
                    hv_UseZoomImage.Dispose();
                    hv_DLSampleHighRes.Dispose();
                    hv_DLPreprocessParamHighRes.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                    hv___Tmp_Ctrl_Dict_Init_2.Dispose();

                    return;
                }
                //
                //Get the input image and its properties.
                hv_ImageKeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image", out hv_ImageKeyExists);
                if ((int)(hv_ImageKeyExists.TupleNot()) != 0)
                {
                    throw new HalconException("The sample to process needs to include an image.");
                }
                ho_InputImage.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_InputImage = hv_DLSample.TupleGetDictObject(
                        "image");
                }
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_InputImage, out hv_NumImages);
                if ((int)(new HTuple(hv_NumImages.TupleNotEqual(1))) != 0)
                {
                    throw new HalconException("The sample to process needs to include exactly 1 image.");
                }
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_InputImage, out hv_NumChannels);
                hv_ImageType.Dispose();
                HOperatorSet.GetImageType(ho_InputImage, out hv_ImageType);
                hv_InputImageWidth.Dispose(); hv_InputImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_InputImage, out hv_InputImageWidth, out hv_InputImageHeight);
                //
                //Execute model specific preprocessing.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(1))) != 0)
                    {
                        throw new HalconException("The only 'image_num_channels' value supported for ocr_recognition models is 1.");
                    }
                    if ((int)(new HTuple((new HTuple(hv_ImageType.TupleRegexpTest("byte|real"))).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Please provide only images of type 'byte' or 'real' for ocr_recognition models.");
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(((hv_NumChannels.TupleEqualElem(
                        1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Please provide only 1- or 3-channels images for ocr_recognition models.");
                    }
                    //
                    ho_ImageHighRes.Dispose();
                    HOperatorSet.FullDomain(ho_InputImage, out ho_ImageHighRes);
                    if ((int)(new HTuple(hv_NumChannels.TupleEqual(3))) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Rgb1ToGray(ho_ImageHighRes, out ExpTmpOutVar_0);
                            ho_ImageHighRes.Dispose();
                            ho_ImageHighRes = ExpTmpOutVar_0;
                        }
                    }
                    hv_InputImageWidthHeightRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageWidthHeightRatio = hv_InputImageWidth / (hv_InputImageHeight.TupleReal()
                            );
                    }
                    hv_ZoomHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomHeight = hv_InputImageHeight.TupleMin2(
                            2 * hv_ImageHeight);
                    }
                    hv_ZoomWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomWidth = ((hv_ZoomHeight * hv_InputImageWidthHeightRatio)).TupleInt()
                            ;
                    }
                    hv_HasPadding.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HasPadding = new HTuple(((((hv_ImageHeight * hv_InputImageWidthHeightRatio)).TupleInt()
                            )).TupleLess(hv_ImageWidth));
                    }
                    if ((int)((new HTuple(hv_ZoomHeight.TupleGreater(hv_ImageHeight))).TupleOr(
                        hv_HasPadding)) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomImageSize(ho_ImageHighRes, out ExpTmpOutVar_0, hv_ZoomWidth,
                                hv_ZoomHeight, "constant");
                            ho_ImageHighRes.Dispose();
                            ho_ImageHighRes = ExpTmpOutVar_0;
                        }
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                        HOperatorSet.SetDictTuple(hv_DLSample, "augmentation_data", hv___Tmp_Ctrl_Dict_Init_1);
                        hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                                "HNULL");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictObject(ho_ImageHighRes, hv_DLSample.TupleGetDictTuple(
                                "augmentation_data"), "image_high_res");
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"),
                                "preprocess_params", hv_DLPreprocessParam);
                        }
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(3))) != 0)
                    {
                        throw new HalconException("The only 'image_num_channels' value supported for ocr_detection models is 3.");
                    }
                    if ((int)(new HTuple((new HTuple(hv_ImageType.TupleRegexpTest("byte|real"))).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Please provide only images of type 'byte' or 'real' for ocr_detection models.");
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(((hv_NumChannels.TupleEqualElem(
                        1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Please provide only 1- or 3-channels images for ocr_detection models.");
                    }
                    //
                    //Calculate aspect-ratio preserving zoom dimensions for high resolution.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomFactorWidth.Dispose(); hv_ZoomFactorHeight.Dispose();
                        calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight,
                            2 * hv_ImageWidth, 2 * hv_ImageHeight, hv_DLPreprocessParam, out hv_ZoomFactorWidth,
                            out hv_ZoomFactorHeight);
                    }
                    hv_ZoomHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomHeight = ((hv_ZoomFactorHeight * hv_InputImageHeight)).TupleRound()
                            ;
                    }
                    hv_ZoomWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomWidth = ((hv_ZoomFactorWidth * hv_InputImageWidth)).TupleRound()
                            ;
                    }
                    //
                    //Use the better size for high resolution: 2x resolution size of preprocess image or input image size.
                    hv_UseZoomImage.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UseZoomImage = (new HTuple(hv_ZoomWidth.TupleLess(
                            hv_InputImageWidth))).TupleOr(new HTuple(hv_ZoomHeight.TupleLess(hv_InputImageHeight)));
                    }
                    hv_DLSampleHighRes.Dispose();
                    HOperatorSet.CopyDict(hv_DLSample, new HTuple(), new HTuple(), out hv_DLSampleHighRes);
                    hv_DLPreprocessParamHighRes.Dispose();
                    HOperatorSet.CopyDict(hv_DLPreprocessParam, new HTuple(), new HTuple(), out hv_DLPreprocessParamHighRes);
                    //
                    ho_ImageHighRes.Dispose();
                    HOperatorSet.FullDomain(ho_InputImage, out ho_ImageHighRes);
                    if ((int)(hv_UseZoomImage) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_width", hv_ZoomWidth);
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_height",
                            hv_ZoomHeight);
                        preprocess_dl_model_bbox_rect2(ho_ImageHighRes, hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
                        gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomImageSize(ho_ImageHighRes, out ExpTmpOutVar_0, hv_ZoomWidth,
                                hv_ZoomHeight, "constant");
                            ho_ImageHighRes.Dispose();
                            ho_ImageHighRes = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_width", hv_InputImageWidth);
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParamHighRes, "image_height",
                            hv_InputImageHeight);
                        gen_dl_ocr_detection_targets(hv_DLSampleHighRes, hv_DLPreprocessParamHighRes);
                    }
                    HOperatorSet.SetDictObject(ho_ImageHighRes, hv_DLSampleHighRes, "image");
                    //
                    hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_2);
                    HOperatorSet.SetDictTuple(hv_DLSample, "augmentation_data", hv___Tmp_Ctrl_Dict_Init_2);
                    hv___Tmp_Ctrl_Dict_Init_2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_2 = HTuple.TupleConstant(
                            "HNULL");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"),
                            "sample_high_res", hv_DLSampleHighRes);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_DLSample.TupleGetDictTuple("augmentation_data"),
                            "preprocess_params", hv_DLPreprocessParam);
                    }
                }
                //
                ho_InputImage.Dispose();
                ho_ImageHighRes.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ModelType.Dispose();
                hv_AugmentationKeyExists.Dispose();
                hv_ImageKeyExists.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageType.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_InputImageWidthHeightRatio.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_HasPadding.Dispose();
                hv_ZoomFactorWidth.Dispose();
                hv_ZoomFactorHeight.Dispose();
                hv_UseZoomImage.Dispose();
                hv_DLSampleHighRes.Dispose();
                hv_DLPreprocessParamHighRes.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_InputImage.Dispose();
                ho_ImageHighRes.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ModelType.Dispose();
                hv_AugmentationKeyExists.Dispose();
                hv_ImageKeyExists.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageType.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_InputImageWidthHeightRatio.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_HasPadding.Dispose();
                hv_ZoomFactorWidth.Dispose();
                hv_ZoomFactorHeight.Dispose();
                hv_UseZoomImage.Dispose();
                hv_DLSampleHighRes.Dispose();
                hv_DLPreprocessParamHighRes.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                hv___Tmp_Ctrl_Dict_Init_2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Preprocess the bounding boxes of type 'rectangle1' for a given sample. 
        private void preprocess_dl_model_bbox_rect1(HObject ho_ImageRaw, HTuple hv_DLSample,
            HTuple hv_DLPreprocessParam)
        {




            // Local iconic variables 

            HObject ho_DomainRaw = null;

            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_DomainHandling = new HTuple(), hv_BBoxCol1 = new HTuple();
            HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow1 = new HTuple();
            HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxLabel = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
            HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
            HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
            HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
            HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
            HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
            HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
            HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
            HTuple hv_BBoxLabelNew = new HTuple(), hv_FactorResampleWidth = new HTuple();
            HTuple hv_FactorResampleHeight = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DomainRaw);
            try
            {
                //
                //This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the preprocessing parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                //
                //Get bounding box coordinates and labels.
                try
                {
                    hv_BBoxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
                    hv_BBoxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
                    hv_BBoxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
                    hv_BBoxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
                    hv_BBoxLabel.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_ImageId.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
                    {
                        hv_ExceptionMessage.Dispose();
                        hv_ExceptionMessage = "A bounding box coordinate key is missing.";
                    }
                    else
                    {
                        hv_ExceptionMessage.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ExceptionMessage = hv_Exception.TupleSelect(
                                2);
                        }
                    }
                    throw new HalconException((("An error has occurred during preprocessing image_id " + hv_ImageId) + " when getting bounding box coordinates : ") + hv_ExceptionMessage);
                }
                //
                //Check that there are no invalid boxes.
                if ((int)(new HTuple((new HTuple(hv_BBoxRow1.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_BoxesInvalid.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BoxesInvalid = ((hv_BBoxRow1.TupleGreaterEqualElem(
                            hv_BBoxRow2))).TupleOr(hv_BBoxCol1.TupleGreaterEqualElem(hv_BBoxCol2));
                    }
                    if ((int)(new HTuple(((hv_BoxesInvalid.TupleSum())).TupleGreater(0))) != 0)
                    {
                        hv_ImageId.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
                        throw new HalconException(("An error has occurred during preprocessing image_id " + hv_ImageId) + new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_col1 >= bbox_col2 or bbox_row1 >= bbox_row2."));
                    }
                }
                else
                {
                    //There are no bounding boxes, hence nothing to do.
                    ho_DomainRaw.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_DomainHandling.Dispose();
                    hv_BBoxCol1.Dispose();
                    hv_BBoxCol2.Dispose();
                    hv_BBoxRow1.Dispose();
                    hv_BBoxRow2.Dispose();
                    hv_BBoxLabel.Dispose();
                    hv_Exception.Dispose();
                    hv_ImageId.Dispose();
                    hv_ExceptionMessage.Dispose();
                    hv_BoxesInvalid.Dispose();
                    hv_DomainRow1.Dispose();
                    hv_DomainColumn1.Dispose();
                    hv_DomainRow2.Dispose();
                    hv_DomainColumn2.Dispose();
                    hv_WidthRaw.Dispose();
                    hv_HeightRaw.Dispose();
                    hv_Row1.Dispose();
                    hv_Col1.Dispose();
                    hv_Row2.Dispose();
                    hv_Col2.Dispose();
                    hv_MaskDelete.Dispose();
                    hv_MaskNewBbox.Dispose();
                    hv_BBoxCol1New.Dispose();
                    hv_BBoxCol2New.Dispose();
                    hv_BBoxRow1New.Dispose();
                    hv_BBoxRow2New.Dispose();
                    hv_BBoxLabelNew.Dispose();
                    hv_FactorResampleWidth.Dispose();
                    hv_FactorResampleHeight.Dispose();

                    return;
                }
                //
                //If the domain is cropped, crop bounding boxes.
                if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    //
                    //Get domain.
                    ho_DomainRaw.Dispose();
                    HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
                    //
                    //Set the size of the raw image to the domain extensions.
                    hv_DomainRow1.Dispose(); hv_DomainColumn1.Dispose(); hv_DomainRow2.Dispose(); hv_DomainColumn2.Dispose();
                    HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_DomainRow1, out hv_DomainColumn1,
                        out hv_DomainRow2, out hv_DomainColumn2);
                    //The domain is always given as a pixel-precise region.
                    hv_WidthRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WidthRaw = (hv_DomainColumn2 - hv_DomainColumn1) + 1.0;
                    }
                    hv_HeightRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HeightRaw = (hv_DomainRow2 - hv_DomainRow1) + 1.0;
                    }
                    //
                    //Crop the bounding boxes.
                    hv_Row1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row1 = hv_BBoxRow1.TupleMax2(
                            hv_DomainRow1 - .5);
                    }
                    hv_Col1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Col1 = hv_BBoxCol1.TupleMax2(
                            hv_DomainColumn1 - .5);
                    }
                    hv_Row2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row2 = hv_BBoxRow2.TupleMin2(
                            hv_DomainRow2 + .5);
                    }
                    hv_Col2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Col2 = hv_BBoxCol2.TupleMin2(
                            hv_DomainColumn2 + .5);
                    }
                    hv_MaskDelete.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaskDelete = ((hv_Row1.TupleGreaterEqualElem(
                            hv_Row2))).TupleOr(hv_Col1.TupleGreaterEqualElem(hv_Col2));
                    }
                    hv_MaskNewBbox.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaskNewBbox = 1 - hv_MaskDelete;
                    }
                    //Store the preprocessed bounding box entries.
                    hv_BBoxCol1New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxCol1New = (hv_Col1.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainColumn1;
                    }
                    hv_BBoxCol2New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxCol2New = (hv_Col2.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainColumn1;
                    }
                    hv_BBoxRow1New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxRow1New = (hv_Row1.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainRow1;
                    }
                    hv_BBoxRow2New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxRow2New = (hv_Row2.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainRow1;
                    }
                    hv_BBoxLabelNew.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
                            hv_MaskNewBbox);
                    }
                    //
                    //If we remove/select bounding boxes we also need to filter the corresponding
                    //instance segmentation masks if they exist.
                    filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
                {
                    //If the entire image is used, set the variables accordingly.
                    //Get the original size.
                    hv_WidthRaw.Dispose(); hv_HeightRaw.Dispose();
                    HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
                    //Set new coordinates to input coordinates.
                    hv_BBoxCol1New.Dispose();
                    hv_BBoxCol1New = new HTuple(hv_BBoxCol1);
                    hv_BBoxCol2New.Dispose();
                    hv_BBoxCol2New = new HTuple(hv_BBoxCol2);
                    hv_BBoxRow1New.Dispose();
                    hv_BBoxRow1New = new HTuple(hv_BBoxRow1);
                    hv_BBoxRow2New.Dispose();
                    hv_BBoxRow2New = new HTuple(hv_BBoxRow2);
                    hv_BBoxLabelNew.Dispose();
                    hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
                }
                else
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'");
                }
                //
                //Rescale the bounding boxes.
                //
                //Get required images width and height.
                //
                //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
                if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
                    new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
                {
                    //Calculate rescaling factor.
                    hv_FactorResampleWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
                            ) / hv_WidthRaw;
                    }
                    hv_FactorResampleHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
                            ) / hv_HeightRaw;
                    }
                    //Rescale the bounding box coordinates.
                    //As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.
                    //Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used
                    //for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxCol1New = ((hv_BBoxCol1New + .5) * hv_FactorResampleWidth) - .5;
                            hv_BBoxCol1New.Dispose();
                            hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxCol2New = ((hv_BBoxCol2New + .5) * hv_FactorResampleWidth) - .5;
                            hv_BBoxCol2New.Dispose();
                            hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxRow1New = ((hv_BBoxRow1New + .5) * hv_FactorResampleHeight) - .5;
                            hv_BBoxRow1New.Dispose();
                            hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxRow2New = ((hv_BBoxRow2New + .5) * hv_FactorResampleHeight) - .5;
                            hv_BBoxRow2New.Dispose();
                            hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
                        }
                    }
                    //
                }
                //
                //Make a final check and remove bounding boxes that have zero area.
                if ((int)(new HTuple((new HTuple(hv_BBoxRow1New.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_MaskDelete.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaskDelete = ((hv_BBoxRow1New.TupleGreaterEqualElem(
                            hv_BBoxRow2New))).TupleOr(hv_BBoxCol1New.TupleGreaterEqualElem(hv_BBoxCol2New));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxCol1New = hv_BBoxCol1New.TupleSelectMask(
                                1 - hv_MaskDelete);
                            hv_BBoxCol1New.Dispose();
                            hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxCol2New = hv_BBoxCol2New.TupleSelectMask(
                                1 - hv_MaskDelete);
                            hv_BBoxCol2New.Dispose();
                            hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxRow1New = hv_BBoxRow1New.TupleSelectMask(
                                1 - hv_MaskDelete);
                            hv_BBoxRow1New.Dispose();
                            hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxRow2New = hv_BBoxRow2New.TupleSelectMask(
                                1 - hv_MaskDelete);
                            hv_BBoxRow2New.Dispose();
                            hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_BBoxLabelNew = hv_BBoxLabelNew.TupleSelectMask(
                                1 - hv_MaskDelete);
                            hv_BBoxLabelNew.Dispose();
                            hv_BBoxLabelNew = ExpTmpLocalVar_BBoxLabelNew;
                        }
                    }
                    //
                    //If we remove/select bounding boxes we also need to filter the corresponding
                    //instance segmentation masks if they exist.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        filter_dl_sample_instance_segmentation_masks(hv_DLSample, 1 - hv_MaskDelete);
                    }
                }
                //
                //Set new bounding box coordinates in the dictionary.
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
                //
                ho_DomainRaw.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxLabel.Dispose();
                hv_Exception.Dispose();
                hv_ImageId.Dispose();
                hv_ExceptionMessage.Dispose();
                hv_BoxesInvalid.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_Row1.Dispose();
                hv_Col1.Dispose();
                hv_Row2.Dispose();
                hv_Col2.Dispose();
                hv_MaskDelete.Dispose();
                hv_MaskNewBbox.Dispose();
                hv_BBoxCol1New.Dispose();
                hv_BBoxCol2New.Dispose();
                hv_BBoxRow1New.Dispose();
                hv_BBoxRow2New.Dispose();
                hv_BBoxLabelNew.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_DomainRaw.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxLabel.Dispose();
                hv_Exception.Dispose();
                hv_ImageId.Dispose();
                hv_ExceptionMessage.Dispose();
                hv_BoxesInvalid.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_Row1.Dispose();
                hv_Col1.Dispose();
                hv_Row2.Dispose();
                hv_Col2.Dispose();
                hv_MaskDelete.Dispose();
                hv_MaskNewBbox.Dispose();
                hv_BBoxCol1New.Dispose();
                hv_BBoxCol2New.Dispose();
                hv_BBoxRow1New.Dispose();
                hv_BBoxRow2New.Dispose();
                hv_BBoxLabelNew.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Preprocess the bounding boxes of type 'rectangle2' for a given sample. 
        private void preprocess_dl_model_bbox_rect2(HObject ho_ImageRaw, HTuple hv_DLSample,
            HTuple hv_DLPreprocessParam)
        {




            // Local iconic variables 

            HObject ho_DomainRaw = null, ho_Rectangle2XLD = null;
            HObject ho_Rectangle2XLDSheared = null;

            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_DomainHandling = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_ClassIDsNoOrientation = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
            HTuple hv_BBoxLength1 = new HTuple(), hv_BBoxLength2 = new HTuple();
            HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabel = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
            HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
            HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
            HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
            HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
            HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
            HTuple hv_BBoxRowNew = new HTuple(), hv_BBoxColNew = new HTuple();
            HTuple hv_BBoxLength1New = new HTuple(), hv_BBoxLength2New = new HTuple();
            HTuple hv_BBoxPhiNew = new HTuple(), hv_BBoxLabelNew = new HTuple();
            HTuple hv_ClassIDsNoOrientationIndices = new HTuple();
            HTuple hv_Index = new HTuple(), hv_ClassIDsNoOrientationIndicesTmp = new HTuple();
            HTuple hv_DirectionLength1Row = new HTuple(), hv_DirectionLength1Col = new HTuple();
            HTuple hv_DirectionLength2Row = new HTuple(), hv_DirectionLength2Col = new HTuple();
            HTuple hv_Corner1Row = new HTuple(), hv_Corner1Col = new HTuple();
            HTuple hv_Corner2Row = new HTuple(), hv_Corner2Col = new HTuple();
            HTuple hv_FactorResampleWidth = new HTuple(), hv_FactorResampleHeight = new HTuple();
            HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxCol1 = new HTuple();
            HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxCol2 = new HTuple();
            HTuple hv_BBoxRow3 = new HTuple(), hv_BBoxCol3 = new HTuple();
            HTuple hv_BBoxRow4 = new HTuple(), hv_BBoxCol4 = new HTuple();
            HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
            HTuple hv_BBoxCol3New = new HTuple(), hv_BBoxCol4New = new HTuple();
            HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
            HTuple hv_BBoxRow3New = new HTuple(), hv_BBoxRow4New = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DScale = new HTuple();
            HTuple hv__ = new HTuple(), hv_BBoxPhiTmp = new HTuple();
            HTuple hv_PhiDelta = new HTuple(), hv_PhiDeltaNegativeIndices = new HTuple();
            HTuple hv_IndicesRot90 = new HTuple(), hv_IndicesRot180 = new HTuple();
            HTuple hv_IndicesRot270 = new HTuple(), hv_SwapIndices = new HTuple();
            HTuple hv_Tmp = new HTuple(), hv_BBoxPhiNewIndices = new HTuple();
            HTuple hv_PhiThreshold = new HTuple(), hv_PhiToCorrect = new HTuple();
            HTuple hv_NumCorrections = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DomainRaw);
            HOperatorSet.GenEmptyObj(out ho_Rectangle2XLD);
            HOperatorSet.GenEmptyObj(out ho_Rectangle2XLDSheared);
            try
            {
                //This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.
                //
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get preprocess parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                //The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.
                hv_IgnoreDirection.Dispose();
                hv_IgnoreDirection = 0;
                hv_ClassIDsNoOrientation.Dispose();
                hv_ClassIDsNoOrientation = new HTuple();
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("ignore_direction")).TupleConcat(
                    "class_ids_no_orientation"), out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_IgnoreDirection.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_direction", out hv_IgnoreDirection);
                    if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        hv_IgnoreDirection = 1;
                    }
                    else if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        hv_IgnoreDirection = 0;
                    }
                }
                if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                {
                    hv_ClassIDsNoOrientation.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_no_orientation",
                        out hv_ClassIDsNoOrientation);
                }
                //
                //Get bounding box coordinates and labels.
                try
                {
                    hv_BBoxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
                    hv_BBoxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
                    hv_BBoxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BBoxLength1);
                    hv_BBoxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BBoxLength2);
                    hv_BBoxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
                    hv_BBoxLabel.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_ImageId.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
                    {
                        hv_ExceptionMessage.Dispose();
                        hv_ExceptionMessage = "A bounding box coordinate key is missing.";
                    }
                    else
                    {
                        hv_ExceptionMessage.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ExceptionMessage = hv_Exception.TupleSelect(
                                2);
                        }
                    }
                    throw new HalconException((("An error has occurred during preprocessing image_id " + hv_ImageId) + " when getting bounding box coordinates : ") + hv_ExceptionMessage);
                }
                //
                //Check that there are no invalid boxes.
                if ((int)(new HTuple((new HTuple(hv_BBoxRow.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_BoxesInvalid.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BoxesInvalid = (((hv_BBoxLength1.TupleEqualElem(
                            0))).TupleSum()) + (((hv_BBoxLength2.TupleEqualElem(0))).TupleSum());
                    }
                    if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
                    {
                        hv_ImageId.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
                        throw new HalconException(("An error has occurred during preprocessing image_id " + hv_ImageId) + new HTuple(": Sample contains at least one bounding box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
                    }
                }
                else
                {
                    //There are no bounding boxes, hence nothing to do.
                    ho_DomainRaw.Dispose();
                    ho_Rectangle2XLD.Dispose();
                    ho_Rectangle2XLDSheared.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_DomainHandling.Dispose();
                    hv_IgnoreDirection.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_BBoxRow.Dispose();
                    hv_BBoxCol.Dispose();
                    hv_BBoxLength1.Dispose();
                    hv_BBoxLength2.Dispose();
                    hv_BBoxPhi.Dispose();
                    hv_BBoxLabel.Dispose();
                    hv_Exception.Dispose();
                    hv_ImageId.Dispose();
                    hv_ExceptionMessage.Dispose();
                    hv_BoxesInvalid.Dispose();
                    hv_DomainRow1.Dispose();
                    hv_DomainColumn1.Dispose();
                    hv_DomainRow2.Dispose();
                    hv_DomainColumn2.Dispose();
                    hv_WidthRaw.Dispose();
                    hv_HeightRaw.Dispose();
                    hv_MaskDelete.Dispose();
                    hv_MaskNewBbox.Dispose();
                    hv_BBoxRowNew.Dispose();
                    hv_BBoxColNew.Dispose();
                    hv_BBoxLength1New.Dispose();
                    hv_BBoxLength2New.Dispose();
                    hv_BBoxPhiNew.Dispose();
                    hv_BBoxLabelNew.Dispose();
                    hv_ClassIDsNoOrientationIndices.Dispose();
                    hv_Index.Dispose();
                    hv_ClassIDsNoOrientationIndicesTmp.Dispose();
                    hv_DirectionLength1Row.Dispose();
                    hv_DirectionLength1Col.Dispose();
                    hv_DirectionLength2Row.Dispose();
                    hv_DirectionLength2Col.Dispose();
                    hv_Corner1Row.Dispose();
                    hv_Corner1Col.Dispose();
                    hv_Corner2Row.Dispose();
                    hv_Corner2Col.Dispose();
                    hv_FactorResampleWidth.Dispose();
                    hv_FactorResampleHeight.Dispose();
                    hv_BBoxRow1.Dispose();
                    hv_BBoxCol1.Dispose();
                    hv_BBoxRow2.Dispose();
                    hv_BBoxCol2.Dispose();
                    hv_BBoxRow3.Dispose();
                    hv_BBoxCol3.Dispose();
                    hv_BBoxRow4.Dispose();
                    hv_BBoxCol4.Dispose();
                    hv_BBoxCol1New.Dispose();
                    hv_BBoxCol2New.Dispose();
                    hv_BBoxCol3New.Dispose();
                    hv_BBoxCol4New.Dispose();
                    hv_BBoxRow1New.Dispose();
                    hv_BBoxRow2New.Dispose();
                    hv_BBoxRow3New.Dispose();
                    hv_BBoxRow4New.Dispose();
                    hv_HomMat2DIdentity.Dispose();
                    hv_HomMat2DScale.Dispose();
                    hv__.Dispose();
                    hv_BBoxPhiTmp.Dispose();
                    hv_PhiDelta.Dispose();
                    hv_PhiDeltaNegativeIndices.Dispose();
                    hv_IndicesRot90.Dispose();
                    hv_IndicesRot180.Dispose();
                    hv_IndicesRot270.Dispose();
                    hv_SwapIndices.Dispose();
                    hv_Tmp.Dispose();
                    hv_BBoxPhiNewIndices.Dispose();
                    hv_PhiThreshold.Dispose();
                    hv_PhiToCorrect.Dispose();
                    hv_NumCorrections.Dispose();

                    return;
                }
                //
                //If the domain is cropped, crop bounding boxes.
                if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    //
                    //Get domain.
                    ho_DomainRaw.Dispose();
                    HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
                    //
                    //Set the size of the raw image to the domain extensions.
                    hv_DomainRow1.Dispose(); hv_DomainColumn1.Dispose(); hv_DomainRow2.Dispose(); hv_DomainColumn2.Dispose();
                    HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_DomainRow1, out hv_DomainColumn1,
                        out hv_DomainRow2, out hv_DomainColumn2);
                    hv_WidthRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WidthRaw = (hv_DomainColumn2 - hv_DomainColumn1) + 1;
                    }
                    hv_HeightRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HeightRaw = (hv_DomainRow2 - hv_DomainRow1) + 1;
                    }
                    //
                    //Crop the bounding boxes.
                    //Remove the boxes with center outside of the domain.
                    hv_MaskDelete.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaskDelete = (new HTuple((new HTuple(((hv_BBoxRow.TupleLessElem(
                            hv_DomainRow1))).TupleOr(hv_BBoxCol.TupleLessElem(hv_DomainColumn1)))).TupleOr(
                            hv_BBoxRow.TupleGreaterElem(hv_DomainRow2)))).TupleOr(hv_BBoxCol.TupleGreaterElem(
                            hv_DomainColumn2));
                    }
                    hv_MaskNewBbox.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaskNewBbox = 1 - hv_MaskDelete;
                    }
                    //Store the preprocessed bounding box entries.
                    hv_BBoxRowNew.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxRowNew = (hv_BBoxRow.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainRow1;
                    }
                    hv_BBoxColNew.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxColNew = (hv_BBoxCol.TupleSelectMask(
                            hv_MaskNewBbox)) - hv_DomainColumn1;
                    }
                    hv_BBoxLength1New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxLength1New = hv_BBoxLength1.TupleSelectMask(
                            hv_MaskNewBbox);
                    }
                    hv_BBoxLength2New.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxLength2New = hv_BBoxLength2.TupleSelectMask(
                            hv_MaskNewBbox);
                    }
                    hv_BBoxPhiNew.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxPhiNew = hv_BBoxPhi.TupleSelectMask(
                            hv_MaskNewBbox);
                    }
                    hv_BBoxLabelNew.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
                            hv_MaskNewBbox);
                    }
                    //
                    //If we remove/select bounding boxes we also need to filter the corresponding
                    //instance segmentation masks if they exist.
                    filter_dl_sample_instance_segmentation_masks(hv_DLSample, hv_MaskNewBbox);
                    //
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
                {
                    //If the entire image is used, set the variables accordingly.
                    //Get the original size.
                    hv_WidthRaw.Dispose(); hv_HeightRaw.Dispose();
                    HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
                    //Set new coordinates to input coordinates.
                    hv_BBoxRowNew.Dispose();
                    hv_BBoxRowNew = new HTuple(hv_BBoxRow);
                    hv_BBoxColNew.Dispose();
                    hv_BBoxColNew = new HTuple(hv_BBoxCol);
                    hv_BBoxLength1New.Dispose();
                    hv_BBoxLength1New = new HTuple(hv_BBoxLength1);
                    hv_BBoxLength2New.Dispose();
                    hv_BBoxLength2New = new HTuple(hv_BBoxLength2);
                    hv_BBoxPhiNew.Dispose();
                    hv_BBoxPhiNew = new HTuple(hv_BBoxPhi);
                    hv_BBoxLabelNew.Dispose();
                    hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
                }
                else
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'");
                }
                //
                //Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.
                hv_ClassIDsNoOrientationIndices.Dispose();
                hv_ClassIDsNoOrientationIndices = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassIDsNoOrientation.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ClassIDsNoOrientationIndicesTmp.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsNoOrientationIndicesTmp = ((hv_BBoxLabelNew.TupleEqualElem(
                            hv_ClassIDsNoOrientation.TupleSelect(hv_Index)))).TupleFind(1);
                    }
                    if ((int)(new HTuple(hv_ClassIDsNoOrientationIndicesTmp.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassIDsNoOrientationIndices = hv_ClassIDsNoOrientationIndices.TupleConcat(
                                    hv_ClassIDsNoOrientationIndicesTmp);
                                hv_ClassIDsNoOrientationIndices.Dispose();
                                hv_ClassIDsNoOrientationIndices = ExpTmpLocalVar_ClassIDsNoOrientationIndices;
                            }
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_ClassIDsNoOrientationIndices.TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    //Calculate length1 and length2 using position of corners.
                    hv_DirectionLength1Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DirectionLength1Row = -(((hv_BBoxPhiNew.TupleSelect(
                            hv_ClassIDsNoOrientationIndices))).TupleSin());
                    }
                    hv_DirectionLength1Col.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DirectionLength1Col = ((hv_BBoxPhiNew.TupleSelect(
                            hv_ClassIDsNoOrientationIndices))).TupleCos();
                    }
                    hv_DirectionLength2Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DirectionLength2Row = -hv_DirectionLength1Col;
                    }
                    hv_DirectionLength2Col.Dispose();
                    hv_DirectionLength2Col = new HTuple(hv_DirectionLength1Row);
                    hv_Corner1Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Corner1Row = ((hv_BBoxLength1New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength1Row) + ((hv_BBoxLength2New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength2Row);
                    }
                    hv_Corner1Col.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Corner1Col = ((hv_BBoxLength1New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength1Col) + ((hv_BBoxLength2New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength2Col);
                    }
                    hv_Corner2Row.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Corner2Row = ((hv_BBoxLength1New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength1Row) - ((hv_BBoxLength2New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength2Row);
                    }
                    hv_Corner2Col.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Corner2Col = ((hv_BBoxLength1New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength1Col) - ((hv_BBoxLength2New.TupleSelect(
                            hv_ClassIDsNoOrientationIndices)) * hv_DirectionLength2Col);
                    }
                    //
                    if (hv_BBoxPhiNew == null)
                        hv_BBoxPhiNew = new HTuple();
                    hv_BBoxPhiNew[hv_ClassIDsNoOrientationIndices] = 0.0;
                    if (hv_BBoxLength1New == null)
                        hv_BBoxLength1New = new HTuple();
                    hv_BBoxLength1New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Col.TupleAbs()
                        )).TupleMax2(hv_Corner2Col.TupleAbs());
                    if (hv_BBoxLength2New == null)
                        hv_BBoxLength2New = new HTuple();
                    hv_BBoxLength2New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Row.TupleAbs()
                        )).TupleMax2(hv_Corner2Row.TupleAbs());
                }
                //
                //Rescale bounding boxes.
                //
                //Get required images width and height.
                //
                //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
                if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
                    new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
                {
                    //
                    //Calculate rescaling factor.
                    hv_FactorResampleWidth.Dispose(); hv_FactorResampleHeight.Dispose();
                    calculate_dl_image_zoom_factors(hv_WidthRaw, hv_HeightRaw, hv_ImageWidth,
                        hv_ImageHeight, hv_DLPreprocessParam, out hv_FactorResampleWidth, out hv_FactorResampleHeight);
                    //
                    if ((int)((new HTuple(hv_FactorResampleHeight.TupleNotEqual(hv_FactorResampleWidth))).TupleAnd(
                        new HTuple((new HTuple(hv_BBoxRowNew.TupleLength())).TupleGreater(0)))) != 0)
                    {
                        //In order to preserve the correct orientation we have to transform the points individually.
                        //Get the coordinates of the four corner points.
                        hv_BBoxRow1.Dispose(); hv_BBoxCol1.Dispose(); hv_BBoxRow2.Dispose(); hv_BBoxCol2.Dispose(); hv_BBoxRow3.Dispose(); hv_BBoxCol3.Dispose(); hv_BBoxRow4.Dispose(); hv_BBoxCol4.Dispose();
                        convert_rect2_5to8param(hv_BBoxRowNew, hv_BBoxColNew, hv_BBoxLength1New,
                            hv_BBoxLength2New, hv_BBoxPhiNew, out hv_BBoxRow1, out hv_BBoxCol1,
                            out hv_BBoxRow2, out hv_BBoxCol2, out hv_BBoxRow3, out hv_BBoxCol3,
                            out hv_BBoxRow4, out hv_BBoxCol4);
                        //
                        //Rescale the coordinates.
                        hv_BBoxCol1New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol1New = hv_BBoxCol1 * hv_FactorResampleWidth;
                        }
                        hv_BBoxCol2New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol2New = hv_BBoxCol2 * hv_FactorResampleWidth;
                        }
                        hv_BBoxCol3New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol3New = hv_BBoxCol3 * hv_FactorResampleWidth;
                        }
                        hv_BBoxCol4New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxCol4New = hv_BBoxCol4 * hv_FactorResampleWidth;
                        }
                        hv_BBoxRow1New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow1New = hv_BBoxRow1 * hv_FactorResampleHeight;
                        }
                        hv_BBoxRow2New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow2New = hv_BBoxRow2 * hv_FactorResampleHeight;
                        }
                        hv_BBoxRow3New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow3New = hv_BBoxRow3 * hv_FactorResampleHeight;
                        }
                        hv_BBoxRow4New.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxRow4New = hv_BBoxRow4 * hv_FactorResampleHeight;
                        }
                        //
                        //The rectangles will get sheared, that is why new rectangles have to be found.
                        //Generate homography to scale rectangles.
                        hv_HomMat2DIdentity.Dispose();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        hv_HomMat2DScale.Dispose();
                        HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_FactorResampleHeight,
                            hv_FactorResampleWidth, 0, 0, out hv_HomMat2DScale);
                        //Generate XLD contours for the rectangles.
                        ho_Rectangle2XLD.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2XLD, hv_BBoxRowNew,
                            hv_BBoxColNew, hv_BBoxPhiNew, hv_BBoxLength1New, hv_BBoxLength2New);
                        //Scale the XLD contours --> results in sheared regions.
                        ho_Rectangle2XLDSheared.Dispose();
                        HOperatorSet.AffineTransContourXld(ho_Rectangle2XLD, out ho_Rectangle2XLDSheared,
                            hv_HomMat2DScale);
                        hv_BBoxRowNew.Dispose(); hv_BBoxColNew.Dispose(); hv_BBoxPhiNew.Dispose(); hv_BBoxLength1New.Dispose(); hv_BBoxLength2New.Dispose();
                        HOperatorSet.SmallestRectangle2Xld(ho_Rectangle2XLDSheared, out hv_BBoxRowNew,
                            out hv_BBoxColNew, out hv_BBoxPhiNew, out hv_BBoxLength1New, out hv_BBoxLength2New);
                        //
                        //smallest_rectangle2_xld might change the orientation of the bounding box.
                        //Hence, take the orientation that is closest to the one obtained out of the 4 corner points.
                        hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_BBoxPhiTmp.Dispose();
                        convert_rect2_8to5param(hv_BBoxRow1New, hv_BBoxCol1New, hv_BBoxRow2New,
                            hv_BBoxCol2New, hv_BBoxRow3New, hv_BBoxCol3New, hv_BBoxRow4New, hv_BBoxCol4New,
                            hv_IgnoreDirection, out hv__, out hv__, out hv__, out hv__, out hv_BBoxPhiTmp);
                        hv_PhiDelta.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PhiDelta = ((hv_BBoxPhiTmp - hv_BBoxPhiNew)).TupleFmod(
                                (new HTuple(360)).TupleRad());
                        }
                        //Guarantee that angles are positive.
                        hv_PhiDeltaNegativeIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PhiDeltaNegativeIndices = ((hv_PhiDelta.TupleLessElem(
                                0.0))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_PhiDeltaNegativeIndices.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_PhiDelta == null)
                                hv_PhiDelta = new HTuple();
                            hv_PhiDelta[hv_PhiDeltaNegativeIndices] = (hv_PhiDelta.TupleSelect(hv_PhiDeltaNegativeIndices)) + ((new HTuple(360)).TupleRad()
                                );
                        }
                        hv_IndicesRot90.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndicesRot90 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
                                (new HTuple(45)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
                                (new HTuple(135)).TupleRad())))).TupleFind(1);
                        }
                        hv_IndicesRot180.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndicesRot180 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
                                (new HTuple(135)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
                                (new HTuple(225)).TupleRad())))).TupleFind(1);
                        }
                        hv_IndicesRot270.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndicesRot270 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
                                (new HTuple(225)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
                                (new HTuple(315)).TupleRad())))).TupleFind(1);
                        }
                        hv_SwapIndices.Dispose();
                        hv_SwapIndices = new HTuple();
                        if ((int)(new HTuple(hv_IndicesRot90.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_BBoxPhiNew == null)
                                hv_BBoxPhiNew = new HTuple();
                            hv_BBoxPhiNew[hv_IndicesRot90] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot90)) + ((new HTuple(90)).TupleRad()
                                );
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                                        hv_IndicesRot90);
                                    hv_SwapIndices.Dispose();
                                    hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_IndicesRot180.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_BBoxPhiNew == null)
                                hv_BBoxPhiNew = new HTuple();
                            hv_BBoxPhiNew[hv_IndicesRot180] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot180)) + ((new HTuple(180)).TupleRad()
                                );
                        }
                        if ((int)(new HTuple(hv_IndicesRot270.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_BBoxPhiNew == null)
                                hv_BBoxPhiNew = new HTuple();
                            hv_BBoxPhiNew[hv_IndicesRot270] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot270)) + ((new HTuple(270)).TupleRad()
                                );
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                                        hv_IndicesRot270);
                                    hv_SwapIndices.Dispose();
                                    hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_SwapIndices.TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Tmp.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Tmp = hv_BBoxLength1New.TupleSelect(
                                    hv_SwapIndices);
                            }
                            if (hv_BBoxLength1New == null)
                                hv_BBoxLength1New = new HTuple();
                            hv_BBoxLength1New[hv_SwapIndices] = hv_BBoxLength2New.TupleSelect(hv_SwapIndices);
                            if (hv_BBoxLength2New == null)
                                hv_BBoxLength2New = new HTuple();
                            hv_BBoxLength2New[hv_SwapIndices] = hv_Tmp;
                        }
                        //Change angles such that they lie in the range (-180°, 180°].
                        hv_BBoxPhiNewIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BBoxPhiNewIndices = ((hv_BBoxPhiNew.TupleGreaterElem(
                                (new HTuple(180)).TupleRad()))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_BBoxPhiNewIndices.TupleNotEqual(-1))) != 0)
                        {
                            if (hv_BBoxPhiNew == null)
                                hv_BBoxPhiNew = new HTuple();
                            hv_BBoxPhiNew[hv_BBoxPhiNewIndices] = (hv_BBoxPhiNew.TupleSelect(hv_BBoxPhiNewIndices)) - ((new HTuple(360)).TupleRad()
                                );
                        }
                        //
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxColNew = hv_BBoxColNew * hv_FactorResampleWidth;
                                hv_BBoxColNew.Dispose();
                                hv_BBoxColNew = ExpTmpLocalVar_BBoxColNew;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxRowNew = hv_BBoxRowNew * hv_FactorResampleWidth;
                                hv_BBoxRowNew.Dispose();
                                hv_BBoxRowNew = ExpTmpLocalVar_BBoxRowNew;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxLength1New = hv_BBoxLength1New * hv_FactorResampleWidth;
                                hv_BBoxLength1New.Dispose();
                                hv_BBoxLength1New = ExpTmpLocalVar_BBoxLength1New;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BBoxLength2New = hv_BBoxLength2New * hv_FactorResampleWidth;
                                hv_BBoxLength2New.Dispose();
                                hv_BBoxLength2New = ExpTmpLocalVar_BBoxLength2New;
                            }
                        }
                        //Phi stays the same.
                    }
                    //
                }
                //
                //Adapt the bounding box angles such that they are within the correct range,
                //which is (-180°,180°] for 'ignore_direction'==false and (-90°,90°] else.
                hv_PhiThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PhiThreshold = ((new HTuple(180)).TupleRad()
                        ) - (hv_IgnoreDirection * ((new HTuple(90)).TupleRad()));
                }
                hv_PhiDelta.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PhiDelta = 2 * hv_PhiThreshold;
                }
                //Correct angles that are too large.
                hv_PhiToCorrect.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PhiToCorrect = ((hv_BBoxPhiNew.TupleGreaterElem(
                        hv_PhiThreshold))).TupleFind(1);
                }
                if ((int)((new HTuple(hv_PhiToCorrect.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PhiToCorrect.TupleNotEqual(
                    new HTuple())))) != 0)
                {
                    hv_NumCorrections.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumCorrections = (((((hv_BBoxPhiNew.TupleSelect(
                            hv_PhiToCorrect)) - hv_PhiThreshold) / hv_PhiDelta)).TupleInt()) + 1;
                    }
                    if (hv_BBoxPhiNew == null)
                        hv_BBoxPhiNew = new HTuple();
                    hv_BBoxPhiNew[hv_PhiToCorrect] = (hv_BBoxPhiNew.TupleSelect(hv_PhiToCorrect)) - (hv_NumCorrections * hv_PhiDelta);
                }
                //Correct angles that are too small.
                hv_PhiToCorrect.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PhiToCorrect = ((hv_BBoxPhiNew.TupleLessEqualElem(
                        -hv_PhiThreshold))).TupleFind(1);
                }
                if ((int)((new HTuple(hv_PhiToCorrect.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PhiToCorrect.TupleNotEqual(
                    new HTuple())))) != 0)
                {
                    hv_NumCorrections.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumCorrections = (((((((hv_BBoxPhiNew.TupleSelect(
                            hv_PhiToCorrect)) + hv_PhiThreshold)).TupleAbs()) / hv_PhiDelta)).TupleInt()
                            ) + 1;
                    }
                    if (hv_BBoxPhiNew == null)
                        hv_BBoxPhiNew = new HTuple();
                    hv_BBoxPhiNew[hv_PhiToCorrect] = (hv_BBoxPhiNew.TupleSelect(hv_PhiToCorrect)) + (hv_NumCorrections * hv_PhiDelta);
                }
                //
                //Check that there are no invalid boxes.
                if ((int)(new HTuple((new HTuple(hv_BBoxRowNew.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BoxesInvalid.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BoxesInvalid = (((hv_BBoxLength1New.TupleEqualElem(
                            0))).TupleSum()) + (((hv_BBoxLength2New.TupleEqualElem(0))).TupleSum());
                    }
                    if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
                    {
                        hv_ImageId.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
                        throw new HalconException(("An error has occurred during preprocessing image_id " + hv_ImageId) + new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
                    }
                }
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_BBoxRowNew);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_BBoxColNew);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv_BBoxLength1New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv_BBoxLength2New);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhiNew);
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
                //
                ho_DomainRaw.Dispose();
                ho_Rectangle2XLD.Dispose();
                ho_Rectangle2XLDSheared.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_KeyExists.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabel.Dispose();
                hv_Exception.Dispose();
                hv_ImageId.Dispose();
                hv_ExceptionMessage.Dispose();
                hv_BoxesInvalid.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_MaskDelete.Dispose();
                hv_MaskNewBbox.Dispose();
                hv_BBoxRowNew.Dispose();
                hv_BBoxColNew.Dispose();
                hv_BBoxLength1New.Dispose();
                hv_BBoxLength2New.Dispose();
                hv_BBoxPhiNew.Dispose();
                hv_BBoxLabelNew.Dispose();
                hv_ClassIDsNoOrientationIndices.Dispose();
                hv_Index.Dispose();
                hv_ClassIDsNoOrientationIndicesTmp.Dispose();
                hv_DirectionLength1Row.Dispose();
                hv_DirectionLength1Col.Dispose();
                hv_DirectionLength2Row.Dispose();
                hv_DirectionLength2Col.Dispose();
                hv_Corner1Row.Dispose();
                hv_Corner1Col.Dispose();
                hv_Corner2Row.Dispose();
                hv_Corner2Col.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow3.Dispose();
                hv_BBoxCol3.Dispose();
                hv_BBoxRow4.Dispose();
                hv_BBoxCol4.Dispose();
                hv_BBoxCol1New.Dispose();
                hv_BBoxCol2New.Dispose();
                hv_BBoxCol3New.Dispose();
                hv_BBoxCol4New.Dispose();
                hv_BBoxRow1New.Dispose();
                hv_BBoxRow2New.Dispose();
                hv_BBoxRow3New.Dispose();
                hv_BBoxRow4New.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DScale.Dispose();
                hv__.Dispose();
                hv_BBoxPhiTmp.Dispose();
                hv_PhiDelta.Dispose();
                hv_PhiDeltaNegativeIndices.Dispose();
                hv_IndicesRot90.Dispose();
                hv_IndicesRot180.Dispose();
                hv_IndicesRot270.Dispose();
                hv_SwapIndices.Dispose();
                hv_Tmp.Dispose();
                hv_BBoxPhiNewIndices.Dispose();
                hv_PhiThreshold.Dispose();
                hv_PhiToCorrect.Dispose();
                hv_NumCorrections.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_DomainRaw.Dispose();
                ho_Rectangle2XLD.Dispose();
                ho_Rectangle2XLDSheared.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_KeyExists.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabel.Dispose();
                hv_Exception.Dispose();
                hv_ImageId.Dispose();
                hv_ExceptionMessage.Dispose();
                hv_BoxesInvalid.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_MaskDelete.Dispose();
                hv_MaskNewBbox.Dispose();
                hv_BBoxRowNew.Dispose();
                hv_BBoxColNew.Dispose();
                hv_BBoxLength1New.Dispose();
                hv_BBoxLength2New.Dispose();
                hv_BBoxPhiNew.Dispose();
                hv_BBoxLabelNew.Dispose();
                hv_ClassIDsNoOrientationIndices.Dispose();
                hv_Index.Dispose();
                hv_ClassIDsNoOrientationIndicesTmp.Dispose();
                hv_DirectionLength1Row.Dispose();
                hv_DirectionLength1Col.Dispose();
                hv_DirectionLength2Row.Dispose();
                hv_DirectionLength2Col.Dispose();
                hv_Corner1Row.Dispose();
                hv_Corner1Col.Dispose();
                hv_Corner2Row.Dispose();
                hv_Corner2Col.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow3.Dispose();
                hv_BBoxCol3.Dispose();
                hv_BBoxRow4.Dispose();
                hv_BBoxCol4.Dispose();
                hv_BBoxCol1New.Dispose();
                hv_BBoxCol2New.Dispose();
                hv_BBoxCol3New.Dispose();
                hv_BBoxCol4New.Dispose();
                hv_BBoxRow1New.Dispose();
                hv_BBoxRow2New.Dispose();
                hv_BBoxRow3New.Dispose();
                hv_BBoxRow4New.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DScale.Dispose();
                hv__.Dispose();
                hv_BBoxPhiTmp.Dispose();
                hv_PhiDelta.Dispose();
                hv_PhiDeltaNegativeIndices.Dispose();
                hv_IndicesRot90.Dispose();
                hv_IndicesRot180.Dispose();
                hv_IndicesRot270.Dispose();
                hv_SwapIndices.Dispose();
                hv_Tmp.Dispose();
                hv_BBoxPhiNewIndices.Dispose();
                hv_PhiThreshold.Dispose();
                hv_PhiToCorrect.Dispose();
                hv_NumCorrections.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Preprocess images for deep-learning-based training and inference. 
        public void preprocess_dl_model_images(HObject ho_Images, out HObject ho_ImagesPreprocessed,
            HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_PreservedDomains = null, ho_ImageSelected = null;
            HObject ho_DomainSelected = null, ho_ImagesScaled = null, ho_ImageScaled = null;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ThreeChannelImage = null;
            HObject ho_SingleChannelImage = null;

            // Local copy input parameter variables 
            HObject ho_Images_COPY_INP_TMP;
            ho_Images_COPY_INP_TMP = new HObject(ho_Images);



            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
            HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
            HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_Type = new HTuple();
            HTuple hv_NumMatches = new HTuple(), hv_InputNumChannels = new HTuple();
            HTuple hv_OutputNumChannels = new HTuple(), hv_NumChannels1 = new HTuple();
            HTuple hv_NumChannels3 = new HTuple(), hv_AreInputNumChannels1 = new HTuple();
            HTuple hv_AreInputNumChannels3 = new HTuple(), hv_AreInputNumChannels1Or3 = new HTuple();
            HTuple hv_ValidNumChannels = new HTuple(), hv_ValidNumChannelsText = new HTuple();
            HTuple hv_PreserveDomain = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_UniqRow1 = new HTuple();
            HTuple hv_UniqColumn1 = new HTuple(), hv_UniqRow2 = new HTuple();
            HTuple hv_UniqColumn2 = new HTuple(), hv_RectangleIndex = new HTuple();
            HTuple hv_OriginalWidth = new HTuple(), hv_OriginalHeight = new HTuple();
            HTuple hv_UniqWidth = new HTuple(), hv_UniqHeight = new HTuple();
            HTuple hv_ScaleWidth = new HTuple(), hv_ScaleHeight = new HTuple();
            HTuple hv_ScaleIndex = new HTuple(), hv_ImageIndex = new HTuple();
            HTuple hv_NumChannels = new HTuple(), hv_ChannelIndex = new HTuple();
            HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Scale = new HTuple(), hv_Shift = new HTuple();
            HTuple hv_MeanValues = new HTuple(), hv_DeviationValues = new HTuple();
            HTuple hv_UseDefaultNormalizationValues = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_RescaleRange = new HTuple(), hv_CurrentNumChannels = new HTuple();
            HTuple hv_DiffNumChannelsIndices = new HTuple(), hv_Index = new HTuple();
            HTuple hv_DiffNumChannelsIndex = new HTuple(), hv_NumDomains = new HTuple();
            HTuple hv_DomainIndex = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
            HOperatorSet.GenEmptyObj(out ho_PreservedDomains);
            HOperatorSet.GenEmptyObj(out ho_ImageSelected);
            HOperatorSet.GenEmptyObj(out ho_DomainSelected);
            HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ThreeChannelImage);
            HOperatorSet.GenEmptyObj(out ho_SingleChannelImage);
            try
            {
                //
                //This procedure preprocesses the provided Images according to the parameters in
                //the dictionary DLPreprocessParam. Note that depending on the images, additional
                //preprocessing steps might be beneficial.
                //
                //Validate the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the preprocessing parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                hv_NormalizationType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
                hv_ModelType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
                //
                //Validate the type of the input images.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
                if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Please provide some images to preprocess.");
                }
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
                hv_NumMatches.Dispose();
                HOperatorSet.TupleRegexpTest(hv_Type, "byte|int|real", out hv_NumMatches);
                if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
                {
                    throw new HalconException(new HTuple("Please provide only images of type 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8', or 'real'."));
                }
                //
                //Handle ocr_recognition models.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_recognition"))) != 0)
                {
                    ho_ImagesPreprocessed.Dispose();
                    preprocess_dl_model_images_ocr_recognition(ho_Images_COPY_INP_TMP, out ho_ImagesPreprocessed,
                        hv_DLPreprocessParam);
                    ho_Images_COPY_INP_TMP.Dispose();
                    ho_PreservedDomains.Dispose();
                    ho_ImageSelected.Dispose();
                    ho_DomainSelected.Dispose();
                    ho_ImagesScaled.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_Channel.Dispose();
                    ho_ChannelScaled.Dispose();
                    ho_ThreeChannelImage.Dispose();
                    ho_SingleChannelImage.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_ImageNumChannels.Dispose();
                    hv_ImageRangeMin.Dispose();
                    hv_ImageRangeMax.Dispose();
                    hv_DomainHandling.Dispose();
                    hv_NormalizationType.Dispose();
                    hv_ModelType.Dispose();
                    hv_NumImages.Dispose();
                    hv_Type.Dispose();
                    hv_NumMatches.Dispose();
                    hv_InputNumChannels.Dispose();
                    hv_OutputNumChannels.Dispose();
                    hv_NumChannels1.Dispose();
                    hv_NumChannels3.Dispose();
                    hv_AreInputNumChannels1.Dispose();
                    hv_AreInputNumChannels3.Dispose();
                    hv_AreInputNumChannels1Or3.Dispose();
                    hv_ValidNumChannels.Dispose();
                    hv_ValidNumChannelsText.Dispose();
                    hv_PreserveDomain.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column2.Dispose();
                    hv_UniqRow1.Dispose();
                    hv_UniqColumn1.Dispose();
                    hv_UniqRow2.Dispose();
                    hv_UniqColumn2.Dispose();
                    hv_RectangleIndex.Dispose();
                    hv_OriginalWidth.Dispose();
                    hv_OriginalHeight.Dispose();
                    hv_UniqWidth.Dispose();
                    hv_UniqHeight.Dispose();
                    hv_ScaleWidth.Dispose();
                    hv_ScaleHeight.Dispose();
                    hv_ScaleIndex.Dispose();
                    hv_ImageIndex.Dispose();
                    hv_NumChannels.Dispose();
                    hv_ChannelIndex.Dispose();
                    hv_Min.Dispose();
                    hv_Max.Dispose();
                    hv_Range.Dispose();
                    hv_Scale.Dispose();
                    hv_Shift.Dispose();
                    hv_MeanValues.Dispose();
                    hv_DeviationValues.Dispose();
                    hv_UseDefaultNormalizationValues.Dispose();
                    hv_Exception.Dispose();
                    hv_Indices.Dispose();
                    hv_RescaleRange.Dispose();
                    hv_CurrentNumChannels.Dispose();
                    hv_DiffNumChannelsIndices.Dispose();
                    hv_Index.Dispose();
                    hv_DiffNumChannelsIndex.Dispose();
                    hv_NumDomains.Dispose();
                    hv_DomainIndex.Dispose();

                    return;
                }
                //
                //Handle ocr_detection models.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("ocr_detection"))) != 0)
                {
                    ho_ImagesPreprocessed.Dispose();
                    preprocess_dl_model_images_ocr_detection(ho_Images_COPY_INP_TMP, out ho_ImagesPreprocessed,
                        hv_DLPreprocessParam);
                    ho_Images_COPY_INP_TMP.Dispose();
                    ho_PreservedDomains.Dispose();
                    ho_ImageSelected.Dispose();
                    ho_DomainSelected.Dispose();
                    ho_ImagesScaled.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_Channel.Dispose();
                    ho_ChannelScaled.Dispose();
                    ho_ThreeChannelImage.Dispose();
                    ho_SingleChannelImage.Dispose();

                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_ImageNumChannels.Dispose();
                    hv_ImageRangeMin.Dispose();
                    hv_ImageRangeMax.Dispose();
                    hv_DomainHandling.Dispose();
                    hv_NormalizationType.Dispose();
                    hv_ModelType.Dispose();
                    hv_NumImages.Dispose();
                    hv_Type.Dispose();
                    hv_NumMatches.Dispose();
                    hv_InputNumChannels.Dispose();
                    hv_OutputNumChannels.Dispose();
                    hv_NumChannels1.Dispose();
                    hv_NumChannels3.Dispose();
                    hv_AreInputNumChannels1.Dispose();
                    hv_AreInputNumChannels3.Dispose();
                    hv_AreInputNumChannels1Or3.Dispose();
                    hv_ValidNumChannels.Dispose();
                    hv_ValidNumChannelsText.Dispose();
                    hv_PreserveDomain.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column2.Dispose();
                    hv_UniqRow1.Dispose();
                    hv_UniqColumn1.Dispose();
                    hv_UniqRow2.Dispose();
                    hv_UniqColumn2.Dispose();
                    hv_RectangleIndex.Dispose();
                    hv_OriginalWidth.Dispose();
                    hv_OriginalHeight.Dispose();
                    hv_UniqWidth.Dispose();
                    hv_UniqHeight.Dispose();
                    hv_ScaleWidth.Dispose();
                    hv_ScaleHeight.Dispose();
                    hv_ScaleIndex.Dispose();
                    hv_ImageIndex.Dispose();
                    hv_NumChannels.Dispose();
                    hv_ChannelIndex.Dispose();
                    hv_Min.Dispose();
                    hv_Max.Dispose();
                    hv_Range.Dispose();
                    hv_Scale.Dispose();
                    hv_Shift.Dispose();
                    hv_MeanValues.Dispose();
                    hv_DeviationValues.Dispose();
                    hv_UseDefaultNormalizationValues.Dispose();
                    hv_Exception.Dispose();
                    hv_Indices.Dispose();
                    hv_RescaleRange.Dispose();
                    hv_CurrentNumChannels.Dispose();
                    hv_DiffNumChannelsIndices.Dispose();
                    hv_Index.Dispose();
                    hv_DiffNumChannelsIndex.Dispose();
                    hv_NumDomains.Dispose();
                    hv_DomainIndex.Dispose();

                    return;
                }
                //
                //Validate the number channels of the input images.
                hv_InputNumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_InputNumChannels);
                hv_OutputNumChannels.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OutputNumChannels = HTuple.TupleGenConst(
                        hv_NumImages, hv_ImageNumChannels);
                }
                //Only for 'image_num_channels' 1 and 3 combinations of 1- and 3-channel images are allowed.
                if ((int)((new HTuple(hv_ImageNumChannels.TupleEqual(1))).TupleOr(new HTuple(hv_ImageNumChannels.TupleEqual(
                    3)))) != 0)
                {
                    hv_NumChannels1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumChannels1 = HTuple.TupleGenConst(
                            hv_NumImages, 1);
                    }
                    hv_NumChannels3.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumChannels3 = HTuple.TupleGenConst(
                            hv_NumImages, 3);
                    }
                    hv_AreInputNumChannels1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AreInputNumChannels1 = hv_InputNumChannels.TupleEqualElem(
                            hv_NumChannels1);
                    }
                    hv_AreInputNumChannels3.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AreInputNumChannels3 = hv_InputNumChannels.TupleEqualElem(
                            hv_NumChannels3);
                    }
                    hv_AreInputNumChannels1Or3.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AreInputNumChannels1Or3 = hv_AreInputNumChannels1 + hv_AreInputNumChannels3;
                    }
                    hv_ValidNumChannels.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidNumChannels = new HTuple(hv_AreInputNumChannels1Or3.TupleEqual(
                            hv_NumChannels1));
                    }
                    hv_ValidNumChannelsText.Dispose();
                    hv_ValidNumChannelsText = "Valid numbers of channels for the specified model are 1 or 3.";
                }
                else
                {
                    hv_ValidNumChannels.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidNumChannels = new HTuple(hv_InputNumChannels.TupleEqual(
                            hv_OutputNumChannels));
                    }
                    hv_ValidNumChannelsText.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidNumChannelsText = ("Valid number of channels for the specified model is " + hv_ImageNumChannels) + ".";
                    }
                }
                if ((int)(hv_ValidNumChannels.TupleNot()) != 0)
                {
                    throw new HalconException("Please provide images with a valid number of channels. " + hv_ValidNumChannelsText);
                }
                //Preprocess the images.
                //
                //For models of type '3d_gripping_point_detection', the preprocessing steps need to be performed on full
                //domain images while the domains are preserved and set back into the images after the preprocessing.
                hv_PreserveDomain.Dispose();
                hv_PreserveDomain = 0;
                if ((int)((new HTuple(hv_ModelType.TupleEqual("3d_gripping_point_detection"))).TupleAnd(
                    (new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))).TupleOr(new HTuple(hv_DomainHandling.TupleEqual(
                    "keep_domain"))))) != 0)
                {
                    hv_PreserveDomain.Dispose();
                    hv_PreserveDomain = 1;
                    ho_PreservedDomains.Dispose();
                    HOperatorSet.GetDomain(ho_Images_COPY_INP_TMP, out ho_PreservedDomains);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Apply the domain to the images.
                if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    if ((int)(hv_PreserveDomain) != 0)
                    {
                        //In case of preserved domain, the crop is performed with the smallest rectangle of the
                        //domain to avoid out of domain pixels being set to 0.
                        hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                        HOperatorSet.SmallestRectangle1(ho_PreservedDomains, out hv_Row1, out hv_Column1,
                            out hv_Row2, out hv_Column2);
                        hv_UniqRow1.Dispose();
                        HOperatorSet.TupleUniq(hv_Row1, out hv_UniqRow1);
                        hv_UniqColumn1.Dispose();
                        HOperatorSet.TupleUniq(hv_Column1, out hv_UniqColumn1);
                        hv_UniqRow2.Dispose();
                        HOperatorSet.TupleUniq(hv_Row2, out hv_UniqRow2);
                        hv_UniqColumn2.Dispose();
                        HOperatorSet.TupleUniq(hv_Column2, out hv_UniqColumn2);
                        if ((int)((new HTuple((new HTuple((new HTuple((new HTuple(hv_UniqRow1.TupleLength()
                            )).TupleEqual(1))).TupleAnd(new HTuple((new HTuple(hv_UniqColumn1.TupleLength()
                            )).TupleEqual(1))))).TupleAnd(new HTuple((new HTuple(hv_UniqRow2.TupleLength()
                            )).TupleEqual(1))))).TupleAnd(new HTuple((new HTuple(hv_UniqColumn2.TupleLength()
                            )).TupleEqual(1)))) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.CropRectangle1(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0,
                                    hv_UniqRow1, hv_UniqColumn1, hv_UniqRow2, hv_UniqColumn2);
                                ho_Images_COPY_INP_TMP.Dispose();
                                ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.MoveRegion(ho_PreservedDomains, out ExpTmpOutVar_0, -hv_UniqRow1,
                                    -hv_UniqColumn1);
                                ho_PreservedDomains.Dispose();
                                ho_PreservedDomains = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            for (hv_RectangleIndex = 0; (int)hv_RectangleIndex <= (int)((new HTuple(hv_Row1.TupleLength()
                                )) - 1); hv_RectangleIndex = (int)hv_RectangleIndex + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ImageSelected.Dispose();
                                    HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected,
                                        hv_RectangleIndex + 1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.CropRectangle1(ho_ImageSelected, out ExpTmpOutVar_0, hv_Row1.TupleSelect(
                                        hv_RectangleIndex), hv_Column1.TupleSelect(hv_RectangleIndex),
                                        hv_Row2.TupleSelect(hv_RectangleIndex), hv_Column2.TupleSelect(
                                        hv_RectangleIndex));
                                    ho_ImageSelected.Dispose();
                                    ho_ImageSelected = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0,
                                        hv_RectangleIndex + 1);
                                    ho_Images_COPY_INP_TMP.Dispose();
                                    ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_DomainSelected.Dispose();
                                    HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected,
                                        hv_RectangleIndex + 1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MoveRegion(ho_DomainSelected, out ExpTmpOutVar_0, -(hv_Row1.TupleSelect(
                                        hv_RectangleIndex)), -(hv_Column1.TupleSelect(hv_RectangleIndex)));
                                    ho_DomainSelected.Dispose();
                                    ho_DomainSelected = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ReplaceObj(ho_PreservedDomains, ho_DomainSelected, out ExpTmpOutVar_0,
                                        hv_RectangleIndex + 1);
                                    ho_PreservedDomains.Dispose();
                                    ho_PreservedDomains = ExpTmpOutVar_0;
                                }
                            }
                        }
                    }
                    else
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.CropDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
                            ho_Images_COPY_INP_TMP.Dispose();
                            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                        }
                    }
                }
                else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
                    (new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "3d_gripping_point_detection"))))) != 0)
                {
                    //The option 'keep_domain' is only supported for models of 'type' = 'anomaly_detection' or '3d_gripping_point_detection'.
                }
                else
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'.");
                }
                //
                //Zoom preserved domains before zooming the images.
                if ((int)(hv_PreserveDomain) != 0)
                {
                    hv_OriginalWidth.Dispose(); hv_OriginalHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_OriginalWidth, out hv_OriginalHeight);
                    hv_UniqWidth.Dispose();
                    HOperatorSet.TupleUniq(hv_OriginalWidth, out hv_UniqWidth);
                    hv_UniqHeight.Dispose();
                    HOperatorSet.TupleUniq(hv_OriginalHeight, out hv_UniqHeight);
                    if ((int)((new HTuple((new HTuple(hv_UniqWidth.TupleLength())).TupleEqual(
                        1))).TupleAnd(new HTuple((new HTuple(hv_UniqHeight.TupleLength())).TupleEqual(
                        1)))) != 0)
                    {
                        hv_ScaleWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleWidth = hv_ImageWidth / (hv_UniqWidth.TupleReal()
                                );
                        }
                        hv_ScaleHeight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleHeight = hv_ImageHeight / (hv_UniqHeight.TupleReal()
                                );
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomRegion(ho_PreservedDomains, out ExpTmpOutVar_0, hv_ScaleWidth,
                                hv_ScaleHeight);
                            ho_PreservedDomains.Dispose();
                            ho_PreservedDomains = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        hv_ScaleWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleWidth = hv_ImageWidth / (hv_OriginalWidth.TupleReal()
                                );
                        }
                        hv_ScaleHeight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleHeight = hv_ImageHeight / (hv_OriginalHeight.TupleReal()
                                );
                        }
                        for (hv_ScaleIndex = 0; (int)hv_ScaleIndex <= (int)((new HTuple(hv_ScaleWidth.TupleLength()
                            )) - 1); hv_ScaleIndex = (int)hv_ScaleIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_DomainSelected.Dispose();
                                HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected, hv_ScaleIndex + 1);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ZoomRegion(ho_DomainSelected, out ExpTmpOutVar_0, hv_ScaleWidth.TupleSelect(
                                    hv_ScaleIndex), hv_ScaleHeight.TupleSelect(hv_ScaleIndex));
                                ho_DomainSelected.Dispose();
                                ho_DomainSelected = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ReplaceObj(ho_PreservedDomains, ho_DomainSelected, out ExpTmpOutVar_0,
                                    hv_ScaleIndex + 1);
                                ho_PreservedDomains.Dispose();
                                ho_PreservedDomains = ExpTmpOutVar_0;
                            }
                        }
                    }
                }
                //
                //Convert the images to real and zoom the images.
                //Zoom first to speed up if all image types are supported by zoom_image_size.
                if ((int)(new HTuple((new HTuple(hv_Type.TupleRegexpTest("int1|int4|int8"))).TupleEqual(
                    0))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth,
                            hv_ImageHeight, "constant");
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "real");
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "real");
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth,
                            hv_ImageHeight, "constant");
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                if ((int)(new HTuple(hv_NormalizationType.TupleEqual("all_channels"))) != 0)
                {
                    //Scale for each image the gray values of all channels to ImageRangeMin-ImageRangeMax.
                    ho_ImagesScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
                    HTuple end_val138 = hv_NumImages;
                    HTuple step_val138 = 1;
                    for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val138, step_val138); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val138))
                    {
                        ho_ImageSelected.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                        hv_NumChannels.Dispose();
                        HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
                        ho_ImageScaled.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                        HTuple end_val142 = hv_NumChannels;
                        HTuple step_val142 = 1;
                        for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val142, step_val142); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val142))
                        {
                            ho_Channel.Dispose();
                            HOperatorSet.AccessChannel(ho_ImageSelected, out ho_Channel, hv_ChannelIndex);
                            hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_Min, out hv_Max,
                                out hv_Range);
                            if ((int)(new HTuple(((hv_Max - hv_Min)).TupleEqual(0))) != 0)
                            {
                                hv_Scale.Dispose();
                                hv_Scale = 1;
                            }
                            else
                            {
                                hv_Scale.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Scale = (hv_ImageRangeMax - hv_ImageRangeMin) / (hv_Max - hv_Min);
                                }
                            }
                            hv_Shift.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Shift = ((-hv_Scale) * hv_Min) + hv_ImageRangeMin;
                            }
                            ho_ChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                                    );
                                ho_ImageScaled.Dispose();
                                ho_ImageScaled = ExpTmpOutVar_0;
                            }
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageScaled, out ExpTmpOutVar_0
                                );
                            ho_ImagesScaled.Dispose();
                            ho_ImagesScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_Images_COPY_INP_TMP.Dispose();
                    ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
                }
                else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("first_channel"))) != 0)
                {
                    //Scale for each image the gray values of first channel to ImageRangeMin-ImageRangeMax.
                    ho_ImagesScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
                    HTuple end_val160 = hv_NumImages;
                    HTuple step_val160 = 1;
                    for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val160, step_val160); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val160))
                    {
                        ho_ImageSelected.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                        hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_ImageSelected, ho_ImageSelected, 0, out hv_Min,
                            out hv_Max, out hv_Range);
                        if ((int)(new HTuple(((hv_Max - hv_Min)).TupleEqual(0))) != 0)
                        {
                            hv_Scale.Dispose();
                            hv_Scale = 1;
                        }
                        else
                        {
                            hv_Scale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Scale = (hv_ImageRangeMax - hv_ImageRangeMin) / (hv_Max - hv_Min);
                            }
                        }
                        hv_Shift.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Shift = ((-hv_Scale) * hv_Min) + hv_ImageRangeMin;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ScaleImage(ho_ImageSelected, out ExpTmpOutVar_0, hv_Scale,
                                hv_Shift);
                            ho_ImageSelected.Dispose();
                            ho_ImageSelected = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageSelected, out ExpTmpOutVar_0
                                );
                            ho_ImagesScaled.Dispose();
                            ho_ImagesScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_Images_COPY_INP_TMP.Dispose();
                    ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
                }
                else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("constant_values"))) != 0)
                {
                    //Scale for each image the gray values of all channels to the corresponding channel DeviationValues[].
                    try
                    {
                        hv_MeanValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "mean_values_normalization",
                            out hv_MeanValues);
                        hv_DeviationValues.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "deviation_values_normalization",
                            out hv_DeviationValues);
                        hv_UseDefaultNormalizationValues.Dispose();
                        hv_UseDefaultNormalizationValues = 0;
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_MeanValues.Dispose();
                        hv_MeanValues = new HTuple();
                        hv_MeanValues[0] = 123.675;
                        hv_MeanValues[1] = 116.28;
                        hv_MeanValues[2] = 103.53;
                        hv_DeviationValues.Dispose();
                        hv_DeviationValues = new HTuple();
                        hv_DeviationValues[0] = 58.395;
                        hv_DeviationValues[1] = 57.12;
                        hv_DeviationValues[2] = 57.375;
                        hv_UseDefaultNormalizationValues.Dispose();
                        hv_UseDefaultNormalizationValues = 1;
                    }
                    ho_ImagesScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
                    HTuple end_val185 = hv_NumImages;
                    HTuple step_val185 = 1;
                    for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val185, step_val185); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val185))
                    {
                        ho_ImageSelected.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                        hv_NumChannels.Dispose();
                        HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
                        //Ensure that the number of channels is equal |DeviationValues| and |MeanValues|
                        if ((int)(hv_UseDefaultNormalizationValues) != 0)
                        {
                            if ((int)(new HTuple(hv_NumChannels.TupleEqual(1))) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.Compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected,
                                        out ExpTmpOutVar_0);
                                    ho_ImageSelected.Dispose();
                                    ho_ImageSelected = ExpTmpOutVar_0;
                                }
                                hv_NumChannels.Dispose();
                                HOperatorSet.CountChannels(ho_ImageSelected, out hv_NumChannels);
                            }
                            else if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(
                                3))) != 0)
                            {
                                throw new HalconException("Using default values for normalization type 'constant_values' is allowed only for 1- and 3-channel images.");
                            }
                        }
                        if ((int)((new HTuple((new HTuple(hv_MeanValues.TupleLength())).TupleNotEqual(
                            hv_NumChannels))).TupleOr(new HTuple((new HTuple(hv_DeviationValues.TupleLength()
                            )).TupleNotEqual(hv_NumChannels)))) != 0)
                        {
                            throw new HalconException("The length of mean and deviation values for normalization type 'constant_values' have to be the same size as the number of channels of the image.");
                        }
                        ho_ImageScaled.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                        HTuple end_val201 = hv_NumChannels;
                        HTuple step_val201 = 1;
                        for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val201, step_val201); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val201))
                        {
                            ho_Channel.Dispose();
                            HOperatorSet.AccessChannel(ho_ImageSelected, out ho_Channel, hv_ChannelIndex);
                            hv_Scale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Scale = 1.0 / (hv_DeviationValues.TupleSelect(
                                    hv_ChannelIndex - 1));
                            }
                            hv_Shift.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Shift = (-hv_Scale) * (hv_MeanValues.TupleSelect(
                                    hv_ChannelIndex - 1));
                            }
                            ho_ChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                                    );
                                ho_ImageScaled.Dispose();
                                ho_ImageScaled = ExpTmpOutVar_0;
                            }
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_ImagesScaled, ho_ImageScaled, out ExpTmpOutVar_0
                                );
                            ho_ImagesScaled.Dispose();
                            ho_ImagesScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_Images_COPY_INP_TMP.Dispose();
                    ho_Images_COPY_INP_TMP = new HObject(ho_ImagesScaled);
                }
                else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
                {
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_Type, "byte", out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                    {
                        //Shift the gray values from [0-255] to the expected range for byte images.
                        hv_RescaleRange.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RescaleRange = (hv_ImageRangeMax - hv_ImageRangeMin) / 255.0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_ImageSelected.Dispose();
                            HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_Indices + 1);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ScaleImage(ho_ImageSelected, out ExpTmpOutVar_0, hv_RescaleRange,
                                hv_ImageRangeMin);
                            ho_ImageSelected.Dispose();
                            ho_ImageSelected = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0,
                                hv_Indices + 1);
                            ho_Images_COPY_INP_TMP.Dispose();
                            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_NormalizationType.TupleNotEqual("none"))) != 0)
                {
                    throw new HalconException("Unsupported parameter value for 'normalization_type'");
                }
                //
                //Ensure that the number of channels of the resulting images is consistent with the
                //number of channels of the given model. The only exceptions that are adapted below
                //are combinations of 1- and 3-channel images if ImageNumChannels is either 1 or 3.
                if ((int)((new HTuple(hv_ImageNumChannels.TupleEqual(1))).TupleOr(new HTuple(hv_ImageNumChannels.TupleEqual(
                    3)))) != 0)
                {
                    hv_CurrentNumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_CurrentNumChannels);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DiffNumChannelsIndices.Dispose();
                        HOperatorSet.TupleFind(hv_CurrentNumChannels.TupleNotEqualElem(hv_OutputNumChannels),
                            1, out hv_DiffNumChannelsIndices);
                    }
                    if ((int)(new HTuple(hv_DiffNumChannelsIndices.TupleNotEqual(-1))) != 0)
                    {
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DiffNumChannelsIndices.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            hv_DiffNumChannelsIndex.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DiffNumChannelsIndex = hv_DiffNumChannelsIndices.TupleSelect(
                                    hv_Index);
                            }
                            hv_ImageIndex.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageIndex = hv_DiffNumChannelsIndex + 1;
                            }
                            hv_NumChannels.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumChannels = hv_CurrentNumChannels.TupleSelect(
                                    hv_ImageIndex - 1);
                            }
                            ho_ImageSelected.Dispose();
                            HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected,
                                hv_ImageIndex);
                            if ((int)((new HTuple(hv_NumChannels.TupleEqual(1))).TupleAnd(new HTuple(hv_ImageNumChannels.TupleEqual(
                                3)))) != 0)
                            {
                                //Conversion from 1- to 3-channel image required
                                ho_ThreeChannelImage.Dispose();
                                HOperatorSet.Compose3(ho_ImageSelected, ho_ImageSelected, ho_ImageSelected,
                                    out ho_ThreeChannelImage);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage,
                                        out ExpTmpOutVar_0, hv_ImageIndex);
                                    ho_Images_COPY_INP_TMP.Dispose();
                                    ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                                }
                            }
                            else if ((int)((new HTuple(hv_NumChannels.TupleEqual(3))).TupleAnd(
                                new HTuple(hv_ImageNumChannels.TupleEqual(1)))) != 0)
                            {
                                //Conversion from 3- to 1-channel image required
                                ho_SingleChannelImage.Dispose();
                                HOperatorSet.Rgb1ToGray(ho_ImageSelected, out ho_SingleChannelImage
                                    );
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage,
                                        out ExpTmpOutVar_0, hv_ImageIndex);
                                    ho_Images_COPY_INP_TMP.Dispose();
                                    ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                                }
                            }
                            else
                            {
                                throw new HalconException(((("Unexpected error adapting the number of channels. The number of channels of the resulting image is " + hv_NumChannels) + new HTuple(", but the number of channels of the model is ")) + hv_ImageNumChannels) + ".");
                            }
                        }
                    }
                }
                //
                //In case the image domains were preserved, they need to be set back into the images.
                if ((int)(hv_PreserveDomain) != 0)
                {
                    hv_NumDomains.Dispose();
                    HOperatorSet.CountObj(ho_PreservedDomains, out hv_NumDomains);
                    HTuple end_val254 = hv_NumDomains;
                    HTuple step_val254 = 1;
                    for (hv_DomainIndex = 1; hv_DomainIndex.Continue(end_val254, step_val254); hv_DomainIndex = hv_DomainIndex.TupleAdd(step_val254))
                    {
                        ho_ImageSelected.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, hv_DomainIndex);
                        ho_DomainSelected.Dispose();
                        HOperatorSet.SelectObj(ho_PreservedDomains, out ho_DomainSelected, hv_DomainIndex);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ReduceDomain(ho_ImageSelected, ho_DomainSelected, out ExpTmpOutVar_0
                                );
                            ho_ImageSelected.Dispose();
                            ho_ImageSelected = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ImageSelected, out ExpTmpOutVar_0,
                                hv_DomainIndex);
                            ho_Images_COPY_INP_TMP.Dispose();
                            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                        }
                    }
                }
                //
                //Write preprocessed images to output variable.
                ho_ImagesPreprocessed.Dispose();
                ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
                //
                ho_Images_COPY_INP_TMP.Dispose();
                ho_PreservedDomains.Dispose();
                ho_ImageSelected.Dispose();
                ho_DomainSelected.Dispose();
                ho_ImagesScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ThreeChannelImage.Dispose();
                ho_SingleChannelImage.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_Type.Dispose();
                hv_NumMatches.Dispose();
                hv_InputNumChannels.Dispose();
                hv_OutputNumChannels.Dispose();
                hv_NumChannels1.Dispose();
                hv_NumChannels3.Dispose();
                hv_AreInputNumChannels1.Dispose();
                hv_AreInputNumChannels3.Dispose();
                hv_AreInputNumChannels1Or3.Dispose();
                hv_ValidNumChannels.Dispose();
                hv_ValidNumChannelsText.Dispose();
                hv_PreserveDomain.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_UniqRow1.Dispose();
                hv_UniqColumn1.Dispose();
                hv_UniqRow2.Dispose();
                hv_UniqColumn2.Dispose();
                hv_RectangleIndex.Dispose();
                hv_OriginalWidth.Dispose();
                hv_OriginalHeight.Dispose();
                hv_UniqWidth.Dispose();
                hv_UniqHeight.Dispose();
                hv_ScaleWidth.Dispose();
                hv_ScaleHeight.Dispose();
                hv_ScaleIndex.Dispose();
                hv_ImageIndex.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_MeanValues.Dispose();
                hv_DeviationValues.Dispose();
                hv_UseDefaultNormalizationValues.Dispose();
                hv_Exception.Dispose();
                hv_Indices.Dispose();
                hv_RescaleRange.Dispose();
                hv_CurrentNumChannels.Dispose();
                hv_DiffNumChannelsIndices.Dispose();
                hv_Index.Dispose();
                hv_DiffNumChannelsIndex.Dispose();
                hv_NumDomains.Dispose();
                hv_DomainIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Images_COPY_INP_TMP.Dispose();
                ho_PreservedDomains.Dispose();
                ho_ImageSelected.Dispose();
                ho_DomainSelected.Dispose();
                ho_ImagesScaled.Dispose();
                ho_ImageScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ThreeChannelImage.Dispose();
                ho_SingleChannelImage.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_Type.Dispose();
                hv_NumMatches.Dispose();
                hv_InputNumChannels.Dispose();
                hv_OutputNumChannels.Dispose();
                hv_NumChannels1.Dispose();
                hv_NumChannels3.Dispose();
                hv_AreInputNumChannels1.Dispose();
                hv_AreInputNumChannels3.Dispose();
                hv_AreInputNumChannels1Or3.Dispose();
                hv_ValidNumChannels.Dispose();
                hv_ValidNumChannelsText.Dispose();
                hv_PreserveDomain.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_UniqRow1.Dispose();
                hv_UniqColumn1.Dispose();
                hv_UniqRow2.Dispose();
                hv_UniqColumn2.Dispose();
                hv_RectangleIndex.Dispose();
                hv_OriginalWidth.Dispose();
                hv_OriginalHeight.Dispose();
                hv_UniqWidth.Dispose();
                hv_UniqHeight.Dispose();
                hv_ScaleWidth.Dispose();
                hv_ScaleHeight.Dispose();
                hv_ScaleIndex.Dispose();
                hv_ImageIndex.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_MeanValues.Dispose();
                hv_DeviationValues.Dispose();
                hv_UseDefaultNormalizationValues.Dispose();
                hv_Exception.Dispose();
                hv_Indices.Dispose();
                hv_RescaleRange.Dispose();
                hv_CurrentNumChannels.Dispose();
                hv_DiffNumChannelsIndices.Dispose();
                hv_Index.Dispose();
                hv_DiffNumChannelsIndex.Dispose();
                hv_NumDomains.Dispose();
                hv_DomainIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR detection models. 
        public void preprocess_dl_model_images_ocr_detection(HObject ho_Images, out HObject ho_ImagesPreprocessed,
            HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_ImageScaled = null;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ImageG = null;
            HObject ho_ImageB = null;

            // Local copy input parameter variables 
            HObject ho_Images_COPY_INP_TMP;
            ho_Images_COPY_INP_TMP = new HObject(ho_Images);



            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
            HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
            HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ImageTypes = new HTuple(), hv_InputImageWidths = new HTuple();
            HTuple hv_InputImageHeights = new HTuple(), hv_ImageRange = new HTuple();
            HTuple hv_I = new HTuple(), hv_InputImageWidth = new HTuple();
            HTuple hv_InputImageHeight = new HTuple(), hv_ZoomFactorWidth = new HTuple();
            HTuple hv_ZoomFactorHeight = new HTuple(), hv_ZoomHeight = new HTuple();
            HTuple hv_ZoomWidth = new HTuple(), hv_ChannelIndex = new HTuple();
            HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Scale = new HTuple(), hv_Shift = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            try
            {
                //This procedure preprocesses the provided images according to the parameters
                //in the dictionary DLPreprocessParam for an ocr_detection model.
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the preprocessing parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                hv_NormalizationType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
                hv_ModelType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
                //
                //Check the preprocessing parameters.
                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("ocr_detection"))) != 0)
                {
                    throw new HalconException("The only 'model_type' value supported is'ocr_detection'.");
                }
                if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(3))) != 0)
                {
                    throw new HalconException("The only 'image_num_channels' value supported for ocr_detection models is 3.");
                }
                if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
                {
                    throw new HalconException("The only 'domain_handling' value supported for ocr_detection models is 'full_domain'.");
                }
                if ((int)((new HTuple(hv_NormalizationType.TupleNotEqual("none"))).TupleAnd(
                    new HTuple(hv_NormalizationType.TupleNotEqual("all_channels")))) != 0)
                {
                    throw new HalconException("The 'normalization_type' values supported for ocr_detection models are 'all_channels' and 'none'.");
                }
                //
                //Get the image properties.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
                hv_ImageTypes.Dispose();
                HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_ImageTypes);
                hv_InputImageWidths.Dispose(); hv_InputImageHeights.Dispose();
                HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_InputImageWidths,
                    out hv_InputImageHeights);
                //
                //Check the image properties.
                if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Please provide some images to preprocess.");
                }
                if ((int)(new HTuple(hv_NumImages.TupleNotEqual(new HTuple(hv_ImageTypes.TupleRegexpTest(
                    "byte"))))) != 0)
                {
                    throw new HalconException("Please provide only images of type 'byte'.");
                }
                if ((int)(new HTuple(hv_NumImages.TupleNotEqual((new HTuple(((hv_NumChannels.TupleEqualElem(
                    1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum()))) != 0)
                {
                    throw new HalconException("Please provide only 1- or 3-channels images for ocr_detection models.");
                }
                //
                //Preprocess the images.
                hv_ImageRange.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRange = ((hv_ImageRangeMax - hv_ImageRangeMin)).TupleReal()
                        ;
                }
                HTuple end_val49 = hv_NumImages - 1;
                HTuple step_val49 = 1;
                for (hv_I = 0; hv_I.Continue(end_val49, step_val49); hv_I = hv_I.TupleAdd(step_val49))
                {
                    hv_InputImageWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageWidth = hv_InputImageWidths.TupleSelect(
                            hv_I);
                    }
                    hv_InputImageHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageHeight = hv_InputImageHeights.TupleSelect(
                            hv_I);
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_Image, hv_I + 1);
                    }
                    //
                    //Calculate aspect-ratio preserving zoom factors
                    hv_ZoomFactorWidth.Dispose(); hv_ZoomFactorHeight.Dispose();
                    calculate_dl_image_zoom_factors(hv_InputImageWidth, hv_InputImageHeight,
                        hv_ImageWidth, hv_ImageHeight, hv_DLPreprocessParam, out hv_ZoomFactorWidth,
                        out hv_ZoomFactorHeight);
                    //
                    //Zoom image
                    hv_ZoomHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomHeight = ((hv_ZoomFactorHeight * hv_InputImageHeight)).TupleRound()
                            ;
                    }
                    hv_ZoomWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomWidth = ((hv_ZoomFactorWidth * hv_InputImageWidth)).TupleRound()
                            ;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ZoomWidth, hv_ZoomHeight,
                            "constant");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    //
                    //Convert to real and normalize
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "real");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    if ((int)(new HTuple(hv_NormalizationType.TupleEqual("all_channels"))) != 0)
                    {
                        ho_ImageScaled.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                        HTuple end_val67 = hv_NumChannels.TupleSelect(
                            hv_I);
                        HTuple step_val67 = 1;
                        for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val67, step_val67); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val67))
                        {
                            ho_Channel.Dispose();
                            HOperatorSet.AccessChannel(ho_Image, out ho_Channel, hv_ChannelIndex);
                            hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_Min, out hv_Max,
                                out hv_Range);
                            if ((int)(new HTuple(((hv_Max - hv_Min)).TupleEqual(0))) != 0)
                            {
                                hv_Scale.Dispose();
                                hv_Scale = 1;
                            }
                            else
                            {
                                hv_Scale.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Scale = (hv_ImageRangeMax - hv_ImageRangeMin) / (hv_Max - hv_Min);
                                }
                            }
                            hv_Shift.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Shift = ((-hv_Scale) * hv_Min) + hv_ImageRangeMin;
                            }
                            ho_ChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_Channel, out ho_ChannelScaled, hv_Scale, hv_Shift);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageScaled, ho_ChannelScaled, out ExpTmpOutVar_0
                                    );
                                ho_ImageScaled.Dispose();
                                ho_ImageScaled = ExpTmpOutVar_0;
                            }
                        }
                        ho_Image.Dispose();
                        ho_Image = new HObject(ho_ImageScaled);
                    }
                    else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_ImageRange / 255.0,
                                hv_ImageRangeMin);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    //
                    //Obtain an RGB image.
                    if ((int)(new HTuple(((hv_NumChannels.TupleSelect(hv_I))).TupleEqual(1))) != 0)
                    {
                        ho_ImageG.Dispose();
                        HOperatorSet.CopyImage(ho_Image, out ho_ImageG);
                        ho_ImageB.Dispose();
                        HOperatorSet.CopyImage(ho_Image, out ho_ImageB);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Compose3(ho_Image, ho_ImageG, ho_ImageB, out ExpTmpOutVar_0
                                );
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    //
                    //Apply padding to fit the desired image size.
                    //The padding value is zero, corresponding to the
                    //border handling of the convolution layers.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ChangeFormat(ho_Image, out ExpTmpOutVar_0, hv_ImageWidth, hv_ImageHeight);
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_Image, out ExpTmpOutVar_0,
                            hv_I + 1);
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Return the preprocessed images.
                ho_ImagesPreprocessed.Dispose();
                ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
                ho_Images_COPY_INP_TMP.Dispose();
                ho_Image.Dispose();
                ho_ImageScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageTypes.Dispose();
                hv_InputImageWidths.Dispose();
                hv_InputImageHeights.Dispose();
                hv_ImageRange.Dispose();
                hv_I.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_ZoomFactorWidth.Dispose();
                hv_ZoomFactorHeight.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_ChannelIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Images_COPY_INP_TMP.Dispose();
                ho_Image.Dispose();
                ho_ImageScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageTypes.Dispose();
                hv_InputImageWidths.Dispose();
                hv_InputImageHeights.Dispose();
                hv_ImageRange.Dispose();
                hv_I.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_ZoomFactorWidth.Dispose();
                hv_ZoomFactorHeight.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_ChannelIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Preprocess images for deep-learning-based training and inference of Deep OCR recognition models. 
        public void preprocess_dl_model_images_ocr_recognition(HObject ho_Images, out HObject ho_ImagesPreprocessed,
            HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TargetImage, ho_Image = null;

            // Local copy input parameter variables 
            HObject ho_Images_COPY_INP_TMP;
            ho_Images_COPY_INP_TMP = new HObject(ho_Images);



            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
            HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
            HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ImageTypes = new HTuple(), hv_InputImageWidths = new HTuple();
            HTuple hv_InputImageHeights = new HTuple(), hv_PaddingGrayval = new HTuple();
            HTuple hv_ImageRange = new HTuple(), hv_I = new HTuple();
            HTuple hv_InputImageWidth = new HTuple(), hv_InputImageHeight = new HTuple();
            HTuple hv_InputImageWidthHeightRatio = new HTuple(), hv_ZoomHeight = new HTuple();
            HTuple hv_ZoomWidth = new HTuple(), hv_GrayvalMin = new HTuple();
            HTuple hv_GrayvalMax = new HTuple(), hv_Range = new HTuple();
            HTuple hv_GrayvalRange = new HTuple(), hv_Scale = new HTuple();
            HTuple hv_Shift = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
            HOperatorSet.GenEmptyObj(out ho_TargetImage);
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //This procedure preprocesses the provided Images according to the parameters
                //in the dictionary DLPreprocessParam for an ocr_recognition model.
                //
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the preprocessing parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                hv_NormalizationType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
                hv_ModelType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
                //
                //Check the preprocessing parameters.
                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition"))) != 0)
                {
                    throw new HalconException("The only 'model_type' value supported is'ocr_recognition'.");
                }
                if ((int)(new HTuple(hv_ImageNumChannels.TupleNotEqual(1))) != 0)
                {
                    throw new HalconException("The only 'image_num_channels' value supported for ocr_recognition models is 1.");
                }
                if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
                {
                    throw new HalconException("The only 'domain_handling' value supported for ocr_recognition models is 'full_domain'.");
                }
                if ((int)((new HTuple((new HTuple(hv_NormalizationType.TupleNotEqual("none"))).TupleAnd(
                    new HTuple(hv_NormalizationType.TupleNotEqual("first_channel"))))).TupleAnd(
                    new HTuple(hv_NormalizationType.TupleNotEqual("all_channels")))) != 0)
                {
                    throw new HalconException(new HTuple("The 'normalization_type' values supported for ocr_recognition models are 'first_channel', 'all_channels' and 'none'."));
                }
                //
                //Get the image properties.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
                hv_ImageTypes.Dispose();
                HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_ImageTypes);
                hv_InputImageWidths.Dispose(); hv_InputImageHeights.Dispose();
                HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_InputImageWidths,
                    out hv_InputImageHeights);
                //
                //Check the image properties.
                if ((int)(new HTuple(hv_NumImages.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Please provide some images to preprocess.");
                }
                if ((int)(new HTuple(hv_NumImages.TupleNotEqual(new HTuple(hv_ImageTypes.TupleRegexpTest(
                    "byte|real"))))) != 0)
                {
                    throw new HalconException("Please provide only images of type 'byte' or 'real'.");
                }
                if ((int)(new HTuple(hv_NumImages.TupleNotEqual((new HTuple(((hv_NumChannels.TupleEqualElem(
                    1))).TupleOr(hv_NumChannels.TupleEqualElem(3)))).TupleSum()))) != 0)
                {
                    throw new HalconException("Please provide only 1- or 3-channels images for ocr_recognition models.");
                }
                //
                //Preprocess the images.
                hv_PaddingGrayval.Dispose();
                hv_PaddingGrayval = 0.0;
                hv_ImageRange.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRange = ((hv_ImageRangeMax - hv_ImageRangeMin)).TupleReal()
                        ;
                }
                ho_TargetImage.Dispose();
                HOperatorSet.GenImageConst(out ho_TargetImage, "real", hv_ImageWidth, hv_ImageHeight);
                HOperatorSet.OverpaintRegion(ho_TargetImage, ho_TargetImage, hv_PaddingGrayval,
                    "fill");
                HTuple end_val52 = hv_NumImages - 1;
                HTuple step_val52 = 1;
                for (hv_I = 0; hv_I.Continue(end_val52, step_val52); hv_I = hv_I.TupleAdd(step_val52))
                {
                    hv_InputImageWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageWidth = hv_InputImageWidths.TupleSelect(
                            hv_I);
                    }
                    hv_InputImageHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageHeight = hv_InputImageHeights.TupleSelect(
                            hv_I);
                    }
                    hv_InputImageWidthHeightRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InputImageWidthHeightRatio = hv_InputImageWidth / (hv_InputImageHeight.TupleReal()
                            );
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_Image, hv_I + 1);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_Image, out ExpTmpOutVar_0);
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    if ((int)(new HTuple(((hv_NumChannels.TupleSelect(hv_I))).TupleEqual(3))) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.Rgb1ToGray(ho_Image, out ExpTmpOutVar_0);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    //
                    hv_ZoomHeight.Dispose();
                    hv_ZoomHeight = new HTuple(hv_ImageHeight);
                    hv_ZoomWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ZoomWidth = hv_ImageWidth.TupleMin2(
                            ((hv_ImageHeight * hv_InputImageWidthHeightRatio)).TupleInt());
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ZoomWidth, hv_ZoomHeight,
                            "constant");
                        ho_Image.Dispose();
                        ho_Image = ExpTmpOutVar_0;
                    }
                    if ((int)(new HTuple(((hv_ImageTypes.TupleSelect(hv_I))).TupleEqual("byte"))) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConvertImageType(ho_Image, out ExpTmpOutVar_0, "real");
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    if ((int)((new HTuple(hv_NormalizationType.TupleEqual("first_channel"))).TupleOr(
                        new HTuple(hv_NormalizationType.TupleEqual("all_channels")))) != 0)
                    {
                        hv_GrayvalMin.Dispose(); hv_GrayvalMax.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_Image, ho_Image, 0, out hv_GrayvalMin, out hv_GrayvalMax,
                            out hv_Range);
                        hv_GrayvalRange.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GrayvalRange = ((hv_GrayvalMax - hv_GrayvalMin)).TupleReal()
                                ;
                        }
                        if ((int)(new HTuple(hv_GrayvalRange.TupleEqual(0.0))) != 0)
                        {
                            hv_Scale.Dispose();
                            hv_Scale = 1.0;
                        }
                        else
                        {
                            hv_Scale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Scale = hv_ImageRange / hv_GrayvalRange;
                            }
                        }
                        hv_Shift.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Shift = ((-hv_Scale) * hv_GrayvalMin) + hv_ImageRangeMin;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_Scale, hv_Shift);
                            ho_Image.Dispose();
                            ho_Image = ExpTmpOutVar_0;
                        }
                    }
                    else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(((hv_ImageTypes.TupleSelect(hv_I))).TupleEqual("byte"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ScaleImage(ho_Image, out ExpTmpOutVar_0, hv_ImageRange / 255.0,
                                    hv_ImageRangeMin);
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                        }
                    }
                    //
                    HOperatorSet.OverpaintGray(ho_TargetImage, ho_Image);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReduceDomain(ho_TargetImage, ho_Image, out ExpTmpOutVar_0);
                        ho_TargetImage.Dispose();
                        ho_TargetImage = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_TargetImage, out ExpTmpOutVar_0,
                            hv_I + 1);
                        ho_Images_COPY_INP_TMP.Dispose();
                        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Return the preprocessed images.
                ho_ImagesPreprocessed.Dispose();
                ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
                ho_Images_COPY_INP_TMP.Dispose();
                ho_TargetImage.Dispose();
                ho_Image.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageTypes.Dispose();
                hv_InputImageWidths.Dispose();
                hv_InputImageHeights.Dispose();
                hv_PaddingGrayval.Dispose();
                hv_ImageRange.Dispose();
                hv_I.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_InputImageWidthHeightRatio.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_GrayvalMin.Dispose();
                hv_GrayvalMax.Dispose();
                hv_Range.Dispose();
                hv_GrayvalRange.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Images_COPY_INP_TMP.Dispose();
                ho_TargetImage.Dispose();
                ho_Image.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_NormalizationType.Dispose();
                hv_ModelType.Dispose();
                hv_NumImages.Dispose();
                hv_NumChannels.Dispose();
                hv_ImageTypes.Dispose();
                hv_InputImageWidths.Dispose();
                hv_InputImageHeights.Dispose();
                hv_PaddingGrayval.Dispose();
                hv_ImageRange.Dispose();
                hv_I.Dispose();
                hv_InputImageWidth.Dispose();
                hv_InputImageHeight.Dispose();
                hv_InputImageWidthHeightRatio.Dispose();
                hv_ZoomHeight.Dispose();
                hv_ZoomWidth.Dispose();
                hv_GrayvalMin.Dispose();
                hv_GrayvalMax.Dispose();
                hv_Range.Dispose();
                hv_GrayvalRange.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Preprocess the instance segmentation masks for a sample given by the dictionary DLSample. 
        private void preprocess_dl_model_instance_masks(HObject ho_ImageRaw, HTuple hv_DLSample,
            HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_InstanceMasks, ho_Domain = null;

            // Local control variables 

            HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
            HTuple hv_DomainHandling = new HTuple(), hv_NumMasks = new HTuple();
            HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
            HTuple hv_DomainRow1 = new HTuple(), hv_DomainColumn1 = new HTuple();
            HTuple hv_DomainRow2 = new HTuple(), hv_DomainColumn2 = new HTuple();
            HTuple hv_FactorResampleWidth = new HTuple(), hv_FactorResampleHeight = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_InstanceMasks);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            try
            {
                //
                //This procedure preprocesses the instance masks of a DLSample.
                //
                //Check preprocess parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get relevant preprocess parameters.
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                //
                //Get the preprocessed instance masks.
                ho_InstanceMasks.Dispose();
                HOperatorSet.GetDictObject(out ho_InstanceMasks, hv_DLSample, "mask");
                //
                //Get the number of instance masks.
                hv_NumMasks.Dispose();
                HOperatorSet.CountObj(ho_InstanceMasks, out hv_NumMasks);
                //
                //Domain handling of the image to be preprocessed.
                //
                hv_WidthRaw.Dispose(); hv_HeightRaw.Dispose();
                HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
                if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    //Clip and translate masks w.r.t. the image domain
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_ImageRaw, out ho_Domain);
                    hv_DomainRow1.Dispose(); hv_DomainColumn1.Dispose(); hv_DomainRow2.Dispose(); hv_DomainColumn2.Dispose();
                    HOperatorSet.SmallestRectangle1(ho_Domain, out hv_DomainRow1, out hv_DomainColumn1,
                        out hv_DomainRow2, out hv_DomainColumn2);
                    //
                    //Clip the remaining regions to the domain.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ClipRegion(ho_InstanceMasks, out ExpTmpOutVar_0, hv_DomainRow1,
                            hv_DomainColumn1, hv_DomainRow2, hv_DomainColumn2);
                        ho_InstanceMasks.Dispose();
                        ho_InstanceMasks = ExpTmpOutVar_0;
                    }
                    hv_WidthRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WidthRaw = (hv_DomainColumn2 - hv_DomainColumn1) + 1.0;
                    }
                    hv_HeightRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HeightRaw = (hv_DomainRow2 - hv_DomainRow1) + 1.0;
                    }
                    //We need to move the remaining regions back to the origin,
                    //because crop_domain will be applied to the image
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.MoveRegion(ho_InstanceMasks, out ExpTmpOutVar_0, -hv_DomainRow1,
                            -hv_DomainColumn1);
                        ho_InstanceMasks.Dispose();
                        ho_InstanceMasks = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))) != 0)
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'");
                }
                //
                //Zoom masks only if the image has a different size than the specified size.
                if ((int)(((hv_ImageWidth.TupleNotEqualElem(hv_WidthRaw))).TupleOr(hv_ImageHeight.TupleNotEqualElem(
                    hv_HeightRaw))) != 0)
                {
                    //Calculate rescaling factor.
                    hv_FactorResampleWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
                            ) / hv_WidthRaw;
                    }
                    hv_FactorResampleHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
                            ) / hv_HeightRaw;
                    }

                    //Zoom the masks.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomRegion(ho_InstanceMasks, out ExpTmpOutVar_0, hv_FactorResampleWidth,
                            hv_FactorResampleHeight);
                        ho_InstanceMasks.Dispose();
                        ho_InstanceMasks = ExpTmpOutVar_0;
                    }
                }
                //
                //Set the preprocessed instance masks.
                HOperatorSet.SetDictObject(ho_InstanceMasks, hv_DLSample, "mask");
                //
                //
                ho_InstanceMasks.Dispose();
                ho_Domain.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_NumMasks.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_InstanceMasks.Dispose();
                ho_Domain.Dispose();

                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_DomainHandling.Dispose();
                hv_NumMasks.Dispose();
                hv_WidthRaw.Dispose();
                hv_HeightRaw.Dispose();
                hv_DomainRow1.Dispose();
                hv_DomainColumn1.Dispose();
                hv_DomainRow2.Dispose();
                hv_DomainColumn2.Dispose();
                hv_FactorResampleWidth.Dispose();
                hv_FactorResampleHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. 
        public void preprocess_dl_model_segmentations(HObject ho_ImagesRaw, HObject ho_Segmentations,
            out HObject ho_SegmentationsPreprocessed, HTuple hv_DLPreprocessParam)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Domain = null, ho_SelectedSeg = null;
            HObject ho_SelectedDomain = null;

            // Local copy input parameter variables 
            HObject ho_Segmentations_COPY_INP_TMP;
            ho_Segmentations_COPY_INP_TMP = new HObject(ho_Segmentations);



            // Local control variables 

            HTuple hv_NumberImages = new HTuple(), hv_NumberSegmentations = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WidthSeg = new HTuple(), hv_HeightSeg = new HTuple();
            HTuple hv_DLModelType = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
            HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
            HTuple hv_DomainHandling = new HTuple(), hv_SetBackgroundID = new HTuple();
            HTuple hv_ClassesToBackground = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_IsInt = new HTuple(), hv_IndexImage = new HTuple();
            HTuple hv_ImageWidthRaw = new HTuple(), hv_ImageHeightRaw = new HTuple();
            HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
            HTuple hv_Type = new HTuple(), hv_EqualReal = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationsPreprocessed);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_SelectedSeg);
            HOperatorSet.GenEmptyObj(out ho_SelectedDomain);
            try
            {
                //
                //This procedure preprocesses the segmentation or weight images
                //given by Segmentations so that they can be handled by
                //train_dl_model_batch and apply_dl_model.
                //
                //Check input data.
                //Examine number of images.
                hv_NumberImages.Dispose();
                HOperatorSet.CountObj(ho_ImagesRaw, out hv_NumberImages);
                hv_NumberSegmentations.Dispose();
                HOperatorSet.CountObj(ho_Segmentations_COPY_INP_TMP, out hv_NumberSegmentations);
                if ((int)(new HTuple(hv_NumberImages.TupleNotEqual(hv_NumberSegmentations))) != 0)
                {
                    throw new HalconException("Equal number of images given in ImagesRaw and Segmentations required");
                }
                //Size of images.
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_ImagesRaw, out hv_Width, out hv_Height);
                hv_WidthSeg.Dispose(); hv_HeightSeg.Dispose();
                HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_WidthSeg, out hv_HeightSeg);
                if ((int)((new HTuple(hv_Width.TupleNotEqual(hv_WidthSeg))).TupleOr(new HTuple(hv_Height.TupleNotEqual(
                    hv_HeightSeg)))) != 0)
                {
                    throw new HalconException("Equal size of the images given in ImagesRaw and Segmentations required.");
                }
                //Check the validity of the preprocessing parameters.
                check_dl_preprocess_param(hv_DLPreprocessParam);
                //
                //Get the relevant preprocessing parameters.
                hv_DLModelType.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
                hv_ImageRangeMin.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
                hv_ImageRangeMax.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
                hv_DomainHandling.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
                //Segmentation specific parameters.
                hv_SetBackgroundID.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
                hv_ClassesToBackground.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassesToBackground);
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                //
                //Check the input parameter for setting the background ID.
                if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Check that the model is a segmentation model.
                    if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
                    {
                        throw new HalconException("Setting class IDs to background is only implemented for segmentation.");
                    }
                    //Check the background ID.
                    hv_IsInt.Dispose();
                    HOperatorSet.TupleIsIntElem(hv_SetBackgroundID, out hv_IsInt);
                    if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Only one class_id as 'set_background_id' allowed.");
                    }
                    else if ((int)(hv_IsInt.TupleNot()) != 0)
                    {
                        //Given class_id has to be of type int.
                        throw new HalconException("The class_id given as 'set_background_id' has to be of type int.");
                    }
                    //Check the values of ClassesToBackground.
                    if ((int)(new HTuple((new HTuple(hv_ClassesToBackground.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        //Check that the given classes are of length > 0.
                        throw new HalconException(new HTuple("If 'set_background_id' is given, 'class_ids_background' must at least contain this class ID."));
                    }
                    else if ((int)(new HTuple(((hv_ClassesToBackground.TupleIntersection(
                        hv_IgnoreClassIDs))).TupleNotEqual(new HTuple()))) != 0)
                    {
                        //Check that class_ids_background is not included in the ignore_class_ids of the DLModel.
                        throw new HalconException("The given 'class_ids_background' must not be included in the 'ignore_class_ids' of the model.");
                    }
                }
                //
                //Domain handling of the image to be preprocessed.
                //
                if ((int)((new HTuple(hv_DomainHandling.TupleEqual("full_domain"))).TupleOr(
                    new HTuple(hv_DomainHandling.TupleEqual("keep_domain")))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
                            );
                        ho_Segmentations_COPY_INP_TMP.Dispose();
                        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
                {
                    //If the domain should be cropped the domain has to be transferred
                    //from the raw image to the segmentation image.
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_ImagesRaw, out ho_Domain);
                    HTuple end_val66 = hv_NumberImages;
                    HTuple step_val66 = 1;
                    for (hv_IndexImage = 1; hv_IndexImage.Continue(end_val66, step_val66); hv_IndexImage = hv_IndexImage.TupleAdd(step_val66))
                    {
                        ho_SelectedSeg.Dispose();
                        HOperatorSet.SelectObj(ho_Segmentations_COPY_INP_TMP, out ho_SelectedSeg,
                            hv_IndexImage);
                        ho_SelectedDomain.Dispose();
                        HOperatorSet.SelectObj(ho_Domain, out ho_SelectedDomain, hv_IndexImage);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ChangeDomain(ho_SelectedSeg, ho_SelectedDomain, out ExpTmpOutVar_0
                                );
                            ho_SelectedSeg.Dispose();
                            ho_SelectedSeg = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ReplaceObj(ho_Segmentations_COPY_INP_TMP, ho_SelectedSeg,
                                out ExpTmpOutVar_0, hv_IndexImage);
                            ho_Segmentations_COPY_INP_TMP.Dispose();
                            ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.CropDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
                            );
                        ho_Segmentations_COPY_INP_TMP.Dispose();
                        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    throw new HalconException("Unsupported parameter value for 'domain_handling'");
                }
                //
                //Preprocess the segmentation images.
                //
                //Set all background classes to the given background class ID.
                if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        reassign_pixel_values(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0,
                            hv_ClassesToBackground, hv_SetBackgroundID);
                        ho_Segmentations_COPY_INP_TMP.Dispose();
                        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Zoom images only if they have a different size than the specified size.
                hv_ImageWidthRaw.Dispose(); hv_ImageHeightRaw.Dispose();
                HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_ImageWidthRaw,
                    out hv_ImageHeightRaw);
                hv_EqualWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
                        hv_ImageWidthRaw);
                }
                hv_EqualHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
                        hv_ImageHeightRaw);
                }
                if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
                    new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ZoomImageSize(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0,
                            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
                        ho_Segmentations_COPY_INP_TMP.Dispose();
                        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Check the type of the input images
                //and convert if necessary.
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_Segmentations_COPY_INP_TMP, out hv_Type);
                hv_EqualReal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EqualReal = hv_Type.TupleEqualElem(
                        "real");
                }
                //
                if ((int)(new HTuple(((hv_EqualReal.TupleMin())).TupleEqual(0))) != 0)
                {
                    //Convert the image type to 'real',
                    //because the model expects 'real' images.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "real");
                        ho_Segmentations_COPY_INP_TMP.Dispose();
                        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Write preprocessed Segmentations to output variable.
                ho_SegmentationsPreprocessed.Dispose();
                ho_SegmentationsPreprocessed = new HObject(ho_Segmentations_COPY_INP_TMP);
                ho_Segmentations_COPY_INP_TMP.Dispose();
                ho_Domain.Dispose();
                ho_SelectedSeg.Dispose();
                ho_SelectedDomain.Dispose();

                hv_NumberImages.Dispose();
                hv_NumberSegmentations.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthSeg.Dispose();
                hv_HeightSeg.Dispose();
                hv_DLModelType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassesToBackground.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_IsInt.Dispose();
                hv_IndexImage.Dispose();
                hv_ImageWidthRaw.Dispose();
                hv_ImageHeightRaw.Dispose();
                hv_EqualWidth.Dispose();
                hv_EqualHeight.Dispose();
                hv_Type.Dispose();
                hv_EqualReal.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Segmentations_COPY_INP_TMP.Dispose();
                ho_Domain.Dispose();
                ho_SelectedSeg.Dispose();
                ho_SelectedDomain.Dispose();

                hv_NumberImages.Dispose();
                hv_NumberSegmentations.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthSeg.Dispose();
                hv_HeightSeg.Dispose();
                hv_DLModelType.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_DomainHandling.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassesToBackground.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_IsInt.Dispose();
                hv_IndexImage.Dispose();
                hv_ImageWidthRaw.Dispose();
                hv_ImageHeightRaw.Dispose();
                hv_EqualWidth.Dispose();
                hv_EqualHeight.Dispose();
                hv_Type.Dispose();
                hv_EqualReal.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. 
        public void preprocess_dl_samples(HTuple hv_DLSampleBatch, HTuple hv_DLPreprocessParam)
        {



            // Local iconic variables 

            HObject ho_ImageRaw = null, ho_ImagePreprocessed = null;
            HObject ho_AnomalyImageRaw = null, ho_AnomalyImagePreprocessed = null;
            HObject ho_SegmentationRaw = null, ho_SegmentationPreprocessed = null;
            HObject ho_ImageRawDomain = null;

            // Local control variables 

            HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_ImageExists = new HTuple(), hv_KeysExists = new HTuple();
            HTuple hv_AnomalyParamExist = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
            HTuple hv_Rectangle2ParamExist = new HTuple(), hv_InstanceMaskParamExist = new HTuple();
            HTuple hv_SegmentationParamExist = new HTuple(), hv_OCRParamExist = new HTuple();
            HTuple hv_DLPreprocessParam_COPY_INP_TMP = new HTuple(hv_DLPreprocessParam);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageRaw);
            HOperatorSet.GenEmptyObj(out ho_ImagePreprocessed);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImageRaw);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImagePreprocessed);
            HOperatorSet.GenEmptyObj(out ho_SegmentationRaw);
            HOperatorSet.GenEmptyObj(out ho_SegmentationPreprocessed);
            HOperatorSet.GenEmptyObj(out ho_ImageRawDomain);
            try
            {
                //
                //This procedure preprocesses all images of the sample dictionaries
                //in the tuple DLSampleBatch.
                //The images are preprocessed according to the parameters provided
                //in DLPreprocessParam.
                //
                //Check the validity of the preprocessing parameters.
                //The procedure check_dl_preprocess_param might change DLPreprocessParam.
                //To avoid race conditions when preprocess_dl_samples is used from
                //multiple threads with the same DLPreprocessParam dictionary,
                //work on a copy.
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.CopyDict(hv_DLPreprocessParam_COPY_INP_TMP, new HTuple(), new HTuple(),
                        out ExpTmpOutVar_0);
                    hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
                    hv_DLPreprocessParam_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                check_dl_preprocess_param(hv_DLPreprocessParam_COPY_INP_TMP);
                //
                //
                //
                //Preprocess the sample entries.
                //
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_DLSampleBatch.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSampleBatch.TupleSelect(
                            hv_SampleIndex);
                    }
                    //
                    //Preprocess augmentation data.
                    preprocess_dl_model_augmentation_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                    //
                    //Check the existence of the sample keys.
                    hv_ImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image", out hv_ImageExists);
                    //
                    //Preprocess the images.
                    if ((int)(hv_ImageExists) != 0)
                    {
                        //
                        //Get the image.
                        ho_ImageRaw.Dispose();
                        HOperatorSet.GetDictObject(out ho_ImageRaw, hv_DLSample, "image");
                        //
                        //Preprocess the image.
                        ho_ImagePreprocessed.Dispose();
                        preprocess_dl_model_images(ho_ImageRaw, out ho_ImagePreprocessed, hv_DLPreprocessParam_COPY_INP_TMP);
                        //
                        //Replace the image in the dictionary.
                        HOperatorSet.SetDictObject(ho_ImagePreprocessed, hv_DLSample, "image");
                        //
                        //Check existence of model specific sample keys:
                        //- 'anomaly_ground_truth':
                        //  For model 'type' = 'anomaly_detection' and
                        //  model 'type' = 'gc_anomaly_detection'
                        //- 'bbox_row1':
                        //  For 'instance_type' = 'rectangle1' and
                        //  model 'type' = 'detection'
                        //- 'bbox_phi':
                        //  For 'instance_type' = 'rectangle2' and
                        //  model 'type' = 'detection'
                        //- 'mask':
                        //  For 'instance_type' = 'rectangle1',
                        //  model 'type' = 'detection', and
                        //  'instance_segmentation' = true
                        //- 'segmentation_image':
                        //  For model 'type' = 'segmentation'
                        hv_KeysExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", (((((new HTuple("anomaly_ground_truth")).TupleConcat(
                            "bbox_row1")).TupleConcat("bbox_phi")).TupleConcat("mask")).TupleConcat(
                            "segmentation_image")).TupleConcat("word"), out hv_KeysExists);
                        hv_AnomalyParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyParamExist = hv_KeysExists.TupleSelect(
                                0);
                        }
                        hv_Rectangle1ParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Rectangle1ParamExist = hv_KeysExists.TupleSelect(
                                1);
                        }
                        hv_Rectangle2ParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Rectangle2ParamExist = hv_KeysExists.TupleSelect(
                                2);
                        }
                        hv_InstanceMaskParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InstanceMaskParamExist = hv_KeysExists.TupleSelect(
                                3);
                        }
                        hv_SegmentationParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SegmentationParamExist = hv_KeysExists.TupleSelect(
                                4);
                        }
                        hv_OCRParamExist.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OCRParamExist = hv_KeysExists.TupleSelect(
                                5);
                        }
                        //
                        //Preprocess the anomaly ground truth for
                        //model 'type' = 'anomaly_detection' or
                        //model 'type' = 'gc_anomaly_detection' if present.
                        if ((int)(hv_AnomalyParamExist) != 0)
                        {
                            //
                            //Get the anomaly image.
                            ho_AnomalyImageRaw.Dispose();
                            HOperatorSet.GetDictObject(out ho_AnomalyImageRaw, hv_DLSample, "anomaly_ground_truth");
                            //
                            //Preprocess the anomaly image.
                            ho_AnomalyImagePreprocessed.Dispose();
                            preprocess_dl_model_anomaly(ho_AnomalyImageRaw, out ho_AnomalyImagePreprocessed,
                                hv_DLPreprocessParam_COPY_INP_TMP);
                            //
                            //Set preprocessed anomaly image.
                            HOperatorSet.SetDictObject(ho_AnomalyImagePreprocessed, hv_DLSample,
                                "anomaly_ground_truth");
                        }
                        //
                        //Preprocess depending on the model type.
                        //If bounding boxes are given, rescale them as well.
                        if ((int)(hv_Rectangle1ParamExist) != 0)
                        {
                            //
                            //Preprocess the bounding boxes of type 'rectangle1'.
                            preprocess_dl_model_bbox_rect1(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                        }
                        else if ((int)(hv_Rectangle2ParamExist) != 0)
                        {
                            //
                            //Preprocess the bounding boxes of type 'rectangle2'.
                            preprocess_dl_model_bbox_rect2(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                        }
                        if ((int)(hv_InstanceMaskParamExist) != 0)
                        {
                            //
                            //Preprocess the instance masks.
                            preprocess_dl_model_instance_masks(ho_ImageRaw, hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                        }
                        //
                        //Preprocess the segmentation image if present.
                        if ((int)(hv_SegmentationParamExist) != 0)
                        {
                            //
                            //Get the segmentation image.
                            ho_SegmentationRaw.Dispose();
                            HOperatorSet.GetDictObject(out ho_SegmentationRaw, hv_DLSample, "segmentation_image");
                            //
                            //Preprocess the segmentation image.
                            ho_SegmentationPreprocessed.Dispose();
                            preprocess_dl_model_segmentations(ho_ImageRaw, ho_SegmentationRaw, out ho_SegmentationPreprocessed,
                                hv_DLPreprocessParam_COPY_INP_TMP);
                            //
                            //Set preprocessed segmentation image.
                            HOperatorSet.SetDictObject(ho_SegmentationPreprocessed, hv_DLSample,
                                "segmentation_image");
                        }
                        //
                        //Preprocess the word bounding boxes and generate targets.
                        if ((int)(hv_OCRParamExist.TupleAnd(hv_Rectangle2ParamExist)) != 0)
                        {
                            //
                            //Preprocess Sample.
                            gen_dl_ocr_detection_targets(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                        }
                        //
                        //Preprocess 3D relevant data if present.
                        hv_KeysExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", (((new HTuple("x")).TupleConcat(
                            "y")).TupleConcat("z")).TupleConcat("normals"), out hv_KeysExists);
                        if ((int)(hv_KeysExists.TupleMax()) != 0)
                        {
                            //We need to handle crop_domain before preprocess_dl_model_3d_data
                            //if it is necessary.
                            //Note, we are not cropping the image of DLSample because it has
                            //been done by preprocess_dl_model_images.
                            //Since we always keep the domain of 3D data we do not need to handle
                            //'keep_domain' or 'full_domain'.
                            ho_ImageRawDomain.Dispose();
                            HOperatorSet.GetDomain(ho_ImageRaw, out ho_ImageRawDomain);
                            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "x", hv_DLPreprocessParam_COPY_INP_TMP);
                            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "y", hv_DLPreprocessParam_COPY_INP_TMP);
                            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "z", hv_DLPreprocessParam_COPY_INP_TMP);
                            crop_dl_sample_image(ho_ImageRawDomain, hv_DLSample, "normals", hv_DLPreprocessParam_COPY_INP_TMP);
                            //
                            preprocess_dl_model_3d_data(hv_DLSample, hv_DLPreprocessParam_COPY_INP_TMP);
                        }
                    }
                    else
                    {
                        throw new HalconException((new HTuple("All samples processed need to include an image, but the sample with index ") + hv_SampleIndex) + " does not.");
                    }
                }
                //
                ho_ImageRaw.Dispose();
                ho_ImagePreprocessed.Dispose();
                ho_AnomalyImageRaw.Dispose();
                ho_AnomalyImagePreprocessed.Dispose();
                ho_SegmentationRaw.Dispose();
                ho_SegmentationPreprocessed.Dispose();
                ho_ImageRawDomain.Dispose();

                hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImageExists.Dispose();
                hv_KeysExists.Dispose();
                hv_AnomalyParamExist.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskParamExist.Dispose();
                hv_SegmentationParamExist.Dispose();
                hv_OCRParamExist.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageRaw.Dispose();
                ho_ImagePreprocessed.Dispose();
                ho_AnomalyImageRaw.Dispose();
                ho_AnomalyImagePreprocessed.Dispose();
                ho_SegmentationRaw.Dispose();
                ho_SegmentationPreprocessed.Dispose();
                ho_ImageRawDomain.Dispose();

                hv_DLPreprocessParam_COPY_INP_TMP.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImageExists.Dispose();
                hv_KeysExists.Dispose();
                hv_AnomalyParamExist.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_InstanceMaskParamExist.Dispose();
                hv_SegmentationParamExist.Dispose();
                hv_OCRParamExist.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tuple / Conversion
        // Short Description: Print a tuple of values to a string. 
        private void pretty_print_tuple(HTuple hv_Tuple, out HTuple hv_TupleStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_J = new HTuple();
            // Initialize local and output iconic variables 
            hv_TupleStr = new HTuple();
            try
            {
                //
                //This procedure prints a tuple of values to a string.
                //
                if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(1))) != 0)
                {
                    hv_TupleStr.Dispose();
                    hv_TupleStr = "[";
                    for (hv_J = 0; (int)hv_J <= (int)((new HTuple(hv_Tuple.TupleLength())) - 1); hv_J = (int)hv_J + 1)
                    {
                        if ((int)(new HTuple(hv_J.TupleGreater(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_TupleStr = hv_TupleStr + new HTuple(",");
                                    hv_TupleStr.Dispose();
                                    hv_TupleStr = ExpTmpLocalVar_TupleStr;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TupleStr = hv_TupleStr + (hv_Tuple.TupleSelect(
                                    hv_J));
                                hv_TupleStr.Dispose();
                                hv_TupleStr = ExpTmpLocalVar_TupleStr;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TupleStr = hv_TupleStr + "]";
                            hv_TupleStr.Dispose();
                            hv_TupleStr = ExpTmpLocalVar_TupleStr;
                        }
                    }
                }
                else
                {
                    hv_TupleStr.Dispose();
                    hv_TupleStr = new HTuple(hv_Tuple);
                }

                hv_J.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_J.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Read the dictionaries DLSamples from files. 
        public void read_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
            HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
            HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
            HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure reads a batch of DLSample dictionaries from disk.
                //The wanted samples are selected from a DLDataset by their indices.
                //The indices of the wanted samples are handed over in SampleIndices.
                //It returns the tuple of read-in dictionaries in DLSampleBatch.
                //
                //Sanity checks of inputs.
                //
                if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
                    0))) != 0)
                {
                    //Check the length of selected indices.
                    throw new HalconException(new HTuple("Invalid length of SelectedIndices: ") + (new HTuple(hv_SampleIndices.TupleLength()
                        )));
                }
                else
                {
                    //Get the samples from the DLDataset.
                    hv_DatasetSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                    //Get min and max value of given indices.
                    hv_MinIndex.Dispose();
                    HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                    hv_MaxIndex.Dispose();
                    HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                    if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                        (new HTuple(hv_DatasetSamples.TupleLength())) - 1)))) != 0)
                    {
                        //Check the value range of the provided indices.
                        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                    }
                }
                //
                //Check if the key dlsample_dir is given.
                hv_KeyDirExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
                //
                if ((int)(hv_KeyDirExists) != 0)
                {
                    //
                    //Get the dlsample_dir.
                    hv_DictDir.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
                    //Get the samples to be processed.
                    hv_DLSamplesProc.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
                            hv_SampleIndices);
                    }
                    //
                    //Initialize DLSampleBatch tuple.
                    hv_DLSampleBatch.Dispose();
                    hv_DLSampleBatch = new HTuple();
                    //
                    //Read in all DLSamples into the batch.
                    for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                        )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                    {
                        //Check if dlsample key exist.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_KeyFileExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "key_exists", "dlsample_file_name", out hv_KeyFileExists);
                        }
                        //
                        if ((int)(hv_KeyFileExists.TupleNot()) != 0)
                        {
                            //
                            //If the key does not exist, check if a corresponding file exists.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "image_id", out hv_ImageID);
                            }
                            hv_FileNameRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameRelative = hv_ImageID + "_dlsample.hdict";
                            }
                            hv_FileNameSample.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameSample = (hv_DictDir + "/") + hv_FileNameRelative;
                            }
                            //
                            hv_FileExists.Dispose();
                            HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
                            if ((int)(hv_FileExists) != 0)
                            {
                                //If it exists, create corresponding key.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "dlsample_file_name", hv_FileNameRelative);
                                }
                            }
                            else
                            {
                                //If not, throw an error.
                                throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID " + hv_ImageID);
                            }
                            //
                        }
                        //
                        //If dlsample dictionary is available for reading, read it.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DictPath.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "dlsample_file_name", out hv_DictPath);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSample.Dispose();
                                HOperatorSet.ReadDict((hv_DictDir + "/") + hv_DictPath, new HTuple(), new HTuple(),
                                    out hv_DLSample);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException((((("An error has occurred while reading " + hv_DictDir) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                                0)));
                        }
                        //Add it to the DLSampleBatch.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                    hv_DLSample);
                                hv_DLSampleBatch.Dispose();
                                hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                            }
                        }
                        //
                    }
                }
                else
                {
                    throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
                }


                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Image / Manipulation
        // Short Description: Change value of ValuesToChange in Image to NewValue. 
        private void reassign_pixel_values(HObject ho_Image, out HObject ho_ImageOut,
            HTuple hv_ValuesToChange, HTuple hv_NewValue)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionToChange, ho_RegionClass = null;

            // Local control variables 

            HTuple hv_IndexReset = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageOut);
            HOperatorSet.GenEmptyObj(out ho_RegionToChange);
            HOperatorSet.GenEmptyObj(out ho_RegionClass);
            try
            {
                //
                //This procedure sets all pixels of Image
                //with the values given in ValuesToChange to the given value NewValue.
                //
                ho_RegionToChange.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_RegionToChange);
                for (hv_IndexReset = 0; (int)hv_IndexReset <= (int)((new HTuple(hv_ValuesToChange.TupleLength()
                    )) - 1); hv_IndexReset = (int)hv_IndexReset + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_RegionClass.Dispose();
                        HOperatorSet.Threshold(ho_Image, out ho_RegionClass, hv_ValuesToChange.TupleSelect(
                            hv_IndexReset), hv_ValuesToChange.TupleSelect(hv_IndexReset));
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Union2(ho_RegionToChange, ho_RegionClass, out ExpTmpOutVar_0
                            );
                        ho_RegionToChange.Dispose();
                        ho_RegionToChange = ExpTmpOutVar_0;
                    }
                }
                HOperatorSet.OverpaintRegion(ho_Image, ho_RegionToChange, hv_NewValue, "fill");
                ho_ImageOut.Dispose();
                ho_ImageOut = new HObject(ho_Image);
                ho_RegionToChange.Dispose();
                ho_RegionClass.Dispose();

                hv_IndexReset.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_RegionToChange.Dispose();
                ho_RegionClass.Dispose();

                hv_IndexReset.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Reduce the evaluation result to a single value. 
        private void reduce_dl_evaluation_result(HTuple hv_EvaluationResult, HTuple hv_EvaluationComparisonKeys,
            out HTuple hv_Value, out HTuple hv_ValidEvaluationKeys)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TopLevelResult = new HTuple();
            HTuple hv_KeysEvalResult = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_FirstMaxNumDetections = new HTuple(), hv_KeysFirstMaxNumDetections = new HTuple();
            HTuple hv_DetectionResult = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ClassificationResult = new HTuple(), hv_KeysExist = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_Values = new HTuple();
            HTuple hv_K = new HTuple(), hv_Key = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple(hv_EvaluationComparisonKeys);
            HTuple hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_EvaluationResult);

            // Initialize local and output iconic variables 
            hv_Value = new HTuple();
            hv_ValidEvaluationKeys = new HTuple();
            try
            {
                //
                //In order to compare a model we need to reduce the evaluation parameter/result
                //to a single float Value which is comparable via >.
                //
                if ((int)((new HTuple((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0))).TupleAnd(new HTuple((new HTuple(hv_EvaluationResult_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0)))) != 0)
                {
                    hv_TopLevelResult.Dispose();
                    hv_TopLevelResult = new HTuple(hv_EvaluationResult_COPY_INP_TMP);
                    //We need to check for a special case: detection results.
                    //They have a complex structure.
                    hv_KeysEvalResult.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_KeysEvalResult);
                    hv_NumMatches.Dispose();
                    HOperatorSet.TupleRegexpTest(hv_KeysEvalResult, "max_num_detections_.*",
                        out hv_NumMatches);
                    if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
                    {
                        //We use only the first results of every level.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FirstMaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_KeysEvalResult.TupleSelect(
                                0), out hv_FirstMaxNumDetections);
                        }
                        hv_KeysFirstMaxNumDetections.Dispose();
                        HOperatorSet.GetDictParam(hv_FirstMaxNumDetections, "keys", new HTuple(),
                            out hv_KeysFirstMaxNumDetections);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DetectionResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_FirstMaxNumDetections, hv_KeysFirstMaxNumDetections.TupleSelect(
                                0), out hv_DetectionResult);
                        }
                        //We use this result here as the top level to retrieve values.
                        hv_EvaluationResult_COPY_INP_TMP.Dispose();
                        hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_DetectionResult);
                    }
                    //We need to check for a special case: classification results.
                    //They have a complex structure.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index.Dispose();
                        HOperatorSet.TupleFind(hv_KeysEvalResult.TupleEqualElem("global"), 1, out hv_Index);
                    }
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        //We use the results for key 'global'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassificationResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_KeysEvalResult.TupleSelect(
                                hv_Index), out hv_ClassificationResult);
                        }
                        hv_EvaluationResult_COPY_INP_TMP.Dispose();
                        hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_ClassificationResult);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index.Dispose();
                        HOperatorSet.TupleFind(hv_KeysEvalResult.TupleEqualElem("ocr_detection"),
                            1, out hv_Index);
                    }
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        //We use the results for key 'ocr_detection'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationResult_COPY_INP_TMP.Dispose();
                            HOperatorSet.GetDictTuple(hv_TopLevelResult, hv_KeysEvalResult.TupleSelect(
                                hv_Index), out hv_EvaluationResult_COPY_INP_TMP);
                        }
                    }
                    //Reduce comparison to keys that exist.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "key_exists",
                        hv_EvaluationComparisonKeys_COPY_INP_TMP, out hv_KeysExist);
                    //
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_KeysExist, 1, out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
                    {
                        hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                        hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple();
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvaluationComparisonKeys = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
                                    hv_Indices);
                                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                                hv_EvaluationComparisonKeys_COPY_INP_TMP = ExpTmpLocalVar_EvaluationComparisonKeys;
                            }
                        }
                    }
                }
                //
                hv_ValidEvaluationKeys.Dispose();
                hv_ValidEvaluationKeys = new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP);
                //
                hv_Value.Dispose();
                hv_Value = 0.0;
                hv_Values.Dispose();
                hv_Values = new HTuple();
                if ((int)(new HTuple((new HTuple(hv_EvaluationResult_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_K = (int)hv_K + 1)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
                                hv_K);
                        }
                        //
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_Key, out hv_Tuple);
                        //Use the mean in order to reduce tuples with length > 1.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Values = hv_Values.TupleConcat(
                                    hv_Tuple.TupleMean());
                                hv_Values.Dispose();
                                hv_Values = ExpTmpLocalVar_Values;
                            }
                        }
                    }
                }
                else
                {
                    hv_Value.Dispose();
                    hv_Value = -1;
                }
                if ((int)(new HTuple((new HTuple(hv_Values.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_Value.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Value = hv_Values.TupleMean()
                            ;
                    }
                }
                //

                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                hv_EvaluationResult_COPY_INP_TMP.Dispose();
                hv_TopLevelResult.Dispose();
                hv_KeysEvalResult.Dispose();
                hv_NumMatches.Dispose();
                hv_FirstMaxNumDetections.Dispose();
                hv_KeysFirstMaxNumDetections.Dispose();
                hv_DetectionResult.Dispose();
                hv_Index.Dispose();
                hv_ClassificationResult.Dispose();
                hv_KeysExist.Dispose();
                hv_Indices.Dispose();
                hv_Values.Dispose();
                hv_K.Dispose();
                hv_Key.Dispose();
                hv_Tuple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                hv_EvaluationResult_COPY_INP_TMP.Dispose();
                hv_TopLevelResult.Dispose();
                hv_KeysEvalResult.Dispose();
                hv_NumMatches.Dispose();
                hv_FirstMaxNumDetections.Dispose();
                hv_KeysFirstMaxNumDetections.Dispose();
                hv_DetectionResult.Dispose();
                hv_Index.Dispose();
                hv_ClassificationResult.Dispose();
                hv_KeysExist.Dispose();
                hv_Indices.Dispose();
                hv_Values.Dispose();
                hv_K.Dispose();
                hv_Key.Dispose();
                hv_Tuple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: File / Misc
        // Short Description: Remove a directory recursively. 
        public void remove_dir_recursively(HTuple hv_DirName)
        {



            // Local control variables 

            HTuple hv_Dirs = new HTuple(), hv_I = new HTuple();
            HTuple hv_Files = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //Recursively delete all subdirectories.
                hv_Dirs.Dispose();
                HOperatorSet.ListFiles(hv_DirName, "directories", out hv_Dirs);
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Dirs.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        remove_dir_recursively(hv_Dirs.TupleSelect(hv_I));
                    }
                }
                //Delete all files.
                hv_Files.Dispose();
                HOperatorSet.ListFiles(hv_DirName, "files", out hv_Files);
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Files.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DeleteFile(hv_Files.TupleSelect(hv_I));
                    }
                }
                //Remove empty directory.
                HOperatorSet.RemoveDir(hv_DirName);

                hv_Dirs.Dispose();
                hv_I.Dispose();
                hv_Files.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Dirs.Dispose();
                hv_I.Dispose();
                hv_Files.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Remove invalid 3D pixels from a given domain. 
        private void remove_invalid_3d_pixels(HObject ho_ImageX, HObject ho_ImageY, HObject ho_ImageZ,
            HObject ho_Domain, out HObject ho_DomainOut, HTuple hv_InvalidPixelValue)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageXOut = null, ho_ImageYOut = null;
            HObject ho_ImageZOut = null, ho_RegionInvalX, ho_RegionInvalY;
            HObject ho_RegionInvalZ, ho_RegionInvalXY, ho_RegionInval;
            HObject ho_RegionInvalComplement;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DomainOut);
            HOperatorSet.GenEmptyObj(out ho_ImageXOut);
            HOperatorSet.GenEmptyObj(out ho_ImageYOut);
            HOperatorSet.GenEmptyObj(out ho_ImageZOut);
            HOperatorSet.GenEmptyObj(out ho_RegionInvalX);
            HOperatorSet.GenEmptyObj(out ho_RegionInvalY);
            HOperatorSet.GenEmptyObj(out ho_RegionInvalZ);
            HOperatorSet.GenEmptyObj(out ho_RegionInvalXY);
            HOperatorSet.GenEmptyObj(out ho_RegionInval);
            HOperatorSet.GenEmptyObj(out ho_RegionInvalComplement);
            try
            {
                ho_DomainOut.Dispose();
                ho_DomainOut = new HObject(ho_Domain);
                ho_ImageXOut.Dispose();
                ho_ImageXOut = new HObject(ho_ImageX);
                ho_ImageYOut.Dispose();
                ho_ImageYOut = new HObject(ho_ImageY);
                ho_ImageZOut.Dispose();
                ho_ImageZOut = new HObject(ho_ImageZ);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageXOut, ho_DomainOut, out ExpTmpOutVar_0);
                    ho_ImageXOut.Dispose();
                    ho_ImageXOut = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageYOut, ho_DomainOut, out ExpTmpOutVar_0);
                    ho_ImageYOut.Dispose();
                    ho_ImageYOut = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ReduceDomain(ho_ImageZOut, ho_DomainOut, out ExpTmpOutVar_0);
                    ho_ImageZOut.Dispose();
                    ho_ImageZOut = ExpTmpOutVar_0;
                }
                ho_RegionInvalX.Dispose();
                HOperatorSet.Threshold(ho_ImageXOut, out ho_RegionInvalX, hv_InvalidPixelValue,
                    hv_InvalidPixelValue);
                ho_RegionInvalY.Dispose();
                HOperatorSet.Threshold(ho_ImageYOut, out ho_RegionInvalY, hv_InvalidPixelValue,
                    hv_InvalidPixelValue);
                ho_RegionInvalZ.Dispose();
                HOperatorSet.Threshold(ho_ImageZOut, out ho_RegionInvalZ, hv_InvalidPixelValue,
                    hv_InvalidPixelValue);
                ho_RegionInvalXY.Dispose();
                HOperatorSet.Intersection(ho_RegionInvalX, ho_RegionInvalY, out ho_RegionInvalXY
                    );
                ho_RegionInval.Dispose();
                HOperatorSet.Intersection(ho_RegionInvalXY, ho_RegionInvalZ, out ho_RegionInval
                    );
                ho_RegionInvalComplement.Dispose();
                HOperatorSet.Complement(ho_RegionInval, out ho_RegionInvalComplement);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Intersection(ho_DomainOut, ho_RegionInvalComplement, out ExpTmpOutVar_0
                        );
                    ho_DomainOut.Dispose();
                    ho_DomainOut = ExpTmpOutVar_0;
                }
                ho_ImageXOut.Dispose();
                ho_ImageYOut.Dispose();
                ho_ImageZOut.Dispose();
                ho_RegionInvalX.Dispose();
                ho_RegionInvalY.Dispose();
                ho_RegionInvalZ.Dispose();
                ho_RegionInvalXY.Dispose();
                ho_RegionInval.Dispose();
                ho_RegionInvalComplement.Dispose();


                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageXOut.Dispose();
                ho_ImageYOut.Dispose();
                ho_ImageZOut.Dispose();
                ho_RegionInvalX.Dispose();
                ho_RegionInvalY.Dispose();
                ho_RegionInvalZ.Dispose();
                ho_RegionInvalXY.Dispose();
                ho_RegionInval.Dispose();
                ho_RegionInvalComplement.Dispose();


                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Replace legacy preprocessing parameters or values. 
        private void replace_legacy_preprocessing_parameters(HTuple hv_DLPreprocessParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Exception = new HTuple(), hv_NormalizationTypeExists = new HTuple();
            HTuple hv_NormalizationType = new HTuple(), hv_LegacyNormalizationKeyExists = new HTuple();
            HTuple hv_ContrastNormalization = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure adapts the dictionary DLPreprocessParam
                //if a legacy preprocessing parameter is set.
                //
                //Map legacy value set to new parameter.
                hv_Exception.Dispose();
                hv_Exception = 0;
                try
                {
                    hv_NormalizationTypeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "normalization_type",
                        out hv_NormalizationTypeExists);
                    //
                    if ((int)(hv_NormalizationTypeExists) != 0)
                    {
                        hv_NormalizationType.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
                        if ((int)(new HTuple(hv_NormalizationType.TupleEqual("true"))) != 0)
                        {
                            hv_NormalizationType.Dispose();
                            hv_NormalizationType = "first_channel";
                        }
                        else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("false"))) != 0)
                        {
                            hv_NormalizationType.Dispose();
                            hv_NormalizationType = "none";
                        }
                        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", hv_NormalizationType);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                //Map legacy parameter to new parameter and corresponding value.
                hv_Exception.Dispose();
                hv_Exception = 0;
                try
                {
                    hv_LegacyNormalizationKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "contrast_normalization",
                        out hv_LegacyNormalizationKeyExists);
                    if ((int)(hv_LegacyNormalizationKeyExists) != 0)
                    {
                        hv_ContrastNormalization.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "contrast_normalization",
                            out hv_ContrastNormalization);
                        //Replace 'contrast_normalization' by 'normalization_type'.
                        if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual("false"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type",
                                "none");
                        }
                        else if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual(
                            "true"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type",
                                "first_channel");
                        }
                        HOperatorSet.RemoveDictKey(hv_DLPreprocessParam, "contrast_normalization");
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }

                hv_Exception.Dispose();
                hv_NormalizationTypeExists.Dispose();
                hv_NormalizationType.Dispose();
                hv_LegacyNormalizationKeyExists.Dispose();
                hv_ContrastNormalization.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Exception.Dispose();
                hv_NormalizationTypeExists.Dispose();
                hv_NormalizationType.Dispose();
                hv_LegacyNormalizationKeyExists.Dispose();
                hv_ContrastNormalization.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Restore serialized DL train information to resume the training. 
        private void restore_dl_train_info_for_resuming(HTuple hv_StartEpoch, HTuple hv_SerializationData,
            HTuple hv_TrainParam, HTuple hv_DisplayData, out HTuple hv_EvaluationInfos,
            out HTuple hv_TrainInfos, out HTuple hv_DisplayEvaluationEpochs, out HTuple hv_DisplayValidationEvaluationValues,
            out HTuple hv_DisplayTrainEvaluationValues, out HTuple hv_DisplayLossEpochs,
            out HTuple hv_DisplayLoss, out HTuple hv_DisplayLearningRates, out HTuple hv_TrainResultsRestored,
            out HTuple hv_StartEpochNumber)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TrainResults = new HTuple(), hv_SerializationStrategies = new HTuple();
            HTuple hv_RawData = new HTuple(), hv_FoundEpochs = new HTuple();
            HTuple hv_FoundDicts = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_Type = new HTuple();
            HTuple hv_Basename = new HTuple(), hv_Substrings = new HTuple();
            HTuple hv_BaseFolder = new HTuple(), hv_Files = new HTuple();
            HTuple hv_DictFiles = new HTuple(), hv_EpochStrings = new HTuple();
            HTuple hv_EpochStringsNumbers = new HTuple(), hv_DictFileNames = new HTuple();
            HTuple hv_IndexDict = new HTuple(), hv_DictFileName = new HTuple();
            HTuple hv_InfoDicts = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_ReadSuccess = new HTuple(), hv_InfoDict = new HTuple();
            HTuple hv_Epoch = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_DisplayEnabled = new HTuple();
            HTuple hv_IndexEval = new HTuple(), hv_EvaluationResult = new HTuple();
            HTuple hv_Value = new HTuple(), hv_ValidEvaluationKeys = new HTuple();
            HTuple hv_IndexTrain = new HTuple(), hv_EpochsStatus = new HTuple();
            HTuple hv_MeanLoss = new HTuple(), hv_ModelParams = new HTuple();
            HTuple hv_DisplayLearningRate = new HTuple(), hv_LossParam = new HTuple();
            HTuple hv_CountSamples = new HTuple(), hv_LossValues = new HTuple();
            HTuple hv_NumMeanLossSamples = new HTuple(), hv_SamplesPerEpoch = new HTuple();
            HTuple hv_MeanLossCur = new HTuple(), hv_NumSamplesInterval = new HTuple();
            HTuple hv_LossValueIdxsPrev = new HTuple(), hv_MeanLossCurInterval = new HTuple();
            HTuple hv_LossValuesCurInterval = new HTuple(), hv_IndexSample = new HTuple();
            HTuple hv_TrainResult = new HTuple(), hv_NumEpochs = new HTuple();
            HTuple hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_StartEpoch);

            // Initialize local and output iconic variables 
            hv_EvaluationInfos = new HTuple();
            hv_TrainInfos = new HTuple();
            hv_DisplayEvaluationEpochs = new HTuple();
            hv_DisplayValidationEvaluationValues = new HTuple();
            hv_DisplayTrainEvaluationValues = new HTuple();
            hv_DisplayLossEpochs = new HTuple();
            hv_DisplayLoss = new HTuple();
            hv_DisplayLearningRates = new HTuple();
            hv_TrainResultsRestored = new HTuple();
            hv_StartEpochNumber = new HTuple();
            try
            {
                //
                //This procedure initializes training relevant parameters that are stored
                //during training. If StartEpoch is greater than zero or equal to 'resume',
                //the procedure restores this information. This allows to properly resume a
                //training that had been paused or should be continued for another reason.
                //
                //Initialize the variable to collect all training results during training.
                hv_TrainResults.Dispose();
                hv_TrainResults = new HTuple();
                //
                //Initialize the variable to collect the evaluation information during training.
                hv_EvaluationInfos.Dispose();
                hv_EvaluationInfos = new HTuple();
                hv_TrainResultsRestored.Dispose();
                hv_TrainResultsRestored = new HTuple();
                //
                //Initialize the variable to collect the train status information during training.
                hv_TrainInfos.Dispose();
                hv_TrainInfos = new HTuple();
                //
                //Initialize visualization parameters.
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLossEpochs = new HTuple();
                hv_DisplayLoss.Dispose();
                hv_DisplayLoss = new HTuple();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayEvaluationEpochs = new HTuple();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayValidationEvaluationValues = new HTuple();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues = new HTuple();
                hv_DisplayLearningRates.Dispose();
                hv_DisplayLearningRates = new HTuple();
                //
                //Initialize the start epoch number.
                hv_StartEpochNumber.Dispose();
                hv_StartEpochNumber = 0;
                //
                //Training parameters are initialized for new training,
                //hence return if StartEpoch is zero.
                if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleEqual(0.0))) != 0)
                {

                    hv_StartEpoch_COPY_INP_TMP.Dispose();
                    hv_TrainResults.Dispose();
                    hv_SerializationStrategies.Dispose();
                    hv_RawData.Dispose();
                    hv_FoundEpochs.Dispose();
                    hv_FoundDicts.Dispose();
                    hv_Index.Dispose();
                    hv_Strategy.Dispose();
                    hv_Type.Dispose();
                    hv_Basename.Dispose();
                    hv_Substrings.Dispose();
                    hv_BaseFolder.Dispose();
                    hv_Files.Dispose();
                    hv_DictFiles.Dispose();
                    hv_EpochStrings.Dispose();
                    hv_EpochStringsNumbers.Dispose();
                    hv_DictFileNames.Dispose();
                    hv_IndexDict.Dispose();
                    hv_DictFileName.Dispose();
                    hv_InfoDicts.Dispose();
                    hv_Epochs.Dispose();
                    hv_ReadSuccess.Dispose();
                    hv_InfoDict.Dispose();
                    hv_Epoch.Dispose();
                    hv_Exception.Dispose();
                    hv_EvaluationComparisonKeys.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_IndexEval.Dispose();
                    hv_EvaluationResult.Dispose();
                    hv_Value.Dispose();
                    hv_ValidEvaluationKeys.Dispose();
                    hv_IndexTrain.Dispose();
                    hv_EpochsStatus.Dispose();
                    hv_MeanLoss.Dispose();
                    hv_ModelParams.Dispose();
                    hv_DisplayLearningRate.Dispose();
                    hv_LossParam.Dispose();
                    hv_CountSamples.Dispose();
                    hv_LossValues.Dispose();
                    hv_NumMeanLossSamples.Dispose();
                    hv_SamplesPerEpoch.Dispose();
                    hv_MeanLossCur.Dispose();
                    hv_NumSamplesInterval.Dispose();
                    hv_LossValueIdxsPrev.Dispose();
                    hv_MeanLossCurInterval.Dispose();
                    hv_LossValuesCurInterval.Dispose();
                    hv_IndexSample.Dispose();
                    hv_TrainResult.Dispose();
                    hv_NumEpochs.Dispose();

                    return;
                }
                //
                //This procedure reads the latest training and evaluation information from disk to resume training.
                //
                //Initialize each serialization strategy.
                hv_SerializationStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "strategies", out hv_SerializationStrategies);
                hv_RawData.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "raw_data", out hv_RawData);
                //
                //Loop over all serialization strategies. If more than one is available and StartEpoch='resume',
                //choose the most up-to-date training information that can be found.
                hv_FoundEpochs.Dispose();
                hv_FoundEpochs = new HTuple();
                hv_FoundDicts.Dispose();
                hv_FoundDicts = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_SerializationStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //
                    //Get current strategy and data.
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_SerializationStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_Type.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);
                    hv_Basename.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "basename", out hv_Basename);
                    //
                    if ((int)((new HTuple((new HTuple(hv_Type.TupleEqual("best"))).TupleOr(new HTuple(hv_Type.TupleEqual(
                        "current"))))).TupleOr(new HTuple(hv_Type.TupleEqual("epochs")))) != 0)
                    {
                        //
                        if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                        {
                            //Find the last written training information
                            {
                                HTuple ExpTmpOutVar_0;
                                HOperatorSet.TupleRegexpReplace(hv_Basename, (new HTuple("\\\\+")).TupleConcat(
                                    "replace_all"), "/", out ExpTmpOutVar_0);
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpOutVar_0;
                            }
                            hv_Substrings.Dispose();
                            HOperatorSet.TupleSplit(hv_Basename, "/", out hv_Substrings);
                            hv_BaseFolder.Dispose();
                            hv_BaseFolder = ".";
                            if ((int)(new HTuple((new HTuple(hv_Substrings.TupleLength())).TupleGreater(
                                1))) != 0)
                            {
                                hv_BaseFolder.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BaseFolder = (hv_Substrings.TupleSelectRange(
                                        0, (new HTuple(hv_Substrings.TupleLength())) - 2)) + "/";
                                }
                            }
                            hv_Files.Dispose();
                            HOperatorSet.ListFiles(hv_BaseFolder, "files", out hv_Files);
                            hv_DictFiles.Dispose();
                            HOperatorSet.TupleRegexpSelect(hv_Files, "[0-9]\\.[0-9]*_info\\.hdict",
                                out hv_DictFiles);
                            hv_EpochStrings.Dispose();
                            HOperatorSet.TupleRegexpMatch(hv_DictFiles, "[0-9]\\.[0-9]*", out hv_EpochStrings);
                            hv_EpochStringsNumbers.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EpochStringsNumbers = hv_EpochStrings.TupleNumber()
                                    ;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DictFileNames.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_EpochStrings.TupleLength()),
                                    "", out hv_DictFileNames);
                            }
                            for (hv_IndexDict = 0; (int)hv_IndexDict <= (int)((new HTuple(hv_EpochStrings.TupleLength()
                                )) - 1); hv_IndexDict = (int)hv_IndexDict + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DictFileName.Dispose();
                                    HOperatorSet.TupleRegexpSelect(hv_DictFiles, (((hv_EpochStringsNumbers.TupleSelect(
                                        hv_IndexDict))).TupleString(".2f")) + "_info.hdict", out hv_DictFileName);
                                }
                                if ((int)(new HTuple((new HTuple(hv_DictFileName.TupleLength())).TupleNotEqual(
                                    0))) != 0)
                                {
                                    if (hv_DictFileNames == null)
                                        hv_DictFileNames = new HTuple();
                                    hv_DictFileNames[hv_IndexDict] = hv_DictFileName;
                                }
                            }
                        }
                        else
                        {
                            hv_DictFileNames.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DictFileNames = hv_Basename + "_info.hdict";
                            }
                        }
                        //
                        //Try to read in the training information dictionaries.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InfoDicts.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_DictFileNames.TupleLength()),
                                -1, out hv_InfoDicts);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Epochs.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_DictFileNames.TupleLength()),
                                -1, out hv_Epochs);
                        }
                        hv_ReadSuccess.Dispose();
                        hv_ReadSuccess = 0;
                        for (hv_IndexDict = 0; (int)hv_IndexDict <= (int)((new HTuple(hv_DictFileNames.TupleLength()
                            )) - 1); hv_IndexDict = (int)hv_IndexDict + 1)
                        {
                            try
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_InfoDict.Dispose();
                                    HOperatorSet.ReadDict(hv_DictFileNames.TupleSelect(hv_IndexDict), new HTuple(),
                                        new HTuple(), out hv_InfoDict);
                                }
                                hv_Epoch.Dispose();
                                HOperatorSet.GetDictTuple(hv_InfoDict, "epoch", out hv_Epoch);
                                if (hv_InfoDicts == null)
                                    hv_InfoDicts = new HTuple();
                                hv_InfoDicts[hv_IndexDict] = hv_InfoDict;
                                if (hv_Epochs == null)
                                    hv_Epochs = new HTuple();
                                hv_Epochs[hv_IndexDict] = hv_Epoch;
                                hv_ReadSuccess.Dispose();
                                hv_ReadSuccess = 1;
                            }
                            // catch (Exception) 
                            catch (HalconException HDevExpDefaultException1)
                            {
                                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            }
                        }
                        if ((int)(hv_ReadSuccess.TupleNot()) != 0)
                        {
                            //Not even a single file has been found.
                            continue;
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FoundEpochs = hv_FoundEpochs.TupleConcat(
                                    hv_Epochs);
                                hv_FoundEpochs.Dispose();
                                hv_FoundEpochs = ExpTmpLocalVar_FoundEpochs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FoundDicts = hv_FoundDicts.TupleConcat(
                                    hv_InfoDicts);
                                hv_FoundDicts.Dispose();
                                hv_FoundDicts = ExpTmpLocalVar_FoundDicts;
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        //Nothing to restore.
                        continue;
                    }
                    else
                    {
                        throw new HalconException(("Unknown serialization strategy type: '" + hv_Type) + "'");
                    }
                }
                //
                //Check if training can or needs to be resumed.
                if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleEqual("resume"))) != 0)
                {
                    //Resume at highest epoch available.
                    hv_Epoch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Epoch = hv_FoundEpochs.TupleMax()
                            ;
                    }
                    if ((int)(new HTuple(hv_Epoch.TupleLess(0.0))) != 0)
                    {
                        throw new HalconException("No training information found. Training cannot be resumed.");
                    }
                    hv_Index.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index = ((hv_FoundEpochs.TupleEqualElem(
                            hv_Epoch))).TupleFindFirst(1);
                    }
                    hv_InfoDict.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InfoDict = hv_FoundDicts.TupleSelect(
                            hv_Index);
                    }
                    hv_StartEpoch_COPY_INP_TMP.Dispose();
                    hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_Epoch);
                }
                else
                {
                    //Check if requested StartEpoch was found.
                    hv_Index.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index = ((hv_FoundEpochs.TupleEqualElem(
                            hv_StartEpoch_COPY_INP_TMP))).TupleFindFirst(1);
                    }
                    if ((int)((new HTuple(hv_Index.TupleNotEqual(new HTuple()))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(
                        -1)))) != 0)
                    {
                        hv_InfoDict.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InfoDict = hv_FoundDicts.TupleSelect(
                                hv_Index);
                        }
                    }
                    else
                    {
                        //Try to find the rounded value as it is serialized.
                        hv_Index.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Index = ((((hv_FoundEpochs.TupleString(
                                ".2f"))).TupleEqualElem(hv_StartEpoch_COPY_INP_TMP.TupleString(".2f")))).TupleFindFirst(
                                1);
                        }
                        if ((int)((new HTuple(hv_Index.TupleNotEqual(new HTuple()))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(
                            -1)))) != 0)
                        {
                            hv_InfoDict.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_InfoDict = hv_FoundDicts.TupleSelect(
                                    hv_Index);
                            }
                        }
                        else
                        {
                            throw new HalconException("No training information matches requested StartEpoch " + hv_StartEpoch_COPY_INP_TMP);
                        }
                    }
                }
                //
                //Get evaluation and training information.
                hv_EvaluationInfos.Dispose();
                HOperatorSet.GetDictTuple(hv_InfoDict, "evaluation_infos", out hv_EvaluationInfos);
                hv_TrainInfos.Dispose();
                HOperatorSet.GetDictTuple(hv_InfoDict, "train_infos", out hv_TrainInfos);
                hv_EvaluationComparisonKeys.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
                //
                //Restore history of display values.
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                if ((int)(hv_DisplayEnabled) != 0)
                {
                    for (hv_IndexEval = 0; (int)hv_IndexEval <= (int)((new HTuple(hv_EvaluationInfos.TupleLength()
                        )) - 1); hv_IndexEval = (int)hv_IndexEval + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                "result", out hv_EvaluationResult);
                        }
                        hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                        reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                            out hv_Value, out hv_ValidEvaluationKeys);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayValidationEvaluationValues = hv_DisplayValidationEvaluationValues.TupleConcat(
                                    hv_Value);
                                hv_DisplayValidationEvaluationValues.Dispose();
                                hv_DisplayValidationEvaluationValues = ExpTmpLocalVar_DisplayValidationEvaluationValues;
                            }
                        }
                        hv_Value.Dispose();
                        hv_Value = -1;
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EvaluationResult.Dispose();
                                HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                    "train_result", out hv_EvaluationResult);
                            }
                            hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                            reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                                out hv_Value, out hv_ValidEvaluationKeys);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayTrainEvaluationValues = hv_DisplayTrainEvaluationValues.TupleConcat(
                                    hv_Value);
                                hv_DisplayTrainEvaluationValues.Dispose();
                                hv_DisplayTrainEvaluationValues = ExpTmpLocalVar_DisplayTrainEvaluationValues;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Epoch.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                "epoch", out hv_Epoch);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayEvaluationEpochs = hv_DisplayEvaluationEpochs.TupleConcat(
                                    hv_Epoch);
                                hv_DisplayEvaluationEpochs.Dispose();
                                hv_DisplayEvaluationEpochs = ExpTmpLocalVar_DisplayEvaluationEpochs;
                            }
                        }
                    }
                    for (hv_IndexTrain = 0; (int)hv_IndexTrain <= (int)((new HTuple(hv_TrainInfos.TupleLength()
                        )) - 1); hv_IndexTrain = (int)hv_IndexTrain + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EpochsStatus.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "epoch",
                                out hv_EpochsStatus);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLossEpochs = hv_DisplayLossEpochs.TupleConcat(
                                    hv_EpochsStatus);
                                hv_DisplayLossEpochs.Dispose();
                                hv_DisplayLossEpochs = ExpTmpLocalVar_DisplayLossEpochs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanLoss.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss",
                                out hv_MeanLoss);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLoss = hv_DisplayLoss.TupleConcat(
                                    hv_MeanLoss);
                                hv_DisplayLoss.Dispose();
                                hv_DisplayLoss = ExpTmpLocalVar_DisplayLoss;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ModelParams.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "model_params",
                                out hv_ModelParams);
                        }
                        hv_DisplayLearningRate.Dispose();
                        HOperatorSet.GetDictTuple(hv_ModelParams, "learning_rate", out hv_DisplayLearningRate);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLearningRates = hv_DisplayLearningRates.TupleConcat(
                                    hv_DisplayLearningRate);
                                hv_DisplayLearningRates.Dispose();
                                hv_DisplayLearningRates = ExpTmpLocalVar_DisplayLearningRates;
                            }
                        }
                    }
                }
                //
                //Restore dictionaries that contain the approximate loss-values for each iteration.
                //We cannot reconstruct the exact loss values, therefore, we use the serialized mean values.
                hv_LossParam.Dispose();
                hv_LossParam = "total_loss";
                hv_CountSamples.Dispose();
                hv_CountSamples = 0;
                hv_LossValues.Dispose();
                hv_LossValues = new HTuple();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Epoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(0), "epoch", out hv_Epoch);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumMeanLossSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(0), "mean_loss_samples",
                        out hv_NumMeanLossSamples);
                }
                hv_SamplesPerEpoch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SamplesPerEpoch = (hv_NumMeanLossSamples.TupleReal()
                        ) / hv_Epoch;
                }
                //
                for (hv_IndexTrain = 0; (int)hv_IndexTrain <= (int)((new HTuple(hv_TrainInfos.TupleLength()
                    )) - 1); hv_IndexTrain = (int)hv_IndexTrain + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanLossCur.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss",
                            out hv_MeanLossCur);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumMeanLossSamples.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss_samples",
                            out hv_NumMeanLossSamples);
                    }
                    //The iterations within one interval are not fixed.
                    //Calculate the current iteration and the number of iterations within the interval based on the epoch.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Epoch.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "epoch",
                            out hv_Epoch);
                    }
                    hv_NumSamplesInterval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumSamplesInterval = (((hv_Epoch * hv_SamplesPerEpoch)).TupleRound()
                            ) - hv_CountSamples;
                    }
                    //For multiple resuming it can happen that more than one train-info for the same time-point exists.
                    if ((int)(new HTuple(hv_NumSamplesInterval.TupleEqual(0))) != 0)
                    {
                        continue;
                    }
                    //Calculate the mean loss within the interval between the previous and the current serialization time-point.
                    hv_LossValueIdxsPrev.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValueIdxsPrev = (HTuple.TupleGenSequence(
                            (new HTuple(hv_LossValues.TupleLength())) - (hv_NumMeanLossSamples - hv_NumSamplesInterval),
                            (new HTuple(hv_LossValues.TupleLength())) - 1, 1)).TupleInt();
                    }
                    if ((int)(new HTuple(hv_LossValueIdxsPrev.TupleLength())) != 0)
                    {
                        //The total mean loss (MeanLossCur) consists of the mean loss within this interval (MeanLossCurInterval) and
                        //the fraction of previous samples.
                        hv_MeanLossCurInterval.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanLossCurInterval = ((hv_MeanLossCur * hv_NumMeanLossSamples) - (((hv_LossValues.TupleSelect(
                                hv_LossValueIdxsPrev))).TupleSum())) / hv_NumSamplesInterval;
                        }
                    }
                    else
                    {
                        //In this case the total mean loss is just the loss of this interval.
                        hv_MeanLossCurInterval.Dispose();
                        hv_MeanLossCurInterval = new HTuple(hv_MeanLossCur);
                    }
                    //
                    hv_LossValuesCurInterval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValuesCurInterval = HTuple.TupleGenConst(
                            hv_NumSamplesInterval, hv_MeanLossCurInterval);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LossValues = hv_LossValues.TupleConcat(
                                hv_LossValuesCurInterval);
                            hv_LossValues.Dispose();
                            hv_LossValues = ExpTmpLocalVar_LossValues;
                        }
                    }
                    //
                    //Pack the loss values into dictionaries.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TrainResultsRestored = hv_TrainResultsRestored.TupleConcat(
                                HTuple.TupleGenConst(hv_NumSamplesInterval, -1));
                            hv_TrainResultsRestored.Dispose();
                            hv_TrainResultsRestored = ExpTmpLocalVar_TrainResultsRestored;
                        }
                    }
                    HTuple end_val200 = hv_NumSamplesInterval - 1;
                    HTuple step_val200 = 1;
                    for (hv_IndexSample = 0; hv_IndexSample.Continue(end_val200, step_val200); hv_IndexSample = hv_IndexSample.TupleAdd(step_val200))
                    {
                        hv_TrainResult.Dispose();
                        HOperatorSet.CreateDict(out hv_TrainResult);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_TrainResult, hv_LossParam, hv_LossValuesCurInterval.TupleSelect(
                                hv_IndexSample));
                        }
                        if (hv_TrainResultsRestored == null)
                            hv_TrainResultsRestored = new HTuple();
                        hv_TrainResultsRestored[hv_CountSamples] = hv_TrainResult;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_CountSamples = hv_CountSamples + 1;
                                hv_CountSamples.Dispose();
                                hv_CountSamples = ExpTmpLocalVar_CountSamples;
                            }
                        }
                    }
                }
                //
                //Plot the current training status.
                if ((int)(hv_DisplayEnabled) != 0)
                {
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TrainInfos.TupleSelect((new HTuple(hv_TrainInfos.TupleLength()
                            )) - 1), "num_epochs", hv_NumEpochs);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        dev_display_update_train_dl_model(hv_TrainParam, hv_DisplayData, hv_TrainInfos.TupleSelect(
                            (new HTuple(hv_TrainInfos.TupleLength())) - 1), hv_DisplayLossEpochs, hv_DisplayLoss,
                            hv_DisplayLearningRates, hv_DisplayEvaluationEpochs, hv_DisplayValidationEvaluationValues,
                            hv_DisplayTrainEvaluationValues);
                    }
                }
                //
                //Return StartEpoch as number.
                hv_StartEpochNumber.Dispose();
                hv_StartEpochNumber = new HTuple(hv_StartEpoch_COPY_INP_TMP);
                //

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_TrainResults.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_FoundEpochs.Dispose();
                hv_FoundDicts.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Substrings.Dispose();
                hv_BaseFolder.Dispose();
                hv_Files.Dispose();
                hv_DictFiles.Dispose();
                hv_EpochStrings.Dispose();
                hv_EpochStringsNumbers.Dispose();
                hv_DictFileNames.Dispose();
                hv_IndexDict.Dispose();
                hv_DictFileName.Dispose();
                hv_InfoDicts.Dispose();
                hv_Epochs.Dispose();
                hv_ReadSuccess.Dispose();
                hv_InfoDict.Dispose();
                hv_Epoch.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_IndexEval.Dispose();
                hv_EvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_IndexTrain.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_ModelParams.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_LossParam.Dispose();
                hv_CountSamples.Dispose();
                hv_LossValues.Dispose();
                hv_NumMeanLossSamples.Dispose();
                hv_SamplesPerEpoch.Dispose();
                hv_MeanLossCur.Dispose();
                hv_NumSamplesInterval.Dispose();
                hv_LossValueIdxsPrev.Dispose();
                hv_MeanLossCurInterval.Dispose();
                hv_LossValuesCurInterval.Dispose();
                hv_IndexSample.Dispose();
                hv_TrainResult.Dispose();
                hv_NumEpochs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_TrainResults.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_FoundEpochs.Dispose();
                hv_FoundDicts.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Substrings.Dispose();
                hv_BaseFolder.Dispose();
                hv_Files.Dispose();
                hv_DictFiles.Dispose();
                hv_EpochStrings.Dispose();
                hv_EpochStringsNumbers.Dispose();
                hv_DictFileNames.Dispose();
                hv_IndexDict.Dispose();
                hv_DictFileName.Dispose();
                hv_InfoDicts.Dispose();
                hv_Epochs.Dispose();
                hv_ReadSuccess.Dispose();
                hv_InfoDict.Dispose();
                hv_Epoch.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_IndexEval.Dispose();
                hv_EvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_IndexTrain.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_ModelParams.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_LossParam.Dispose();
                hv_CountSamples.Dispose();
                hv_LossValues.Dispose();
                hv_NumMeanLossSamples.Dispose();
                hv_SamplesPerEpoch.Dispose();
                hv_MeanLossCur.Dispose();
                hv_NumSamplesInterval.Dispose();
                hv_LossValueIdxsPrev.Dispose();
                hv_MeanLossCurInterval.Dispose();
                hv_LossValuesCurInterval.Dispose();
                hv_IndexSample.Dispose();
                hv_TrainResult.Dispose();
                hv_NumEpochs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Scale and shift a DL model layer. 
        private void scale_and_shift_dl_model_layer(HTuple hv_DLModelHandle, HTuple hv_LayerName,
            HTuple hv_Scale, HTuple hv_Shift)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Weights, ho_Bias, ho_WeightsScaled;
            HObject ho_ChannelWeights = null, ho_ChannelWeightsScaled = null;
            HObject ho_BiasScaled;

            // Local control variables 

            HTuple hv_BiasTuple = new HTuple(), hv_NumOutputChannels = new HTuple();
            HTuple hv_BiasScaledTuple = new HTuple(), hv_OutputChannelIndex = new HTuple();
            HTuple hv_ChannelMult = new HTuple(), hv_ChannelAdd = new HTuple();
            HTuple hv_ChannelBias = new HTuple(), hv_ChannelBiasScaled = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Weights);
            HOperatorSet.GenEmptyObj(out ho_Bias);
            HOperatorSet.GenEmptyObj(out ho_WeightsScaled);
            HOperatorSet.GenEmptyObj(out ho_ChannelWeights);
            HOperatorSet.GenEmptyObj(out ho_ChannelWeightsScaled);
            HOperatorSet.GenEmptyObj(out ho_BiasScaled);
            try
            {
                //Get the original weights.
                ho_Weights.Dispose();
                HOperatorSet.GetDlModelLayerWeights(out ho_Weights, hv_DLModelHandle, hv_LayerName,
                    "weights");
                ho_Bias.Dispose();
                HOperatorSet.GetDlModelLayerWeights(out ho_Bias, hv_DLModelHandle, hv_LayerName,
                    "bias");
                hv_BiasTuple.Dispose();
                HOperatorSet.GetGrayval(ho_Bias, 0, 0, out hv_BiasTuple);
                hv_NumOutputChannels.Dispose();
                HOperatorSet.CountObj(ho_Weights, out hv_NumOutputChannels);
                //Create collections for the new weights and biases.
                ho_WeightsScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_WeightsScaled);
                hv_BiasScaledTuple.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BiasScaledTuple = HTuple.TupleGenConst(
                        hv_NumOutputChannels, 0);
                }
                //Iterate over the output channels.
                HTuple end_val9 = hv_NumOutputChannels - 1;
                HTuple step_val9 = 1;
                for (hv_OutputChannelIndex = 0; hv_OutputChannelIndex.Continue(end_val9, step_val9); hv_OutputChannelIndex = hv_OutputChannelIndex.TupleAdd(step_val9))
                {
                    hv_ChannelMult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChannelMult = hv_Scale.TupleSelect(
                            hv_OutputChannelIndex);
                    }
                    hv_ChannelAdd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChannelAdd = hv_Shift.TupleSelect(
                            hv_OutputChannelIndex);
                    }
                    //Get the weights and bias of this channel.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_ChannelWeights.Dispose();
                        HOperatorSet.SelectObj(ho_Weights, out ho_ChannelWeights, hv_OutputChannelIndex + 1);
                    }
                    hv_ChannelBias.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChannelBias = hv_BiasTuple.TupleSelect(
                            hv_OutputChannelIndex);
                    }
                    //Each weight scalar needs to be multiplied with ChannelMult.
                    ho_ChannelWeightsScaled.Dispose();
                    HOperatorSet.ScaleImage(ho_ChannelWeights, out ho_ChannelWeightsScaled, hv_ChannelMult,
                        0);
                    //The bias needs to be multiplied with ChannelMult and
                    //added to ChannelAdd.
                    hv_ChannelBiasScaled.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChannelBiasScaled = (hv_ChannelBias * hv_ChannelMult) + hv_ChannelAdd;
                    }
                    //Store the scaled weights and bias.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_WeightsScaled, ho_ChannelWeightsScaled, out ExpTmpOutVar_0
                            );
                        ho_WeightsScaled.Dispose();
                        ho_WeightsScaled = ExpTmpOutVar_0;
                    }
                    if (hv_BiasScaledTuple == null)
                        hv_BiasScaledTuple = new HTuple();
                    hv_BiasScaledTuple[hv_OutputChannelIndex] = hv_ChannelBiasScaled;
                }
                //Create the new bias image.
                ho_BiasScaled.Dispose();
                HOperatorSet.CopyImage(ho_Bias, out ho_BiasScaled);
                HOperatorSet.SetGrayval(ho_BiasScaled, 0, 0, hv_BiasScaledTuple);
                //Set the weights in the model.
                HOperatorSet.SetDlModelLayerWeights(ho_WeightsScaled, hv_DLModelHandle, hv_LayerName,
                    "weights");
                HOperatorSet.SetDlModelLayerWeights(ho_BiasScaled, hv_DLModelHandle, hv_LayerName,
                    "bias");
                ho_Weights.Dispose();
                ho_Bias.Dispose();
                ho_WeightsScaled.Dispose();
                ho_ChannelWeights.Dispose();
                ho_ChannelWeightsScaled.Dispose();
                ho_BiasScaled.Dispose();

                hv_BiasTuple.Dispose();
                hv_NumOutputChannels.Dispose();
                hv_BiasScaledTuple.Dispose();
                hv_OutputChannelIndex.Dispose();
                hv_ChannelMult.Dispose();
                hv_ChannelAdd.Dispose();
                hv_ChannelBias.Dispose();
                hv_ChannelBiasScaled.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Weights.Dispose();
                ho_Bias.Dispose();
                ho_WeightsScaled.Dispose();
                ho_ChannelWeights.Dispose();
                ho_ChannelWeightsScaled.Dispose();
                ho_BiasScaled.Dispose();

                hv_BiasTuple.Dispose();
                hv_NumOutputChannels.Dispose();
                hv_BiasScaledTuple.Dispose();
                hv_OutputChannelIndex.Dispose();
                hv_ChannelMult.Dispose();
                hv_ChannelAdd.Dispose();
                hv_ChannelBias.Dispose();
                hv_ChannelBiasScaled.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Filters / Arithmetic
        // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
        public void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min,
            HTuple hv_Max)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageSelected = null, ho_SelectedChannel = null;
            HObject ho_LowerRegion = null, ho_UpperRegion = null, ho_ImageSelectedScaled = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = new HObject(ho_Image);



            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
            HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
            HTuple hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageSelected);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
            try
            {
                //Convenience procedure to scale the gray values of the
                //input image Image from the interval [Min,Max]
                //to the interval [0,255] (default).
                //Gray values < 0 or > 255 (after scaling) are clipped.
                //
                //If the image shall be scaled to an interval different from [0,255],
                //this can be achieved by passing tuples with 2 values [From, To]
                //as Min and Max.
                //Example:
                //scale_image_range(Image:ImageScaled:[100,50],[200,250])
                //maps the gray values of Image from the interval [100,200] to [50,250].
                //All other gray values will be clipped.
                //
                //input parameters:
                //Image: the input image
                //Min: the minimum gray value which will be mapped to 0
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //Max: The maximum gray value which will be mapped to 255
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //
                //Output parameter:
                //ImageScale: the resulting scaled image.
                //
                if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_LowerLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Min_COPY_INP_TMP.Dispose();
                            hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
                        }
                    }
                }
                else
                {
                    hv_LowerLimit.Dispose();
                    hv_LowerLimit = 0.0;
                }
                if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_UpperLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Max_COPY_INP_TMP.Dispose();
                            hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
                        }
                    }
                }
                else
                {
                    hv_UpperLimit.Dispose();
                    hv_UpperLimit = 255.0;
                }
                //
                //Calculate scaling parameters.
                //Only scale if the scaling range is not zero.
                if ((int)((new HTuple(((((hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP)).TupleAbs()
                    )).TupleLess(1.0E-6))).TupleNot()) != 0)
                {
                    hv_Mult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()
                            ) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
                    }
                    hv_Add.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
                    }
                    //Scale image.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult,
                            hv_Add);
                        ho_Image_COPY_INP_TMP.Dispose();
                        ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Clip gray values if necessary.
                //This must be done for each image and channel separately.
                ho_ImageScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
                HTuple end_val51 = hv_NumImages;
                HTuple step_val51 = 1;
                for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val51, step_val51); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val51))
                {
                    ho_ImageSelected.Dispose();
                    HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
                    HTuple end_val54 = hv_Channels;
                    HTuple step_val54 = 1;
                    for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val54, step_val54); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val54))
                    {
                        ho_SelectedChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
                        hv_MinGray.Dispose(); hv_MaxGray.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray,
                            out hv_MaxGray, out hv_Range);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LowerRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
                                hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_UpperRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                                ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_LowerLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_UpperLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
                        {
                            ho_ImageSelectedScaled.Dispose();
                            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled,
                                1, 1);
                        }
                        else
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel,
                                    out ExpTmpOutVar_0);
                                ho_ImageSelectedScaled.Dispose();
                                ho_ImageSelectedScaled = ExpTmpOutVar_0;
                            }
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
                            );
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Serialize a DLModelHandle with current meta information. 
        private void serialize_train_dl_model_intermediate(HTuple hv_DLModelHandle, HTuple hv_Epoch,
            HTuple hv_EvaluationValueReduced, HTuple hv_Strategy, HTuple hv_TrainInfos,
            HTuple hv_EvaluationInfos, out HTuple hv_FilenameModel, out HTuple hv_FilenameMetaData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_Basename = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_Index = new HTuple(), hv_MetaData = new HTuple();
            // Initialize local and output iconic variables 
            hv_FilenameModel = new HTuple();
            hv_FilenameMetaData = new HTuple();
            try
            {
                //
                //Serialize the model DLModelHandle with current meta information.
                //
                //We need the type of strategy used.
                hv_Type.Dispose();
                HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);

                //Get basename/default.
                try
                {
                    hv_Basename.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "basename", out hv_Basename);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                    {
                        hv_Basename.Dispose();
                        hv_Basename = "model_at_epoch";
                    }
                    else
                    {
                        hv_Basename.Dispose();
                        hv_Basename = new HTuple(hv_Type);
                    }
                }
                //
                //If we serialize epochs and only one basename is given,
                //we need to add the current epoch to it.
                //If a basename has been specified for each epoch,
                //appending the current epoch is not necessary.
                if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                {
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "epochs", out hv_Epochs);
                    if ((int)(new HTuple((new HTuple(hv_Basename.TupleLength())).TupleEqual(new HTuple(hv_Epochs.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Index.Dispose();
                            HOperatorSet.TupleFindLast(hv_Epoch.TupleLessElem(hv_Epochs), 0, out hv_Index);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Basename = hv_Basename.TupleSelect(
                                    hv_Index);
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpLocalVar_Basename;
                            }
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Basename = (hv_Basename + "_") + (hv_Epoch.TupleString(
                                    ".2f"));
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpLocalVar_Basename;
                            }
                        }
                    }
                }
                //
                //Filenames.
                hv_FilenameModel.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FilenameModel = hv_Basename + ".hdl";
                }
                hv_FilenameMetaData.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FilenameMetaData = hv_Basename + "_info.hdict";
                }
                //
                //Metadata.
                hv_MetaData.Dispose();
                HOperatorSet.CreateDict(out hv_MetaData);
                HOperatorSet.SetDictTuple(hv_MetaData, "train_infos", hv_TrainInfos);
                HOperatorSet.SetDictTuple(hv_MetaData, "evaluation_infos", hv_EvaluationInfos);
                HOperatorSet.SetDictTuple(hv_MetaData, "epoch", hv_Epoch);
                if ((int)(new HTuple((new HTuple(hv_EvaluationValueReduced.TupleLength())).TupleGreaterEqual(
                    1))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_MetaData, "best_value", hv_EvaluationValueReduced);
                }
                //
                //Write files.
                HOperatorSet.WriteDlModel(hv_DLModelHandle, hv_FilenameModel);
                HOperatorSet.WriteDict(hv_MetaData, hv_FilenameMetaData, new HTuple(), new HTuple());

                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Exception.Dispose();
                hv_Epochs.Dispose();
                hv_Index.Dispose();
                hv_MetaData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Exception.Dispose();
                hv_Epochs.Dispose();
                hv_Index.Dispose();
                hv_MetaData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Text
        // Short Description: Set font independent of OS 
        public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
            HTuple hv_Bold, HTuple hv_Slant)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
            HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
            HTuple hv_Indices = new HTuple();
            HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
            HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

            // Initialize local and output iconic variables 
            try
            {
                //This procedure sets the text font of the current window with
                //the specified attributes.
                //
                //Input parameters:
                //WindowHandle: The graphics window for which the font will be set
                //Size: The font size. If Size=-1, the default of 16 is used.
                //Bold: If set to 'true', a bold font is used
                //Slant: If set to 'true', a slanted font is used
                //
                hv_OS.Dispose();
                HOperatorSet.GetSystem("operating_system", out hv_OS);
                if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                {
                    hv_Size_COPY_INP_TMP.Dispose();
                    hv_Size_COPY_INP_TMP = 16;
                }
                if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                {
                    //Restore previous behavior
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Courier";
                    hv_Fonts[1] = "Courier 10 Pitch";
                    hv_Fonts[2] = "Courier New";
                    hv_Fonts[3] = "CourierNew";
                    hv_Fonts[4] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Consolas";
                    hv_Fonts[1] = "Menlo";
                    hv_Fonts[2] = "Courier";
                    hv_Fonts[3] = "Courier 10 Pitch";
                    hv_Fonts[4] = "FreeMono";
                    hv_Fonts[5] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Luxi Sans";
                    hv_Fonts[1] = "DejaVu Sans";
                    hv_Fonts[2] = "FreeSans";
                    hv_Fonts[3] = "Arial";
                    hv_Fonts[4] = "Liberation Sans";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Times New Roman";
                    hv_Fonts[1] = "Luxi Serif";
                    hv_Fonts[2] = "DejaVu Serif";
                    hv_Fonts[3] = "FreeSerif";
                    hv_Fonts[4] = "Utopia";
                    hv_Fonts[5] = "Liberation Serif";
                }
                else
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
                }
                hv_Style.Dispose();
                hv_Style = "";
                if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Bold";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Bold";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Italic";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Slant";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
                {
                    hv_Style.Dispose();
                    hv_Style = "Normal";
                }
                hv_AvailableFonts.Dispose();
                HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
                hv_Font_COPY_INP_TMP.Dispose();
                hv_Font_COPY_INP_TMP = "";
                for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
                {
                    hv_Indices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices = hv_AvailableFonts.TupleFind(
                            hv_Fonts.TupleSelect(hv_Fdx));
                    }
                    if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                        {
                            hv_Font_COPY_INP_TMP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                    hv_Fdx);
                            }
                            break;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
                {
                    throw new HalconException("Wrong value of control parameter Font");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                        hv_Font_COPY_INP_TMP.Dispose();
                        hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                    }
                }
                HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Split rectangle2 into a number of rectangles. 
        private void split_rectangle2(HTuple hv_Row, HTuple hv_Column, HTuple hv_Phi,
            HTuple hv_Length1, HTuple hv_Length2, HTuple hv_NumSplits, out HTuple hv_SplitRow,
            out HTuple hv_SplitColumn, out HTuple hv_SplitPhi, out HTuple hv_SplitLength1Out,
            out HTuple hv_SplitLength2Out)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SplitLength = new HTuple(), hv_TRow = new HTuple();
            HTuple hv_TCol = new HTuple(), hv_HomMat2D = new HTuple();
            // Initialize local and output iconic variables 
            hv_SplitRow = new HTuple();
            hv_SplitColumn = new HTuple();
            hv_SplitPhi = new HTuple();
            hv_SplitLength1Out = new HTuple();
            hv_SplitLength2Out = new HTuple();
            try
            {
                if ((int)(new HTuple(hv_NumSplits.TupleGreater(0))) != 0)
                {
                    hv_SplitLength.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SplitLength = hv_Length1 / (hv_NumSplits.TupleReal()
                            );
                    }
                    //Assume center (0,0), transform afterwards.
                    hv_TRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TRow = HTuple.TupleGenConst(
                            hv_NumSplits, 0.0);
                    }
                    hv_TCol.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TCol = ((-hv_Length1) + hv_SplitLength) + ((HTuple.TupleGenSequence(
                            0, hv_NumSplits - 1, 1) * 2) * hv_SplitLength);
                    }
                    hv_HomMat2D.Dispose();
                    HOperatorSet.HomMat2dIdentity(out hv_HomMat2D);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.HomMat2dRotate(hv_HomMat2D, hv_Phi, 0, 0, out ExpTmpOutVar_0);
                        hv_HomMat2D.Dispose();
                        hv_HomMat2D = ExpTmpOutVar_0;
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.HomMat2dTranslate(hv_HomMat2D, hv_Row, hv_Column, out ExpTmpOutVar_0);
                        hv_HomMat2D.Dispose();
                        hv_HomMat2D = ExpTmpOutVar_0;
                    }
                    hv_SplitLength1Out.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SplitLength1Out = HTuple.TupleGenConst(
                            hv_NumSplits, hv_SplitLength);
                    }
                    hv_SplitLength2Out.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SplitLength2Out = HTuple.TupleGenConst(
                            hv_NumSplits, hv_Length2);
                    }
                    hv_SplitPhi.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SplitPhi = HTuple.TupleGenConst(
                            hv_NumSplits, hv_Phi);
                    }
                    hv_SplitRow.Dispose(); hv_SplitColumn.Dispose();
                    HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_TRow, hv_TCol, out hv_SplitRow,
                        out hv_SplitColumn);
                }
                else
                {
                    throw new HalconException("Number of splits must be greater than 0.");
                }

                hv_SplitLength.Dispose();
                hv_TRow.Dispose();
                hv_TCol.Dispose();
                hv_HomMat2D.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SplitLength.Dispose();
                hv_TRow.Dispose();
                hv_TCol.Dispose();
                hv_HomMat2D.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Apply the given thresholds on anomaly detection and Global Context Anomaly Detection results for image classification and region segmentation. 
        public void threshold_dl_anomaly_results(HTuple hv_AnomalySegmentationThreshold,
            HTuple hv_AnomalyClassificationThreshold, HTuple hv_DLResults)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_AnomalyRegion = null;

            // Local control variables 

            HTuple hv_DLResultIndex = new HTuple(), hv_DLResult = new HTuple();
            HTuple hv_DLResultKeys = new HTuple(), hv_ImageKeys = new HTuple();
            HTuple hv_ScoreKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_AnomalyImageRegionType = new HTuple(), hv_AnomalyRegionName = new HTuple();
            HTuple hv_AnomalyScoreType = new HTuple(), hv_AnomalyScoreName = new HTuple();
            HTuple hv_AnomalyScore = new HTuple(), hv_AnomalyClassName = new HTuple();
            HTuple hv_AnomalyClassIDName = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            try
            {
                //This procedure applies given thresholds on anomaly detection (AD)
                //or Global Context Anomaly Detection (GC-AD) results.
                //The thresholds are used for:
                //
                //1. Region segmentation: AnomalySegmentationThreshold is used as threshold
                //whether a pixel within the anomaly image belongs to a region of an anomaly.
                //The region is returned in DLResult under one of the following keys, depending on
                //the anomaly image key stored in the DLResult:
                //- 'anomaly_region' (AD, GC_AD)
                //- 'anomaly_region_local' (GC-AD)
                //- 'anomaly_region_global' (GC-AD)
                //2. Image classification: AnomalyClassificationThreshold is used as threshold
                //whether the image is classified as containing an anomaly ('nok' / class_id: 1) or not ('ok' / class_id: 0).
                //The class is returned in DLResult under one of the following keys:
                //- 'anomaly_class' (AD, GC_AD): The classification result as a string ('ok' or 'nok').
                //- 'anomaly_class_local' (GC-AD): The classification result as a string ('ok' or 'nok').
                //- 'anomaly_class_global' (GC-AD): The classification result as a string ('ok' or 'nok').
                //- 'anomaly_class_id' (AD, GC_AD): The classification result as an integer (0 or 1).
                //- 'anomaly_class_id_local' (GC-AD): The classification result as an integer (0 or 1).
                //- 'anomaly_class_id_global' (GC-AD): The classification result as an integer (0 or 1).
                //
                //The applied thresholds are also stored in DLResult.
                //
                //Check for invalid AnomalySegmentationThreshold.
                if ((int)(new HTuple((new HTuple(hv_AnomalySegmentationThreshold.TupleLength()
                    )).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException("AnomalySegmentationThreshold must be specified by exactly one value.");
                }
                //
                //Check for invalid AnomalyClassificationThreshold.
                if ((int)(new HTuple((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                    )).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException("AnomalyClassificationThreshold must be specified by exactly one value.");
                }
                //
                //Evaluate each DLResult.
                for (hv_DLResultIndex = 0; (int)hv_DLResultIndex <= (int)((new HTuple(hv_DLResults.TupleLength()
                    )) - 1); hv_DLResultIndex = (int)hv_DLResultIndex + 1)
                {
                    //
                    //Read anomaly image and anomaly score from DLResult.
                    hv_DLResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLResult = hv_DLResults.TupleSelect(
                            hv_DLResultIndex);
                    }
                    hv_DLResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_DLResultKeys);
                    hv_ImageKeys.Dispose();
                    HOperatorSet.TupleRegexpSelect(hv_DLResultKeys, ".*_image.*", out hv_ImageKeys);
                    hv_ScoreKeys.Dispose();
                    HOperatorSet.TupleRegexpSelect(hv_DLResultKeys, ".*_score.*", out hv_ScoreKeys);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleSort(hv_ImageKeys, out ExpTmpOutVar_0);
                        hv_ImageKeys.Dispose();
                        hv_ImageKeys = ExpTmpOutVar_0;
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleSort(hv_ScoreKeys, out ExpTmpOutVar_0);
                        hv_ScoreKeys.Dispose();
                        hv_ScoreKeys = ExpTmpOutVar_0;
                    }
                    if ((int)((new HTuple(hv_ImageKeys.TupleEqual(new HTuple()))).TupleOr(new HTuple(hv_ScoreKeys.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        throw new HalconException(new HTuple("DLResult must contain keys 'anomaly_image' (local, global) and 'anomaly_score' (local, global)."));
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageKeys.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        //Apply AnomalyThreshold to the anomaly image.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_AnomalyImage.Dispose();
                            HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, hv_ImageKeys.TupleSelect(
                                hv_Index));
                        }
                        ho_AnomalyRegion.Dispose();
                        HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalySegmentationThreshold,
                            "max");
                        //
                        //Write AnomalyRegion to DLResult.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyImageRegionType.Dispose();
                            HOperatorSet.TupleRegexpMatch(hv_ImageKeys.TupleSelect(hv_Index), "anomaly_image(.*)",
                                out hv_AnomalyImageRegionType);
                        }
                        hv_AnomalyRegionName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyRegionName = "anomaly_region" + hv_AnomalyImageRegionType;
                        }
                        HOperatorSet.SetDictObject(ho_AnomalyRegion, hv_DLResult, hv_AnomalyRegionName);
                        //
                        //Classify sample as 'ok' or 'nok'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScoreType.Dispose();
                            HOperatorSet.TupleRegexpMatch(hv_ScoreKeys.TupleSelect(hv_Index), "anomaly_score(.*)",
                                out hv_AnomalyScoreType);
                        }
                        hv_AnomalyScoreName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyScoreName = hv_ScoreKeys.TupleSelect(
                                hv_Index);
                        }
                        hv_AnomalyScore.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, hv_AnomalyScoreName, out hv_AnomalyScore);
                        hv_AnomalyClassName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyClassName = "anomaly_class" + hv_AnomalyScoreType;
                        }
                        hv_AnomalyClassIDName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AnomalyClassIDName = "anomaly_class_id" + hv_AnomalyScoreType;
                        }
                        if ((int)(new HTuple(hv_AnomalyScore.TupleLess(hv_AnomalyClassificationThreshold))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLResult, hv_AnomalyClassName, "ok");
                            HOperatorSet.SetDictTuple(hv_DLResult, hv_AnomalyClassIDName, 0);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_DLResult, hv_AnomalyClassName, "nok");
                            HOperatorSet.SetDictTuple(hv_DLResult, hv_AnomalyClassIDName, 1);
                        }
                    }
                    //
                    //Write anomaly thresholds to DLResult.
                    HOperatorSet.SetDictTuple(hv_DLResult, "anomaly_classification_threshold",
                        hv_AnomalyClassificationThreshold);
                    HOperatorSet.SetDictTuple(hv_DLResult, "anomaly_segmentation_threshold",
                        hv_AnomalySegmentationThreshold);
                }
                //
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_DLResultIndex.Dispose();
                hv_DLResult.Dispose();
                hv_DLResultKeys.Dispose();
                hv_ImageKeys.Dispose();
                hv_ScoreKeys.Dispose();
                hv_Index.Dispose();
                hv_AnomalyImageRegionType.Dispose();
                hv_AnomalyRegionName.Dispose();
                hv_AnomalyScoreType.Dispose();
                hv_AnomalyScoreName.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassName.Dispose();
                hv_AnomalyClassIDName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_DLResultIndex.Dispose();
                hv_DLResult.Dispose();
                hv_DLResultKeys.Dispose();
                hv_ImageKeys.Dispose();
                hv_ScoreKeys.Dispose();
                hv_Index.Dispose();
                hv_AnomalyImageRegionType.Dispose();
                hv_AnomalyRegionName.Dispose();
                hv_AnomalyScoreType.Dispose();
                hv_AnomalyScoreName.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassName.Dispose();
                hv_AnomalyClassIDName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: System / Operating System
        // Short Description: Create a formatted string of a time span. 
        public void timespan_string(HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
            HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
            HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
            HTuple hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

            // Initialize local and output iconic variables 
            hv_TimeString = new HTuple();
            try
            {
                //
                //This procedure creates a readable representation of a time span
                //given the elapsed time in seconds.
                //
                //Ensure that the input is an integer.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
                            ;
                        hv_TotalSeconds_COPY_INP_TMP.Dispose();
                        hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
                    }
                }
                //
                hv_Seconds.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Seconds = hv_TotalSeconds_COPY_INP_TMP % 60;
                }
                //
                hv_TotalMinutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP / 60;
                }
                hv_Minutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Minutes = hv_TotalMinutes % 60;
                }
                //
                hv_TotalHours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP / 3600;
                }
                hv_Hours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Hours = hv_TotalHours % 24;
                }
                //
                hv_Days.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Days = hv_TotalSeconds_COPY_INP_TMP / 86400;
                }
                //
                if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
                {
                    //Print the highest non-zero unit and all remaining sub-units.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                                "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                                "d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
                {
                    //Print the highest non-zero unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Days.TupleString(
                                "d")) + "d";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Hours.TupleString(
                                "d")) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Minutes.TupleString(
                                "d")) + "m";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
                {
                    //Print the highest non-zero unit and the following sub-unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
                {
                    //Print a Days-Hours-Minutes-Seconds string.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                            "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
                {
                    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((hv_TotalHours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                            "d"))) + "s";
                    }
                }
                else
                {
                    throw new HalconException("Unknown format string.");
                }
                //

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Train a deep-learning-based model on a dataset. 
        public void train_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_TrainParam,
            HTuple hv_StartEpoch, out HTuple hv_TrainResults, out HTuple hv_TrainInfos,
            out HTuple hv_EvaluationInfos)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_TrainSampleIndices = new HTuple(), hv_NumTrainSamples = new HTuple();
            HTuple hv_EvaluationComparisonKeyExist = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_EvaluationOptimizationMethod = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_SeedRand = new HTuple();
            HTuple hv_SampleIndicesTrainRaw = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Shuffled = new HTuple(), hv_SampleSeedsTrainRaw = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_EvaluateBeforeTraining = new HTuple();
            HTuple hv_ChangeStrategyData = new HTuple(), hv_SerializationData = new HTuple();
            HTuple hv_DisplayData = new HTuple(), hv_DisplayEnabled = new HTuple();
            HTuple hv_DisplayPreviewInitialized = new HTuple(), hv_DisplayEvaluationEpochs = new HTuple();
            HTuple hv_DisplayValidationEvaluationValues = new HTuple();
            HTuple hv_DisplayTrainEvaluationValues = new HTuple();
            HTuple hv_DisplayLossEpochs = new HTuple(), hv_DisplayLoss = new HTuple();
            HTuple hv_DisplayLearningRates = new HTuple(), hv_TrainResultsRestored = new HTuple();
            HTuple hv_StartTime = new HTuple(), hv_ThresholdInformation = new HTuple();
            HTuple hv_FirstIteration = new HTuple(), hv_Epoch = new HTuple();
            HTuple hv_Iteration = new HTuple(), hv_NumIterationsPerEpoch = new HTuple();
            HTuple hv_BatchSizeDevice = new HTuple(), hv_BatchSizeMultiplier = new HTuple();
            HTuple hv_BatchSizeModel = new HTuple(), hv_NumIterations = new HTuple();
            HTuple hv_SampleIndicesTrain = new HTuple(), hv_IterationEvaluateOnly = new HTuple();
            HTuple hv_BatchStart = new HTuple(), hv_BatchEnd = new HTuple();
            HTuple hv_BatchIndices = new HTuple(), hv_DLSampleBatch = new HTuple();
            HTuple hv_AugmentationParam = new HTuple(), hv_TrainResult = new HTuple();
            HTuple hv_EvaluationIntervalEpochs = new HTuple(), hv_EvaluationInterval = new HTuple();
            HTuple hv_ValidationEvaluationResult = new HTuple(), hv_TrainEvaluationResult = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_SelectPercentageTrainSamples = new HTuple();
            HTuple hv_EvaluationParam = new HTuple(), hv__ = new HTuple();
            HTuple hv_TrainEvaluationRatio = new HTuple(), hv_NumTrainEvaluationSampleIndices = new HTuple();
            HTuple hv_TrainEvaluationSampleIndices = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_EvaluationInfo = new HTuple();
            HTuple hv_Valuevalidation = new HTuple(), hv_ValueTrain = new HTuple();
            HTuple hv_TrainInfoUpdateIntervalSeconds = new HTuple();
            HTuple hv_LastUpdate = new HTuple(), hv_Seconds = new HTuple();
            HTuple hv_NumSamplesMeanLoss = new HTuple(), hv_TrainInfo = new HTuple();
            HTuple hv_UpdateTime = new HTuple(), hv_EpochsStatus = new HTuple();
            HTuple hv_MeanLoss = new HTuple(), hv_DisplayLearningRate = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_UpdateImagesIntervalEpochs = new HTuple();
            HTuple hv_UpdateImagesInterval = new HTuple(), hv_WindowImages = new HTuple();
            HTuple hv_FirstCall = new HTuple(), hv_GenParamTiled = new HTuple();
            HTuple hv_TrainParamAnomaly = new HTuple(), hv_WindowHandleInfo = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_0 = new HTuple();
            HTuple hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_StartEpoch);

            // Initialize local and output iconic variables 
            hv_TrainResults = new HTuple();
            hv_TrainInfos = new HTuple();
            hv_EvaluationInfos = new HTuple();
            try
            {
                //
                //This procedure contains all steps for training a model given through DLModelHandle
                //on a dataset DLDataset.
                //The required training parameters are provided through the dictionary TrainParam,
                //which can be created by create_dl_train_param.
                //The training is started at StartEpoch, which allows resuming the training of a model.
                //In case of models of type 'anomaly_detection', training cannot be resumed and hence,
                //StartEpoch is always 0.
                //
                //The procedure returns three dictionaries:
                //- TrainResults: Collected results returned by train_dl_model_batch of every iteration.
                //                For models of type 'anomaly_detection': The final error and the final epoch.
                //- TrainInfo: Collected information of the training progress. This dictionary is empty
                //             for models of type 'anomaly_detection'.
                //- EvaluationInfos: Evaluation results collected during training. This dictionary is empty
                //                   for models of type 'anomaly_detection'.
                //
                //Get the model type.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual(
                    "anomaly_detection"))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("classification"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "gc_anomaly_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "ocr_detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("ocr_recognition"))))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("segmentation"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "3d_gripping_point_detection")))) != 0)
                {
                    throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
                }
                //
                //Get the samples for training.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_TrainSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_TrainSampleIndices);
                hv_NumTrainSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumTrainSamples = new HTuple(hv_TrainSampleIndices.TupleLength()
                        );
                }
                //
                //Check inconsistent training parameters.
                check_train_dl_model_params(hv_DLDataset, hv_DLModelHandle, hv_NumTrainSamples,
                    hv_StartEpoch_COPY_INP_TMP, hv_TrainParam);
                //
                //Determine evaluation optimization method.
                hv_EvaluationComparisonKeyExist.Dispose();
                HOperatorSet.GetDictParam(hv_TrainParam, "key_exists", "evaluation_comparison_keys",
                    out hv_EvaluationComparisonKeyExist);
                if ((int)(hv_EvaluationComparisonKeyExist) != 0)
                {
                    hv_EvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
                    hv_EvaluationOptimizationMethod.Dispose();
                    get_dl_evaluation_optimization_method(hv_EvaluationComparisonKeys, out hv_EvaluationOptimizationMethod);
                }
                //
                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Check if training is required.
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    if ((int)(hv_StartEpoch_COPY_INP_TMP.TupleIsNumber()) != 0)
                    {
                        if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleGreaterEqual(hv_NumEpochs))) != 0)
                        {
                            //Nothing to do.

                            hv_StartEpoch_COPY_INP_TMP.Dispose();
                            hv_ModelType.Dispose();
                            hv_DLSamples.Dispose();
                            hv_TrainSampleIndices.Dispose();
                            hv_NumTrainSamples.Dispose();
                            hv_EvaluationComparisonKeyExist.Dispose();
                            hv_EvaluationComparisonKeys.Dispose();
                            hv_EvaluationOptimizationMethod.Dispose();
                            hv_NumEpochs.Dispose();
                            hv_SeedRand.Dispose();
                            hv_SampleIndicesTrainRaw.Dispose();
                            hv_Index.Dispose();
                            hv_Shuffled.Dispose();
                            hv_SampleSeedsTrainRaw.Dispose();
                            hv_BatchSize.Dispose();
                            hv_EvaluateBeforeTraining.Dispose();
                            hv_ChangeStrategyData.Dispose();
                            hv_SerializationData.Dispose();
                            hv_DisplayData.Dispose();
                            hv_DisplayEnabled.Dispose();
                            hv_DisplayPreviewInitialized.Dispose();
                            hv_DisplayEvaluationEpochs.Dispose();
                            hv_DisplayValidationEvaluationValues.Dispose();
                            hv_DisplayTrainEvaluationValues.Dispose();
                            hv_DisplayLossEpochs.Dispose();
                            hv_DisplayLoss.Dispose();
                            hv_DisplayLearningRates.Dispose();
                            hv_TrainResultsRestored.Dispose();
                            hv_StartTime.Dispose();
                            hv_ThresholdInformation.Dispose();
                            hv_FirstIteration.Dispose();
                            hv_Epoch.Dispose();
                            hv_Iteration.Dispose();
                            hv_NumIterationsPerEpoch.Dispose();
                            hv_BatchSizeDevice.Dispose();
                            hv_BatchSizeMultiplier.Dispose();
                            hv_BatchSizeModel.Dispose();
                            hv_NumIterations.Dispose();
                            hv_SampleIndicesTrain.Dispose();
                            hv_IterationEvaluateOnly.Dispose();
                            hv_BatchStart.Dispose();
                            hv_BatchEnd.Dispose();
                            hv_BatchIndices.Dispose();
                            hv_DLSampleBatch.Dispose();
                            hv_AugmentationParam.Dispose();
                            hv_TrainResult.Dispose();
                            hv_EvaluationIntervalEpochs.Dispose();
                            hv_EvaluationInterval.Dispose();
                            hv_ValidationEvaluationResult.Dispose();
                            hv_TrainEvaluationResult.Dispose();
                            hv_DisplayParam.Dispose();
                            hv_SelectPercentageTrainSamples.Dispose();
                            hv_EvaluationParam.Dispose();
                            hv__.Dispose();
                            hv_TrainEvaluationRatio.Dispose();
                            hv_NumTrainEvaluationSampleIndices.Dispose();
                            hv_TrainEvaluationSampleIndices.Dispose();
                            hv_Exception.Dispose();
                            hv_EvaluationInfo.Dispose();
                            hv_Valuevalidation.Dispose();
                            hv_ValueTrain.Dispose();
                            hv_TrainInfoUpdateIntervalSeconds.Dispose();
                            hv_LastUpdate.Dispose();
                            hv_Seconds.Dispose();
                            hv_NumSamplesMeanLoss.Dispose();
                            hv_TrainInfo.Dispose();
                            hv_UpdateTime.Dispose();
                            hv_EpochsStatus.Dispose();
                            hv_MeanLoss.Dispose();
                            hv_DisplayLearningRate.Dispose();
                            hv_NumImages.Dispose();
                            hv_UpdateImagesIntervalEpochs.Dispose();
                            hv_UpdateImagesInterval.Dispose();
                            hv_WindowImages.Dispose();
                            hv_FirstCall.Dispose();
                            hv_GenParamTiled.Dispose();
                            hv_TrainParamAnomaly.Dispose();
                            hv_WindowHandleInfo.Dispose();
                            hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                            hv___Tmp_Ctrl_0.Dispose();

                            return;
                        }
                    }
                    //
                    //Set random seed according to parameter value.
                    hv_SeedRand.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "seed_rand", out hv_SeedRand);
                    if ((int)(new HTuple((new HTuple(hv_SeedRand.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //Note, that setting this random seed will not enforce every training to
                        //result in the exact same model because the cuDNN library uses approximate
                        //algorithms on some architectures.
                        //If you want to enforce bit-wise reproducibility, you should also set:
                        //   'set_system('cudnn_deterministic', 'true')'
                        //However, this can slow down computations on some architectures.
                        HOperatorSet.SetSystem("seed_rand", hv_SeedRand);
                    }
                    //
                    //Generate a random sample index for the whole training independent of batch size.
                    hv_SampleIndicesTrainRaw.Dispose();
                    hv_SampleIndicesTrainRaw = new HTuple();
                    HTuple end_val63 = (hv_NumEpochs.TupleCeil()
                        ) - 1;
                    HTuple step_val63 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val63, step_val63); hv_Index = hv_Index.TupleAdd(step_val63))
                    {
                        hv_Shuffled.Dispose();
                        tuple_shuffle(hv_TrainSampleIndices, out hv_Shuffled);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_SampleIndicesTrainRaw = hv_SampleIndicesTrainRaw.TupleConcat(
                                    hv_Shuffled);
                                hv_SampleIndicesTrainRaw.Dispose();
                                hv_SampleIndicesTrainRaw = ExpTmpLocalVar_SampleIndicesTrainRaw;
                            }
                        }
                    }
                    //
                    //Generate a random seed pool for the whole training independent of batch size.
                    hv_SampleSeedsTrainRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleSeedsTrainRaw = (new HTuple((((new HTuple(2)).TuplePow(
                            31)) - 1) * HTuple.TupleRand(new HTuple(hv_SampleIndicesTrainRaw.TupleLength()
                            )))).TupleInt();
                    }
                    //
                    //Initialize the variables for the training.
                    //
                    //Initialize the batch size with an invalid value so that
                    //the while loop will initialize all values directly.
                    hv_BatchSize.Dispose();
                    hv_BatchSize = -1;
                    //Initialize iteration overhead parameter to 0 or 1.
                    //0: if no evaluation before training is performed
                    //1: if evaluation before training is performed
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "true");
                    hv_EvaluateBeforeTraining.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluateBeforeTraining = ((hv_TrainParam.TupleConcat(
                            hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem("evaluate_before_train",
                            "comp");
                    }
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                            "HNULL");
                    }
                    //
                    //Initialize change strategies.
                    hv_ChangeStrategyData.Dispose();
                    init_train_dl_model_change_strategies(hv_TrainParam, out hv_ChangeStrategyData);
                    //
                    //Initialize serialization strategies.
                    hv_SerializationData.Dispose();
                    init_train_dl_model_serialization_strategies(hv_TrainParam, out hv_SerializationData);
                    //
                    //Initialize visualizations if enabled.
                    hv_DisplayData.Dispose();
                    dev_display_init_train_dl_model(hv_DLModelHandle, hv_TrainParam, out hv_DisplayData);
                    hv_DisplayEnabled.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                    hv_DisplayPreviewInitialized.Dispose();
                    hv_DisplayPreviewInitialized = 0;
                    //
                    //Initialize parameters to start new or resume previous training.
                    hv_EvaluationInfos.Dispose(); hv_TrainInfos.Dispose(); hv_DisplayEvaluationEpochs.Dispose(); hv_DisplayValidationEvaluationValues.Dispose(); hv_DisplayTrainEvaluationValues.Dispose(); hv_DisplayLossEpochs.Dispose(); hv_DisplayLoss.Dispose(); hv_DisplayLearningRates.Dispose(); hv_TrainResultsRestored.Dispose();
                    {
                        HTuple ExpTmpOutVar_0;
                        restore_dl_train_info_for_resuming(hv_StartEpoch_COPY_INP_TMP, hv_SerializationData,
                            hv_TrainParam, hv_DisplayData, out hv_EvaluationInfos, out hv_TrainInfos,
                            out hv_DisplayEvaluationEpochs, out hv_DisplayValidationEvaluationValues,
                            out hv_DisplayTrainEvaluationValues, out hv_DisplayLossEpochs, out hv_DisplayLoss,
                            out hv_DisplayLearningRates, out hv_TrainResultsRestored, out ExpTmpOutVar_0);
                        hv_StartEpoch_COPY_INP_TMP.Dispose();
                        hv_StartEpoch_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    //
                    //Start time for measurement of elapsed training time.
                    hv_StartTime.Dispose();
                    HOperatorSet.CountSeconds(out hv_StartTime);
                    //
                    //In case of a 'gc_anomaly_detection' model it is necessary to normalize
                    //the model outputs before training.
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("gc_anomaly_detection"))) != 0)
                    {
                        if ((int)(hv_DisplayEnabled) != 0)
                        {
                            hv_ThresholdInformation.Dispose();
                            hv_ThresholdInformation = new HTuple();
                            hv_ThresholdInformation[0] = "Preparing the model for training";
                            hv_ThresholdInformation[1] = "by analyzing image statistics...";
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ThresholdInformation,
                                    "window", "top", "left", "black", "box", "false");
                            }
                            hv___Tmp_Ctrl_0.Dispose();
                            HOperatorSet.CountSeconds(out hv___Tmp_Ctrl_0);
                            HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv___Tmp_Ctrl_0);
                        }
                        normalize_dl_gc_anomaly_features(hv_DLDataset, hv_DLModelHandle, new HTuple());
                    }
                    //
                    //The while loop needs to know if it is the very first iteration.
                    hv_FirstIteration.Dispose();
                    hv_FirstIteration = 1;
                    while ((int)(1) != 0)
                    {
                        //Do some initializations only for the very first iteration.
                        if ((int)(hv_FirstIteration) != 0)
                        {
                            //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
                            hv_Epoch.Dispose();
                            hv_Epoch = new HTuple(hv_StartEpoch_COPY_INP_TMP);
                        }
                        else
                        {
                            hv_Epoch.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Epoch = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                                    );
                            }
                        }
                        //
                        //Update any parameters based on strategies.
                        update_train_dl_model_change_strategies(hv_DLModelHandle, hv_ChangeStrategyData,
                            hv_Epoch);
                        //
                        //Check if the current batch size and total model batch size differ.
                        hv_BatchSizeDevice.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                        hv_BatchSizeMultiplier.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier",
                            out hv_BatchSizeMultiplier);
                        hv_BatchSizeModel.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BatchSizeModel = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                        }
                        //
                        if ((int)((new HTuple(hv_BatchSize.TupleNotEqual(hv_BatchSizeModel))).TupleOr(
                            hv_FirstIteration)) != 0)
                        {
                            //Set the current value.
                            hv_BatchSize.Dispose();
                            hv_BatchSize = new HTuple(hv_BatchSizeModel);
                            //Now, we compute all values which are related to the batch size of the model.
                            //That way, the batch_size can be changed during the training without issues.
                            //All inputs/outputs/visualizations are based on epochs.
                            //
                            //Calculate total number of iterations.
                            hv_NumIterationsPerEpoch.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumIterationsPerEpoch = ((((hv_NumTrainSamples / (hv_BatchSize.TupleReal()
                                    ))).TupleFloor())).TupleInt();
                            }
                            hv_NumIterations.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumIterations = ((hv_NumIterationsPerEpoch * hv_NumEpochs)).TupleInt()
                                    ;
                            }
                            //Select those indices that fit into the batch size.
                            hv_SampleIndicesTrain.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SampleIndicesTrain = hv_SampleIndicesTrainRaw.TupleSelectRange(
                                    0, (hv_NumIterations * hv_BatchSize) - 1);
                            }
                            //The TrainResults tuple will be updated every iteration.
                            //Hence, we initialize it as a constant tuple for speedup.
                            //It is based on the iterations and hence cannot be reused if the batch size changes.
                            hv_TrainResults.Dispose();
                            HOperatorSet.TupleGenConst(hv_NumIterations, -1, out hv_TrainResults);
                            if ((int)(hv_FirstIteration.TupleNot()) != 0)
                            {
                                hv_Iteration.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Iteration = (((((hv_Epoch.TupleReal()
                                        ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                                }
                                hv_Epoch.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Epoch = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                                        );
                                }
                            }
                        }
                        //
                        //In the first iteration do some initializations.
                        if ((int)(hv_FirstIteration) != 0)
                        {
                            //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
                            hv_Iteration.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Iteration = (((((hv_StartEpoch_COPY_INP_TMP.TupleReal()
                                    ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                            }
                            hv_FirstIteration.Dispose();
                            hv_FirstIteration = 0;
                            if ((int)(new HTuple((((hv_Iteration * hv_BatchSize) + hv_BatchSize)).TupleGreater(
                                new HTuple(hv_SampleIndicesTrain.TupleLength())))) != 0)
                            {
                                hv_Iteration.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Iteration = hv_NumIterations - 1;
                                }
                                break;
                            }
                            if ((int)((new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleGreater(0.0))).TupleAnd(
                                new HTuple((new HTuple(hv_TrainResultsRestored.TupleLength())).TupleGreater(
                                0)))) != 0)
                            {
                                //Overwrite the first train results.
                                if ((int)(new HTuple((new HTuple(hv_TrainResultsRestored.TupleLength()
                                    )).TupleGreater(hv_Iteration))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_TrainResultsRestored = hv_TrainResultsRestored.TupleSelectRange(
                                                (new HTuple(hv_TrainResultsRestored.TupleLength())) - hv_Iteration,
                                                (new HTuple(hv_TrainResultsRestored.TupleLength())) - 1);
                                            hv_TrainResultsRestored.Dispose();
                                            hv_TrainResultsRestored = ExpTmpLocalVar_TrainResultsRestored;
                                        }
                                    }
                                }
                                if (hv_TrainResults == null)
                                    hv_TrainResults = new HTuple();
                                hv_TrainResults[HTuple.TupleGenSequence(hv_Iteration - (new HTuple(hv_TrainResultsRestored.TupleLength()
                                    )), hv_Iteration - 1, 1)] = hv_TrainResultsRestored;
                            }
                            //
                            //Add an iteration before starting the training for the evaluation if specified.
                            hv_IterationEvaluateOnly.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IterationEvaluateOnly = hv_Iteration - 1;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Iteration = hv_Iteration - hv_EvaluateBeforeTraining;
                                    hv_Iteration.Dispose();
                                    hv_Iteration = ExpTmpLocalVar_Iteration;
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_Iteration.TupleGreater(hv_IterationEvaluateOnly))) != 0)
                        {
                            //
                            //Generate the sample batch indices.
                            hv_BatchStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BatchStart = hv_Iteration * hv_BatchSize;
                            }
                            hv_BatchEnd.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BatchEnd = (hv_BatchStart + hv_BatchSize) - 1;
                            }
                            hv_BatchIndices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BatchIndices = hv_SampleIndicesTrain.TupleSelectRange(
                                    hv_BatchStart, hv_BatchEnd);
                            }
                            //
                            //Set a random seed for the sample batch.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetSystem("seed_rand", hv_SampleSeedsTrainRaw.TupleSelect(
                                    hv_BatchEnd));
                            }
                            //
                            //Read preprocessed samples.
                            hv_DLSampleBatch.Dispose();
                            read_dl_samples(hv_DLDataset, hv_BatchIndices, out hv_DLSampleBatch);
                            //
                            //Augment samples based on train parameter.
                            hv_AugmentationParam.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainParam, "augmentation_param", out hv_AugmentationParam);
                            augment_dl_samples(hv_DLSampleBatch, hv_AugmentationParam);
                            //
                            //Train the model on current batch.
                            hv_TrainResult.Dispose();
                            HOperatorSet.TrainDlModelBatch(hv_DLModelHandle, hv_DLSampleBatch, out hv_TrainResult);
                            //
                            //We store each train result.
                            if (hv_TrainResults == null)
                                hv_TrainResults = new HTuple();
                            hv_TrainResults[hv_Iteration] = hv_TrainResult;
                        }
                        //
                        //Evaluation handling.
                        hv_EvaluationIntervalEpochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_interval_epochs",
                            out hv_EvaluationIntervalEpochs);
                        hv_EvaluationInterval.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationInterval = ((((hv_EvaluationIntervalEpochs * hv_NumIterationsPerEpoch)).TupleFloor()
                                )).TupleInt();
                        }
                        hv_ValidationEvaluationResult.Dispose();
                        hv_ValidationEvaluationResult = new HTuple();
                        hv_TrainEvaluationResult.Dispose();
                        hv_TrainEvaluationResult = new HTuple();
                        hv_DisplayParam.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
                        //Get percentage of evaluated training samples from display parameters.
                        hv_SelectPercentageTrainSamples.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, "selected_percentage_train_samples",
                            out hv_SelectPercentageTrainSamples);
                        //
                        //Evaluate the current model.
                        if ((int)(new HTuple(hv_EvaluationInterval.TupleGreater(0))) != 0)
                        {
                            //Evaluate the model at given intervals.
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_EvaluationInterval.TupleEqual(
                                1))).TupleOr((new HTuple(((hv_Iteration % hv_EvaluationInterval)).TupleEqual(
                                0))).TupleAnd(new HTuple(hv_Iteration.TupleNotEqual(0)))))).TupleOr(
                                new HTuple(hv_Iteration.TupleEqual(hv_NumIterations - 1))))).TupleOr(
                                new HTuple(hv_Iteration.TupleEqual(hv_IterationEvaluateOnly)))) != 0)
                            {
                                hv_EvaluationParam.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_param", out hv_EvaluationParam);
                                //Evaluate on validation split.
                                hv_ValidationEvaluationResult.Dispose(); hv__.Dispose();
                                evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "validation",
                                    hv_EvaluationParam, out hv_ValidationEvaluationResult, out hv__);
                                //Evaluate a subset of the train split.
                                hv_TrainEvaluationRatio.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TrainEvaluationRatio = hv_SelectPercentageTrainSamples / 100.0;
                                }
                                hv_NumTrainEvaluationSampleIndices.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumTrainEvaluationSampleIndices = ((hv_TrainEvaluationRatio * (new HTuple(hv_TrainSampleIndices.TupleLength()
                                        )))).TupleInt();
                                }
                                if ((int)(new HTuple(hv_NumTrainEvaluationSampleIndices.TupleGreater(
                                    0))) != 0)
                                {
                                    hv_TrainEvaluationSampleIndices.Dispose();
                                    tuple_shuffle(hv_TrainSampleIndices, out hv_TrainEvaluationSampleIndices);
                                    //It might happen that the subset is too small for evaluation.
                                    try
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_TrainEvaluationResult.Dispose(); hv__.Dispose();
                                            evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "sample_indices",
                                                hv_TrainEvaluationSampleIndices.TupleSelectRange(0, hv_NumTrainEvaluationSampleIndices - 1),
                                                hv_EvaluationParam, out hv_TrainEvaluationResult, out hv__);
                                        }
                                    }
                                    // catch (Exception) 
                                    catch (HalconException HDevExpDefaultException1)
                                    {
                                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                                    }
                                }
                                hv_EvaluationInfo.Dispose();
                                HOperatorSet.CreateDict(out hv_EvaluationInfo);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "epoch", hv_Epoch);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_EvaluationInfo, "iteration", hv_Iteration + hv_EvaluateBeforeTraining);
                                }
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "result", hv_ValidationEvaluationResult);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "result_train", hv_TrainEvaluationResult);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_EvaluationInfos = hv_EvaluationInfos.TupleConcat(
                                            hv_EvaluationInfo);
                                        hv_EvaluationInfos.Dispose();
                                        hv_EvaluationInfos = ExpTmpLocalVar_EvaluationInfos;
                                    }
                                }
                                if ((int)(hv_DisplayEnabled) != 0)
                                {
                                    hv_EvaluationComparisonKeys.Dispose();
                                    HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                                        out hv_EvaluationComparisonKeys);
                                    hv_Valuevalidation.Dispose(); hv__.Dispose();
                                    reduce_dl_evaluation_result(hv_ValidationEvaluationResult, hv_EvaluationComparisonKeys,
                                        out hv_Valuevalidation, out hv__);
                                    hv_ValueTrain.Dispose(); hv__.Dispose();
                                    reduce_dl_evaluation_result(hv_TrainEvaluationResult, hv_EvaluationComparisonKeys,
                                        out hv_ValueTrain, out hv__);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayValidationEvaluationValues = hv_DisplayValidationEvaluationValues.TupleConcat(
                                                hv_Valuevalidation);
                                            hv_DisplayValidationEvaluationValues.Dispose();
                                            hv_DisplayValidationEvaluationValues = ExpTmpLocalVar_DisplayValidationEvaluationValues;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayTrainEvaluationValues = hv_DisplayTrainEvaluationValues.TupleConcat(
                                                hv_ValueTrain);
                                            hv_DisplayTrainEvaluationValues.Dispose();
                                            hv_DisplayTrainEvaluationValues = ExpTmpLocalVar_DisplayTrainEvaluationValues;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayEvaluationEpochs = hv_DisplayEvaluationEpochs.TupleConcat(
                                                hv_Epoch);
                                            hv_DisplayEvaluationEpochs.Dispose();
                                            hv_DisplayEvaluationEpochs = ExpTmpLocalVar_DisplayEvaluationEpochs;
                                        }
                                    }
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_Iteration.TupleGreater(hv_IterationEvaluateOnly))) != 0)
                        {
                            //
                            //Check if an update is needed.
                            hv_TrainInfoUpdateIntervalSeconds.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_TrainInfoUpdateIntervalSeconds);
                            hv_LastUpdate.Dispose();
                            HOperatorSet.GetDictTuple(hv_DisplayData, "last_update", out hv_LastUpdate);
                            hv_Seconds.Dispose();
                            HOperatorSet.CountSeconds(out hv_Seconds);
                            //Check for next update (enough time has elapsed or last iteration).
                            if ((int)((new HTuple((new HTuple(((((hv_LastUpdate - hv_Seconds)).TupleAbs()
                                )).TupleGreater(hv_TrainInfoUpdateIntervalSeconds))).TupleOr(new HTuple(hv_Iteration.TupleEqual(
                                hv_NumIterations - 1))))).TupleOr(new HTuple((new HTuple(hv_ValidationEvaluationResult.TupleLength()
                                )).TupleGreater(0)))) != 0)
                            {
                                HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Seconds);
                                hv_EvaluationComparisonKeys.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                                    out hv_EvaluationComparisonKeys);
                                hv_NumSamplesMeanLoss.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainParam, "num_samples_mean_loss", out hv_NumSamplesMeanLoss);
                                hv_TrainInfo.Dispose();
                                collect_train_dl_model_info(hv_DLModelHandle, hv_TrainResults, hv_EvaluationInfos,
                                    hv_EvaluationComparisonKeys, hv_EvaluationOptimizationMethod, hv_Iteration,
                                    hv_NumIterations, hv_NumIterationsPerEpoch, hv_NumSamplesMeanLoss,
                                    out hv_TrainInfo);

                                HOperatorSet.SetDictTuple(hv_TrainInfo, "start_epoch", hv_StartEpoch_COPY_INP_TMP);
                                HOperatorSet.SetDictTuple(hv_TrainInfo, "start_time", hv_StartTime);
                                hv_UpdateTime.Dispose();
                                HOperatorSet.CountSeconds(out hv_UpdateTime);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_TrainInfo, "time_elapsed", hv_UpdateTime - hv_StartTime);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_TrainInfos = hv_TrainInfos.TupleConcat(
                                            hv_TrainInfo);
                                        hv_TrainInfos.Dispose();
                                        hv_TrainInfos = ExpTmpLocalVar_TrainInfos;
                                    }
                                }
                                //
                                //Display handling.
                                if ((int)(hv_DisplayEnabled) != 0)
                                {
                                    hv_EpochsStatus.Dispose();
                                    HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochsStatus);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayLossEpochs = hv_DisplayLossEpochs.TupleConcat(
                                                hv_EpochsStatus);
                                            hv_DisplayLossEpochs.Dispose();
                                            hv_DisplayLossEpochs = ExpTmpLocalVar_DisplayLossEpochs;
                                        }
                                    }
                                    hv_MeanLoss.Dispose();
                                    HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayLoss = hv_DisplayLoss.TupleConcat(
                                                hv_MeanLoss);
                                            hv_DisplayLoss.Dispose();
                                            hv_DisplayLoss = ExpTmpLocalVar_DisplayLoss;
                                        }
                                    }
                                    hv_DisplayLearningRate.Dispose();
                                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "learning_rate", out hv_DisplayLearningRate);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayLearningRates = hv_DisplayLearningRates.TupleConcat(
                                                hv_DisplayLearningRate);
                                            hv_DisplayLearningRates.Dispose();
                                            hv_DisplayLearningRates = ExpTmpLocalVar_DisplayLearningRates;
                                        }
                                    }
                                    dev_display_update_train_dl_model(hv_TrainParam, hv_DisplayData,
                                        hv_TrainInfo, hv_DisplayLossEpochs, hv_DisplayLoss, hv_DisplayLearningRates,
                                        hv_DisplayEvaluationEpochs, hv_DisplayValidationEvaluationValues,
                                        hv_DisplayTrainEvaluationValues);
                                }
                            }
                            //
                            //Image result preview handling.
                            if ((int)(hv_DisplayEnabled) != 0)
                            {
                                //Show interim results for test images.
                                //For models of type 'gc_anomaly_detection' this is not possible.
                                hv_NumImages.Dispose();
                                HOperatorSet.GetDictTuple(hv_DisplayParam, "num_images", out hv_NumImages);
                                if ((int)(new HTuple(hv_NumImages.TupleGreater(0))) != 0)
                                {
                                    //Check if the image preview has to be updated.
                                    hv_UpdateImagesIntervalEpochs.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DisplayParam, "update_images_interval_epochs",
                                        out hv_UpdateImagesIntervalEpochs);
                                    hv_UpdateImagesInterval.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_UpdateImagesInterval = (((((hv_UpdateImagesIntervalEpochs.TupleReal()
                                            ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                                    }
                                    if ((int)(new HTuple(hv_UpdateImagesInterval.TupleEqual(0))) != 0)
                                    {
                                        hv_UpdateImagesInterval.Dispose();
                                        hv_UpdateImagesInterval = 1;
                                    }
                                    if ((int)((new HTuple(((hv_Iteration % hv_UpdateImagesInterval)).TupleEqual(
                                        0))).TupleOr(hv_DisplayPreviewInitialized.TupleNot())) != 0)
                                    {
                                        hv_WindowImages.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DisplayData, "window_images", out hv_WindowImages);
                                        hv_FirstCall.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_FirstCall = new HTuple((new HTuple(hv_WindowImages.TupleLength()
                                                )).TupleEqual(0));
                                        }
                                        hv_GenParamTiled.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DisplayParam, "tiled_param", out hv_GenParamTiled);
                                        //
                                        {
                                            HTuple ExpTmpOutVar_0;
                                            dev_display_dl_data_tiled(hv_DLDataset, hv_DLModelHandle, hv_NumImages,
                                                "validation", hv_GenParamTiled, hv_WindowImages, out ExpTmpOutVar_0);
                                            hv_WindowImages.Dispose();
                                            hv_WindowImages = ExpTmpOutVar_0;
                                        }
                                        //
                                        if ((int)(hv_FirstCall) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", hv_WindowImages);
                                            set_display_font(hv_WindowImages, 12, "mono", "true", "false");
                                        }
                                        dev_display_tiled_legend(hv_WindowImages, hv_GenParamTiled);
                                        hv_DisplayPreviewInitialized.Dispose();
                                        hv_DisplayPreviewInitialized = 1;
                                    }
                                }
                            }
                            //
                            //Serialization handling.
                            update_train_dl_model_serialization(hv_TrainParam, hv_SerializationData,
                                hv_Iteration, hv_NumIterations, hv_Epoch, hv_ValidationEvaluationResult,
                                hv_EvaluationOptimizationMethod, hv_DLModelHandle, hv_TrainInfos,
                                hv_EvaluationInfos);
                        }
                        //
                        //Check for end of training.
                        if ((int)(new HTuple(hv_Iteration.TupleGreaterEqual(hv_NumIterations - 1))) != 0)
                        {
                            break;
                        }
                        if ((int)(new HTuple(hv_Iteration.TupleEqual(hv_IterationEvaluateOnly))) != 0)
                        {
                            hv_EvaluateBeforeTraining.Dispose();
                            hv_EvaluateBeforeTraining = 0;
                        }
                        //
                        //Continue with next iteration.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Iteration = hv_Iteration + 1;
                                hv_Iteration.Dispose();
                                hv_Iteration = ExpTmpLocalVar_Iteration;
                            }
                        }
                    }
                    //
                }
                else
                {
                    //Case for models of type 'anomaly_detection'.
                    //
                    //Read the training samples.
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_TrainSampleIndices, out hv_DLSamples);
                    //
                    //Get training parameters for anomaly detection.
                    hv_TrainParamAnomaly.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                    //
                    //Display information about training.
                    hv_DisplayParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                    hv_DisplayEnabled.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
                    if ((int)(hv_DisplayEnabled) != 0)
                    {
                        hv_WindowHandleInfo.Dispose();
                        dev_display_train_info_anomaly_detection(hv_TrainParam, out hv_WindowHandleInfo);
                    }
                    //
                    //Train the model.
                    hv_TrainResults.Dispose();
                    HOperatorSet.TrainDlModelAnomalyDataset(hv_DLModelHandle, hv_DLSamples, hv_TrainParamAnomaly,
                        out hv_TrainResults);
                    //
                    //Initialize TrainInfos and EvaluationInfos
                    hv_TrainInfos.Dispose();
                    hv_TrainInfos = new HTuple();
                    hv_EvaluationInfos.Dispose();
                    hv_EvaluationInfos = new HTuple();
                    //
                    //Close window with information about the training.
                    if ((int)(hv_DisplayEnabled) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleInfo);
                    }
                }
                //

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumTrainSamples.Dispose();
                hv_EvaluationComparisonKeyExist.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_EvaluationOptimizationMethod.Dispose();
                hv_NumEpochs.Dispose();
                hv_SeedRand.Dispose();
                hv_SampleIndicesTrainRaw.Dispose();
                hv_Index.Dispose();
                hv_Shuffled.Dispose();
                hv_SampleSeedsTrainRaw.Dispose();
                hv_BatchSize.Dispose();
                hv_EvaluateBeforeTraining.Dispose();
                hv_ChangeStrategyData.Dispose();
                hv_SerializationData.Dispose();
                hv_DisplayData.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayPreviewInitialized.Dispose();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLoss.Dispose();
                hv_DisplayLearningRates.Dispose();
                hv_TrainResultsRestored.Dispose();
                hv_StartTime.Dispose();
                hv_ThresholdInformation.Dispose();
                hv_FirstIteration.Dispose();
                hv_Epoch.Dispose();
                hv_Iteration.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSizeModel.Dispose();
                hv_NumIterations.Dispose();
                hv_SampleIndicesTrain.Dispose();
                hv_IterationEvaluateOnly.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_BatchIndices.Dispose();
                hv_DLSampleBatch.Dispose();
                hv_AugmentationParam.Dispose();
                hv_TrainResult.Dispose();
                hv_EvaluationIntervalEpochs.Dispose();
                hv_EvaluationInterval.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_DisplayParam.Dispose();
                hv_SelectPercentageTrainSamples.Dispose();
                hv_EvaluationParam.Dispose();
                hv__.Dispose();
                hv_TrainEvaluationRatio.Dispose();
                hv_NumTrainEvaluationSampleIndices.Dispose();
                hv_TrainEvaluationSampleIndices.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_Valuevalidation.Dispose();
                hv_ValueTrain.Dispose();
                hv_TrainInfoUpdateIntervalSeconds.Dispose();
                hv_LastUpdate.Dispose();
                hv_Seconds.Dispose();
                hv_NumSamplesMeanLoss.Dispose();
                hv_TrainInfo.Dispose();
                hv_UpdateTime.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_NumImages.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_UpdateImagesInterval.Dispose();
                hv_WindowImages.Dispose();
                hv_FirstCall.Dispose();
                hv_GenParamTiled.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_WindowHandleInfo.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_0.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumTrainSamples.Dispose();
                hv_EvaluationComparisonKeyExist.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_EvaluationOptimizationMethod.Dispose();
                hv_NumEpochs.Dispose();
                hv_SeedRand.Dispose();
                hv_SampleIndicesTrainRaw.Dispose();
                hv_Index.Dispose();
                hv_Shuffled.Dispose();
                hv_SampleSeedsTrainRaw.Dispose();
                hv_BatchSize.Dispose();
                hv_EvaluateBeforeTraining.Dispose();
                hv_ChangeStrategyData.Dispose();
                hv_SerializationData.Dispose();
                hv_DisplayData.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayPreviewInitialized.Dispose();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLoss.Dispose();
                hv_DisplayLearningRates.Dispose();
                hv_TrainResultsRestored.Dispose();
                hv_StartTime.Dispose();
                hv_ThresholdInformation.Dispose();
                hv_FirstIteration.Dispose();
                hv_Epoch.Dispose();
                hv_Iteration.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSizeModel.Dispose();
                hv_NumIterations.Dispose();
                hv_SampleIndicesTrain.Dispose();
                hv_IterationEvaluateOnly.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_BatchIndices.Dispose();
                hv_DLSampleBatch.Dispose();
                hv_AugmentationParam.Dispose();
                hv_TrainResult.Dispose();
                hv_EvaluationIntervalEpochs.Dispose();
                hv_EvaluationInterval.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_DisplayParam.Dispose();
                hv_SelectPercentageTrainSamples.Dispose();
                hv_EvaluationParam.Dispose();
                hv__.Dispose();
                hv_TrainEvaluationRatio.Dispose();
                hv_NumTrainEvaluationSampleIndices.Dispose();
                hv_TrainEvaluationSampleIndices.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_Valuevalidation.Dispose();
                hv_ValueTrain.Dispose();
                hv_TrainInfoUpdateIntervalSeconds.Dispose();
                hv_LastUpdate.Dispose();
                hv_Seconds.Dispose();
                hv_NumSamplesMeanLoss.Dispose();
                hv_TrainInfo.Dispose();
                hv_UpdateTime.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_NumImages.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_UpdateImagesInterval.Dispose();
                hv_WindowImages.Dispose();
                hv_FirstCall.Dispose();
                hv_GenParamTiled.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_WindowHandleInfo.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_0.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tuple / Element Order
        // Short Description: Sort the elements of a tuple randomly. 
        public void tuple_shuffle(HTuple hv_Tuple, out HTuple hv_Shuffled)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShuffleIndices = new HTuple();
            // Initialize local and output iconic variables 
            hv_Shuffled = new HTuple();
            try
            {
                //This procedure sorts the input tuple randomly.
                //
                if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(0))) != 0)
                {
                    //Create a tuple of random numbers,
                    //sort this tuple, and return the indices
                    //of this sorted tuple.
                    hv_ShuffleIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ShuffleIndices = (HTuple.TupleRand(
                            new HTuple(hv_Tuple.TupleLength()))).TupleSortIndex();
                    }
                    //Assign the elements of Tuple
                    //to these random positions.
                    hv_Shuffled.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Shuffled = hv_Tuple.TupleSelect(
                            hv_ShuffleIndices);
                    }
                }
                else
                {
                    //If the input tuple is empty,
                    //an empty tuple should be returned.
                    hv_Shuffled.Dispose();
                    hv_Shuffled = new HTuple();
                }

                hv_ShuffleIndices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShuffleIndices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tuple / Arithmetic
        // Short Description: Calculate the cross product of two vectors of length 3. 
        public void tuple_vector_cross_product(HTuple hv_V1, HTuple hv_V2, out HTuple hv_VC)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_VC = new HTuple();
            //The caller must ensure that the length of both input vectors is 3
            hv_VC.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_VC = ((hv_V1.TupleSelect(
                    1)) * (hv_V2.TupleSelect(2))) - ((hv_V1.TupleSelect(2)) * (hv_V2.TupleSelect(1)));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_VC = hv_VC.TupleConcat(
                        ((hv_V1.TupleSelect(2)) * (hv_V2.TupleSelect(0))) - ((hv_V1.TupleSelect(0)) * (hv_V2.TupleSelect(
                        2))));
                    hv_VC.Dispose();
                    hv_VC = ExpTmpLocalVar_VC;
                }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                {
                    HTuple
                      ExpTmpLocalVar_VC = hv_VC.TupleConcat(
                        ((hv_V1.TupleSelect(0)) * (hv_V2.TupleSelect(1))) - ((hv_V1.TupleSelect(1)) * (hv_V2.TupleSelect(
                        0))));
                    hv_VC.Dispose();
                    hv_VC = ExpTmpLocalVar_VC;
                }
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
        public void update_running_evaluation_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the running measures depending on the evaluation type.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("ocr_detection")))) != 0)
                {
                    update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("segmentation"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection")))) != 0)
                {
                    update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                    if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                    {
                        update_running_region_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                        update_running_gripping_point_measures(hv_Samples, hv_Results, hv_EvalParams,
                            hv_RunningMeasures);
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
                {
                    update_running_ocr_recognition_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: 3D Matching / 3D Gripping Point Detection
        // Short Description: Update running measures for 3D gripping points. 
        private void update_running_gripping_point_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            HObject ho_AnnotationRegion = null, ho_GTRegions = null;
            HObject ho_GTRegion = null;

            // Local control variables 

            HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_Result = new HTuple(), hv_NumGTRegions = new HTuple();
            HTuple hv_GrippingPointFound = new HTuple(), hv_IndexGTRegions = new HTuple();
            HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_IndexGrippingPoint = new HTuple();
            HTuple hv_GrippingPoint = new HTuple(), hv_GPFound = new HTuple();
            HTuple hv_NumGrippingPointFound = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnnotationRegion);
            HOperatorSet.GenEmptyObj(out ho_GTRegions);
            HOperatorSet.GenEmptyObj(out ho_GTRegion);
            try
            {
                if ((int)(new HTuple((new HTuple((new HTuple(((hv_EvalParams.TupleGetDictTuple(
                    "measures"))).TupleRegexpSelect("gripping_point_.*|all"))).TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Sample.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Sample = hv_Samples.TupleSelect(
                                hv_Index);
                        }
                        hv_Result.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Result = hv_Results.TupleSelect(
                                hv_Index);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            gen_dl_3d_gripping_points_and_poses(hv_Sample, hv_EvalParams.TupleGetDictTuple(
                                "gripping_point_params"), hv_Result);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_AnnotationRegion.Dispose();
                            HOperatorSet.Threshold(hv_Sample.TupleGetDictObject("segmentation_image"),
                                out ho_AnnotationRegion, ((hv_EvalParams.TupleGetDictTuple("class_ids"))).TupleSelect(
                                0), ((hv_EvalParams.TupleGetDictTuple("class_ids"))).TupleSelect(0));
                        }
                        ho_GTRegions.Dispose();
                        HOperatorSet.Connection(ho_AnnotationRegion, out ho_GTRegions);
                        hv_NumGTRegions.Dispose();
                        HOperatorSet.CountObj(ho_GTRegions, out hv_NumGTRegions);
                        //True positives: Only one gripping point
                        //within a ground truth region is counted
                        //as true positive. All additional points
                        //witin the same ground truth region are
                        //considered a false positive.
                        //False negative: All ground truth regions
                        //that do not contain at least one
                        //gripping point are a false negative.
                        hv_GrippingPointFound.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GrippingPointFound = HTuple.TupleGenConst(
                                new HTuple(((hv_Result.TupleGetDictTuple("gripping_points"))).TupleLength()
                                ), 0);
                        }
                        HTuple end_val17 = hv_NumGTRegions;
                        HTuple step_val17 = 1;
                        for (hv_IndexGTRegions = 1; hv_IndexGTRegions.Continue(end_val17, step_val17); hv_IndexGTRegions = hv_IndexGTRegions.TupleAdd(step_val17))
                        {
                            ho_GTRegion.Dispose();
                            HOperatorSet.SelectObj(ho_GTRegions, out ho_GTRegion, hv_IndexGTRegions);
                            hv_TP.Dispose();
                            hv_TP = 0.0;
                            hv_FP.Dispose();
                            hv_FP = 0.0;
                            for (hv_IndexGrippingPoint = 0; (int)hv_IndexGrippingPoint <= (int)((new HTuple(((hv_Result.TupleGetDictTuple(
                                "gripping_points"))).TupleLength())) - 1); hv_IndexGrippingPoint = (int)hv_IndexGrippingPoint + 1)
                            {
                                hv_GrippingPoint.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GrippingPoint = ((hv_Result.TupleGetDictTuple(
                                        "gripping_points"))).TupleSelect(hv_IndexGrippingPoint);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GPFound.Dispose();
                                    HOperatorSet.TestRegionPoint(ho_GTRegion, hv_GrippingPoint.TupleGetDictTuple(
                                        "row"), hv_GrippingPoint.TupleGetDictTuple("column"), out hv_GPFound);
                                }
                                if ((int)(hv_GPFound) != 0)
                                {
                                    if ((int)(new HTuple(hv_TP.TupleEqual(0.0))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_TP = hv_TP + 1.0;
                                                hv_TP.Dispose();
                                                hv_TP = ExpTmpLocalVar_TP;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_FP = hv_FP + 1.0;
                                                hv_FP.Dispose();
                                                hv_FP = ExpTmpLocalVar_FP;
                                            }
                                        }
                                    }
                                    if (hv_GrippingPointFound == null)
                                        hv_GrippingPointFound = new HTuple();
                                    hv_GrippingPointFound[hv_IndexGrippingPoint] = 1;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_tp", (hv_RunningMeasures.TupleGetDictTuple(
                                    "gp_tp")) + hv_TP);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple(
                                    "gp_fp")) + hv_FP);
                            }
                            if ((int)(new HTuple(hv_TP.TupleEqual(0.0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fn", (hv_RunningMeasures.TupleGetDictTuple(
                                        "gp_fn")) + 1.0);
                                }
                            }
                        }
                        //All gripping points that have not been
                        //found to lie within the ground truth
                        //region are additional false positives.
                        if ((int)(new HTuple((new HTuple(hv_GrippingPointFound.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            hv_NumGrippingPointFound.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumGrippingPointFound = hv_GrippingPointFound.TupleSum()
                                    ;
                            }
                        }
                        else
                        {
                            hv_NumGrippingPointFound.Dispose();
                            hv_NumGrippingPointFound = 0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "gp_fp", (hv_RunningMeasures.TupleGetDictTuple(
                                "gp_fp")) + ((new HTuple(hv_GrippingPointFound.TupleLength())) - hv_NumGrippingPointFound));
                        }
                    }
                }
                ho_AnnotationRegion.Dispose();
                ho_GTRegions.Dispose();
                ho_GTRegion.Dispose();

                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_Result.Dispose();
                hv_NumGTRegions.Dispose();
                hv_GrippingPointFound.Dispose();
                hv_IndexGTRegions.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_IndexGrippingPoint.Dispose();
                hv_GrippingPoint.Dispose();
                hv_GPFound.Dispose();
                hv_NumGrippingPointFound.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnnotationRegion.Dispose();
                ho_GTRegions.Dispose();
                ho_GTRegion.Dispose();

                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_Result.Dispose();
                hv_NumGTRegions.Dispose();
                hv_GrippingPointFound.Dispose();
                hv_IndexGTRegions.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_IndexGrippingPoint.Dispose();
                hv_GrippingPoint.Dispose();
                hv_GPFound.Dispose();
                hv_NumGrippingPointFound.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection and Global Context Anomaly Detection
        // Short Description: Update running measures for an anomaly detection or Global Context Anomaly Detection evaluation. 
        private void update_running_image_anomaly_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
            HTuple hv_AnomalyLabelID = new HTuple(), hv_Result = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_AnomalyScoreKey = new HTuple();
            HTuple hv_AnomalyScore = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
                //
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly label ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get anomaly scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //Loop over all samples and update running measures accordingly.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_AnomalyLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "anomaly_label_id", out hv_AnomalyLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_Result, "keys", new HTuple(), out hv_Keys);
                    hv_AnomalyScoreKey.Dispose();
                    HOperatorSet.TupleRegexpSelect(hv_Keys, "anomaly_score.*", out hv_AnomalyScoreKey);
                    //It is not expected that AnomalyScoreKey contains more than one item.
                    //In case it unexpectedly does, we index it with [0].
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_AnomalyScore.Dispose();
                        HOperatorSet.GetDictTuple(hv_Result, hv_AnomalyScoreKey.TupleSelect(0), out hv_AnomalyScore);
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(
                                hv_AnomalyLabelID);
                            hv_AnomalyLabelIDs.Dispose();
                            hv_AnomalyLabelIDs = ExpTmpLocalVar_AnomalyLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyScores = hv_AnomalyScores.TupleConcat(
                                hv_AnomalyScore);
                            hv_AnomalyScores.Dispose();
                            hv_AnomalyScores = ExpTmpLocalVar_AnomalyScores;
                        }
                    }
                }
                //
                //Set image ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                //Set anomaly label ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
                //Set anomaly scores in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
                //

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_Keys.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyScore.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_Keys.Dispose();
                hv_AnomalyScoreKey.Dispose();
                hv_AnomalyScore.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Update running measures for an image classification evaluation. 
        private void update_running_image_classification_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RegExpTopKError = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_K = new HTuple(), hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Top1Prediction = new HTuple(), hv_TopKPredictionDicts = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
            HTuple hv_Result = new HTuple(), hv_PredictedClassIDs = new HTuple();
            HTuple hv_TopKPrediction = new HTuple(), hv_TopKPredictionDict = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for classification.
                //
                //To avoid memory, only save first K predictions per sample.
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_K.Dispose();
                hv_K = 1;
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest(hv_RegExpTopKError);
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_K = hv_K.TupleMax2(
                                    ((((hv_Measures.TupleSelect(hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber()
                                    );
                                hv_K.Dispose();
                                hv_K = ExpTmpLocalVar_K;
                            }
                        }
                    }
                }
                //
                //Extend tuples in RunningMeasures with new results.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Top1Prediction.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Top1Prediction);
                hv_TopKPredictionDicts.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictionDicts);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_Index);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_ImageLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_label_id", out hv_ImageLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_Index);
                    }
                    hv_PredictedClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "classification_class_ids", out hv_PredictedClassIDs);
                    hv_TopKPrediction.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    hv_TopKPredictionDict.Dispose();
                    HOperatorSet.CreateDict(out hv_TopKPredictionDict);
                    HOperatorSet.SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                hv_ImageLabelID);
                            hv_ImageLabelIDs.Dispose();
                            hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Top1Prediction = hv_Top1Prediction.TupleConcat(
                                hv_TopKPrediction.TupleSelect(0));
                            hv_Top1Prediction.Dispose();
                            hv_Top1Prediction = ExpTmpLocalVar_Top1Prediction;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(
                                hv_TopKPredictionDict);
                            hv_TopKPredictionDicts.Dispose();
                            hv_TopKPredictionDicts = ExpTmpLocalVar_TopKPredictionDicts;
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
                //

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Object Detection and Instance Segmentation
        // Short Description: Update running measures for an instance-based evaluation. 
        private void update_running_instance_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_NumAreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDToClassIdx = new HTuple();
            HTuple hv_EvaluateOrientation = new HTuple(), hv_SIdx = new HTuple();
            HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
            HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
            HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
            HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
            HTuple hv_IoUs = new HTuple(), hv_GtPhis = new HTuple();
            HTuple hv_ResPhis = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
            HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
            HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
            HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
            HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
            HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
            HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
            HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
            HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
            HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
            HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
            HTuple hv_GtSortIdx = new HTuple(), hv_CurrentResPhis = new HTuple();
            HTuple hv_CurrentGtPhis = new HTuple(), hv_ITIdx = new HTuple();
            HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
            HTuple hv_ResAbsOrientationDiff = new HTuple(), hv_ResIgnore = new HTuple();
            HTuple hv_ResIdx = new HTuple(), hv_CurrentIoU = new HTuple();
            HTuple hv_MatchIdx = new HTuple(), hv_GtIdx = new HTuple();
            HTuple hv_AreaIgnore = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_PerClassMeasures = new HTuple(), hv_CurrentIsTP = new HTuple();
            HTuple hv_CurrentIgnore = new HTuple(), hv_CurrentAbsOrientationDiff = new HTuple();
            HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
            HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
            HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
            HTuple hv_ResAbsOrientationDiffClass = new HTuple(), hv_ResAbsOrientationDiffLocalization = new HTuple();
            HTuple hv_ResAbsOrientationDiffDuplicate = new HTuple();
            HTuple hv_ResAbsOrientationDiffMultiple = new HTuple();
            HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
            HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
            HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
            HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_AbsOrientationDiff = new HTuple();
            HTuple hv_IsFPClass = new HTuple(), hv_IsFPBackground = new HTuple();
            HTuple hv_IsFPLocalization = new HTuple(), hv_IsFPDuplicate = new HTuple();
            HTuple hv_IsFPMultiple = new HTuple(), hv_AbsOrientationDiffMultiple = new HTuple();
            HTuple hv_AbsOrientationDiffDuplicate = new HTuple(), hv_AbsOrientationDiffLocalization = new HTuple();
            HTuple hv_AbsOrientationDiffClass = new HTuple(), hv_CurrentImageID = new HTuple();
            HTuple hv_ImageIDsWithFN = new HTuple(), hv_NumImageIDsWithFN = new HTuple();
            HTuple hv_ImageIDsWithFP = new HTuple(), hv_NumImageIDsWithFP = new HTuple();
            HTuple hv___Tmp_Ctrl_Dict_Init_0 = new HTuple(), hv___Tmp_Ctrl_Dict_Init_1 = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for an instance-based evaluation for detection.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                dev_update_off();
                //Get the necessary evaluation parameters.
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                //
                //Get the area parameters: name, min, and max.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                hv_NumAreaRanges.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
                        )) - 1;
                }
                //
                //Get the allocation length for extending tuples.
                hv_AllocationBlockLength.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                //
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                    //We need a mapping from class IDs to class indices
                    hv_ClassIDToClassIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                            (hv_ClassIDs.TupleMax()) + 1, -1);
                    }
                    if (hv_ClassIDToClassIdx == null)
                        hv_ClassIDToClassIdx = new HTuple();
                    hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, hv_NumClasses - 1, 1);
                }
                //
                //Check if the orientation is to be evaluated.
                hv_EvaluateOrientation.Dispose();
                hv_EvaluateOrientation = 0;
                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd((new HTuple(((hv_Measures.TupleFind(
                    "soap"))).TupleNotEqual(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                    "all"))).TupleNotEqual(-1))))) != 0)
                {
                    hv_EvaluateOrientation.Dispose();
                    hv_EvaluateOrientation = 1;
                }
                //
                //Go through samples.
                for (hv_SIdx = 0; (int)hv_SIdx <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_SIdx = (int)hv_SIdx + 1)
                {
                    //
                    hv_CurrentSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentSample = hv_Samples.TupleSelect(
                            hv_SIdx);
                    }
                    hv_CurrentResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentResult = hv_Results.TupleSelect(
                            hv_SIdx);
                    }
                    //
                    //Get classes.
                    hv_GtClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
                    //Convert results from Deep OCR format to rectangle2 Object Detection format.
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_0);
                    HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_0, "comp", "ocr_detection");
                    if ((int)(((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_0))).TupleTestEqualDictItem(
                        "evaluation_type", "comp")) != 0)
                    {
                        {
                            HTuple ExpTmpOutVar_0;
                            convert_ocr_detection_result_to_object_detection(hv_CurrentResult, out ExpTmpOutVar_0);
                            hv_CurrentResult.Dispose();
                            hv_CurrentResult = ExpTmpOutVar_0;
                        }
                    }
                    hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv___Tmp_Ctrl_Dict_Init_0 = HTuple.TupleConstant(
                            "HNULL");
                    }
                    hv_ResClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
                    hv_NumGT.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
                            );
                    }
                    hv_NumRes.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
                            );
                    }
                    //
                    //Get result confidences and sort them in descending order.
                    hv_Confidences.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
                    hv_ResSortIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                hv_ResSortIndices);
                            hv_Confidences.Dispose();
                            hv_Confidences = ExpTmpLocalVar_Confidences;
                        }
                    }
                    //Sort the result class IDs.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
                                hv_ResSortIndices);
                            hv_ResClassIDs.Dispose();
                            hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
                        }
                    }
                    //
                    //Compute the IoUs of the instances.
                    hv_GtAreas.Dispose(); hv_ResAreas.Dispose(); hv_IoUs.Dispose();
                    area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices,
                        out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
                    //
                    if ((int)(hv_EvaluateOrientation) != 0)
                    {
                        hv_GtPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_phi", out hv_GtPhis);
                        hv_ResPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_phi", out hv_ResPhis);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ResPhis = hv_ResPhis.TupleSelect(
                                    hv_ResSortIndices);
                                hv_ResPhis.Dispose();
                                hv_ResPhis = ExpTmpLocalVar_ResPhis;
                            }
                        }
                    }
                    //Loop over the maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Loop over the area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //
                            //Get information about the current area range.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            //Set ignore-flag for ground truth instances.
                            //For Deep OCR detection, ignore classes other than 'word'
                            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                            HOperatorSet.CreateDict(out hv___Tmp_Ctrl_Dict_Init_1);
                            HOperatorSet.SetDictTuple(hv___Tmp_Ctrl_Dict_Init_1, "comp", "ocr_detection");
                            if ((int)(((hv_EvalParams.TupleConcat(hv___Tmp_Ctrl_Dict_Init_1))).TupleTestEqualDictItem(
                                "evaluation_type", "comp")) != 0)
                            {
                                hv_GtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnore = hv_GtClassIDs.TupleNotEqualElem(
                                        0);
                                }
                            }
                            else
                            {
                                hv_GtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnore = HTuple.TupleGenConst(
                                        hv_NumGT, 0);
                                }
                            }
                            hv___Tmp_Ctrl_Dict_Init_1.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv___Tmp_Ctrl_Dict_Init_1 = HTuple.TupleConstant(
                                    "HNULL");
                            }
                            //
                            //Ignore ground truth instances with area outside the area range.
                            if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnoreInds.Dispose();
                                    HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                                        hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
                                }
                                if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
                                {
                                    if (hv_GtIgnore == null)
                                        hv_GtIgnore = new HTuple();
                                    hv_GtIgnore[hv_GtIgnoreInds] = 1;
                                }
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Store if a sample has at least one false positive or false negative (for each IoU threshold).
                                hv_SampleHasFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_SampleHasFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            //Loop over the classes.
                            HTuple end_val127 = hv_NumClasses - 1;
                            HTuple step_val127 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val127, step_val127); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val127))
                            {
                                hv_CurrentClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx);
                                }
                                //
                                //Get the ground truth for this class.
                                hv_CurrentGtIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentGtIdxs.Dispose();
                                    hv_CurrentGtIdxs = new HTuple();
                                }
                                hv_CurrentNumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                                        );
                                }
                                //
                                //Get ground truth ignore for this class.
                                hv_CurrentGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                                        hv_CurrentGtIdxs);
                                }
                                if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                                    0))) != 0)
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    hv_CurrentNumGtIgnore = 0;
                                }
                                else
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                                            ;
                                    }
                                }
                                //
                                //Number of gt for this class and without ignore.
                                hv_CurrentNumGtNoIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGtNoIgnore = hv_CurrentNumGt - hv_CurrentNumGtIgnore;
                                }
                                //
                                //Get results for this class.
                                hv_CurrentResIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentResIdxs.Dispose();
                                    hv_CurrentResIdxs = new HTuple();
                                }
                                hv_CurrentNumRes.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                                        new HTuple(hv_CurrentResIdxs.TupleLength()));
                                }
                                //MaxNum -1 corresponds to taking all results.
                                if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentNumRes.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                                            );
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                                            0, hv_CurrentNumRes - 1);
                                        hv_CurrentResIdxs.Dispose();
                                        hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
                                    }
                                }
                                //
                                //Get areas of the current results.
                                hv_CurrentResAreas.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                                        hv_CurrentResIdxs);
                                }
                                //
                                //Update the confidences, num_gt and num_pred for this class.
                                hv_OldNumPred.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if (hv_PerClassNumGt == null)
                                    hv_PerClassNumGt = new HTuple();
                                hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx)) + hv_CurrentNumGt;
                                if (hv_PerClassNumGtIgnore == null)
                                    hv_PerClassNumGtIgnore = new HTuple();
                                hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                                    hv_ClsIdx)) + hv_CurrentNumGtIgnore;
                                if (hv_PerClassNumPred == null)
                                    hv_PerClassNumPred = new HTuple();
                                hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) + hv_CurrentNumRes;
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassConfidences.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), out hv_CurrentClassConfidences);
                                }
                                //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
                                //if the allocated block is long enough, otherwise allocate a new block.
                                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                    new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            hv_CurrentClassConfidences.Dispose();
                                            hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
                                        }
                                    }
                                }
                                if (hv_CurrentClassConfidences == null)
                                    hv_CurrentClassConfidences = new HTuple();
                                hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                    hv_ClsIdx)) - 1, 1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_CurrentClassConfidences);
                                }
                                //
                                //Sort the ground truth: Non-ignored instances first.
                                hv_GtSortIdx.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                                        ;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIgnore.Dispose();
                                        hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIdxs.Dispose();
                                        hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
                                    }
                                }
                                //
                                //Get orientations of result and ground truth instances.
                                if ((int)(hv_EvaluateOrientation) != 0)
                                {
                                    hv_CurrentResPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentResPhis = hv_ResPhis.TupleSelect(
                                            hv_CurrentResIdxs);
                                    }
                                    hv_CurrentGtPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentGtPhis = hv_GtPhis.TupleSelect(
                                            hv_CurrentGtIdxs);
                                    }
                                }
                                //
                                if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
                                {
                                    //Loop over IoU thresholds.
                                    for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                        )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                    {
                                        //We check which ground truth and
                                        //result instance can be matched.
                                        hv_GtMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_GtMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumGt, 0);
                                        }
                                        hv_ResMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        //
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            //Initialize the absolute orientation difference to -1.
                                            hv_ResAbsOrientationDiff.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiff = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                        }
                                        //Store which detections should be ignored.
                                        hv_ResIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIgnore = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        HTuple end_val202 = hv_CurrentNumRes - 1;
                                        HTuple step_val202 = 1;
                                        for (hv_ResIdx = 0; hv_ResIdx.Continue(end_val202, step_val202); hv_ResIdx = hv_ResIdx.TupleAdd(step_val202))
                                        {
                                            //Set the currently best achieved IoU to the IoU threshold and
                                            //initialize the matching index.
                                            hv_CurrentIoU.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx))).TupleMin2(1 - 1.0e-10);
                                            }
                                            hv_MatchIdx.Dispose();
                                            hv_MatchIdx = -1;
                                            //Loop over ground truth.
                                            HTuple end_val208 = hv_CurrentNumGt - 1;
                                            HTuple step_val208 = 1;
                                            for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val208, step_val208); hv_GtIdx = hv_GtIdx.TupleAdd(step_val208))
                                            {
                                                //Continue if this ground truth has already been matched.
                                                if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                                                {
                                                    continue;
                                                }
                                                //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                                                if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                                                {
                                                    if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                                                        0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                                                        hv_GtIdx))).TupleEqual(1)))) != 0)
                                                    {
                                                        break;
                                                    }
                                                }
                                                //Continue if IoU is not better than a previous match.
                                                if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                                                    hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                                                    hv_CurrentIoU))) != 0)
                                                {
                                                    continue;
                                                }
                                                //We got a new best match, store it.
                                                hv_CurrentIoU.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_CurrentIoU = hv_IoUs.TupleSelect(
                                                        ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(
                                                        hv_ResIdx)));
                                                }
                                                hv_MatchIdx.Dispose();
                                                hv_MatchIdx = new HTuple(hv_GtIdx);
                                            }
                                            //If a match has been made we store it for both ground truth and result.
                                            if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                                            {
                                                //In COCO they use the IDs of GT and Res, we just use 1
                                                //to indicate the matching, but don't store which one has been matched.
                                                if (hv_ResMatched == null)
                                                    hv_ResMatched = new HTuple();
                                                hv_ResMatched[hv_ResIdx] = 1;
                                                if (hv_GtMatched == null)
                                                    hv_GtMatched = new HTuple();
                                                hv_GtMatched[hv_MatchIdx] = 1;
                                                if (hv_ResIgnore == null)
                                                    hv_ResIgnore = new HTuple();
                                                hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                                                //
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    //Set the absolute orientation difference.
                                                    if (hv_ResAbsOrientationDiff == null)
                                                        hv_ResAbsOrientationDiff = new HTuple();
                                                    hv_ResAbsOrientationDiff[hv_ResIdx] = (((hv_CurrentResPhis.TupleSelect(
                                                        hv_ResIdx)) - (hv_CurrentGtPhis.TupleSelect(hv_MatchIdx)))).TupleAbs()
                                                        ;
                                                    if ((int)(new HTuple(((hv_ResAbsOrientationDiff.TupleSelect(
                                                        hv_ResIdx))).TupleGreater((new HTuple(180)).TupleRad()
                                                        ))) != 0)
                                                    {
                                                        if (hv_ResAbsOrientationDiff == null)
                                                            hv_ResAbsOrientationDiff = new HTuple();
                                                        hv_ResAbsOrientationDiff[hv_ResIdx] = ((new HTuple(360)).TupleRad()
                                                            ) - (hv_ResAbsOrientationDiff.TupleSelect(hv_ResIdx));
                                                    }
                                                }
                                            }
                                        }
                                        //Ignore the unmatched results that are outside of the current area range.
                                        hv_AreaIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                                                hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                                                    -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                                                hv_ResIgnore.Dispose();
                                                hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                                            }
                                        }
                                        //True positives are the matched results.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_PerClassMeasures);
                                        }
                                        hv_CurrentIsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                                        //As for confidences, check if we have to allocate a new block.
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIsTP.Dispose();
                                                    hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIsTP == null)
                                            hv_CurrentIsTP = new HTuple();
                                        hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResMatched;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                                        //Set the ignored results.
                                        hv_CurrentIgnore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIgnore.Dispose();
                                                    hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIgnore == null)
                                            hv_CurrentIgnore = new HTuple();
                                        hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIgnore;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                                        //Set the absolute orientation difference.
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_CurrentAbsOrientationDiff.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                out hv_CurrentAbsOrientationDiff);
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_CurrentAbsOrientationDiff.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_CurrentAbsOrientationDiff.Dispose();
                                                        hv_CurrentAbsOrientationDiff = ExpTmpLocalVar_CurrentAbsOrientationDiff;
                                                    }
                                                }
                                            }
                                            if (hv_CurrentAbsOrientationDiff == null)
                                                hv_CurrentAbsOrientationDiff = new HTuple();
                                            hv_CurrentAbsOrientationDiff[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiff;
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                hv_CurrentAbsOrientationDiff);
                                        }
                                        //
                                        //Beginning of detailed evaluation processing (optional).
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Check if there have been false negatives.
                                            if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                                            {
                                                hv_GtMatchedNoIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                                                        hv_CurrentGtIgnore.TupleNot());
                                                }
                                                if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                                                    hv_CurrentNumGtNoIgnore))) != 0)
                                                {
                                                    if (hv_SampleHasFN == null)
                                                        hv_SampleHasFN = new HTuple();
                                                    hv_SampleHasFN[hv_ITIdx] = 1;
                                                }
                                            }
                                            //
                                            //Initialize the detailed running measures.
                                            hv_ResIsFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPClass = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResIsFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPBackground = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPLocalization = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPMultiple = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            //
                                            //Initialize detailed running measures for orientation difference.
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_ResAbsOrientationDiffClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffClass = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffLocalization = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffDuplicate = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffMultiple = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                            }
                                            //Check if there have been false positives.
                                            if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                                            {
                                                if (hv_SampleHasFP == null)
                                                    hv_SampleHasFP = new HTuple();
                                                hv_SampleHasFP[hv_ITIdx] = 1;
                                                //
                                                //For each false positive, find out what was the reason for being false positive:
                                                hv_FPResIdxsThisClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                                                        0);
                                                }
                                                hv_FPResIdxsAllResults.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                                                        hv_FPResIdxsThisClass);
                                                }
                                                hv_GTIdxsNotToIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                                                        0);
                                                }
                                                for (hv_ResIdx = 0; (int)hv_ResIdx <= (int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                                                    )) - 1); hv_ResIdx = (int)hv_ResIdx + 1)
                                                {
                                                    if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                                                        hv_ResIdx)))).TupleNot()) != 0)
                                                    {
                                                        if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                                                            )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                                                            -1)))) != 0)
                                                        {
                                                            //No GT instances or all GT instances are ignored.
                                                            //Thus, any detection is a background detection
                                                            hv_MaxIoU.Dispose();
                                                            hv_MaxIoU = 0.0;
                                                        }
                                                        else
                                                        {
                                                            //We have GT instances to consider.
                                                            hv_IoUsWithGT.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_IoUsWithGT = hv_IoUs.TupleSelect(
                                                                    (hv_GTIdxsNotToIgnore * hv_NumRes) + (hv_FPResIdxsAllResults.TupleSelect(
                                                                    hv_ResIdx)));
                                                            }
                                                            hv_MaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                                                                    ;
                                                            }
                                                            //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                                                            hv_MaxIdx.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                                                                    hv_MaxIoU);
                                                            }
                                                            hv_GTClassIDMaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                                                            }
                                                        }
                                                        if ((int)(hv_EvaluateOrientation.TupleAnd(new HTuple(hv_MaxIoU.TupleGreater(
                                                            0.0)))) != 0)
                                                        {
                                                            //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                                                            hv_AbsOrientationDiff.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_AbsOrientationDiff = (((hv_ResPhis.TupleSelect(
                                                                    hv_FPResIdxsAllResults.TupleSelect(hv_ResIdx))) - (hv_GtPhis.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx))))).TupleAbs()
                                                                    ;
                                                            }
                                                            if ((int)(new HTuple(hv_AbsOrientationDiff.TupleGreater(
                                                                (new HTuple(180)).TupleRad()))) != 0)
                                                            {
                                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                                {
                                                                    {
                                                                        HTuple
                                                                          ExpTmpLocalVar_AbsOrientationDiff = ((new HTuple(360)).TupleRad()
                                                                            ) - hv_AbsOrientationDiff;
                                                                        hv_AbsOrientationDiff.Dispose();
                                                                        hv_AbsOrientationDiff = ExpTmpLocalVar_AbsOrientationDiff;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        //Determine false positive type.
                                                        if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                                                        {
                                                            //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                                                            if (hv_ResIsFPBackground == null)
                                                                hv_ResIsFPBackground = new HTuple();
                                                            hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //False class.
                                                            //Note that this does not necessarily mean that this detection
                                                            //would be a true positive if the class was changed. It could still be a duplicate.
                                                            if (hv_ResIsFPClass == null)
                                                                hv_ResIsFPClass = new HTuple();
                                                            hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                                                                hv_GTClassIDMaxIoU);
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffClass == null)
                                                                    hv_ResAbsOrientationDiffClass = new HTuple();
                                                                hv_ResAbsOrientationDiffClass[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                                                            if (hv_ResIsFPDuplicate == null)
                                                                hv_ResIsFPDuplicate = new HTuple();
                                                            hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffDuplicate == null)
                                                                    hv_ResAbsOrientationDiffDuplicate = new HTuple();
                                                                hv_ResAbsOrientationDiffDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Bad localization. Class is correct, but the IoU is too low.
                                                            if (hv_ResIsFPLocalization == null)
                                                                hv_ResIsFPLocalization = new HTuple();
                                                            hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffLocalization == null)
                                                                    hv_ResAbsOrientationDiffLocalization = new HTuple();
                                                                hv_ResAbsOrientationDiffLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Wrong class and bad localization.
                                                            if (hv_ResIsFPMultiple == null)
                                                                hv_ResIsFPMultiple = new HTuple();
                                                            hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffMultiple == null)
                                                                    hv_ResAbsOrientationDiffMultiple = new HTuple();
                                                                hv_ResAbsOrientationDiffMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //This case should never occur.
                                                            throw new HalconException("Fatal error during detailed evaluation.");
                                                        }
                                                    }
                                                }
                                            }
                                            //
                                            //Overwrite the detailed running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_AbsOrientationDiffMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AbsOrientationDiffMultiple);
                                                hv_AbsOrientationDiffDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AbsOrientationDiffDuplicate);
                                                hv_AbsOrientationDiffLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AbsOrientationDiffLocalization);
                                                hv_AbsOrientationDiffClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AbsOrientationDiffClass);
                                            }
                                            //Allocate new blocks if necessary (all have the same length).
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPClass.Dispose();
                                                        hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPBackground.Dispose();
                                                        hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPLocalization.Dispose();
                                                        hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPDuplicate.Dispose();
                                                        hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPMultiple.Dispose();
                                                        hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                                                    }
                                                }
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffMultiple.Dispose();
                                                            hv_AbsOrientationDiffMultiple = ExpTmpLocalVar_AbsOrientationDiffMultiple;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffDuplicate.Dispose();
                                                            hv_AbsOrientationDiffDuplicate = ExpTmpLocalVar_AbsOrientationDiffDuplicate;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffLocalization.Dispose();
                                                            hv_AbsOrientationDiffLocalization = ExpTmpLocalVar_AbsOrientationDiffLocalization;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffClass.Dispose();
                                                            hv_AbsOrientationDiffClass = ExpTmpLocalVar_AbsOrientationDiffClass;
                                                        }
                                                    }
                                                }
                                            }
                                            if (hv_IsFPClass == null)
                                                hv_IsFPClass = new HTuple();
                                            hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPClass;
                                            if (hv_IsFPBackground == null)
                                                hv_IsFPBackground = new HTuple();
                                            hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPBackground;
                                            if (hv_IsFPLocalization == null)
                                                hv_IsFPLocalization = new HTuple();
                                            hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPLocalization;
                                            if (hv_IsFPDuplicate == null)
                                                hv_IsFPDuplicate = new HTuple();
                                            hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPDuplicate;
                                            if (hv_IsFPMultiple == null)
                                                hv_IsFPMultiple = new HTuple();
                                            hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPMultiple;
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                if (hv_AbsOrientationDiffMultiple == null)
                                                    hv_AbsOrientationDiffMultiple = new HTuple();
                                                hv_AbsOrientationDiffMultiple[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffMultiple;
                                                if (hv_AbsOrientationDiffDuplicate == null)
                                                    hv_AbsOrientationDiffDuplicate = new HTuple();
                                                hv_AbsOrientationDiffDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffDuplicate;
                                                if (hv_AbsOrientationDiffLocalization == null)
                                                    hv_AbsOrientationDiffLocalization = new HTuple();
                                                hv_AbsOrientationDiffLocalization[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffLocalization;
                                                if (hv_AbsOrientationDiffClass == null)
                                                    hv_AbsOrientationDiffClass = new HTuple();
                                                hv_AbsOrientationDiffClass[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffClass;
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                hv_IsFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                hv_IsFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                hv_IsFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                hv_IsFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    hv_AbsOrientationDiffMultiple);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    hv_AbsOrientationDiffDuplicate);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    hv_AbsOrientationDiffLocalization);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    hv_AbsOrientationDiffClass);
                                            }
                                        }
                                        //
                                        //End of detailed evaluation processing.
                                        //
                                    }
                                }
                                else
                                {
                                    if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                                        0)))) != 0)
                                    {
                                        //There are false negatives for this class.
                                        //Loop over IoU thresholds.
                                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                        {
                                            if (hv_SampleHasFN == null)
                                                hv_SampleHasFN = new HTuple();
                                            hv_SampleHasFN[hv_ITIdx] = 1;
                                        }
                                    }
                                }
                            }
                            //Update the confidences, num_gt and num_pred.
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Set values that are calculated over all classes (for each IoU threshold).
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Set image IDs with false negatives
                                    if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            out hv_ImageIDsWithFN);
                                        hv_NumImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                            out hv_NumImageIDsWithFN);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFN + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFN.Dispose();
                                                    hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFN == null)
                                            hv_ImageIDsWithFN = new HTuple();
                                        hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            hv_ImageIDsWithFN);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                                hv_NumImageIDsWithFN + 1);
                                        }
                                    }
                                    if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            out hv_ImageIDsWithFP);
                                        hv_NumImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                            out hv_NumImageIDsWithFP);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFP + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFP.Dispose();
                                                    hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFP == null)
                                            hv_ImageIDsWithFP = new HTuple();
                                        hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            hv_ImageIDsWithFP);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                                hv_NumImageIDsWithFP + 1);
                                        }
                                    }
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                hv_AreaRunningMeasures);
                        }
                    }
                }
                //

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();
                hv___Tmp_Ctrl_Dict_Init_0.Dispose();
                hv___Tmp_Ctrl_Dict_Init_1.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: OCR / Deep OCR
        // Short Description: Update running measures for an OCR recognition evaluation. 
        private void update_running_ocr_recognition_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_N = new HTuple(), hv_ImageIDsBatch = new HTuple();
            HTuple hv_WordsPredictionBatch = new HTuple(), hv_WordsGroundTruthBatch = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_Result = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for OCR recognition.
                //
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //
                hv_N.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_N = new HTuple(hv_Samples.TupleLength()
                        );
                }
                hv_ImageIDsBatch.Dispose();
                HOperatorSet.TupleGenConst(hv_N, 0, out hv_ImageIDsBatch);
                hv_WordsPredictionBatch.Dispose();
                HOperatorSet.TupleGenConst(hv_N, 0, out hv_WordsPredictionBatch);
                hv_WordsGroundTruthBatch.Dispose();
                HOperatorSet.TupleGenConst(hv_N, 0, out hv_WordsGroundTruthBatch);
                //Loop over all samples and update running measures accordingly.
                HTuple end_val12 = hv_N - 1;
                HTuple step_val12 = 1;
                for (hv_SampleIndex = 0; hv_SampleIndex.Continue(end_val12, step_val12); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val12))
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_SampleIndex);
                    }
                    if (hv_ImageIDsBatch == null)
                        hv_ImageIDsBatch = new HTuple();
                    hv_ImageIDsBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("image_id");
                    if (hv_WordsPredictionBatch == null)
                        hv_WordsPredictionBatch = new HTuple();
                    hv_WordsPredictionBatch[hv_SampleIndex] = hv_Result.TupleGetDictTuple("word");
                    if (hv_WordsGroundTruthBatch == null)
                        hv_WordsGroundTruthBatch = new HTuple();
                    hv_WordsGroundTruthBatch[hv_SampleIndex] = hv_Sample.TupleGetDictTuple("word");
                }
                //
                //Update running measures
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", ((hv_RunningMeasures.TupleGetDictTuple(
                        "image_ids"))).TupleConcat(hv_ImageIDsBatch));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_prediction", ((hv_RunningMeasures.TupleGetDictTuple(
                        "words_prediction"))).TupleConcat(hv_WordsPredictionBatch));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "words_ground_truth", ((hv_RunningMeasures.TupleGetDictTuple(
                        "words_ground_truth"))).TupleConcat(hv_WordsGroundTruthBatch));
                }
                //

                hv_N.Dispose();
                hv_ImageIDsBatch.Dispose();
                hv_WordsPredictionBatch.Dispose();
                hv_WordsGroundTruthBatch.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_Result.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_N.Dispose();
                hv_ImageIDsBatch.Dispose();
                hv_WordsPredictionBatch.Dispose();
                hv_WordsGroundTruthBatch.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_Result.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation and Edge Extraction
        // Short Description: Update running measures for a pixel-based evaluation. 
        private void update_running_pixel_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Annot = null, ho_Result = null, ho_ClsIgnore = null;
            HObject ho_ClsIgnoreTmp = null, ho_ClsAnnot = null, ho_ClsResult = null;
            HObject ho_TPReg = null, ho_FPReg = null, ho_FNReg = null;

            // Local control variables 

            HTuple hv_EvaluationType = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_PixelMeasures = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_CalcConfMatrix = new HTuple(), hv_SegmentationImageExists = new HTuple();
            HTuple hv_GrippingMapExists = new HTuple(), hv_ResultKey = new HTuple();
            HTuple hv_ClassIDsResult = new HTuple(), hv_ConfMatrix = new HTuple();
            HTuple hv_MapClassIDs = new HTuple(), hv_ClsIdToClsIdx = new HTuple();
            HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_Rows = new HTuple();
            HTuple hv_Columns = new HTuple(), hv_AnnotVals = new HTuple();
            HTuple hv_ResultVals = new HTuple(), hv_ConfTuple = new HTuple();
            HTuple hv_ConfHist = new HTuple(), hv_BinSize = new HTuple();
            HTuple hv_ConfMatrixTmp = new HTuple(), hv_IgnoreIndex = new HTuple();
            HTuple hv_ClsIndex = new HTuple(), hv_ClsId = new HTuple();
            HTuple hv_ClsIdRes = new HTuple(), hv_ClsTP = new HTuple();
            HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Annot);
            HOperatorSet.GenEmptyObj(out ho_Result);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
            HOperatorSet.GenEmptyObj(out ho_ClsResult);
            HOperatorSet.GenEmptyObj(out ho_TPReg);
            HOperatorSet.GenEmptyObj(out ho_FPReg);
            HOperatorSet.GenEmptyObj(out ho_FNReg);
            try
            {
                //
                //This procedure updates the RunningMeasures for a pixel-
                //based evaluation for segmentation or 3D Gripping Point
                //Detection. These measures are stored in the dictionary
                //RunningMeasures and updated by incorporating the Results
                //the model obtained for the Samples.
                //
                //Get evaluation type.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                //Get evaluation measures.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                //Check if any pixel measures are requested.
                hv_PixelMeasures.Dispose();
                get_requested_pixel_measures(hv_Measures, hv_EvaluationType, out hv_PixelMeasures);
                if ((int)(new HTuple((new HTuple(hv_PixelMeasures.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    ho_Annot.Dispose();
                    ho_Result.Dispose();
                    ho_ClsIgnore.Dispose();
                    ho_ClsIgnoreTmp.Dispose();
                    ho_ClsAnnot.Dispose();
                    ho_ClsResult.Dispose();
                    ho_TPReg.Dispose();
                    ho_FPReg.Dispose();
                    ho_FNReg.Dispose();

                    hv_EvaluationType.Dispose();
                    hv_Measures.Dispose();
                    hv_PixelMeasures.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClasses.Dispose();
                    hv_IgnoreClassIDs.Dispose();
                    hv_CalcConfMatrix.Dispose();
                    hv_SegmentationImageExists.Dispose();
                    hv_GrippingMapExists.Dispose();
                    hv_ResultKey.Dispose();
                    hv_ClassIDsResult.Dispose();
                    hv_ConfMatrix.Dispose();
                    hv_MapClassIDs.Dispose();
                    hv_ClsIdToClsIdx.Dispose();
                    hv_TP.Dispose();
                    hv_FP.Dispose();
                    hv_FN.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_Rows.Dispose();
                    hv_Columns.Dispose();
                    hv_AnnotVals.Dispose();
                    hv_ResultVals.Dispose();
                    hv_ConfTuple.Dispose();
                    hv_ConfHist.Dispose();
                    hv_BinSize.Dispose();
                    hv_ConfMatrixTmp.Dispose();
                    hv_IgnoreIndex.Dispose();
                    hv_ClsIndex.Dispose();
                    hv_ClsId.Dispose();
                    hv_ClsIdRes.Dispose();
                    hv_ClsTP.Dispose();
                    hv_ClsFP.Dispose();
                    hv_ClsFN.Dispose();

                    return;
                }
                //
                //Get the class IDs.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //Get the number of classes.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                //Get the ignore class IDs.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                //
                //Check if we need to compute/update the confusion matrix.
                hv_CalcConfMatrix.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcConfMatrix = new HTuple(((hv_PixelMeasures.TupleFind(
                        "pixel_confusion_matrix"))).TupleGreater(-1));
                }
                //
                //Check and set result type and class IDs.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "segmentation_image",
                        out hv_SegmentationImageExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GrippingMapExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "gripping_map",
                        out hv_GrippingMapExists);
                }
                if ((int)(hv_SegmentationImageExists) != 0)
                {
                    hv_ResultKey.Dispose();
                    hv_ResultKey = "segmentation_image";
                    //Class IDs in the result are the same as in the groundtruth.
                    hv_ClassIDsResult.Dispose();
                    hv_ClassIDsResult = new HTuple(hv_ClassIDs);
                }
                else if ((int)(hv_GrippingMapExists) != 0)
                {
                    hv_ResultKey.Dispose();
                    hv_ResultKey = "gripping_map";
                    //Since the result is a binary gripping map, the class ID
                    //is always 1.
                    hv_ClassIDsResult.Dispose();
                    hv_ClassIDsResult = 1;
                }
                else
                {
                    throw new HalconException("No result available for evaluation");
                }
                //
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Get the current confusion matrix.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Check if we need to map the class IDs.
                    hv_MapClassIDs.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping",
                        out hv_MapClassIDs);
                    if ((int)(hv_MapClassIDs) != 0)
                    {
                        hv_ClsIdToClsIdx.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
                                ) + 1;
                        }
                    }
                }
                else
                {
                    //Get the tuples for TP/FP/FN
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //Loop over images, i.e. sample dictionaries.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //Get annotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Annot.Dispose();
                        HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //Get result.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Result.Dispose();
                        HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                            hv_ResultKey);
                    }
                    //
                    //Update the measures.
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Get the ground truth and predicted class IDs of all pixels.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
                        hv_AnnotVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
                        hv_ResultVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
                        //Map the class IDs to class indices.
                        if ((int)(hv_MapClassIDs) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_AnnotVals);
                                    hv_AnnotVals.Dispose();
                                    hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_ResultVals);
                                    hv_ResultVals.Dispose();
                                    hv_ResultVals = ExpTmpLocalVar_ResultVals;
                                }
                            }
                        }
                        //The ground truth and predicted IDs are accumulated
                        //such that each confusion pair (class_i <-> class_j) gets a unique value.
                        hv_ConfTuple.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfTuple = (hv_NumClasses * hv_AnnotVals) + hv_ResultVals;
                        }
                        //Compute the histogram of this confusion tuple.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfHist.Dispose(); hv_BinSize.Dispose();
                            HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses * hv_NumClasses) - 1,
                                hv_NumClasses * hv_NumClasses, out hv_ConfHist, out hv_BinSize);
                        }
                        hv_ConfMatrixTmp.Dispose();
                        HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrixTmp.Dispose();
                            hv_ConfMatrixTmp = ExpTmpOutVar_0;
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //Get the ignore region.
                        ho_ClsIgnore.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
                        for (hv_IgnoreIndex = 0; (int)hv_IgnoreIndex <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )) - 1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ClsIgnoreTmp.Dispose();
                                HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
                                    hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0
                                    );
                                ho_ClsIgnore.Dispose();
                                ho_ClsIgnore = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Go through model classes.
                        for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                            )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                        {
                            hv_ClsId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsId = hv_ClassIDs.TupleSelect(
                                    hv_ClsIndex);
                            }
                            hv_ClsIdRes.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsIdRes = hv_ClassIDsResult.TupleSelect(
                                    hv_ClsIndex);
                            }
                            //Get the annotated region for this class.
                            ho_ClsAnnot.Dispose();
                            HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                            //Get the result region for this class.
                            ho_ClsResult.Dispose();
                            HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
                            //The pixels in the ignore region should not be considered.
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0
                                    );
                                ho_ClsResult.Dispose();
                                ho_ClsResult = ExpTmpOutVar_0;
                            }
                            //Get TP/FP/FN.
                            ho_TPReg.Dispose();
                            HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
                            ho_FPReg.Dispose();
                            HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
                            //We define false negatives as pixels that have been labeled as this class,
                            //but not been correctly predicted.
                            ho_FNReg.Dispose();
                            HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
                            //Get corresponding pixel numbers and update.
                            hv_ClsTP.Dispose();
                            HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
                            hv_ClsFP.Dispose();
                            HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
                            hv_ClsFN.Dispose();
                            HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
                            if (hv_TP == null)
                                hv_TP = new HTuple();
                            hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex)) + hv_ClsTP;
                            if (hv_FP == null)
                                hv_FP = new HTuple();
                            hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex)) + hv_ClsFP;
                            if (hv_FN == null)
                                hv_FN = new HTuple();
                            hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex)) + hv_ClsFN;
                        }
                    }
                }
                //
                //Update running measures.
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                }
                //
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_PixelMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_PixelMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update running measures for a region-based evaluation. 
        private void update_running_region_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Annot = null, ho_Result = null, ho_ClsAnnot = null;
            HObject ho_ClsResult = null, ho_ClsAnnotConnected = null, ho_ClsAnnotSelected = null;
            HObject ho_RegionIntersection = null;

            // Local control variables 

            HTuple hv_Measures = new HTuple(), hv_CalcRegionMeasures = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_GrippingMapExists = new HTuple();
            HTuple hv_ResultKey = new HTuple(), hv_ClassIDsResult = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_ClsIndex = new HTuple();
            HTuple hv_ClsId = new HTuple(), hv_ClsIdRes = new HTuple();
            HTuple hv_NumRegions = new HTuple(), hv_RegionIndex = new HTuple();
            HTuple hv_AreaIntersection = new HTuple(), hv_AreaGroundtruth = new HTuple();
            HTuple hv_RegionOverlap = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Annot);
            HOperatorSet.GenEmptyObj(out ho_Result);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
            HOperatorSet.GenEmptyObj(out ho_ClsResult);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnotConnected);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnotSelected);
            HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
            try
            {
                //
                //This procedure updates the RunningMeasures for a region-
                //based evaluation for 3D Gripping Point Detection.
                //These measures are stored in the dictionary RunningMeasures
                //and updated by incorporating the Results the model obtained
                //for the Samples.
                //
                //Check if we need to compute any region measures.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_CalcRegionMeasures.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcRegionMeasures = (new HTuple(((hv_Measures.TupleFind(
                        "mean_pro"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                if ((int)(hv_CalcRegionMeasures.TupleNot()) != 0)
                {
                    ho_Annot.Dispose();
                    ho_Result.Dispose();
                    ho_ClsAnnot.Dispose();
                    ho_ClsResult.Dispose();
                    ho_ClsAnnotConnected.Dispose();
                    ho_ClsAnnotSelected.Dispose();
                    ho_RegionIntersection.Dispose();

                    hv_Measures.Dispose();
                    hv_CalcRegionMeasures.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_GrippingMapExists.Dispose();
                    hv_ResultKey.Dispose();
                    hv_ClassIDsResult.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_ClsIndex.Dispose();
                    hv_ClsId.Dispose();
                    hv_ClsIdRes.Dispose();
                    hv_NumRegions.Dispose();
                    hv_RegionIndex.Dispose();
                    hv_AreaIntersection.Dispose();
                    hv_AreaGroundtruth.Dispose();
                    hv_RegionOverlap.Dispose();

                    return;
                }
                //
                //Get the class IDs.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //
                //Check and set result type and class IDs.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GrippingMapExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Results.TupleSelect(0), "key_exists", "gripping_map",
                        out hv_GrippingMapExists);
                }
                if ((int)(hv_GrippingMapExists) != 0)
                {
                    hv_ResultKey.Dispose();
                    hv_ResultKey = "gripping_map";
                    //Since the result is a binary gripping map, the class ID
                    //is always 1.
                    hv_ClassIDsResult.Dispose();
                    hv_ClassIDsResult = 1;
                }
                else
                {
                    throw new HalconException("No result available for evaluation");
                }
                //
                //Loop over images, i.e. sample dictionaries.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //Get annotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Annot.Dispose();
                        HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //Get result.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Result.Dispose();
                        HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                            hv_ResultKey);
                    }
                    //
                    //Go through model classes.
                    for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                        )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                    {
                        hv_ClsId.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClsId = hv_ClassIDs.TupleSelect(
                                hv_ClsIndex);
                        }
                        hv_ClsIdRes.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClsIdRes = hv_ClassIDsResult.TupleSelect(
                                hv_ClsIndex);
                        }
                        //Get the annotated region for this class.
                        ho_ClsAnnot.Dispose();
                        HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                        //Get the result region for this class.
                        ho_ClsResult.Dispose();
                        HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsIdRes, hv_ClsIdRes);
                        //
                        ho_ClsAnnotConnected.Dispose();
                        HOperatorSet.Connection(ho_ClsAnnot, out ho_ClsAnnotConnected);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.SelectShape(ho_ClsAnnotConnected, out ExpTmpOutVar_0, "area",
                                "and", 1, "max");
                            ho_ClsAnnotConnected.Dispose();
                            ho_ClsAnnotConnected = ExpTmpOutVar_0;
                        }
                        hv_NumRegions.Dispose();
                        HOperatorSet.CountObj(ho_ClsAnnotConnected, out hv_NumRegions);
                        HTuple end_val47 = hv_NumRegions;
                        HTuple step_val47 = 1;
                        for (hv_RegionIndex = 1; hv_RegionIndex.Continue(end_val47, step_val47); hv_RegionIndex = hv_RegionIndex.TupleAdd(step_val47))
                        {
                            ho_ClsAnnotSelected.Dispose();
                            HOperatorSet.SelectObj(ho_ClsAnnotConnected, out ho_ClsAnnotSelected,
                                hv_RegionIndex);
                            ho_RegionIntersection.Dispose();
                            HOperatorSet.Intersection(ho_ClsResult, ho_ClsAnnotSelected, out ho_RegionIntersection
                                );
                            hv_AreaIntersection.Dispose();
                            HOperatorSet.RegionFeatures(ho_RegionIntersection, "area", out hv_AreaIntersection);
                            hv_AreaGroundtruth.Dispose();
                            HOperatorSet.RegionFeatures(ho_ClsAnnotSelected, "area", out hv_AreaGroundtruth);
                            hv_RegionOverlap.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_RegionOverlap = (hv_AreaIntersection.TupleReal()
                                    ) / (hv_AreaGroundtruth.TupleReal());
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTupleAt(hv_RunningMeasures, "gt_overlap", hv_ClsIndex,
                                    (((hv_RunningMeasures.TupleGetDictTuple("gt_overlap"))).TupleSelect(
                                    hv_ClsIndex)) + hv_RegionOverlap);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTupleAt(hv_RunningMeasures, "num_gt_regions", hv_ClsIndex,
                                    (((hv_RunningMeasures.TupleGetDictTuple("num_gt_regions"))).TupleSelect(
                                    hv_ClsIndex)) + 1);
                            }
                        }
                    }
                }
                //
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_ClsAnnotConnected.Dispose();
                ho_ClsAnnotSelected.Dispose();
                ho_RegionIntersection.Dispose();

                hv_Measures.Dispose();
                hv_CalcRegionMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_SampleIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIndex.Dispose();
                hv_AreaIntersection.Dispose();
                hv_AreaGroundtruth.Dispose();
                hv_RegionOverlap.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_ClsAnnotConnected.Dispose();
                ho_ClsAnnotSelected.Dispose();
                ho_RegionIntersection.Dispose();

                hv_Measures.Dispose();
                hv_CalcRegionMeasures.Dispose();
                hv_ClassIDs.Dispose();
                hv_GrippingMapExists.Dispose();
                hv_ResultKey.Dispose();
                hv_ClassIDsResult.Dispose();
                hv_SampleIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsIdRes.Dispose();
                hv_NumRegions.Dispose();
                hv_RegionIndex.Dispose();
                hv_AreaIntersection.Dispose();
                hv_AreaGroundtruth.Dispose();
                hv_RegionOverlap.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update model parameters according to the change strategies. 
        private void update_train_dl_model_change_strategies(HTuple hv_DLModelHandle,
            HTuple hv_ChangeStrategyData, HTuple hv_Epoch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Enabled = new HTuple(), hv_ChangeStrategies = new HTuple();
            HTuple hv_SolverType = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ChangeStrategy = new HTuple(), hv_ModelParam = new HTuple();
            HTuple hv_Epochs = new HTuple(), hv_Values = new HTuple();
            HTuple hv_Initial = new HTuple(), hv_Greater = new HTuple();
            HTuple hv_ValueIndex = new HTuple(), hv_Value = new HTuple();
            HTuple hv_InternalCurrentExists = new HTuple(), hv_InternalCurrent = new HTuple();
            HTuple hv_ScaleThreshold = new HTuple(), hv_CurrentLR = new HTuple();
            HTuple hv_LRChangeRatio = new HTuple(), hv_PreviousMomentumExists = new HTuple();
            HTuple hv_CurrentMomentum = new HTuple(), hv_AdaptedMomentum = new HTuple();
            HTuple hv_AdaptedMomentumExists = new HTuple(), hv_PreviousMomentum = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates all parameters according to the change strategies
                //with respect to the current iteration.
                //
                hv_Enabled.Dispose();
                HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "enabled", out hv_Enabled);
                if ((int)(hv_Enabled.TupleNot()) != 0)
                {

                    hv_Enabled.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_SolverType.Dispose();
                    hv_Index.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ModelParam.Dispose();
                    hv_Epochs.Dispose();
                    hv_Values.Dispose();
                    hv_Initial.Dispose();
                    hv_Greater.Dispose();
                    hv_ValueIndex.Dispose();
                    hv_Value.Dispose();
                    hv_InternalCurrentExists.Dispose();
                    hv_InternalCurrent.Dispose();
                    hv_ScaleThreshold.Dispose();
                    hv_CurrentLR.Dispose();
                    hv_LRChangeRatio.Dispose();
                    hv_PreviousMomentumExists.Dispose();
                    hv_CurrentMomentum.Dispose();
                    hv_AdaptedMomentum.Dispose();
                    hv_AdaptedMomentumExists.Dispose();
                    hv_PreviousMomentum.Dispose();

                    return;
                }
                //
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "strategies", out hv_ChangeStrategies);
                hv_SolverType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "solver_type", out hv_SolverType);
                //
                //Update the parameter of each strategy.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ChangeStrategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_ModelParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
                    hv_Values.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
                    hv_Initial.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
                    //Epochs defines at which epoch the change happens. Its sorting is enforced during initialization.
                    hv_Greater.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Greater = hv_Epoch.TupleGreaterEqualElem(
                            hv_Epochs);
                    }
                    hv_ValueIndex.Dispose();
                    HOperatorSet.TupleFindLast(hv_Greater, 1, out hv_ValueIndex);
                    if ((int)(new HTuple(hv_ValueIndex.TupleEqual(-1))) != 0)
                    {
                        hv_Value.Dispose();
                        hv_Value = new HTuple(hv_Initial);
                    }
                    else
                    {
                        hv_Value.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value = hv_Values.TupleSelect(
                                hv_ValueIndex);
                        }
                    }
                    //Check current value and only make changes if the value changed.
                    hv_InternalCurrentExists.Dispose();
                    HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "internal_current_value",
                        out hv_InternalCurrentExists);
                    if ((int)(hv_InternalCurrentExists) != 0)
                    {
                        hv_InternalCurrent.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "internal_current_value",
                            out hv_InternalCurrent);
                    }
                    else
                    {
                        hv_InternalCurrent.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ModelParam, out hv_InternalCurrent);
                    }
                    //If the current value differs from the new value we change it.
                    if ((int)(new HTuple(((((hv_InternalCurrent.TupleNotEqualElem(hv_Value))).TupleSum()
                        )).TupleGreater(0))) != 0)
                    {
                        //If the changed model parameter is the learning rate, we also change the momentum
                        //to adapt the scale of the previous update.
                        if ((int)(new HTuple(hv_ModelParam.TupleEqual("learning_rate"))) != 0)
                        {
                            //Get the threshold.
                            hv_ScaleThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                                out hv_ScaleThreshold);
                            if ((int)((new HTuple((new HTuple(hv_ScaleThreshold.TupleLength())).TupleGreater(
                                0))).TupleAnd(new HTuple(hv_SolverType.TupleEqual("sgd")))) != 0)
                            {
                                hv_CurrentLR.Dispose();
                                HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ModelParam, out hv_CurrentLR);
                                //Check if the change is larger than the specified threshold.
                                hv_LRChangeRatio.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_LRChangeRatio = (((hv_Value.TupleReal()
                                        ) / (hv_CurrentLR.TupleMax2(1e-10)))).TupleMax2((hv_CurrentLR.TupleReal()
                                        ) / (hv_Value.TupleMax2(1e-10)));
                                }
                                if ((int)((new HTuple(hv_LRChangeRatio.TupleGreater(hv_ScaleThreshold))).TupleAnd(
                                    new HTuple(hv_CurrentLR.TupleGreater(1e-7)))) != 0)
                                {
                                    hv_PreviousMomentumExists.Dispose();
                                    HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "previous_momentum",
                                        out hv_PreviousMomentumExists);
                                    if ((int)(hv_PreviousMomentumExists) != 0)
                                    {
                                        hv_CurrentMomentum.Dispose();
                                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                            out hv_CurrentMomentum);
                                    }
                                    else
                                    {
                                        hv_CurrentMomentum.Dispose();
                                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "momentum", out hv_CurrentMomentum);
                                    }
                                    hv_AdaptedMomentum.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AdaptedMomentum = (hv_Value / (hv_CurrentLR.TupleReal()
                                            )) * hv_CurrentMomentum;
                                    }
                                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "momentum", hv_AdaptedMomentum);
                                    //In the next iteration the momentum has to be set back.
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "adapted_momentum",
                                        1);
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                        hv_CurrentMomentum);
                                }
                            }
                        }
                        HOperatorSet.SetDlModelParam(hv_DLModelHandle, hv_ModelParam, hv_Value);
                    }
                    else if ((int)((new HTuple(hv_ModelParam.TupleEqual("learning_rate"))).TupleAnd(
                        new HTuple(hv_SolverType.TupleEqual("sgd")))) != 0)
                    {
                        //Get the threshold.
                        hv_ScaleThreshold.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                            out hv_ScaleThreshold);
                        if ((int)(new HTuple((new HTuple(hv_ScaleThreshold.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            //Set the momentum back if it was adapted in the previous iteration.
                            hv_AdaptedMomentumExists.Dispose();
                            HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "adapted_momentum",
                                out hv_AdaptedMomentumExists);
                            if ((int)(hv_AdaptedMomentumExists) != 0)
                            {
                                hv_AdaptedMomentum.Dispose();
                                HOperatorSet.GetDictTuple(hv_ChangeStrategy, "adapted_momentum", out hv_AdaptedMomentum);
                                if ((int)(hv_AdaptedMomentum) != 0)
                                {
                                    hv_PreviousMomentum.Dispose();
                                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                        out hv_PreviousMomentum);
                                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "momentum", hv_PreviousMomentum);
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "adapted_momentum",
                                        0);
                                    HOperatorSet.RemoveDictKey(hv_ChangeStrategy, "previous_momentum");
                                }
                            }
                        }
                    }
                    //Store the new internal current value.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "internal_current_value", hv_Value);
                }

                hv_Enabled.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_SolverType.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Greater.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();
                hv_InternalCurrentExists.Dispose();
                hv_InternalCurrent.Dispose();
                hv_ScaleThreshold.Dispose();
                hv_CurrentLR.Dispose();
                hv_LRChangeRatio.Dispose();
                hv_PreviousMomentumExists.Dispose();
                hv_CurrentMomentum.Dispose();
                hv_AdaptedMomentum.Dispose();
                hv_AdaptedMomentumExists.Dispose();
                hv_PreviousMomentum.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Enabled.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_SolverType.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Greater.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();
                hv_InternalCurrentExists.Dispose();
                hv_InternalCurrent.Dispose();
                hv_ScaleThreshold.Dispose();
                hv_CurrentLR.Dispose();
                hv_LRChangeRatio.Dispose();
                hv_PreviousMomentumExists.Dispose();
                hv_CurrentMomentum.Dispose();
                hv_AdaptedMomentum.Dispose();
                hv_AdaptedMomentumExists.Dispose();
                hv_PreviousMomentum.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Serialize the model if a strategy applies to the current training status. 
        private void update_train_dl_model_serialization(HTuple hv_TrainParam, HTuple hv_SerializationData,
            HTuple hv_Iteration, HTuple hv_NumIterations, HTuple hv_Epoch, HTuple hv_EvaluationResult,
            HTuple hv_EvaluationOptimizationMethod, HTuple hv_DLModelHandle, HTuple hv_TrainInfos,
            HTuple hv_EvaluationInfos)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
            HTuple hv_Strategies = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Type = new HTuple(), hv_Data = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_EvaluationComparisonKeys = new HTuple();
            HTuple hv_Value = new HTuple(), hv_ValidEvaluationKeys = new HTuple();
            HTuple hv_CurrentBest = new HTuple(), hv_IsNewBest = new HTuple();
            HTuple hv_FilenameModel = new HTuple(), hv_FilenameMetaData = new HTuple();
            HTuple hv_Epochs = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_LastIndex = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //Serialize the model if a strategy applies to the current training status.
                //
                hv_RawData.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "raw_data", out hv_RawData);
                hv_Types.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "types", out hv_Types);
                hv_Strategies.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "strategies", out hv_Strategies);
                //
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Types.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //
                    hv_Type.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Type = hv_Types.TupleSelect(
                            hv_Index);
                    }
                    hv_Data.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Data = hv_RawData.TupleSelect(
                            hv_Index);
                    }
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_Strategies.TupleSelect(
                            hv_Index);
                    }
                    //
                    if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
                    {
                        //If there is no new evaluation result, we will not serialize.
                        if ((int)(new HTuple((new HTuple(hv_EvaluationResult.TupleLength())).TupleEqual(
                            0))) != 0)
                        {
                            continue;
                        }
                        //Get a single value which is combined based on the given evaluation keys.
                        hv_EvaluationComparisonKeys.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                            out hv_EvaluationComparisonKeys);
                        hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                        reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                            out hv_Value, out hv_ValidEvaluationKeys);
                        hv_CurrentBest.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "best_value", out hv_CurrentBest);
                        if ((int)(new HTuple(hv_CurrentBest.TupleEqual(-1))) != 0)
                        {
                            hv_IsNewBest.Dispose();
                            hv_IsNewBest = 1;
                        }
                        else if ((int)(new HTuple(hv_EvaluationOptimizationMethod.TupleEqual(
                            "min"))) != 0)
                        {
                            hv_IsNewBest.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IsNewBest = new HTuple(hv_Value.TupleLess(
                                    hv_CurrentBest));
                            }
                        }
                        else
                        {
                            hv_IsNewBest.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IsNewBest = new HTuple(hv_Value.TupleGreater(
                                    hv_CurrentBest));
                            }
                        }
                        if ((int)(hv_IsNewBest) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_Data, "best_value", hv_Value);
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Value,
                                hv_Strategy, hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel,
                                out hv_FilenameMetaData);
                        }
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        if ((int)(new HTuple(hv_Iteration.TupleEqual(hv_NumIterations - 1))) != 0)
                        {
                            //Serialize final model.
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, new HTuple(),
                                hv_Strategy, hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel,
                                out hv_FilenameMetaData);
                        }
                    }
                    else if ((int)((new HTuple(hv_Type.TupleEqual("epochs"))).TupleOr(
                        new HTuple(hv_Type.TupleEqual("current")))) != 0)
                    {
                        //Check if the specified epoch is reached.
                        hv_Epochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "epochs", out hv_Epochs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFindLast(hv_Epoch.TupleLessElem(hv_Epochs), 0, out hv_Indices);
                        }
                        //Also check that the last saved epoch is not the same.
                        hv_LastIndex.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "last_epoch_index", out hv_LastIndex);
                        if ((int)((new HTuple(hv_Type.TupleEqual("current"))).TupleAnd(new HTuple((new HTuple(hv_EvaluationResult.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //For type current we also write every EvaluationIntervalEpochs epochs.
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, new HTuple(),
                                hv_Strategy, hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel,
                                out hv_FilenameMetaData);
                        }
                        else if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength()
                            )).TupleGreater(0))) != 0)
                        {
                            //
                            if ((int)((new HTuple(((hv_Indices.TupleSelect(0))).TupleGreater(-1))).TupleAnd(
                                new HTuple(((hv_Indices.TupleSelect(0))).TupleNotEqual(hv_LastIndex)))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", hv_Indices.TupleSelect(
                                        0));
                                }
                                //Serialize final model.
                                hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                                serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, new HTuple(),
                                    hv_Strategy, hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel,
                                    out hv_FilenameMetaData);
                            }
                        }
                    }
                }
                //

                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_Strategies.Dispose();
                hv_Index.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Strategy.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_CurrentBest.Dispose();
                hv_IsNewBest.Dispose();
                hv_FilenameModel.Dispose();
                hv_FilenameMetaData.Dispose();
                hv_Epochs.Dispose();
                hv_Indices.Dispose();
                hv_LastIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_Strategies.Dispose();
                hv_Index.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Strategy.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_CurrentBest.Dispose();
                hv_IsNewBest.Dispose();
                hv_FilenameModel.Dispose();
                hv_FilenameMetaData.Dispose();
                hv_Epochs.Dispose();
                hv_Indices.Dispose();
                hv_LastIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Set and return meta information to display images correctly. 
        private void update_window_meta_information(HTuple hv_WindowHandle, HTuple hv_WidthImage,
            HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth,
            HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth,
            out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
            HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
            HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
            HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
            HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatioHeight = new HTuple();
            hv_WindowImageRatioWidth = new HTuple();
            hv_SetPartRow2 = new HTuple();
            hv_SetPartColumn2 = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure sets and returns meta information to display images correctly.
                //
                //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                hv_WindowImageRatioHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioHeight = hv_WindowHeight / (hv_HeightImage * 1.0);
                }
                hv_WindowImageRatioWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioWidth = hv_WindowWidth / (hv_WidthImage * 1.0);
                }
                //
                //Set window part such that image is displayed undistorted.
                hv_WindowRow2.Dispose();
                hv_WindowRow2 = new HTuple(hv_WindowHeight);
                hv_WindowColumn2.Dispose();
                hv_WindowColumn2 = new HTuple(hv_WindowWidth);
                hv_WindowRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRatio = hv_WindowColumn2 / (hv_WindowRow2 * 1.0);
                }
                //
                hv_ImageRow2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRow2 = hv_HeightImage + (hv_MarginBottom / hv_WindowImageRatioHeight);
                }
                hv_ImageColumn2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageColumn2 = hv_WidthImage + (hv_MapColorBarWidth / hv_WindowImageRatioWidth);
                }
                hv_ImageRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRatio = hv_ImageColumn2 / (hv_ImageRow2 * 1.0);
                }
                if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
                {
                    //
                    //Extend image until right window border.
                    hv_SetPartColumn2.Dispose();
                    hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageColumn2 / (hv_WindowColumn2 * 1.0);
                    }
                    hv_ImageRow2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageRow2InWindow = hv_ImageRow2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartRow2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartRow2 = hv_ImageRow2 + ((hv_WindowRow2 - hv_ImageRow2InWindow) / hv_WindowImageRatioWidth);
                    }
                }
                else
                {
                    //
                    //Extend image until bottom of window.
                    hv_SetPartRow2.Dispose();
                    hv_SetPartRow2 = new HTuple(hv_ImageRow2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageRow2 / (hv_WindowRow2 * 1.0);
                    }
                    hv_ImageCol2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageCol2InWindow = hv_ImageColumn2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartColumn2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartColumn2 = hv_ImageColumn2 + ((hv_WindowColumn2 - hv_ImageCol2InWindow) / hv_WindowImageRatioHeight);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2 - 1,
                            hv_SetPartColumn2 - 1);
                    }
                }
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
                }
                //

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Check that all given entries in EvalParams are valid. 
        private void validate_evaluation_param(HTuple hv_EvalParams, out HTuple hv_Valid,
            out HTuple hv_Exception)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_EvalInstancesExists = new HTuple(), hv_EvaluationTypeExists = new HTuple();
            HTuple hv_EvaluationType = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_ValidMeasures = new HTuple(), hv_Ks = new HTuple();
            HTuple hv_KeysExist = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_IouThreshExists = new HTuple(), hv_IouThresholds = new HTuple();
            HTuple hv_MaxNumDetectionsExists = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRangesExist = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaKeysExist = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_InstanceTypeExists = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_ValidInstanceTypes = new HTuple(), hv_AllocationBlockLengthExists = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluationExists = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_InterpolatePRCurves = new HTuple(), hv_IgnoreClassIDsExist = new HTuple();
            HTuple hv_ValidMeasuresString = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_ValidMeasure = new HTuple();
            // Initialize local and output iconic variables 
            hv_Valid = new HTuple();
            hv_Exception = new HTuple();
            try
            {
                //
                //This procedure checks if the dictionary EvalParams
                //contains all necessary parameters and if they are valid (type, range, ...).
                //
                hv_Valid.Dispose();
                hv_Valid = 0;
                hv_Exception.Dispose();
                hv_Exception = "";
                //Check class IDs.
                hv_ClassIDsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
                if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should have at least length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
                        new HTuple(hv_ClassIDs.TupleLength()), 1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
                        -1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be positive or zero";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry num_classes.
                hv_NumClassesExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
                if ((int)(hv_NumClassesExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
                        )).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be at least 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check that num_classes is equal to |class_ids|.
                if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
                    )))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluate_instances'.
                hv_EvalInstancesExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances",
                    out hv_EvalInstancesExists);
                if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluation_type'.
                hv_EvaluationTypeExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", out hv_EvaluationTypeExists);
                if ((int)(hv_EvaluationTypeExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluation_type'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_EvaluationType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind((((((((new HTuple("3d_gripping_point_detection")).TupleConcat(
                        "anomaly_detection")).TupleConcat("classification")).TupleConcat("detection")).TupleConcat(
                        "gc_anomaly_detection")).TupleConcat("ocr_recognition")).TupleConcat(
                        "ocr_detection")).TupleConcat("segmentation"), hv_EvaluationType, out hv_Indices);
                    if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = "Invalid entry for 'evaluation_type': " + hv_EvaluationType;
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry 'measures'.
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'measures' should contain at least one entry";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check evaluation type specific entries of EvalParams.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("3d_gripping_point_detection"))) != 0)
                {
                    //Pixel- and region-based evaluation.
                    hv_ValidMeasures.Dispose();
                    get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                ((((new HTuple("mean_pro")).TupleConcat("gripping_point_precision")).TupleConcat(
                                "gripping_point_recall")).TupleConcat("gripping_point_f_score")).TupleConcat(
                                "all"));
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                }
                else if ((int)((new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))).TupleOr(
                    new HTuple(hv_EvaluationType.TupleEqual("gc_anomaly_detection")))) != 0)
                {
                    //
                    //Check for correct number of classes.
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleNotEqual(
                        2))) != 0)
                    {
                        throw new HalconException("The number of classes must be 2 for model type 'anomaly_detection' or 'gc_anomaly_detection'.");
                    }
                    //
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "anomaly_score_histogram";
                    hv_ValidMeasures[1] = "precision";
                    hv_ValidMeasures[2] = "recall";
                    hv_ValidMeasures[3] = "absolute_confusion_matrix";
                    hv_ValidMeasures[4] = "relative_confusion_matrix";
                    hv_ValidMeasures[5] = "all";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ks.Dispose();
                        HOperatorSet.TupleGenSequence(1, new HTuple(hv_ClassIDs.TupleLength()), 1,
                            out hv_Ks);
                    }
                    hv_ValidMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasures = new HTuple();
                        hv_ValidMeasures[0] = "all";
                        hv_ValidMeasures = hv_ValidMeasures.TupleConcat(("top" + hv_Ks) + "_error");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                ((((new HTuple("precision")).TupleConcat("recall")).TupleConcat("f_score")).TupleConcat(
                                "absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix"));
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                    //
                    //Check if not both of the two options to specify the evaluated classes are chosen.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                        "class_ids_to_evaluate"), out hv_KeysExist);
                    if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                    {
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                        hv_ClassesToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                        if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                        hv_ClassIDsToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                        if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //Instance-based evaluation.
                    //Add instance measures.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "mean_ap";
                    //
                    //Check if the entry 'iou_threshold' is present.
                    hv_IouThreshExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
                    if ((int)(hv_IouThreshExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_IouThresholds.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
                        //Check the length of 'iou_threshold'.
                        if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()), 1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' should be of type real";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if the IoU thresholds are within (0.0, 1.0).
                        if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
                            new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'max_num_detections' is present.
                    hv_MaxNumDetectionsExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections",
                        out hv_MaxNumDetectionsExists);
                    if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_MaxNumDetections.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                        //Check the length of 'max_num_detections'.
                        if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),
                            1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'max_num_detections' is -1 (to use all detections) or positive.
                        if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
                            new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be -1 or positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'area_ranges' is present.
                    hv_AreaRangesExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
                    if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        //Check if the entry 'area_ranges' is a dict.
                        hv_AreaRanges.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                        if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' must be a dict";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check that the necessary keys exist.
                        hv_AreaKeysExist.Dispose();
                        HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
                            "min")).TupleConcat("max"), out hv_AreaKeysExist);
                        if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'name'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'min'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the lengths of the area keys.
                        hv_AreaNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                        if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'name' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MinAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                        if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MaxAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                        if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'max' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                            new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                            )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check values of min, max.
                        if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
                            1))).TupleGreater(-1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if instance-type is valid.
                    hv_InstanceTypeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
                    if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                        hv_ValidInstanceTypes.Dispose();
                        hv_ValidInstanceTypes = new HTuple();
                        hv_ValidInstanceTypes[0] = "rectangle1";
                        hv_ValidInstanceTypes[1] = "rectangle2";
                        hv_ValidInstanceTypes[2] = "mask";
                        if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
                            -1))) != 0)
                        {
                            hv_Exception.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Exception = ("Invalid instance type '" + hv_InstanceType) + "'";
                            }

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'allocation_block_length' is present and valid.
                    hv_AllocationBlockLengthExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length",
                        out hv_AllocationBlockLengthExists);
                    if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_AllocationBlockLength.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                        //Check the length of 'allocation_block_length'.
                        if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength()
                            )).TupleNotEqual(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'allocation_block_length'.
                        if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
                            (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'allocation_block_length' is larger than zero.
                        if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'detailed_evaluation' is valid if present.
                    hv_DetailedEvaluationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                        out hv_DetailedEvaluationExists);
                    if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_DetailedEvaluation.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                        //Check the length of 'detailed_evaluation'.
                        if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'detailed_evaluation'.
                        if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'detailed_evaluation' is true or false.
                        if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_DetailedEvaluation.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'interpolate_pr_curves' is valid if present.
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves",
                        out hv_KeyExists);
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'interpolate_pr_curves'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InterpolatePRCurves.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                        //Check the length of 'interpolate_pr_curves'.
                        if ((int)(new HTuple((new HTuple(hv_InterpolatePRCurves.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'interpolate_pr_curves'.
                        if ((int)(new HTuple(((hv_InterpolatePRCurves.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'interpolate_pr_curves' is true or false.
                        if ((int)((new HTuple(hv_InterpolatePRCurves.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_InterpolatePRCurves.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Add valid measure 'soap' if instance_type is 'rectangle2'.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                    "soap");
                                hv_ValidMeasures.Dispose();
                                hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //Pixel-based evaluation.
                    hv_ValidMeasures.Dispose();
                    get_valid_pixel_measures(hv_EvaluationType, out hv_ValidMeasures);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                "all");
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                    //
                    //Check if the entry 'ignore_class_ids' exists.
                    hv_IgnoreClassIDsExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids",
                        out hv_IgnoreClassIDsExist);
                    if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_recognition"))) != 0)
                {
                    //OCR recognition evaluation.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = "accuracy";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("ocr_detection"))) != 0)
                {
                    //OCR detection evaluation.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "recall";
                    hv_ValidMeasures[2] = "precision";
                    hv_ValidMeasures[3] = "f_score";
                    hv_ValidMeasures[4] = "soap";
                }
                else
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "Unknown evaluation_type: " + hv_EvaluationType;
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check measures.
                hv_ValidMeasuresString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasuresString = HTuple.TupleGenConst(
                        ((new HTuple(hv_ValidMeasures.TupleLength())) * 2) - 1, new HTuple("','"));
                }
                if (hv_ValidMeasuresString == null)
                    hv_ValidMeasuresString = new HTuple();
                hv_ValidMeasuresString[HTuple.TupleGenSequence(0, (new HTuple(hv_ValidMeasuresString.TupleLength()
                    )) - 1, 2)] = hv_ValidMeasures;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
                            ;
                        hv_ValidMeasuresString.Dispose();
                        hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
                    }
                }
                for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
                {
                    hv_ValidMeasure.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
                            hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
                    }
                    if ((int)(hv_ValidMeasure.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = ((("Invalid measure '" + (hv_Measures.TupleSelect(
                                hv_Idx))) + new HTuple("', choose one of ['")) + hv_ValidMeasuresString) + "']";
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //
                //Done with checks.
                hv_Valid.Dispose();
                hv_Valid = 1;

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Local procedures 
        // Short Description: Remove the preprocessed dataset generated by this example. 
        public void clean_up_output(HTuple hv_PreprocessDir)
        {


            // Initialize local and output iconic variables 
            //This local example procedure removes the
            //directory of the preprocessed dataset.

            //Display a warning.
            display_info_text("clean_up");
            // stop(...); only in hdevelop
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }

            remove_dir_recursively(hv_PreprocessDir);



            return;
        }

        // Short Description: Visualize the anomaly images of the local and the global network of the Global Context Anomaly Detection model. 
        public void compare_gc_anomaly_networks(HTuple hv_ImageDir, HTuple hv_ImageSubDirs,
            HTuple hv_DLPreprocessParam, HTuple hv_DLModelHandle)
        {



            // Local iconic variables 

            HObject ho_Image = null;

            // Local control variables 

            HTuple hv_MaxNumImagesPerSubdir = new HTuple();
            HTuple hv_MetaData = new HTuple(), hv_ClassificationThreshold = new HTuple();
            HTuple hv_SegmentationThreshold = new HTuple(), hv_DLDatasetInfo = new HTuple();
            HTuple hv_SubDirIndex = new HTuple(), hv_SubDir = new HTuple();
            HTuple hv_ImageFiles = new HTuple(), hv_ImagePaths = new HTuple();
            HTuple hv_WindowDict = new HTuple(), hv_IndexInference = new HTuple();
            HTuple hv_DLSample = new HTuple(), hv_DLResult = new HTuple();
            HTuple hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //The GC-AD model consists of two subnetworks, the local and
                //the global network. See the Chapter Reference for more
                //details on this topic.

                //In this local example procedure, we visualize the anomaly
                //images of the local and the global network of the GC-AD model.

                //For each defect type in the given ImageSubDirs, we pick 10
                //images to which we apply the model. In the example dataset,
                //the two defect types are 'logical_anomaly' and
                //'structural_anomaly'.

                //As a result one should see that the local network is good at
                //detecting structural anomalies, while the global network
                //successfully finds logical anomalies. Some of the defects are
                //detected by both subnetworks.

                display_info_text("compare_gc_anomaly_networks");
                // stop(...); only in hdevelop
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                hv_MaxNumImagesPerSubdir.Dispose();
                hv_MaxNumImagesPerSubdir = 10;

                //Get thresholds for inference. These have been stored along with
                //the model in the meta data.
                hv_MetaData.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "meta_data", out hv_MetaData);
                hv_ClassificationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassificationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_classification_threshold"))).TupleNumber();
                }
                hv_SegmentationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_segmentation_threshold"))).TupleNumber();
                }

                //Create a dictionary with dataset parameters used for display.
                hv_DLDatasetInfo.Dispose();
                HOperatorSet.CreateDict(out hv_DLDatasetInfo);
                HOperatorSet.SetDictTuple(hv_DLDatasetInfo, "class_names", (new HTuple("ok")).TupleConcat(
                    "nok"));
                HOperatorSet.SetDictTuple(hv_DLDatasetInfo, "class_ids", (new HTuple(0)).TupleConcat(
                    1));

                //Iterate over all subdirectories that contain defects.
                for (hv_SubDirIndex = 0; (int)hv_SubDirIndex <= (int)((new HTuple(hv_ImageSubDirs.TupleLength()
                    )) - 1); hv_SubDirIndex = (int)hv_SubDirIndex + 1)
                {
                    hv_SubDir.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SubDir = hv_ImageSubDirs.TupleSelect(
                            hv_SubDirIndex);
                    }
                    if ((int)((new HTuple(((hv_SubDir.TupleRegexpMatch((new HTuple("^ok$")).TupleConcat(
                        "ignore_case")))).TupleNotEqual(""))).TupleOr(new HTuple(((hv_SubDir.TupleRegexpMatch(
                        (new HTuple("^good$")).TupleConcat("ignore_case")))).TupleNotEqual("")))) != 0)
                    {
                        //Skip the subdirectory, because it is named 'ok' or 'good'.
                        continue;
                    }

                    //Get paths to randomly chosen images from this subdirectory.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageFiles.Dispose();
                        list_image_files((hv_ImageDir + "/") + hv_SubDir, "default", new HTuple(), out hv_ImageFiles);
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        tuple_shuffle(hv_ImageFiles, out ExpTmpOutVar_0);
                        hv_ImageFiles.Dispose();
                        hv_ImageFiles = ExpTmpOutVar_0;
                    }
                    hv_ImagePaths.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImagePaths = hv_ImageFiles.TupleSelectRange(
                            0, hv_MaxNumImagesPerSubdir - 1);
                    }

                    //Infer images containing anomalies with the local and
                    //the global network.
                    hv_WindowDict.Dispose();
                    HOperatorSet.CreateDict(out hv_WindowDict);
                    for (hv_IndexInference = 0; (int)hv_IndexInference <= (int)((new HTuple(hv_ImagePaths.TupleLength()
                        )) - 1); hv_IndexInference = (int)hv_IndexInference + 1)
                    {

                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            HOperatorSet.ReadImage(out ho_Image, hv_ImagePaths.TupleSelect(hv_IndexInference));
                        }
                        hv_DLSample.Dispose();
                        gen_dl_samples_from_images(ho_Image, out hv_DLSample);
                        preprocess_dl_samples(hv_DLSample, hv_DLPreprocessParam);

                        hv_DLResult.Dispose();
                        HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSample, (new HTuple("anomaly_image_local")).TupleConcat(
                            "anomaly_image_global"), out hv_DLResult);

                        //Apply thresholds to classify regions and the entire image.
                        threshold_dl_anomaly_results(hv_SegmentationThreshold, hv_ClassificationThreshold,
                            hv_DLResult);

                        //Display the inference result.
                        dev_display_dl_data(hv_DLSample, hv_DLResult, hv_DLDatasetInfo, ((new HTuple("image")).TupleConcat(
                            "anomaly_image_local")).TupleConcat("anomaly_image_global"), new HTuple(),
                            hv_WindowDict);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = ("Defect type:\n" + hv_SubDir) + "\n\nPress F5 (continue)";
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                "bottom", "center", "black", new HTuple(), new HTuple());
                        }
                        // stop(...); only in hdevelop
                    }
                    dev_close_window_dict(hv_WindowDict);
                }
                ho_Image.Dispose();

                hv_MaxNumImagesPerSubdir.Dispose();
                hv_MetaData.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_DLDatasetInfo.Dispose();
                hv_SubDirIndex.Dispose();
                hv_SubDir.Dispose();
                hv_ImageFiles.Dispose();
                hv_ImagePaths.Dispose();
                hv_WindowDict.Dispose();
                hv_IndexInference.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_MaxNumImagesPerSubdir.Dispose();
                hv_MetaData.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_DLDatasetInfo.Dispose();
                hv_SubDirIndex.Dispose();
                hv_SubDir.Dispose();
                hv_ImageFiles.Dispose();
                hv_ImagePaths.Dispose();
                hv_WindowDict.Dispose();
                hv_IndexInference.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Display informative text about the progress of the example. 
        public void display_info_text(HTuple hv_Part)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandle = new HTuple(), hv_Texts = new HTuple();
            HTuple hv_Colors = new HTuple(), hv_StandardColor = new HTuple();
            HTuple hv_FocusColor = new HTuple(), hv_Text = new HTuple();
            HTuple hv_Title = new HTuple(), hv_Body = new HTuple();
            HTuple hv_LineColors = new HTuple(), hv_TextIndex = new HTuple();
            HTuple hv_TextColor = new HTuple(), hv_NumLines = new HTuple();
            HTuple hv_Position = new HTuple(), hv_LineIndex = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //Helper procedure for displaying informative text at the
                //start of each part of the workflow.
                HOperatorSet.SetWindowAttr("background_color", "light gray");
                HOperatorSet.OpenWindow(0, 0, 500, 300, 0, "visible", "", out hv_WindowHandle);
                HDevWindowStack.Push(hv_WindowHandle);

                set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
                //Texts and Colors should have the same length.
                //Colors contains the color for each text in Texts.
                hv_Texts.Dispose();
                hv_Texts = new HTuple();
                hv_Colors.Dispose();
                hv_Colors = new HTuple();
                hv_StandardColor.Dispose();
                hv_StandardColor = "black";
                hv_FocusColor.Dispose();
                hv_FocusColor = "#f28d26";
                if ((int)(new HTuple(hv_Part.TupleEqual("start"))) != 0)
                {
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple();
                    hv_Text.Dispose();
                    hv_Text = "The workflow is split up into different";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\nparts which are encapsulated in ";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\nseparate local procedures:";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n\n1. load_dataset_and_model";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n2. train";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n3. evaluate";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n4. inference";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n5. compare_gc_anomaly_networks";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Texts = hv_Texts.TupleConcat(
                                hv_Text);
                            hv_Texts.Dispose();
                            hv_Texts = ExpTmpLocalVar_Texts;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Colors = hv_Colors.TupleConcat(
                                hv_StandardColor);
                            hv_Colors.Dispose();
                            hv_Colors = ExpTmpLocalVar_Colors;
                        }
                    }

                    hv_Text.Dispose();
                    hv_Text = "\nPress Run (F5) to enter the first procedure.";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Texts = hv_Texts.TupleConcat(
                                hv_Text);
                            hv_Texts.Dispose();
                            hv_Texts = ExpTmpLocalVar_Texts;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Colors = hv_Colors.TupleConcat(
                                hv_StandardColor);
                            hv_Colors.Dispose();
                            hv_Colors = ExpTmpLocalVar_Colors;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Part.TupleEqual("clean_up"))) != 0)
                {
                    hv_Text.Dispose();
                    hv_Text = new HTuple("Congratulations, you have finished the example.");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\n\nPress Run (F5) to remove the directory";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Text = hv_Text + "\nof the preprocessed dataset.";
                            hv_Text.Dispose();
                            hv_Text = ExpTmpLocalVar_Text;
                        }
                    }
                    hv_Texts.Dispose();
                    hv_Texts = new HTuple(hv_Text);
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple(hv_StandardColor);
                }
                else
                {
                    hv_Title.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Title = hv_Part + "\n";
                    }
                    if ((int)(new HTuple(hv_Part.TupleEqual("load_dataset_and_model"))) != 0)
                    {
                        hv_Body.Dispose();
                        hv_Body = new HTuple("In this part, the model is loaded and");
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + new HTuple("\nthe dataset is preprocessed. Then, randomly");
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nselected preprocessed images are shown.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\n\nPress Run (F5) to continue.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                    }
                    else if ((int)(new HTuple(hv_Part.TupleEqual("train"))) != 0)
                    {
                        hv_Body.Dispose();
                        hv_Body = new HTuple("In this part, the model is trained on");
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nanomaly-free ('ok') images.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + new HTuple("\nDepending on the GPU, the training");
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nmay take multiple hours.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\n\nPress Run (F5) to continue.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                    }
                    else if ((int)(new HTuple(hv_Part.TupleEqual("evaluate"))) != 0)
                    {
                        hv_Body.Dispose();
                        hv_Body = new HTuple("In this part, a classification threshold");
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nand a segmentation threshold are computed.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + new HTuple("\nThen, the model is evaluated on test images.");
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\n\nPress Run (F5) to continue.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                    }
                    else if ((int)(new HTuple(hv_Part.TupleEqual("inference"))) != 0)
                    {
                        hv_Body.Dispose();
                        hv_Body = new HTuple("In this part, the model is applied to some");
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\ntest images that have not been used during";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\ntraining.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\n\nPress Run (F5) to continue.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                    }
                    else if ((int)(new HTuple(hv_Part.TupleEqual("compare_gc_anomaly_networks"))) != 0)
                    {
                        hv_Body.Dispose();
                        hv_Body = new HTuple("The GC-AD model consists of two subnetworks,");
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nthe local and the global network.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + new HTuple("\nIn this procedure, we visualize the");
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nanomaly images of each subnetwork.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\n\nThis step is optional and can be skipped.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Body = hv_Body + "\nPress Run (F5) to continue.";
                                hv_Body.Dispose();
                                hv_Body = ExpTmpLocalVar_Body;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Unknown part: " + hv_Part);
                    }
                    hv_Texts.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Texts = new HTuple();
                        hv_Texts = hv_Texts.TupleConcat(hv_Title, hv_Body);
                    }
                    hv_Colors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors = new HTuple();
                        hv_Colors = hv_Colors.TupleConcat(hv_FocusColor, hv_StandardColor);
                    }
                }

                //Color each text differently. For that, we need to find out the
                //color of each line in the sum of strings in Texts.
                hv_LineColors.Dispose();
                hv_LineColors = new HTuple();
                for (hv_TextIndex = 0; (int)hv_TextIndex <= (int)((new HTuple(hv_Texts.TupleLength()
                    )) - 1); hv_TextIndex = (int)hv_TextIndex + 1)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = hv_Texts.TupleSelect(
                            hv_TextIndex);
                    }
                    hv_TextColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TextColor = hv_Colors.TupleSelect(
                            hv_TextIndex);
                    }
                    //Find out how many lines Text has.
                    hv_NumLines.Dispose();
                    hv_NumLines = 1;
                    hv_Position.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Position = hv_Text.TupleStrchr(
                            "\n");
                    }
                    while ((int)(new HTuple(hv_Position.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumLines = hv_NumLines + 1;
                                hv_NumLines.Dispose();
                                hv_NumLines = ExpTmpLocalVar_NumLines;
                            }
                        }
                        if ((int)(new HTuple(((hv_Position + 1)).TupleEqual(hv_Text.TupleStrlen()
                            ))) != 0)
                        {
                            break;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Text = hv_Text.TupleSubstr(
                                    hv_Position + 1, (hv_Text.TupleStrlen()) - 1);
                                hv_Text.Dispose();
                                hv_Text = ExpTmpLocalVar_Text;
                            }
                        }
                        hv_Position.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Position = hv_Text.TupleStrchr(
                                "\n");
                        }
                    }
                    //Append TextColor to LineColors for each line in Text.
                    HTuple end_val88 = hv_NumLines - 1;
                    HTuple step_val88 = 1;
                    for (hv_LineIndex = 0; hv_LineIndex.Continue(end_val88, step_val88); hv_LineIndex = hv_LineIndex.TupleAdd(step_val88))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LineColors = hv_LineColors.TupleConcat(
                                    hv_TextColor);
                                hv_LineColors.Dispose();
                                hv_LineColors = ExpTmpLocalVar_LineColors;
                            }
                        }
                    }
                }

                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Texts.TupleJoin("\n"),
                            "window", "center", "center", hv_LineColors, "box", "false");
                    }
                }


                hv_WindowHandle.Dispose();
                hv_Texts.Dispose();
                hv_Colors.Dispose();
                hv_StandardColor.Dispose();
                hv_FocusColor.Dispose();
                hv_Text.Dispose();
                hv_Title.Dispose();
                hv_Body.Dispose();
                hv_LineColors.Dispose();
                hv_TextIndex.Dispose();
                hv_TextColor.Dispose();
                hv_NumLines.Dispose();
                hv_Position.Dispose();
                hv_LineIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandle.Dispose();
                hv_Texts.Dispose();
                hv_Colors.Dispose();
                hv_StandardColor.Dispose();
                hv_FocusColor.Dispose();
                hv_Text.Dispose();
                hv_Title.Dispose();
                hv_Body.Dispose();
                hv_LineColors.Dispose();
                hv_TextIndex.Dispose();
                hv_TextColor.Dispose();
                hv_NumLines.Dispose();
                hv_Position.Dispose();
                hv_LineIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Calculate classification and segmentation thresholds and evaluate the trained model. 
        public void evaluate(HTuple hv_DLDataset, HTuple hv_DLModelHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GenParamThreshold = new HTuple();
            HTuple hv_SegmentationThreshold = new HTuple(), hv_ClassificationThresholds = new HTuple();
            HTuple hv_GenParamEvaluation = new HTuple(), hv_EvaluationResult = new HTuple();
            HTuple hv_EvalParams = new HTuple(), hv_GenParamDisplay = new HTuple();
            HTuple hv_WindowDict = new HTuple(), hv_ClassificationThresholdIndex = new HTuple();
            HTuple hv_ClassificationThreshold = new HTuple(), hv_MetaData = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This local example procedure calculates classification and
                //segmentation thresholds and evaluates the performance of
                //the trained model.

                display_info_text("evaluate");
                // stop(...); only in hdevelop
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                //Estimate threshold values. They are used to determine if
                //a pixel or image is regarded as anomalous. The procedure
                //compute_dl_anomaly_thresholds returns possible suggestions
                //based on the dataset used. Depending on the application,
                //manual fine-tuning may be beneficial. See the documentation
                //of compute_dl_anomaly_thresholds for details.
                hv_GenParamThreshold.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamThreshold);
                HOperatorSet.SetDictTuple(hv_GenParamThreshold, "enable_display", "true");
                HOperatorSet.SetDictTuple(hv_GenParamThreshold, "segmentation_criterion", "tolerance");
                HOperatorSet.SetDictTuple(hv_GenParamThreshold, "segmentation_tolerance", 0.0);
                hv_SegmentationThreshold.Dispose(); hv_ClassificationThresholds.Dispose();
                compute_dl_anomaly_thresholds(hv_DLModelHandle, hv_DLDataset, hv_GenParamThreshold,
                    out hv_SegmentationThreshold, out hv_ClassificationThresholds);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                // stop(...); only in hdevelop
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                //Set generic evaluation parameters and evaluate the model on the
                //test split.
                hv_GenParamEvaluation.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamEvaluation);
                HOperatorSet.SetDictTuple(hv_GenParamEvaluation, "measures", "all");
                HOperatorSet.SetDictTuple(hv_GenParamEvaluation, "anomaly_classification_thresholds",
                    hv_ClassificationThresholds);
                HOperatorSet.SetDictTuple(hv_GenParamEvaluation, "gc_anomaly_networks", (new HTuple("local")).TupleConcat(
                    "global"));
                hv_EvaluationResult.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "test", hv_GenParamEvaluation,
                    out hv_EvaluationResult, out hv_EvalParams);

                //Visualize the histogram of the image-level anomaly scores of
                //the test images and the classification thresholds used for the
                //evaluation.
                hv_GenParamDisplay.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamDisplay);
                HOperatorSet.SetDictTuple(hv_GenParamDisplay, "display_mode", (new HTuple("score_histogram")).TupleConcat(
                    "score_legend"));
                hv_WindowDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowDict);
                dev_display_anomaly_detection_evaluation(hv_EvaluationResult, hv_EvalParams,
                    hv_GenParamDisplay, hv_WindowDict);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }
                // stop(...); only in hdevelop
                dev_close_window_dict(hv_WindowDict);

                //Visualize evaluation results such as precision, recall, and
                //confusion matrix for a given classification threshold.
                HOperatorSet.SetDictTuple(hv_GenParamDisplay, "display_mode", ((new HTuple("pie_charts_precision")).TupleConcat(
                    "pie_charts_recall")).TupleConcat("absolute_confusion_matrix"));
                //Select evaluation results for one threshold by its index in
                //ClassificationThresholds for display. We use the last
                //one of the computed ClassificationThresholds.
                //Please note that you should check which ClassificationThreshold
                //best fits your application.
                hv_ClassificationThresholdIndex.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassificationThresholdIndex = (new HTuple(hv_ClassificationThresholds.TupleLength()
                        )) - 1;
                }
                HOperatorSet.SetDictTuple(hv_GenParamDisplay, "classification_threshold_index",
                    hv_ClassificationThresholdIndex);
                hv_WindowDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowDict);
                dev_display_anomaly_detection_evaluation(hv_EvaluationResult, hv_EvalParams,
                    hv_GenParamDisplay, hv_WindowDict);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                // stop(...); only in hdevelop
                dev_close_window_dict(hv_WindowDict);

                //Set the threshold that should be returned.
                hv_ClassificationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassificationThreshold = hv_ClassificationThresholds.TupleSelect(
                        hv_ClassificationThresholdIndex);
                }
                //Store the thresholds in the model's meta data.
                hv_MetaData.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "meta_data", out hv_MetaData);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaData, "anomaly_segmentation_threshold", hv_SegmentationThreshold.TupleString(
                        "1.16e"));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaData, "anomaly_classification_threshold",
                        hv_ClassificationThreshold.TupleString("1.16e"));
                }
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "meta_data", hv_MetaData);

                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "optimize_for_inference", "true");

                hv_GenParamThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_ClassificationThresholds.Dispose();
                hv_GenParamEvaluation.Dispose();
                hv_EvaluationResult.Dispose();
                hv_EvalParams.Dispose();
                hv_GenParamDisplay.Dispose();
                hv_WindowDict.Dispose();
                hv_ClassificationThresholdIndex.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_MetaData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParamThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_ClassificationThresholds.Dispose();
                hv_GenParamEvaluation.Dispose();
                hv_EvaluationResult.Dispose();
                hv_EvalParams.Dispose();
                hv_GenParamDisplay.Dispose();
                hv_WindowDict.Dispose();
                hv_ClassificationThresholdIndex.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_MetaData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void get_example_inference_images(HTuple hv_ImageDir, HTuple hv_NumSamples,
            out HTuple hv_ImageFiles)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageFilesAll = new HTuple();
            // Initialize local and output iconic variables 
            hv_ImageFiles = new HTuple();
            try
            {
                //This procedure creates a list of images used for this example.
                //
                hv_ImageFilesAll.Dispose();
                list_image_files(hv_ImageDir, "default", "recursive", out hv_ImageFilesAll);
                {
                    HTuple ExpTmpOutVar_0;
                    tuple_shuffle(hv_ImageFilesAll, out ExpTmpOutVar_0);
                    hv_ImageFilesAll.Dispose();
                    hv_ImageFilesAll = ExpTmpOutVar_0;
                }
                hv_ImageFiles.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageFiles = hv_ImageFilesAll.TupleSelectRange(
                        0, hv_NumSamples - 1);
                }
                //

                hv_ImageFilesAll.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ImageFilesAll.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Return the path to the HALCON images directory. 
        public void get_image_dir(out HTuple hv_ImageDir)
        {


            // Local iconic variables 

            // Local control variables 

            HTuple hv_OperatingSystem = new HTuple(), hv_IsWindows = new HTuple();
            HTuple hv_Separator = new HTuple();
            // Initialize local and output iconic variables 
            hv_ImageDir = new HTuple();
            try
            {
                hv_ImageDir.Dispose();
                HOperatorSet.GetSystem("image_dir", out hv_ImageDir);
                hv_OperatingSystem.Dispose();
                HOperatorSet.GetSystem("operating_system", out hv_OperatingSystem);
                hv_IsWindows.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IsWindows = new HTuple(((hv_OperatingSystem.TupleSubstr(
                        0, 2))).TupleEqual("Win"));
                }
                if ((int)(hv_IsWindows) != 0)
                {
                    hv_Separator.Dispose();
                    hv_Separator = ";";
                }
                else
                {
                    hv_Separator.Dispose();
                    hv_Separator = ":";
                }
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleSplit(hv_ImageDir, hv_Separator, out ExpTmpOutVar_0);
                    hv_ImageDir.Dispose();
                    hv_ImageDir = ExpTmpOutVar_0;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageDir = hv_ImageDir.TupleSelect(
                            0);
                        hv_ImageDir.Dispose();
                        hv_ImageDir = ExpTmpLocalVar_ImageDir;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ImageDir = hv_ImageDir.TupleRegexpReplace(
                            (new HTuple("\\\\+")).TupleConcat("replace_all"), "/");
                        hv_ImageDir.Dispose();
                        hv_ImageDir = ExpTmpLocalVar_ImageDir;
                    }
                }

                hv_OperatingSystem.Dispose();
                hv_IsWindows.Dispose();
                hv_Separator.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OperatingSystem.Dispose();
                hv_IsWindows.Dispose();
                hv_Separator.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Return paths to randomly chosen test images. 
        public void get_random_test_image_paths(HTuple hv_DLDataset, HTuple hv_MaxNumTestImages,
            out HTuple hv_ImagePaths)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DLSamples = new HTuple(), hv_TestSampleIndices = new HTuple();
            HTuple hv_NumTestImages = new HTuple(), hv_TestSampleIndicesShuffled = new HTuple();
            HTuple hv_Index = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_DLSample = new HTuple(), hv_ImagePath = new HTuple();
            // Initialize local and output iconic variables 
            hv_ImagePaths = new HTuple();
            try
            {
                //This procedure returns paths to randomly chosen test images.

                //Get all test sample indices
                hv_DLSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSamples = hv_DLDataset.TupleGetDictTuple(
                        "samples");
                }
                hv_TestSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "test", "match", out hv_TestSampleIndices);
                hv_NumTestImages.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumTestImages = (new HTuple(hv_TestSampleIndices.TupleLength()
                        )).TupleMin2(hv_MaxNumTestImages);
                }

                hv_TestSampleIndicesShuffled.Dispose();
                tuple_shuffle(hv_TestSampleIndices, out hv_TestSampleIndicesShuffled);

                hv_ImagePaths.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImagePaths = HTuple.TupleGenConst(
                        hv_NumTestImages, -1);
                }
                HTuple end_val10 = hv_NumTestImages - 1;
                HTuple step_val10 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val10, step_val10); hv_Index = hv_Index.TupleAdd(step_val10))
                {
                    hv_SampleIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleIndex = hv_TestSampleIndicesShuffled.TupleSelect(
                            hv_Index);
                    }
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSamples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_ImagePath.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImagePath = ((hv_DLDataset.TupleGetDictTuple(
                            "image_dir")) + "/") + (hv_DLSample.TupleGetDictTuple("image_file_name"));
                    }
                    if (hv_ImagePaths == null)
                        hv_ImagePaths = new HTuple();
                    hv_ImagePaths[hv_Index] = hv_ImagePath;
                }

                hv_DLSamples.Dispose();
                hv_TestSampleIndices.Dispose();
                hv_NumTestImages.Dispose();
                hv_TestSampleIndicesShuffled.Dispose();
                hv_Index.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImagePath.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLSamples.Dispose();
                hv_TestSampleIndices.Dispose();
                hv_NumTestImages.Dispose();
                hv_TestSampleIndicesShuffled.Dispose();
                hv_Index.Dispose();
                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImagePath.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void identity(HObject ho_Image, HTuple hv_DLPreprocessParam, HTuple hv_DLModelHandle,
            HTuple hv_SegmentationThreshold, HTuple hv_ClassificationThreshold)
        {




            // Local iconic variables 

            HObject ho_ImageZoom, ho_AnomalyImage, ho_AnomalyRegion;

            // Local control variables 

            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_DLSample = new HTuple(), hv_DLResult = new HTuple();
            HTuple hv_AnomalyScore = new HTuple(), hv_Text = new HTuple();
            HTuple hv_BoxColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageZoom);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            try
            {
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                hv_DLSample.Dispose();
                gen_dl_samples_from_images(ho_Image, out hv_DLSample);
                preprocess_dl_samples(hv_DLSample, hv_DLPreprocessParam);
                hv_DLResult.Dispose();
                HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSample, (new HTuple("anomaly_image_local")).TupleConcat(
                    "anomaly_image_global"), out hv_DLResult);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ImageZoom.Dispose();
                    HOperatorSet.ZoomImageSize(hv_DLResult.TupleGetDictObject("anomaly_image_global"),
                        out ho_ImageZoom, hv_Width, hv_Height, "constant");
                }
                ho_AnomalyImage.Dispose();
                HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, "anomaly_image_global");
                ho_AnomalyRegion.Dispose();
                HOperatorSet.Threshold(ho_ImageZoom, out ho_AnomalyRegion, hv_SegmentationThreshold,
                    "max");
                hv_AnomalyScore.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_score_global", out hv_AnomalyScore);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                }
                if ((int)(new HTuple(hv_AnomalyScore.TupleLess(hv_ClassificationThreshold))) != 0)
                {
                    hv_Text.Dispose();
                    hv_Text = "OK";
                    hv_BoxColor.Dispose();
                    hv_BoxColor = "green";
                }
                else
                {
                    hv_Text.Dispose();
                    hv_Text = "NOK";
                    hv_BoxColor.Dispose();
                    hv_BoxColor = "red";
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                            "left", "black", (new HTuple("box_color")).TupleConcat("shadow"), hv_BoxColor.TupleConcat(
                            "false"));
                    }
                }
                ho_ImageZoom.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_AnomalyScore.Dispose();
                hv_Text.Dispose();
                hv_BoxColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageZoom.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_AnomalyScore.Dispose();
                hv_Text.Dispose();
                hv_BoxColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Apply the trained model to test images. 
        public void inference(HTuple hv_DLDataset, HTuple hv_DLPreprocessParam, HTuple hv_DLModelHandle)
        {



            // Local iconic variables 

            HObject ho_Image = null;

            // Local control variables 

            HTuple hv_MaxNumInferenceImages = new HTuple();
            HTuple hv_InferenceImagePaths = new HTuple(), hv_MetaData = new HTuple();
            HTuple hv_ClassificationThreshold = new HTuple(), hv_SegmentationThreshold = new HTuple();
            HTuple hv_DLDatasetInfo = new HTuple(), hv_WindowDict = new HTuple();
            HTuple hv_IndexInference = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_DLResult = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //In this local example procedure, we apply the trained model
                //to some randomly chosen images that have not been used during
                //training.

                display_info_text("inference");
                // stop(...); only in hdevelop
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                hv_MaxNumInferenceImages.Dispose();
                hv_MaxNumInferenceImages = 10;
                hv_InferenceImagePaths.Dispose();
                get_random_test_image_paths(hv_DLDataset, hv_MaxNumInferenceImages, out hv_InferenceImagePaths);

                //Get thresholds for inference. These have been stored along with
                //the model in the meta data.
                hv_MetaData.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "meta_data", out hv_MetaData);
                hv_ClassificationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassificationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_classification_threshold"))).TupleNumber();
                }
                hv_SegmentationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_segmentation_threshold"))).TupleNumber();
                }

                //Create a dictionary with dataset parameters used for display.
                hv_DLDatasetInfo.Dispose();
                HOperatorSet.CreateDict(out hv_DLDatasetInfo);
                HOperatorSet.SetDictTuple(hv_DLDatasetInfo, "class_names", (new HTuple("ok")).TupleConcat(
                    "nok"));
                HOperatorSet.SetDictTuple(hv_DLDatasetInfo, "class_ids", (new HTuple(0)).TupleConcat(
                    1));

                //Apply the model to test images.
                hv_WindowDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowDict);
                for (hv_IndexInference = 0; (int)hv_IndexInference <= (int)((new HTuple(hv_InferenceImagePaths.TupleLength()
                    )) - 1); hv_IndexInference = (int)hv_IndexInference + 1)
                {

                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.ReadImage(out ho_Image, hv_InferenceImagePaths.TupleSelect(hv_IndexInference));
                    }
                    hv_DLSample.Dispose();
                    gen_dl_samples_from_images(ho_Image, out hv_DLSample);
                    preprocess_dl_samples(hv_DLSample, hv_DLPreprocessParam);

                    hv_DLResult.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSample, new HTuple(), out hv_DLResult);

                    //Apply thresholds to classify regions and the entire image.
                    threshold_dl_anomaly_results(hv_SegmentationThreshold, hv_ClassificationThreshold,
                        hv_DLResult);

                    //Display the inference result.
                    dev_display_dl_data(hv_DLSample, hv_DLResult, hv_DLDatasetInfo, (new HTuple("anomaly_result")).TupleConcat(
                        "anomaly_image"), new HTuple(), hv_WindowDict);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press F5 (continue)",
                            "window", "bottom", "center", "black", new HTuple(), new HTuple());
                    }
                    // stop(...); only in hdevelop
                }
                dev_close_window_dict(hv_WindowDict);
                ho_Image.Dispose();

                hv_MaxNumInferenceImages.Dispose();
                hv_InferenceImagePaths.Dispose();
                hv_MetaData.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_DLDatasetInfo.Dispose();
                hv_WindowDict.Dispose();
                hv_IndexInference.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_MaxNumInferenceImages.Dispose();
                hv_InferenceImagePaths.Dispose();
                hv_MetaData.Dispose();
                hv_ClassificationThreshold.Dispose();
                hv_SegmentationThreshold.Dispose();
                hv_DLDatasetInfo.Dispose();
                hv_WindowDict.Dispose();
                hv_IndexInference.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void init(HTuple hv_DLModelHandle, out HTuple hv_DLPreprocessParam, out HTuple hv_SegmentationThreshold,
            out HTuple hv_ClassificationThreshold)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MetaData = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLPreprocessParam = new HTuple();
            hv_SegmentationThreshold = new HTuple();
            hv_ClassificationThreshold = new HTuple();
            try
            {
                //预处理参数
                hv_DLPreprocessParam.Dispose();
                create_dl_preprocess_param_from_model(hv_DLModelHandle, "none", "full_domain",
                    new HTuple(), new HTuple(), new HTuple(), out hv_DLPreprocessParam);
                //取得模型参数，主要是获得两个阈值
                hv_MetaData.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "meta_data", out hv_MetaData);
                hv_SegmentationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SegmentationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_segmentation_threshold"))).TupleNumber();
                }
                hv_ClassificationThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassificationThreshold = ((hv_MetaData.TupleGetDictTuple(
                        "anomaly_classification_threshold"))).TupleNumber();
                }

                hv_MetaData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MetaData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Load the Global Context Anomaly Detection model and preprocess the dataset. 
        public void load_dataset_and_model(HTuple hv_TrainedModel, HTuple hv_ImageDir,
            HTuple hv_ImageSubDirs, HTuple hv_ImageWidth, HTuple hv_ImageHeight, HTuple hv_PatchSize,
            out HTuple hv_DLDataset, out HTuple hv_DLPreprocessParam, out HTuple hv_PreprocessDir,
            out HTuple hv_DLModelHandle)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_DLDataset = new HTuple();
            hv_DLPreprocessParam = new HTuple();
            hv_PreprocessDir = new HTuple();
            hv_DLModelHandle = new HTuple();
            //This local example procedure loads the Global Context Anomaly
            //Detection model and preprocesses the dataset.

            display_info_text("load_dataset_and_model");
            // stop(...); only in hdevelop
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }

            //Folder where the preprocessed samples will be stored.
            hv_PreprocessDir.Dispose();
            hv_PreprocessDir = "./anomaly_juice_bottle_data";

            //Load the GC-AD model.





        }

        public void preprocess_dl_samples_bottle(HTuple hv_DLSamples)
        {



            // Local iconic variables 

            HObject ho_GrayImage = null, ho_CenterRegion = null;
            HObject ho_CenterRegionFillUp = null, ho___Tmp_Obj_0 = null;

            // Local control variables 

            HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_CenterRegion);
            HOperatorSet.GenEmptyObj(out ho_CenterRegionFillUp);
            HOperatorSet.GenEmptyObj(out ho___Tmp_Obj_0);
            try
            {

                //This procedure performs a segmentation using a threshold to
                //remove the white background. This improves the performance
                //of the anomaly detection model.

                //Loop over all samples in the dataset.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_DLSamples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //DLSample is a handle(dict), so we get a shallow copy here.
                    //By changing it we are changing DLSamples.
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSamples.TupleSelect(
                            hv_SampleIndex);
                    }

                    //Since anomalies are only located on the bottles we exclude
                    //the white areas surrounding the bottles.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GrayImage.Dispose();
                        HOperatorSet.Rgb1ToGray(hv_DLSample.TupleGetDictObject("image"), out ho_GrayImage
                            );
                    }
                    ho_CenterRegion.Dispose();
                    HOperatorSet.Threshold(ho_GrayImage, out ho_CenterRegion, "min", 1.5);
                    ho_CenterRegionFillUp.Dispose();
                    HOperatorSet.FillUp(ho_CenterRegion, out ho_CenterRegionFillUp);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho___Tmp_Obj_0.Dispose();
                        HOperatorSet.ReduceDomain(hv_DLSample.TupleGetDictObject("image"), ho_CenterRegionFillUp,
                            out ho___Tmp_Obj_0);
                    }
                    HOperatorSet.SetDictObject(ho___Tmp_Obj_0, hv_DLSample, "image");
                }

                ho_GrayImage.Dispose();
                ho_CenterRegion.Dispose();
                ho_CenterRegionFillUp.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GrayImage.Dispose();
                ho_CenterRegion.Dispose();
                ho_CenterRegionFillUp.Dispose();
                ho___Tmp_Obj_0.Dispose();

                hv_SampleIndex.Dispose();
                hv_DLSample.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Train the Global Context Anomaly Detection model. 
        public void train(HTuple hv_DLDataset, HTuple hv_DLModelHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DLDeviceHandle = new HTuple(), hv_NumTrainSteps = new HTuple();
            HTuple hv_TrainSampleIndices = new HTuple(), hv_NumEpochs = new HTuple();
            HTuple hv_AugmentationDict = new HTuple(), hv_InitialLR = new HTuple();
            HTuple hv_LRDecayDict = new HTuple(), hv_SerializationDict = new HTuple();
            HTuple hv_TrainParam = new HTuple(), hv_TrainResults = new HTuple();
            HTuple hv_TrainInfos = new HTuple(), hv_EvaluationInfos = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This local example procedure trains the GC-AD model.

                display_info_text("train");
                // stop(...); only in hdevelop
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                //If the 'batch_size' is set to 1 the best results for
                //GC-AD models can be expected.
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", 1);

                //Use a GPU for training.
                hv_DLDeviceHandle.Dispose();
                HOperatorSet.QueryAvailableDlDevices((new HTuple("runtime")).TupleConcat("id"),
                    (new HTuple("gpu")).TupleConcat(0), out hv_DLDeviceHandle);
                if ((int)(new HTuple(hv_DLDeviceHandle.TupleEqual(new HTuple()))) != 0)
                {
                    throw new HalconException(new HTuple("It is recommended to use a GPU for training, due to a long training time on the CPU."));
                }

                //Set the chosen device. In case of memory difficulties modify
                //the model parameters 'image_dimensions' or 'patch_size'.
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "device", hv_DLDeviceHandle);

                //A good default for the number of training steps is 70,000.
                //If just the local network should be trained we recommend
                //a number of 35,000 training steps.
                hv_NumTrainSteps.Dispose();
                hv_NumTrainSteps = 70000;

                //Convert the number of training steps to epochs.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TrainSampleIndices.Dispose();
                    find_dl_samples(hv_DLDataset.TupleGetDictTuple("samples"), "split", "train",
                        "match", out hv_TrainSampleIndices);
                }
                hv_NumEpochs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumEpochs = (((hv_NumTrainSteps.TupleReal()
                        ) / (new HTuple(hv_TrainSampleIndices.TupleLength())))).TupleCeil();
                }

                //Data augmentation is important for training the global network.
                //In this example, we rotate the images slightly and apply
                //color jitter.
                hv_AugmentationDict.Dispose();
                HOperatorSet.CreateDict(out hv_AugmentationDict);
                HOperatorSet.SetDictTuple(hv_AugmentationDict, "augmentation_percentage", 100);
                HOperatorSet.SetDictTuple(hv_AugmentationDict, "rotate_range", 3);
                HOperatorSet.SetDictTuple(hv_AugmentationDict, "brightness_variation", 20);
                HOperatorSet.SetDictTuple(hv_AugmentationDict, "contrast_variation", 0.2);
                HOperatorSet.SetDictTuple(hv_AugmentationDict, "saturation_variation", 0.2);

                //Decay the learning rate after 95% of the epochs.
                hv_InitialLR.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "learning_rate", out hv_InitialLR);
                hv_LRDecayDict.Dispose();
                HOperatorSet.CreateDict(out hv_LRDecayDict);
                HOperatorSet.SetDictTuple(hv_LRDecayDict, "model_param", "learning_rate");
                HOperatorSet.SetDictTuple(hv_LRDecayDict, "initial_value", hv_InitialLR);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_LRDecayDict, "epochs", 0.95 * hv_NumEpochs);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_LRDecayDict, "values", 0.1 * hv_InitialLR);
                }

                hv_SerializationDict.Dispose();
                HOperatorSet.CreateDict(out hv_SerializationDict);
                HOperatorSet.SetDictTuple(hv_SerializationDict, "type", "current");
                HOperatorSet.SetDictTuple(hv_SerializationDict, "basename", "intermediate_dl_anomaly_global_context");

                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TrainParam.Dispose();
                    create_dl_train_param(hv_DLModelHandle, hv_NumEpochs, new HTuple(), 1, 73,
                        ((new HTuple("augment")).TupleConcat("change")).TupleConcat("serialize"),
                        ((hv_AugmentationDict.TupleConcat(hv_LRDecayDict))).TupleConcat(hv_SerializationDict),
                        out hv_TrainParam);
                }

                //The training and thus the call of train_dl_model_batch () is
                //done using the following procedure. This may take a long time.
                hv_TrainResults.Dispose(); hv_TrainInfos.Dispose(); hv_EvaluationInfos.Dispose();
                train_dl_model(hv_DLDataset, hv_DLModelHandle, hv_TrainParam, 0, out hv_TrainResults,
                    out hv_TrainInfos, out hv_EvaluationInfos);

                //After training, it is very important to normalize the local and
                //the global network.
                normalize_dl_gc_anomaly_scores(hv_DLDataset, hv_DLModelHandle, new HTuple());
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue with the evaluation of the model",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                // stop(...); only in hdevelop

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

                hv_DLDeviceHandle.Dispose();
                hv_NumTrainSteps.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumEpochs.Dispose();
                hv_AugmentationDict.Dispose();
                hv_InitialLR.Dispose();
                hv_LRDecayDict.Dispose();
                hv_SerializationDict.Dispose();
                hv_TrainParam.Dispose();
                hv_TrainResults.Dispose();
                hv_TrainInfos.Dispose();
                hv_EvaluationInfos.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLDeviceHandle.Dispose();
                hv_NumTrainSteps.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumEpochs.Dispose();
                hv_AugmentationDict.Dispose();
                hv_InitialLR.Dispose();
                hv_LRDecayDict.Dispose();
                hv_SerializationDict.Dispose();
                hv_TrainParam.Dispose();
                hv_TrainResults.Dispose();
                hv_TrainInfos.Dispose();
                hv_EvaluationInfos.Dispose();

                throw HDevExpDefaultException;
            }
        }
    }
}
